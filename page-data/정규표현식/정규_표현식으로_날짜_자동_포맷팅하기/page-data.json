{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/정규표현식/정규_표현식으로_날짜_자동_포맷팅하기/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"custom-date-picker를-위한-인풋\" style=\"position:relative;\">Custom Date Picker를 위한 인풋<a href=\"#custom-date-picker%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%92%8B\" aria-label=\"custom date picker를 위한 인풋 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>웹에서 커스텀한 Date Picker를 보여주고 싶다면, 원하는 구성을 직접 만들거나 라이브러리를 활용해야 할 것이다. MUI 같은 라이브러리는 연, 월, 일을 구분하는 구분자를 자동으로 추가하고 유효성도 잘 체크하는 구성을 제공하지만 내게 필요했던 range date picker는 유료여서 채택할 수 없었다. 결국 <code>react-datepicker</code>를 골랐는데 이 라이브러리가 제공하는 인풋에는 아무 문자나 입력할 수 있다는 아쉬움이 있었다. 유효하지 않은 입력을 제한하고 날짜 형식을 자동으로 잡아줘야 했는데 이번 글에 그 목적을 달성하기 위해 공부한 정규 표현식에 관한 내용을 담았다. 최대한 간단한 형태의 예제로 소개할 생각이다 .</p>\n<p>내가 원하는 날짜 형식은 <code>yyyy.MM.dd - yyyy.MM.dd</code>와 같은 형식이다.</p>\n<p><code>date</code> 타입의 인풋은 커스텀하는데 한계가 많기 때문에 커스텀한 달력들은 대부분 <code>text</code> 타입을 사용한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4\">\n          <code slot=\"code\">// index.html\n\n&lt;body&gt;\n  &lt;input type=&quot;text&quot;/&gt;\n  &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;</code>\n        </deckgo-highlight-code>\n<h2 id=\"숫자만-입력-받기\" style=\"position:relative;\">숫자만 입력 받기<a href=\"#%EC%88%AB%EC%9E%90%EB%A7%8C-%EC%9E%85%EB%A0%A5-%EB%B0%9B%EA%B8%B0\" aria-label=\"숫자만 입력 받기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>인풋에서는 숫자 입력만 받고 싶다. <code>keydown</code> 이벤트 핸들러에서 숫자 입력이 아닌 경우에 이벤트의 기본 동작을 제한한다. <code>match()</code> 메서드는 문자열이 정규식에 매칭되는지 검사한다. 만약 매칭된다면 문자열이 포함된 배열을 반환하고, 없다면 <code>null</code>을 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"3,7\">\n          <code slot=\"code\">const input = document.querySelector(&#39;input&#39;);\n\ninput.addEventListener(&#39;keydown&#39;, (e) =&gt; {\n  if (!e.key.match(/\\d/g)) {\n    e.preventDefault();\n  }\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li>정규 표현식에는 메타 문자라는 것이 있는데 주로 쓰이는 <strong>문자 집합</strong>들을 대체하는 특수 문자라고 생각하면 쉽다. <code>\\d</code>도 메타 문자 중 하나로 숫자를 나타낸다. 이 문자는<code>[0-9]</code>와 같은 의미를 가진다.</li>\n<li><code>/\\d/g</code>와 같이 사용하는 <code>g</code>플래그는 일치하는 모든 패턴을 찾는다. 만약 이 플래그가 없다면 패턴과 일치하는 첫 번째 결과만을 반환한다.</li>\n</ul>\n<h2 id=\"whitelist-만들기\" style=\"position:relative;\">Whitelist 만들기<a href=\"#whitelist-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"whitelist 만들기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>숫자 외에도 커서 이동을 위한 방향 키, 폼 제출을 위한 엔터 키, 그리고 삭제를 위한 백스페이스 키도 입력이 가능해야 한다. 입력 가능한 키를 하나의 정규 표현식 그룹에 담는다. 입력된 키가 <code>whitelist</code>에 속하지 않으면 이벤트의 기본 동작을 막는다. 정규 표현식의 <code>test()</code>메서드는 주어진 문자열이 정규식을 만족하는지 검사한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">input.addEventListener(&#39;keydown&#39;, (e) =&gt; {\n  const whitelist = /(\\d|ArrowLeft|ArrowRight|Backspace|Enter)/;\n\n  if (!whitelist.test(e.key)) {\n    e.preventDefault();\n  }\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li>앵커는 행의 시작과 끝 지점을 나타낸다. <code>^</code>은 행의 시작을 의미하고 <code>$</code>는 행의 끝을 의미한다. <code>apple</code>과 완전히 일치하는 문자열을 찾고 싶다면 <code>^apple$</code>와 같이 두 앵커로 감싸준다.</li>\n</ul>\n<h2 id=\"자동으로-점-찍어주기\" style=\"position:relative;\">자동으로 점 찍어주기<a href=\"#%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A0%90-%EC%B0%8D%EC%96%B4%EC%A3%BC%EA%B8%B0\" aria-label=\"자동으로 점 찍어주기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>숫자 입력만 받기 때문에 자동으로 점을 찍어줘야 한다. 먼저 시도해 볼 것은 8자리의 숫자를 입력할 때 <code>yyyy.mm.dd</code>와 같은 형태가 되는 것이다. <code>replace()</code>의 두 번째 매개변수 타입이 <code>string</code>이라면 해당 문자열은 특수한 교체 패턴을 포함할 수 있다. 아래의 <code>'$1.$2.$3'</code>처럼 <code>$n</code>의 패턴이 놓인 자리에는 정규 표현식 내 소괄호로 묶인 <code>n</code>번째 그룹에 매치된 문자열을 삽입한다. 만약 정규 표현식을 각각 (4자리), (2자리), (2자리) 숫자로 묶인 세 캡쳐링 그룹으로 구성한다면, <code>11112233</code>와 같은 문자열을 <code>1111.22.33</code>로 대체한다. 앞서 말했듯이 문자열이 포함하는 특수 교체 패턴에 각 그룹에 매치된 문자열을 삽입하기 때문이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date.replace(/^(\\d{4})(\\d{2})(\\d{2})$/g, &#39;$1.$2.$3&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li>캡쳐링 그룹(capturing group)은 소괄호로 묶인 영역을 의미한다. 캡쳐링 그룹을 사용하면 매치된 부분 문자열을 따로 추출할 수 있다. 캡쳐링된 문자열은 <code>$n</code>과 같은 특수 패턴을 활용하여 추출할 수 있다.</li>\n<li>수량자(quantity)는 패턴이 나타날 수 있는 횟수를 지정해 준다. 수량자는 다음과 같이 사용할 수 있다.\n<ul>\n<li><code>*</code>: 0개 이상</li>\n<li><code>+</code>: 1개 이상</li>\n<li><code>?</code>: 0개 또는 1개</li>\n<li><code>{n}</code>: n개</li>\n<li><code>{n,}</code>: n개 이상</li>\n<li><code>{n,m}</code>: n개 이상, m개 이하</li>\n</ul>\n</li>\n<li>예를 들어, <code>/\\d{2,4}/</code> 패턴은 2자리에서 4자리의 숫자에 매치된다. <code>/\\d+/</code> 패턴은 1개 이상의 숫자에 매치된다. <code>/\\d*/</code> 패턴은 0개 이상의 숫자에 매치된다. <code>/\\d?/</code> 패턴은 0개 또는 1개의 숫자에 매치된다.</li>\n</ul>\n<p><em><strong>구현</strong></em></p>\n<p>8자리 숫자를 입력하면 원하는 자리에 점을 찍어주고 있다.</p>\n<p><img src=\"/5223507fe603f60a2f7a06add8a9f987/regex1.gif\" alt=\"regex1\"></p>\n<p>그러나 사실 내가 원했던 것은 8자리를 모두 입력하지 않더라도 필요한 시점에 점이 찍히는 것이다. 수량자를 변경해보자. 각 그룹이 0개의 숫자부터 캡쳐링할 수 있도록 수량자를 조절한다. 하지만 이렇게만 하면 <code>1..</code>처럼 점이 연속으로 찍히고 그 다음 입력은 마지막 자리에 붙게 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date.replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p>포맷을 바꿔주기 전 숫자를 제외한 문자를 제거하면 최종적으로 원하는 위치에 점을 찍어준다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date\n    .replace(/[^0-9]/g, &#39;&#39;)\n    .replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p>하지만 여전히 입력 중에는 문자열의 끝에 두 개 이상의 점이 붙는다. 이를 방지하기 위해 정규식을 하나 더 추가한다. 이 정규식은 연속된 점을 삭제한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date\n    .replace(/[^0-9]/g, &#39;&#39;)\n    .replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;)\n    .replace(/(\\.{2})/g, &#39;&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>구현</strong></em></p>\n<p>이제는 입력 중에도 원하는 위치에 점을 잘 찍는다.</p>\n<p><img src=\"/c545acf53d5e72cdd246b8b4fe69e34d/regex2.gif\" alt=\"regex2\"></p>\n<h2 id=\"입력-구분하기\" style=\"position:relative;\">입력 구분하기<a href=\"#%EC%9E%85%EB%A0%A5-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0\" aria-label=\"입력 구분하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지는 백스페이스로 삭제를 하더라도 정규식 패턴에 의해 점이 다시 찍히기 때문에 삭제 기능이 동작하지 않았다. 삭제를 할 때는 자동 포맷팅을 하지 않도록 해야 한다. 이런 경우에 <code>InputEvent</code> 인터페이스가 제공하는 <code>inputType</code> 속성을 사용할 수 있다. <code>inputType</code>속성은 타이핑에 의한 <strong>텍스트 주입</strong>이라면 <code>“insertText”</code> 값을 갖는다. 입력을 추가할 때만 <code>replace()</code>를 호출한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4 9\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n  \n  if (e.inputType === &#39;insertText&#39;) {\n    date = date\n      .replace(/[^0-9]/g, &#39;&#39;)\n      .replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;)\n      .replace(/(\\.{2})/g, &#39;&#39;);\n  }\n  \n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<h2 id=\"날짜-범위를-위한-정규-표현식\" style=\"position:relative;\">날짜 범위를 위한 정규 표현식<a href=\"#%EB%82%A0%EC%A7%9C-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D\" aria-label=\"날짜 범위를 위한 정규 표현식 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>단일 인풋으로 하나의 날짜가 아닌, 특정 기간을 입력 받아야 한다면 좀 더 많은 정규 표현식이 필요하다. 서두에 언급했듯이 당초 원했던 것은 <code>yyyy.MM.dd - yyyy.MM.dd</code>와 같은 형식이다. 먼저 하이픈(-)과 같은 날짜 구분자를 추가해야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,9\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n  \n  if (e.inputType === &#39;insertText&#39;) {\n    date = date\n      .replace(/[^0-9]/g, &#39;&#39;)\n      .replace(\n        /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, \n        &#39;$1.$2.$3 - $4.$5.$6&#39;\n      )\n      .replace(/(\\.{2})/g, &#39;&#39;);\n  }\n  \n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>구현</strong></em></p>\n<p>이렇게만 해도 어느 정도는 잘 된다.</p>\n<p><img src=\"/b20b7e62ead6759826be330309aa4658/regex3.gif\" alt=\"regex3\"></p>\n<p>다만 날짜를 모두 지우거나 종료 날짜가 없음에도 보여주고 있는 하이픈(-)을 지우고 싶다. 정규식을 하나 더 추가한다. 부정 전방 탐색을 사용하여 뒤에 <code>숫자</code>, 또는 <code>공백 + 숫자</code>가 오지 않는 하이픈에 대한 매칭을 수행한다. 하이픈의 앞뒤에는 공백 문자가 0개 이상 올 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  if (e.inputType === &#39;insertText&#39;) {\n     date = date\n       .replace(/[^0-9]/g, &#39;&#39;)\n       .replace(\n        /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, \n        &#39;$1.$2.$3 - $4.$5.$6&#39;\n       )\n       .replace(/(\\.{2})/g, &#39;&#39;)\n       .replace(/\\s*-\\s*(?!\\s*\\d)/g, &#39;&#39;)\n  }\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li><code>\\s</code> 메타 문자는 공백 문자를 의미한다. 반면, <code>\\S</code> 는 공백 문자가 아닌 모든 문자를 의미한다.</li>\n<li>전방 탐색(positive lookahead)은 정규 표현식에서 일치하는 부분 문자열을 제외한 부분에 대해 매칭을 수행하는 것을 말한다. 글로 보는 것보다 실제 동작을 보는 것이 더 이해하기 쉬운데 예를 들어, <code>q(?=u)</code>는 <code>u</code> 오른쪽에 둔 <code>q</code>를 매칭한다. 이 정규식은 <code>quiet</code>에서 <code>q</code>에 대해 매칭을 수행하지만, <code>Qantas</code>와 같은 문자열에서는 매칭을 수행하지 않는다.</li>\n<li>부정 전방 탐색(negative lookahead)은 전방 탐색의 반대로 생각하면 쉽다. 예를 들어, <code>q(?!u)</code>는 오른쪽에 <code>u</code>가 나오지 않는 <code>q</code>에 대해 매칭을 수행한다. 이 정규식은 <code>Iraq</code>에서 <code>q</code>와 <code>Qantas</code>에서 <code>q</code>에 대해 매칭을 수행하지만, <code>quiet</code>에서는 매칭을 수행하지 않는다</li>\n</ul>\n<p><em><strong>구현</strong></em></p>\n<p>이제 원하는 모습이 됐다.</p>\n<p><img src=\"/ea18063d0507505c943e5bb18436b912/regex4.gif\" alt=\"regex4\"></p>\n<h2 id=\"코드-리팩토링\" style=\"position:relative;\">코드 리팩토링<a href=\"#%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81\" aria-label=\"코드 리팩토링 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>replace()</code>의 호출을 위한 중복 코드를 제거하고 정규 표현식과 대체 문자열/패턴을 분리하면 코드가 더 읽기 좋아질 것 같아 리팩토링을 했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const regexPatterns = [\n  { regex: /[^0-9]/g, replaceWith: &#39;&#39; },\n  { \n    regex: /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, \n    replaceWith: &#39;$1.$2.$3 - $4.$5.$6&#39; \n  },\n  { regex: /(\\.{2})/g, replaceWith: &#39;.&#39; },\n  { regex: /\\s*-\\s*(?!\\s*\\d)/g, replaceWith: &#39;&#39; },\n]\n\ninput.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  if (e.inputType === &#39;insertText&#39;) {\n     date = regexPatterns.reduce((inputValue, pattern) =&gt; \n              inputValue.replace(pattern.regex, pattern.replaceWith), date\n            );\n  }\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<h2 id=\"남아있는-한계-부제-유효하지-않은-입력-값-수정-방지하기\" style=\"position:relative;\">남아있는 한계 (부제: 유효하지 않은 입력 값 수정 방지하기)<a href=\"#%EB%82%A8%EC%95%84%EC%9E%88%EB%8A%94-%ED%95%9C%EA%B3%84-%EB%B6%80%EC%A0%9C-%EC%9C%A0%ED%9A%A8%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9E%85%EB%A0%A5-%EA%B0%92-%EC%88%98%EC%A0%95-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0\" aria-label=\"남아있는 한계 부제 유효하지 않은 입력 값 수정 방지하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사용자가 순서대로 지우고 순서대로 입력한다면 문제될 것이 없지만, 만약 커서를 옮겨 날짜 구분자를 지우고 입력하거나, 두 개 이상의 숫자를 지우고 입력하면 결국 날짜 형식이 망가질 수 있다. 이런 경우를 최대한 제한하기 위해 여러 정규식을 추가해 봤다.</p>\n<p>각 정규식에 대한 설명은 주석으로 대체한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const regexPatterns = [\n  // &#39;yyyy.mm.dd - yyyy.mm.dd&#39;에서 separator를 제거 후 입력 방지:\n  // (1) 왼쪽에 숫자가 있고 (2)왼쪽에 separator는 없는, (3 - matched) yyyy.mm.dd , (3 - matched) 그룹을 제거\n  { regex: /(?&lt;=\\d\\s?)(?&lt;!(-\\s?))(\\d{4}\\.\\d{2}\\.\\d{2}$)/g, replaceWith: &#39;&#39; },\n  // &#39;yyyy.mm.dd&#39;에서 왼쪽 점을 제거 후 입력 방지:\n  // (1) 왼쪽에 4자리 숫자가 있는, (2 - matched) 3자리 숫자에 (3) 오른쪽에 점(.)과 2자리 숫자도 있다면, (2 - matched) 그룹을 &#39;01&#39;로 대체\n  { regex: /(?&lt;=(\\d{4}))(\\d{3})(?=\\.\\d{2})/g, replaceWith: &#39;01&#39; },\n  // &#39;yyyy.mm.dd&#39;에서 오른쪽 점을 제거 후 입력 방지:\n  // (1) 왼쪽에 4자리 숫자 + 점(.) + 2자리 숫자가 있는, (2 - matched) 3자리 숫자가 있다면, (2 - matched) 그룹을 &#39;.01&#39;로 대체\n  { regex: /(?&lt;=(\\d{4}\\.\\d{2}))(\\d{3})/g, replaceWith: &#39;01&#39; },\n  // 커서 이동 후 separator의 왼쪽 공백 문자를 다른 문자로 대체하는 입력 방지\n  { regex: /(?&lt;=(^\\d{4}\\.\\d{2}\\.\\d{2}))(\\d)(?=-)/g, replaceWith: &#39;&#39; },\n  // year 영역에 커서 이동 &gt; 2개 이상 삭제 &gt; 입력할 때 숫자 당겨지는 현상 방지: year 영역은 최소 4자리로 맞추기\n  { regex: /\\d{1,4}(?=\\.\\d{2}\\.\\d{2})/g, replaceWith: (match) =&gt; match.padEnd(4, &#39;0&#39;) },\n  // month 영역에 커서 이동 &gt; 2개 이상 삭제 &gt; 입력할 때 숫자 당겨지는 현상 방지: month 영역은 최소 2자리로 맞추기\n  { regex: /(?&lt;=(\\.))\\d{1,2}(?=\\.\\d{2})/g, replaceWith: (match) =&gt; match.padEnd(2, &#39;0&#39;) },\n  // date 영역에 커서 이동 &gt; 2개 이상 삭제 &gt; 입력할 때 숫자 당겨지는 현상 방지: 시작 날짜의 date 영역은 최소 2자리로 맞추기\n  { regex: /(?&lt;=\\.)(\\d{1,2})(?=[\\s-])/g, replaceWith: (match) =&gt; match.padEnd(2, &#39;0&#39;) },\n  { regex: /[^0-9]/g, replaceWith: &#39;&#39; },\n  { regex: /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, replaceWith: &#39;$1.$2.$3 - $4.$5.$6&#39; },\n  { regex: /(\\.{2})/g, replaceWith: &#39;&#39; },\n  { regex: /\\s*-\\s*(?!\\s*\\d)/g, replaceWith: &#39;&#39; },\n]\n\ninput.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  if (e.inputType === &#39;insertText&#39;) {\n     date = regexPatterns.reduce((inputValue, pattern) =&gt; \n      inputValue.replace(pattern.regex, pattern.replaceWith), date);\n  }\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p>다만 이렇게 여러 정규식을 추가하는 것이 과연 좋은 방법일까? 여전히 커버하지 못하는 엣지 케이스가 있다. 정규식보다는 인풋의 입력 영역을 나누거나, 좀 더 명확한 방법으로 해결할 필요가 있다고 느꼈다. 아마도 MUI의 <code>&#x3C;DateField /></code>와 같은 모습이라면 좋을 것 같은데 나중에 더 좋은 방법을 찾게 되면 기록으로 남기고 싶다.</p>","excerpt":"Custom Date Picker를 위한 인풋 웹에서 커스텀한 Date Picker를 보여주고 싶다면, 원하는 구성을 직접 만들거나 라이브러리를 활용해야 할 것이다. MUI 같은 라이브러리는 연, 월, 일을 구분하는 구분자를 자동으로 추가하고 유효성…","timeToRead":7,"headings":[{"id":"custom-date-picker를-위한-인풋","value":"Custom Date Picker를 위한 인풋","depth":2},{"id":"숫자만-입력-받기","value":"숫자만 입력 받기","depth":2},{"id":"whitelist-만들기","value":"Whitelist 만들기","depth":2},{"id":"자동으로-점-찍어주기","value":"자동으로 점 찍어주기","depth":2},{"id":"입력-구분하기","value":"입력 구분하기","depth":2},{"id":"날짜-범위를-위한-정규-표현식","value":"날짜 범위를 위한 정규 표현식","depth":2},{"id":"코드-리팩토링","value":"코드 리팩토링","depth":2},{"id":"남아있는-한계-부제-유효하지-않은-입력-값-수정-방지하기","value":"남아있는 한계 (부제: 유효하지 않은 입력 값 수정 방지하기)","depth":2}],"frontmatter":{"created":"2023-03-28","updated":"2023-08-22 00:37:02 +0900"},"fields":{"slug":"/정규표현식/정규_표현식으로_날짜_자동_포맷팅하기","title":"정규 표현식으로 날짜 자동 포맷팅하기"}}},"pageContext":{"slug":"/정규표현식/정규_표현식으로_날짜_자동_포맷팅하기","title":"정규 표현식으로 날짜 자동 포맷팅하기"}},"staticQueryHashes":["2328167765","3156452557"],"slicesMap":{}}