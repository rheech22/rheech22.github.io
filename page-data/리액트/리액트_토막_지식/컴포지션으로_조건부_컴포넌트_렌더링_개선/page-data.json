{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/리액트/리액트_토막_지식/컴포지션으로_조건부_컴포넌트_렌더링_개선/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://tkdodo.eu/blog/component-composition-is-great-btw\">Component Composition is greate btw</a>을 읽고 요약한 글입니다.</p>\n<h2 id=\"본문-요약\" style=\"position:relative;\">본문 요약<a href=\"#%EB%B3%B8%EB%AC%B8-%EC%9A%94%EC%95%BD\" aria-label=\"본문 요약 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>상태에 따라 특정 컴포넌트의 렌더링 여부를 결정해야 하는 경우는 흔하다. 대표적으로 서버로부터 받는 데이터에 따라 무언가를 보여주거나 보여주지 않아야 하는 경우를 예로 들 수 있다. 다음 예시는 장바구니 페이지에서 상품 목록과 스켈레톤 UI를 조건부로 보여준다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const CartPage = () =&gt; {\n    const { data, loading } = useQuery(CART_QUERY); \n\n    return (\n        &lt;div&gt;\n            &lt;Heading&gt;Cart&lt;/Heading&gt;\n            &lt;Content&gt;\n                {data?.isVIP ? &lt;VIPInfo /&gt; : null}\n                {loading ? &lt;Skeleton /&gt; : null}\n                {data \n                    ? data.products.map((product)=&gt; (\n                        &lt;Product key={product.id} product={product}/&gt;\n                    ))\n                    : null}\n            &lt;/Content&gt;\n        &lt;/div&gt;\n    )\n}</code>\n        </deckgo-highlight-code>\n<p>흔하게 접할 수 있는 모양이다. 만약 상품이 없는 경우 특정 요소를 보여주는 요구사항이 추가된다면 어떻게 구현해야 할까?</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const CartPage = () =&gt; {\n    const { data, loading } = useQuery(CART_QUERY); \n\n    return (\n        &lt;div&gt;\n            &lt;Heading&gt;Cart&lt;/Heading&gt;\n            &lt;Content&gt;\n                {data?.isVIP ? &lt;VIPInfo /&gt; : null}\n                {loading ? &lt;Skeleton /&gt; : null}\n                {data \n                    ? data.products.map((product)=&gt; (\n                        &lt;Product key={product.id} product={product}/&gt;\n                    ))\n                    : &lt;EmptyCart /&gt;}\n            &lt;/Content&gt;\n        &lt;/div&gt;\n    )\n}</code>\n        </deckgo-highlight-code>\n<p>상품이 없다면 <code>&#x3C;EmptyCart /></code>를 반환한다. 하지만 이 방식에는 큰 결함이 있는데, 데이터 로딩 중에도 해당 UI가 보여질 수 있다는 점이다. 그래서 상품이 없는 경우와 로딩 중이 아닌 경우를 모두 만족할 때에만 <code>&#x3C;EmptyCart /></code>를 렌더링하도록 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const CartPage = () =&gt; {\n    const { data, loading } = useQuery(CART_QUERY); \n\n    return (\n        &lt;div&gt;\n            &lt;Heading&gt;Cart&lt;/Heading&gt;\n            &lt;Content&gt;\n                {data?.isVIP ? &lt;VIPInfo /&gt; : null}\n                {loading ? &lt;Skeleton /&gt; : null}\n                {!loading &amp;&amp; !data ? &lt;EmptyCart /&gt; : null}\n                {data \n                    ? data.products.map((product)=&gt; (\n                        &lt;Product key={product.id} product={product}/&gt;\n                    ))\n                    : null}\n            &lt;/Content&gt;\n        &lt;/div&gt;\n    )\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://tkdodo.eu/blog/component-composition-is-great-btw#inject-comments\">출처</a>에서는 이러한 코드가 인지 부하를 유발한다고 지적한다. 내 지난 코드를 돌이켜봐도 이런 코드가 있었던 것도 같다. 컴포넌트 합성으로 이 코드를 어떻게 개선하면 좋을지 알아보자.</p>\n<p>먼저 <code>Layout</code>을 분리한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const CartLayout = ({children}) =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;Heading&gt;Cart&lt;/Heading&gt;\n            &lt;Content&gt;\n                {children}\n            &lt;/Content&gt;\n        &lt;/div&gt;\n    )\n}\n\n\nconst CartPage = () =&gt; {\n    const { data, loading } = useQuery(CART_QUERY); \n\n    return (\n        &lt;CartLayout&gt;\n            &lt;Content&gt;\n                {data?.isVIP ? &lt;VIPInfo /&gt; : null}\n                {loading ? &lt;Skeleton /&gt; : null}\n                {loading &amp;&amp; !data ? &lt;EmptyCart /&gt; : null}\n                {data \n                    ? data.products.map((product)=&gt; (\n                        &lt;Product key={product.id} product={product}/&gt;\n                    ))\n                    : null}\n            &lt;/Content&gt;\n        &lt;/CartLayout&gt;\n    )\n}</code>\n        </deckgo-highlight-code>\n<p>그리고 레이아웃 컴포넌트와 함께 Return Early 패턴을 적용한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const CartPage = () =&gt; {\n    const { data, loading } = useQuery(CART_QUERY); \n\n    if(loading) {\n        return (\n            &lt;CartLayout&gt;\n                &lt;Skeleton /&gt;\n            &lt;/CartLayout&gt;\n        )\n    }\n\n    if(!data) {\n        return (\n            &lt;CartLayout&gt;\n                &lt;EmptyCart /&gt;\n            &lt;/CartLayout&gt;\n        )\n    }\n\n    return (\n        &lt;CartLayout&gt;\n            &lt;Content&gt;\n                {data.isVIP ? &lt;VIPInfo /&gt; : null}\n                {data.products.map((product)=&gt; (\n                    &lt;Product key={product.id} product={product}/&gt;\n                ))}\n            &lt;/Content&gt;\n        &lt;/CartLayout&gt;\n    )\n}</code>\n        </deckgo-highlight-code>\n<p>이러한 변경에는 다음과 같은 장점이 있다.</p>\n<ul>\n<li>인지 부하 감소: Return Early 구문으로 상태에 따라 무엇이 반환될지 명확하게 인지할 수 있다. 중첩된 조건을 하나의 분기에서 다루지 않아도 되니까 확실히 인지 소모가 덜하다.</li>\n<li>타입 추론: 타입스크립트를 사용한다면 타입 추론을 통해 더 안정적인 환경에서 개발할 수 있다. 마지막 분기에서 <code>data</code> 유무에 대해서는 의심할 여지가 없는 점을 주목하자.</li>\n<li>확장 가능성: 다른 요구사항이 추가된다면, 분기만 하나 추가하면 되기 때문에 보다 확장하기 쉽다.</li>\n</ul>\n<h2 id=\"인상-깊었던-코멘트\" style=\"position:relative;\">인상 깊었던 코멘트<a href=\"#%EC%9D%B8%EC%83%81-%EA%B9%8A%EC%97%88%EB%8D%98-%EC%BD%94%EB%A9%98%ED%8A%B8\" aria-label=\"인상 깊었던 코멘트 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>로딩 상태 뿐만 아니라 에러 처리에 대한 내용도 포함되어야 한다는 코멘트가 인상적이었다. 컴포넌트가 직접 데이터를 받아오는 경우에는 <code>Promise</code> 객체의 상태에 따라 관심사를 분리하는 것이 복잡성을 많이 줄여준다는 내용이다. 그리고 발생할 수 있는 여러 에러 타입에 대해서도 어떻게 접근하면 좋을지 <a href=\"https://dev.to/jaeyeophan/client-centered-user-exception-handling-23a1\">자신의 글</a>을 소개하기도 한다. (알고보니 토스에 재직하시는 분이었다..!)</li>\n<li>패턴 매칭 함수를 소개하는 내용도 인상적이었다. 각 조건에 따라 반환될 컴포넌트만 함수에 전달하는 방식으로 구현 복잡성을 크게 낮출 수 있을 것 같아서 실무에서도 써볼만한 코드라고 생각했다. 구현 코드는 <a href=\"https://gist.github.com/gpichot/df6b586c0ac09ebde794c7f5bef5800f\">링크</a>에서 확인할 수 있다.\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default function SessionsList() {\n  const sessionsQuery = useSessionsListQuery();\n\n  return (\n    &lt;PageLayout title=&quot;My sessions&quot;&gt;\n      {matchQueryStatus(sessionsQuery, {\n        Loading: &lt;Skeleton /&gt;\n        Errored: &lt;Alert kind=&quot;error&quot; icon={&lt;IconAlertCircle size=&quot;1rem&quot; /&gt;} /&gt;,\n        Empty: &lt;Alert kind=&quot;default&quot; description=&quot;No session scheduled&quot; /&gt;,\n        Success: ({ data }) =&gt; &lt;SessionList items={data} /&gt;\n      })}\n    &lt;/PageLayout&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>","excerpt":"출처 Component Composition is greate btw을 읽고 요약한 글입니다. 본문 요약 상태에 따라 특정 컴포넌트의 렌더링 여부를 결정해야 하는 경우는 흔하다. 대표적으로 서버로부터 받는 데이터에 따라 무언가를 보여주거나 보여주지 …","timeToRead":3,"headings":[{"id":"출처","value":"출처","depth":2},{"id":"본문-요약","value":"본문 요약","depth":2},{"id":"인상-깊었던-코멘트","value":"인상 깊었던 코멘트","depth":2}],"frontmatter":{"created":"2024-10-09 17:13:11 +0900","updated":"2024-10-09 17:46:03 +0900"},"fields":{"slug":"/리액트/리액트_토막_지식/컴포지션으로_조건부_컴포넌트_렌더링_개선","title":"컴포지션으로 조건부 컴포넌트 렌더링 개선"}}},"pageContext":{"slug":"/리액트/리액트_토막_지식/컴포지션으로_조건부_컴포넌트_렌더링_개선","title":"컴포지션으로 조건부 컴포넌트 렌더링 개선"}},"staticQueryHashes":["2328167765","3156452557"],"slicesMap":{}}