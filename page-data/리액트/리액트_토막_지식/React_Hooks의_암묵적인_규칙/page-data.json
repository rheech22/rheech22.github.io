{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/리액트/리액트_토막_지식/React_Hooks의_암묵적인_규칙/","result":{"data":{"markdownRemark":{"html":"<p>출처: <a href=\"https://macwright.com/2024/09/19/the-extra-rules-of-hooks?_bhlid=0bedb870260594251e2ab01928e6affb7ce45a95\">https://macwright.com/2024/09/19/the-extra-rules-of-hooks?_bhlid=0bedb870260594251e2ab01928e6affb7ce45a95</a></p>\n<p>useEffect의 종속성 배열에는 콜백 내에서 참조되는 모든 변수가 포함되어야 한다는 규칙이 있다. 규칙 위반을 방지하기 위해 eslint의 <code>react-hooks/exhaustive-dpeps</code> 규칙을 설정하기도 하는데, 종속성 배열에서 누락된 참조가 있다면 알려주는 식이다.</p>\n<p>하지만, 이 규칙에도 예외가 있는데 일부 \"안정적인 것으로 알려져 있는\" 값은 종속성 배열에 추가하지 않아도 된다. <a href=\"https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/src/ExhaustiveDeps.js#L177-L188\">eslint 규칙 구현</a>에서도 확인할 수 있는 내용이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// Some are known to be stable based on Hook calls.\n// const [state, setState] = useState() / React.useState()\n//               ^^^ true for this reference\n// const [state, dispatch] = useReducer() / React.useReducer()\n//               ^^^ true for this reference\n// const [state, dispatch] = useActionState() / React.useActionState()\n//               ^^^ true for this reference\n// const ref = useRef()\n//       ^^^ true for this reference\n// const onStuff = useEffectEvent(() =&gt; {})\n//       ^^^ true for this reference\n// False for everything else.</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://react.dev/learn/synchronizing-with-effects#why-was-the-ref-omitted-from-the-dependency-array\">리액트 공식 문서</a>도 이 내용을 언급하고 있다.</p>\n<ul>\n<li>useRef 훅의 ref객체는 종속성 배열에 포함시키지 않아도 된다.</li>\n<li>모든 렌더링에서 항상 동일한 객체를 얻을 수 있음이 보장된다.</li>\n<li>useState의 set 함수도 stable identity를 갖기 때문에 종속성 배열에 포함시키지 않아도 된다.</li>\n<li>단, 부모 컴포넌트에서 전달된 경우 항상 동일한 참조를 전달하는지 알기 어렵기 때문에 종속성 배열에 포함시켜야 한다.</li>\n</ul>\n<p>회사 프로젝트에서도 해당 eslint 규칙을 사용하고 있기 때문에 어느 정도 알고 있던 내용이지만 깊게 생각해 본 적은 없었다. 근데 어떤 값이 안정적인 값이고 무엇이 아닌지는 어떻게 알 수 있는걸까? 실제로 어떤 라이브러리에서 넘기는 함수는 종속성 배열의 예외로 취급되기도 하고 다른 라이브러리는 아니기도 한데, 출처에서는 이러한 내용들이 명확하지 않다고 지적하고 있다. 리액트 공식 문서에서는 다음과 같이 설명하고 있다.</p>\n<blockquote>\n<p>Omitting always-stable dependencies only works when the linter can “see” that the object is stable.</p>\n</blockquote>","excerpt":"출처: https://macwright.com/2024/09/19/the-extra-rules-of-hooks?_bhlid=0bedb870260594251e2ab01928e6affb7ce45a95 useEffect의 종속성 배열에는 콜백 내에서 참조…","timeToRead":1,"headings":[],"frontmatter":{"created":"2024-10-09 13:47:44 +0900","updated":"2024-10-09 14:21:40 +0900"},"fields":{"slug":"/리액트/리액트_토막_지식/React_Hooks의_암묵적인_규칙","title":"React Hooks의 암묵적인 규칙"}}},"pageContext":{"slug":"/리액트/리액트_토막_지식/React_Hooks의_암묵적인_규칙","title":"React Hooks의 암묵적인 규칙"}},"staticQueryHashes":["2328167765","3156452557"],"slicesMap":{}}