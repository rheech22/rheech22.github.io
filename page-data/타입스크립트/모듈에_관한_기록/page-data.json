{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/타입스크립트/모듈에_관한_기록/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"모듈-시스템-사용하기\" style=\"position:relative;\">모듈 시스템 사용하기<a href=\"#%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"모듈 시스템 사용하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>package.json</code>에 <code>type</code> 속성을 지정하여 자바스크립트의 특정 모듈 시스템을 사용할 수 있다.</p>\n<deckgo-highlight-code language=\"json\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// ES Module\n&quot;type&quot;: &quot;module&quot;\n// CommonJS\n&quot;type&quot;: &quot;commonjs&quot; // 또는 생략</code>\n        </deckgo-highlight-code>\n<p>혹은 파일 확장자로 강제할 수 있다. 기본적으로는 CommonJS 스타일을 따른다.</p>\n<deckgo-highlight-code language=\"json\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// ES Module\nindex.mjs\n// CommonJS\nindex.cjs</code>\n        </deckgo-highlight-code>\n<h2 id=\"브라우저-스크립트에서-다른-모듈-불러오기\" style=\"position:relative;\">브라우저 스크립트에서 다른 모듈 불러오기<a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A5%B8-%EB%AA%A8%EB%93%88-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0\" aria-label=\"브라우저 스크립트에서 다른 모듈 불러오기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>html의 스크립트에서 다른 모듈을 <code>import</code>로 가져오려면 <code>&#x3C;script /></code> 태그에 <code>type=”module”</code> 속성을 넣어줘야 한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<p>그렇지 않으면 런타임 에러가 발생한다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">Uncaught SyntaxError: Cannot use import statement outside a module</code>\n        </deckgo-highlight-code>\n<h2 id=\"타입스크립트에서의-모듈\" style=\"position:relative;\">타입스크립트에서의 모듈<a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%EB%AA%A8%EB%93%88\" aria-label=\"타입스크립트에서의 모듈 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입스크립트를 사용한다면 타입스크립트 컴파일러가 모듈을 다루는 방식에 대한 이해가 필요하다. 브라우저는 타입스크립트 문법을 해석할 수 없다. 그래서 자바스크립트로 컴파일하는 과정이 필요하다. 이 때 타입스크립트의 컴파일 옵션(<code>tsconfig.json</code>의 <code>compilerOptions</code>)을 통해 애플리케이션의 개발 및 구동 환경에 적합한 옵션을 설정할 수 있다. 제대로 설정하지 못한 경우엔 컴파일이 실패할 수도 있고 최악의 경우 런타임 에러가 발생할 수 있다. 타입스크립트의 컴파일 옵션 중 모듈 시스템에 관한 것으로 <code>module</code>과 <code>moduleResolution</code>이 있다.</p>\n<h3 id=\"compileroptionsmodule\" style=\"position:relative;\">compilerOptions.module<a href=\"#compileroptionsmodule\" aria-label=\"compileroptionsmodule permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong><code>module</code>은 컴파일된 자바스크립트 코드에서 어떤 모듈 시스템을 사용하는지 결정한다.</strong> 그 기본값은 <code>target</code>에 따라 달라지는데 <code>target</code>이 <code>ES5</code>라면 <code>commonjs</code>, 그렇지 않다면 <code>ES6/ES2015</code>라고 한다.(참고로 <code>target</code>의 기본값은 <code>ES5</code>) 주목할만한 옵션으로는 <code>node16</code>, <code>nodenext</code>, <code>perserve</code>, <code>es2015</code>, <code>es2020</code>, <code>es2022</code>, <code>esnext</code> 정도가 있고 다음과 같이 크게 3개의 그룹으로 묶어서 보아도 괜찮을 것 같다.</p>\n<p><strong><code>node16/nodenext</code></strong></p>\n<p><code>node16</code>와 <code>nodenext</code> 는 현재(2024/11/14)로서는 동일하게 동작한다. 나중에 노드의 모듈 시스템이 크게 변경되면 <code>nodenext</code>도 바뀔 것으로 보인다. 두 옵션은 CommonJS와 ESModule의 형식을 모두 지원한다. 여기서 모두 지원한다는 건 파일 확장자 또는 <code>type</code> 속성을 보고 모듈 시스템을 추론하여 알아서 컴파일한다는 의미다.</p>\n<p><strong><code>preserve</code></strong></p>\n<p><code>preserve</code>는 5.4버전부터 추가된 것으로 다소 생소한데, 파일의 <code>import</code>, <code>export</code> 구문은 그대로 보존되고, <code>import x = require(\"...\")</code> 및 <code>export = ...</code> 문은 CommonJS <code>require</code> 및 <code>module.exports</code>로 바뀐다고 한다. 이 옵션은 변환을 암시하지 않기 때문에 주로 번들러에 의해 변환되지 않은 타입스크립 파일을 처리할 때 적합하고 <code>--moduleResolution bundler</code> 및 <code>—-noEmit</code> 옵션과 함께 주로 사용된다.</p>\n<p><strong><code>es2015/es2020/es2022/esnext</code></strong></p>\n<p>나머지 <code>es-</code> 옵션은 <code>moduleResolution</code>의 <code>bundler</code> 옵션과 함께 사용한다. <code>es2020</code>부터는 <code>import.meta</code>를 지원하고 <code>es2022</code>부터는 <code>top-level await</code>을 지원한다. 만약 브라우저가 아닌 Node.js를 위해 ESModule 형식을 갖추고 싶다면,  <code>node16</code>나 <code>nodenext</code>를 사용하는 것이 바람직하다.</p>\n<p>이 밖에도 여러 옵션이 있지만 흔히 사용되지는 않는 것으로 보인다. 그 중에서 흔하게 접할 수 있는 <code>commonjs</code> 도 최근에는 사용이 권장되지 않고 <code>node16/nodenext</code>을 권하고 있다. CommonJS를 위해서라면 <code>node16/nodenext</code>로도 충분하기 때문이다.</p>\n<h3 id=\"compileroptionsmoduleresolution\" style=\"position:relative;\">compilerOptions.moduleResolution<a href=\"#compileroptionsmoduleresolution\" aria-label=\"compileroptionsmoduleresolution permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong>한편 <code>moduleResolution</code> 옵션은 모듈 탐색 방식을 결정한다.</strong> 이 옵션으로 타입스크립트 컴파일러가 가져오기 구문을 만났을 때 모듈을 찾는 방식을 지정할 수 있는데 다음과 같은 옵션이 있다.</p>\n<p><strong><code>node16/nodenext</code></strong></p>\n<p>Node.js 12버전 이상부터 서로 다른 알고리즘을 사용하여 해석되는 <code>import</code>와 <code>require</code>를 모두 지원한다. 타입스크립트 5.2버전부터는 <code>module: “node16/nodenext\"</code>와의 조합이 강제되는데 관련된 내용은 타입스크립트 공식 레포의 <a href=\"https://github.com/microsoft/TypeScript/pull/54567\">PR</a>에서 볼 수 있다. 타입스크립트 컴파일러가 모듈을 해석하는 방법과 실제 빌드된 코드 그리고 런타임 환경이 서로 어긋난 모듈 해석 전략을 취함으로써 발생할 수 있는 문제를 방지하기 위한 선택으로 보인다.</p>\n<p>가령, 컴파일 옵션은 <code>module: “esnext\"</code>, <code>moduleResolution: “node16/nodenext\"</code>, <code>package.json</code>의 <code>type</code>이 <code>module</code>이 아닌 상황을 가정해보자. 이 경우에 <code>type=”module”</code>이 아니기 때문에 런타임 환경에서는 CommonJS 형식을 기대할 것이고 타입스크립트 컴파일러도 <code>moduleResolution: “node16/nodenext\"</code>에 의해 CommonJS 스타일로 모듈을 해석한다. 하지만 실제 컴파일 결과는 <code>module: “esnext\"</code>에 따라 ESModule을 빌드된다면 런타임 에러가 발생할 가능성이 있다.</p>\n<p><strong><code>bundler</code></strong></p>\n<p><code>node16</code>와 <code>nodenext</code>와 마찬가지로 <code>package.json</code>의 <code>imports</code> 및 <code>exports</code> 속성을 지원한다. 단, 모듈 해석에 있어서 번들러가 파일 확장자를 자동으로 처리해주기 때문에 상대 경로의 <code>import</code> 구문에서 파일 확장자를 요구하지 않는다.</p>\n<p><strong><code>node10</code></strong></p>\n<p>이전에는 <code>node</code>였던 것이 변경됐다. CommonJS만 지원하는 Node.js 10버전 이하를 지원하는 옵션이다.</p>\n<p><strong><code>classic</code></strong></p>\n<p>타입스크립트 초기 버전에서 사용되던 모듈 해석 방식인데 <code>module</code>이 <code>commonjs</code>, <code>node16</code>, <code>nodenext</code>가 아닌 경우 기본값으로 사용된다고 한다. 사용이 권장되는 옵션은 아니다. 타입스크립트 6.0버전 이후부터는 <code>depreacated</code>될 예정이다.</p>","excerpt":"모듈 시스템 사용하기 package.json에 type 속성을 지정하여 자바스크립트의 특정 모듈 시스템을 사용할 수 있다. 혹은 파일 확장자로 강제할 수 있다. 기본적으로는 CommonJS 스타일을 따른다. 브라우저 스크립트에서 다른 모듈 불러오기 …","timeToRead":2,"headings":[{"id":"모듈-시스템-사용하기","value":"모듈 시스템 사용하기","depth":2},{"id":"브라우저-스크립트에서-다른-모듈-불러오기","value":"브라우저 스크립트에서 다른 모듈 불러오기","depth":2},{"id":"타입스크립트에서의-모듈","value":"타입스크립트에서의 모듈","depth":2},{"id":"compileroptionsmodule","value":"compilerOptions.module","depth":3},{"id":"compileroptionsmoduleresolution","value":"compilerOptions.moduleResolution","depth":3}],"frontmatter":{"created":"2024-11-14 14:35:13 +0900","updated":"2024-11-14 14:52:13 +0900"},"fields":{"slug":"/타입스크립트/모듈에_관한_기록","title":"모듈에 관한 기록"}}},"pageContext":{"slug":"/타입스크립트/모듈에_관한_기록","title":"모듈에 관한 기록"}},"staticQueryHashes":["2328167765","3156452557"],"slicesMap":{}}