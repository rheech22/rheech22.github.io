{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/책/프레임워크_없는_프론트엔드_개발/3장_DOM_이벤트_관리/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"이벤트-라이프사이클\" style=\"position:relative;\">이벤트 라이프사이클<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4\" aria-label=\"이벤트 라이프사이클 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Event\">Event</a> 인터페이스는 DOM 내에 위치한 이벤트로 계층 구조를 이룬다. 그 종류에 따라 이벤트 인터페이스를 상속하는 좀 더 구체적인 이벤트 인터페이스로 구현될 수 있다.</p>\n<p>이벤트 라이프 사이클은 3단계로 구성된다.</p>\n<ol>\n<li>캡쳐 단계: 이벤트가 html부터 목표 요소로 이동한다.</li>\n<li>목표 단계: 이벤트가 목표 요소에 도달한다.</li>\n<li>버블 단계: 이벤트가 목표 요소로부터 html로 이동한다.</li>\n</ol>\n<p>부모와 자식 요소에 이벤트 핸들러가 모두 연결되어 있다면, 자식 요소에서 이벤트가 발생할 때 부모 요소의 이벤트 핸들러도 실행된다. 이를 이벤트 버블링이라 한다. 기본적으로 발생하는 이 현상을 막기 위해서는 <code>stopPropagation()</code> 메서드를 사용해야 한다.</p>\n<p>부모와 자식의 이벤트 핸들러 중 무엇이 먼저 실행되는지는 <code>useCapture</code> 옵션이 결정한다. 만약 <code>useCapture</code>가 <code>false</code>라면 버블링 단계에서 이벤트 핸들러를 실행한다. 즉 자식의 이벤트 핸들러부터 실행한다. 반면, <code>useCapture</code>가 <code>true</code>인 경우 캡쳐 단계에서 이벤트 핸들러를 실행하기 때문에 부모의 이벤트 핸들러부터 실행한다.</p>\n<h2 id=\"이벤트-핸들러-연결하기\" style=\"position:relative;\">이벤트 핸들러 연결하기<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"이벤트 핸들러 연결하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"on-속성으로-이벤트-핸들러-연결\" style=\"position:relative;\">On* 속성으로 이벤트 핸들러 연결<a href=\"#on-%EC%86%8D%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%97%B0%EA%B2%B0\" aria-label=\"on 속성으로 이벤트 핸들러 연결 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>쉽고 지저분한 방법, 하나의 DOM 요소에 하나의 핸들러만 할당할 수 없다.</p>\n<h3 id=\"addeventlistener로-이벤트-핸들러-연결\" style=\"position:relative;\">addEventListener로 이벤트 핸들러 연결<a href=\"#addeventlistener%EB%A1%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%97%B0%EA%B2%B0\" aria-label=\"addeventlistener로 이벤트 핸들러 연결 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\">addEventListener()</a>로 하나의 DOM 요소에 여러 이벤트 핸들러를 연결할 수 있다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\">removeEventListener()</a>로 이벤트 핸들러를 제거하여 메모리 누수를 방지할 수도 있다.</p>\n<h2 id=\"커스텀-이벤트\" style=\"position:relative;\">커스텀 이벤트<a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8\" aria-label=\"커스텀 이벤트 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/CustomEvent/CustomEvent\">Custom Event</a>를 만들 수도 있다.</p>\n<p>아래 핸들러는 인풋 값의 길이가 5를 넘어가면 커스텀 이벤트를 생성 및 실행한다. 생성자의 첫 번째 인자에는 이벤트 이름, 두 번째 인자로는 <code>detail</code> 속성을 포함하는 옵션을 전달할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const handleChangeInput = (e) =&gt; {\n  const { length } = e.target.value;\n\n  if (length &lt; 5) {\n    console.log(&#39;default event&#39;);\n  } else {\n    input.dispatchEvent(new CustomEvent(&#39;customEvent&#39;, {\n      detail: { time: new Date().getTime() }\n    }))\n  }\n}\n\ninput.addEventListener(&#39;input&#39;, handleChangeInput);\ninput.addEventListener(&#39;customEvent&#39;, (e) =&gt; log(e.target.value, e.detail.time))</code>\n        </deckgo-highlight-code>\n<h2 id=\"기존-투두리스트-애플리케이션의-문제점\" style=\"position:relative;\">기존 투두리스트 애플리케이션의 문제점<a href=\"#%EA%B8%B0%EC%A1%B4-%ED%88%AC%EB%91%90%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"기존 투두리스트 애플리케이션의 문제점 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지난 챕터에서 만들었던 애플리케이션은 할 일 요소를 문자열로 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,18\">\n          <code slot=\"code\">const Todos = todo =&gt; {\n  const {\n    text,\n    completed\n  } = todo\n\n  return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;input class=&quot;edit&quot; value=&quot;${text}&quot;&gt;\n      &lt;/li&gt;`\n}</code>\n        </deckgo-highlight-code>\n<p>그러나 문자열에는 <code>addEventListener()</code>로 이벤트 핸들러를 추가할 수 없다. 다른 방법을 알아보자.</p>\n<h2 id=\"createelement-api\" style=\"position:relative;\">createElement API<a href=\"#createelement-api\" aria-label=\"createelement api permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// source: MDN\n\nfunction addElement () {\n  // create a new div element\n  var newDiv = document.createElement(&quot;div&quot;);\n  // and give it some content\n  var newContent = document.createTextNode(&quot;환영합니다!&quot;);\n  // add the text node to the newly created div\n  newDiv.appendChild(newContent);\n\n  // add the newly created element and its content into the DOM\n  var currentDiv = document.getElementById(&quot;div1&quot;);\n  document.body.insertBefore(newDiv, currentDiv);\n}</code>\n        </deckgo-highlight-code>\n<p><code>createElement API</code>를 사용하여 새로운 DOM 노드를 생성할 수 있다. 이 방식은 가독성이 그리 좋지 않고 유지보수가 어렵다는 단점이 있다.</p>\n<h2 id=\"template-element\" style=\"position:relative;\">Template element<a href=\"#template-element\" aria-label=\"template element permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>&#x3C;template /></code>요소는 동적으로 DOM 노드를 생성하는 수단이다. 이 요소는 페이지를 불러오는 순간에는 렌더링되지 않는다. 대신 자바스크립트가 <code>&#x3C;template /></code>기반의 돔 노드를 생성할 수 있다. 컴포넌트 함수에서 문자열로 만들던 내용을 지우고 <code>&#x3C;template /></code> 을 작성한다.</p>\n<p>두 개의 템플릿을 추가했다.</p>\n<ol>\n<li>할 일 요소 구성을 담는 todo-item 템플릿</li>\n<li>전체 앱의 구성을 담는 todo-app 템플릿</li>\n</ol>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,36\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;li&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;삭제&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/li&gt; \n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;section class=&quot;todoapp&quot;&gt;\n        &lt;header&gt;\n          &lt;h1&gt;todos&lt;/h1&gt;\n          &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n        &lt;/header&gt;\n        &lt;section class=&quot;main&quot;&gt;\n          &lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label for=&quot;toggle-all&quot;&gt;전체 완료&lt;/label&gt; \n          &lt;ul data-component=&quot;todos&quot;&gt;&lt;/ul&gt;\n        &lt;/section&gt;\n        &lt;footer class=&quot;footer&quot;&gt;\n          &lt;span data-component=&quot;counter&quot;&gt;&lt;/span&gt;\n          &lt;ul data-component=&quot;filters&quot;&gt;\n            &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;미완료&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n          &lt;/ul&gt;\n          &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n        &lt;/footer&gt;\n      &lt;/section&gt;\n    &lt;/template&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p><code>Todo</code> 컴포넌트는 더 이상 문자열을 리턴하지 않는다. <code>state.todos</code>를 순회하며 새로운 할 일 목록을 구성하고 반환한다. <code>createNewTodo()</code>는 각각의 할 일을 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,8\">\n          <code slot=\"code\">const Todos = (targetElement, { todos }) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = &#39;&#39;;\n\n  todos\n    .map((todo, index) =&gt; createNewTodo(todo, index))\n    .forEach((todo) =&gt; newTodoList.appendChild(todo));\n\n  return newTodoList\n}</code>\n        </deckgo-highlight-code>\n<p><code>createNewTodo()</code>는 할 일의 내용과 속성을 채워준다. <code>todoElement()</code>는 DOM 요소를 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,14\">\n          <code slot=\"code\">const createNewTodo = (todo, index) =&gt; {\n  const {\n    text,\n    completed\n  } = todo;\n\n  const element = todoElement();\n\n  element.querySelector(&#39;label&#39;).textContent = text;\n\n  if (completed) {\n    element.classList.add(&#39;completed&#39;);\n    element.querySelector(&#39;input.toggle&#39;).checked = true;\n  }\n\n  return element;\n}</code>\n        </deckgo-highlight-code>\n<p><code>todoElement()</code>는 템플릿을 복제한 요소를 반환한다. 이처럼 템플릿을 재사용하면서 DOM을 동적으로 생성할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5\">\n          <code slot=\"code\">let template;\n\nconst todoElement = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-item&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n};</code>\n        </deckgo-highlight-code>\n<p>App 컴포넌트는 전체 구성을 담는 todo-app 템플릿을 복제하여 DOM을 생성한다.</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5 16\">\n          <code slot=\"code\">let template;\n\nconst getTemplate = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-app&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n}\n\nexport default (targetElement) =&gt; {\n  const newApp = targetElement.cloneNode(true);\n\n  newApp.innerHTML = &#39;&#39;;\n\n  newApp.appendChild(getTemplate());\n\n  return newApp;\n}</code>\n        </deckgo-highlight-code>\n<p>App 컴포넌트도 다른 컴포넌트와 마찬가지로 레지스트리에 등록한다.</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\n\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\naddComponent(&#39;filters&#39;, Filters);</code>\n        </deckgo-highlight-code>\n<p>뷰에도 App 컴포넌트가 들어갈 자리가 필요하다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12,14\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;!-- 생략 --&gt;\n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;!-- 생략 --&gt;\n    &lt;/template&gt;\n    &lt;div id=&quot;root&quot;&gt;\n      &lt;div data-component=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>렌더링 함수는 <code>.todoapp</code>이 아닌 <code>root div</code>에 접근한다.</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state);\n\n    renderDiff(document.body, app, newApp);\n  })\n}</code>\n        </deckgo-highlight-code>\n<p>이전과 같이 할 일 목록을 보여준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b810508f1bf24ac8cee2256a4889c006/6bbf7/todos.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 96.55172413793103%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAABlUlEQVR42q2U226CUBBF+f8v8dnGF1NN1MRL1UYwxFsUkQipUCKCCHLZnTnWpm8W6SQDgYTFnpk9R9put+j3+yJXqxXiOC6VEgNrtRrq9ToGgwE48jzHsyHxx1mWIU1Tcee/JEkinu/vCgE/DgesNxuYpgnbtgXkcrkgDEORQRAUgkqn00nAOp0OxuMxhsMhPM8TKu99KQRkRdfrFY7jCIWu6wrY0z3kCytgKCtTFAXL5RLr9RoHaoeqqtjtdsWAURTB/XThHT2MRiNMJhPMZjMsFgv0ej1Mp1MYhiHKf+QCAeSyg9CH5ZhQZEX4UdM0zOdzAWJ4s9mE7/t/A+ZJDv2g4XXxgrf+UJS5oclz6cbOQKvVwn6/LzYUTu4lJw+FVXBymefz+afch0DTsiDLMrrdLnhr/mVTbmaOyMhXlGD9tk1M1vBpnzPyYvatsgQwTSMagIdqNUWjwf3MyylkoKoeUakkZJm0XMm3AeTksYyGkpHJyzVRsmjK7VabtuOdDoeesE8pILtf13XaW5vMa5U6GDi+AKPjxYkuIYVHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"todos.png\"\n        title=\"\"\n        src=\"/static/b810508f1bf24ac8cee2256a4889c006/31198/todos.png\"\n        srcset=\"/static/b810508f1bf24ac8cee2256a4889c006/fe9c7/todos.png 174w,\n/static/b810508f1bf24ac8cee2256a4889c006/39e45/todos.png 347w,\n/static/b810508f1bf24ac8cee2256a4889c006/31198/todos.png 694w,\n/static/b810508f1bf24ac8cee2256a4889c006/6bbf7/todos.png 716w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>최종 프로젝트 구성은 아래와 같다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── App.js\n│   ├── Counter.js\n│   ├── Filters.js\n│   └── Todos.js\n├── index.html\n├── index.js\n├── registry.js\n└── renderDiff.js</code>\n        </deckgo-highlight-code>\n<h2 id=\"이벤트-추가하기\" style=\"position:relative;\">이벤트 추가하기<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\" aria-label=\"이벤트 추가하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금은 버튼만 존재할 뿐 할 일 추가와 같은 이벤트는 발생하지 않는다. 이벤트 추가를 위해 이벤트 레지스트리를 생성하고 등록한다. 이제 모든 컴포넌트 함수는 세 번째 파라미터로 이벤트 레지스트리 <code>events</code>를 받는다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"16,28 34\">\n          <code slot=\"code\">// index.js\n\n// set state\nconst state = {\n  todos: fetchTodos(),\n  filter: &#39;All&#39;\n}\n\n// 컴포넌트 레지스트리 등록\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\naddComponent(&#39;filters&#39;, Filters);\n\n// 이벤트 레지스트리 등록\nconst events = {\n  deleteItem: (index) =&gt; {\n    state.todos.splice(index, 1);\n    init()\n  },\n  addItem: (text) =&gt; {\n    state.todos.push({\n      text,\n      completed: false\n    })\n    init()\n  }\n}\n\nconst init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state, events);\n\n    renderDiff(document.body, app, newApp);\n  })\n}\n\ninit();</code>\n        </deckgo-highlight-code>\n<p>이벤트 레지스트리에서 필요한 이벤트 함수를 꺼내 이벤트 핸들러로 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"11,19 28\">\n          <code slot=\"code\">let template;\n\nconst getTemplate = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-app&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n}\n\nconst addKeypressEventListener = (targetElement, events) =&gt; {\n  targetElement.querySelector(&#39;.new-todo&#39;).addEventListener(&#39;keypress&#39;, (e) =&gt; {\n    if (e.key === &#39;Enter&#39;) {\n      events.addItem(e.target.value);\n\n      e.target.value = &#39;&#39;\n    }\n  })\n}\n\nexport default (targetElement, _, events) =&gt; {\n  const newApp = targetElement.cloneNode(true);\n\n  newApp.innerHTML = &#39;&#39;;\n\n  newApp.appendChild(getTemplate());\n\n  addKeypressEventListener(newApp, events);\n\n  return newApp;\n}</code>\n        </deckgo-highlight-code>\n<p>Todo 컴포넌트에서도 할 일 삭제 이벤트 핸들러를 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"26 28\">\n          <code slot=\"code\">let template;\n\nconst todoElement = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-item&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n};\n\nconst createNewTodo = (todo, index, events) =&gt; {\n  const {\n    text,\n    completed\n  } = todo;\n\n  const element = todoElement();\n\n  element.querySelector(&#39;label&#39;).textContent = text;\n\n  if (completed) {\n    element.classList.add(&#39;completed&#39;);\n    element.querySelector(&#39;input.toggle&#39;).checked = true;\n  }\n\n  const handler = () =&gt; events.deleteItem(index);\n\n  element.querySelector(&#39;button.destroy&#39;).addEventListener(&#39;click&#39;, handler);\n\n  return element;\n}\n\nconst Todos = (targetElement, { todos }, events) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = &#39;&#39;;\n\n  todos\n    .map((todo, index) =&gt; createNewTodo(todo, index, events))\n    .forEach((todo) =&gt; newTodoList.appendChild(todo));\n\n  return newTodoList\n}\n\nexport default Todos;</code>\n        </deckgo-highlight-code>\n<h2 id=\"이벤트-위임하기\" style=\"position:relative;\">이벤트 위임하기<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84%ED%95%98%EA%B8%B0\" aria-label=\"이벤트 위임하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Todo 컴포넌트는 각 할 일 요소에 이벤트 핸들러를 연결한다. 만약 이벤트 위임을 활용하면 여러 요소를 담는 목록에 하나의 이벤트 핸들러만 할당하여 모든 이벤트를 처리할 수 있다.</p>\n<br>\n<hr>\n<p><a href=\"https://ko.javascript.info/event-delegation\">출처: https://ko.javascript.info/event-delegation</a></p>\n<p>이벤트 위임이란?</p>\n<blockquote>\n<p>이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있습니다.</p>\n</blockquote>\n<p>이벤트 위임의 장점</p>\n<ul>\n<li>많은 핸들러를 할당하지 않아도 되기 때문에 초기화가 단순해지고 메모리가 절약됩니다.</li>\n<li>요소를 추가하거나 제거할 때 해당 요소에 할당된 핸들러를 추가하거나 제거할 필요가 없기 때문에 코드가 짧아집니다.</li>\n<li><code>innerHTML</code>이나 유사한 기능을 하는 스크립트로 요소 덩어리를 더하거나 뺄 수 있기 때문에 DOM 수정이 쉬워집니다.</li>\n</ul>\n<p>이벤트 위임의 단점</p>\n<ul>\n<li>이벤트 위임을 사용하려면 이벤트가 반드시 버블링 되어야 합니다. 하지만 몇몇 이벤트는 버블링 되지 않습니다. 그리고 낮은 레벨에 할당한 핸들러엔 <code>event.stopPropagation()</code>를 쓸 수 없습니다.</li>\n<li>컨테이너 수준에 할당된 핸들러가 응답할 필요가 있는 이벤트이든 아니든 상관없이 모든 하위 컨테이너에서 발생하는 이벤트에 응답해야 하므로 CPU 작업 부하가 늘어날 수 있습니다. 그런데 이런 부하는 무시할만한 수준이므로 실제로는 잘 고려하지 않습니다.</li>\n</ul>\n<hr>\n<br>\n<p>먼저 각 버튼에 인덱스를 부여하고 할 일 목록에 이벤트 리스너를 등록한다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/matches\">Element.matches()</a> 메서드를 통해 삭제 버튼임을 식별하고 필요한 일을 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"26 40,44\">\n          <code slot=\"code\">let template;\n\nconst todoElement = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-item&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n};\n\nconst createNewTodo = (todo, index, events) =&gt; {\n  const {\n    text,\n    completed\n  } = todo;\n\n  const element = todoElement();\n\n  element.querySelector(&#39;label&#39;).textContent = text;\n\n  if (completed) {\n    element.classList.add(&#39;completed&#39;);\n    element.querySelector(&#39;input.toggle&#39;).checked = true;\n  }\n\n  element.querySelector(&#39;button.destroy&#39;).dataset.index = index;\n\n  return element;\n}\n\nconst Todos = (targetElement, { todos }, events) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = &#39;&#39;;\n\n  todos\n    .map((todo, index) =&gt; createNewTodo(todo, index, events))\n    .forEach((todo) =&gt; newTodoList.appendChild(todo));\n\n  newTodoList.addEventListener(&#39;click&#39;, (e) =&gt; {\n    if (e.target.matches(&#39;button.destroy&#39;)) {\n      events.deleteItem(e.target.dataset.index);\n    }\n  })\n\n  return newTodoList\n}\n\nexport default Todos;</code>\n        </deckgo-highlight-code>\n<p>리스트가 아주 길다면 이 같은 이벤트 위임 방식은 성능과 메모리 사용성을 개선시킬 수 있다.</p>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","excerpt":"이벤트 라이프사이클 Event 인터페이스는 DOM 내에 위치한 이벤트로 계층 구조를 이룬다. 그 종류에 따라 이벤트 인터페이스를 상속하는 좀 더 구체적인 이벤트 인터페이스로 구현될 수 있다. 이벤트 라이프 사이클은 3단계로 구성된다. 캡쳐 단계: 이…","timeToRead":7,"headings":[{"id":"이벤트-라이프사이클","value":"이벤트 라이프사이클","depth":2},{"id":"이벤트-핸들러-연결하기","value":"이벤트 핸들러 연결하기","depth":2},{"id":"on-속성으로-이벤트-핸들러-연결","value":"On* 속성으로 이벤트 핸들러 연결","depth":3},{"id":"addeventlistener로-이벤트-핸들러-연결","value":"addEventListener로 이벤트 핸들러 연결","depth":3},{"id":"커스텀-이벤트","value":"커스텀 이벤트","depth":2},{"id":"기존-투두리스트-애플리케이션의-문제점","value":"기존 투두리스트 애플리케이션의 문제점","depth":2},{"id":"createelement-api","value":"createElement API","depth":2},{"id":"template-element","value":"Template element","depth":2},{"id":"이벤트-추가하기","value":"이벤트 추가하기","depth":2},{"id":"이벤트-위임하기","value":"이벤트 위임하기","depth":2},{"id":"출처","value":"출처","depth":2}],"frontmatter":{"created":"2023-02-12","updated":"2023-02-12","title":"3장_DOM 이벤트 관리"},"fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/3장_DOM_이벤트_관리"}}},"pageContext":{"slug":"/책/프레임워크_없는_프론트엔드_개발/3장_DOM_이벤트_관리"}},"staticQueryHashes":["1829208127","2328167765"],"slicesMap":{}}