{"componentChunkName":"component---src-templates-wiki-template-tsx","path":"/책/프레임워크_없는_프론트엔드_개발/4장_웹_컴포넌트/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"웹-컴포넌트\" style=\"position:relative;\">웹 컴포넌트<a href=\"#%EC%9B%B9-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"웹 컴포넌트 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>웹 컴포넌트는 세 가지 주요 내용을 포함한다.</p>\n<ul>\n<li>HTML 템플릿: 마크업에 포함된 템플릿 요소를 화면에 그리진 않는다. 대신 자바스크립트가 템플릿을 사용해서 DOM을 동적으로 생성할 수 있다.</li>\n<li>Shadow DOM: Shadow DOM의 핵심은 캡슐화로 메인 DOM 트리로부터 독립적인 DOM을 생성할 수 있다. <code>&#x3C;input /></code>, <code>&#x3C;video /></code>와 같은 기본 요소에도 Shadow DOM이 숨겨져 있다.</li>\n<li>Custom Elelment: 사용자 정의 요소를 만들고 제어할 수 있는 API로 이 챕터에서 주로 다룰 주제이다.</li>\n</ul>\n<h2 id=\"사용자-정의-요소custom-element\" style=\"position:relative;\">사용자 정의 요소(Custom Element)<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8Ccustom-element\" aria-label=\"사용자 정의 요소custom element permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저 간단한 사용자 정의 요소를 만들어 보자.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&lt;color-box&gt;&lt;/color-box&gt;</code>\n        </deckgo-highlight-code>\n<p>주의 사항</p>\n<ul>\n<li>이름에는 반드시 하이픈(-)이 들어가야 한다.</li>\n<li>태그를 잘 닫아주어야 한다.</li>\n</ul>\n<p>어떻게 사용할까? HTML에 사용자 정의 요소를 추가한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,11\">\n          <code slot=\"code\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=&quot;shortcut icon&quot; href=&quot;../favicon.ico&quot; /&gt;\n        &lt;title&gt;Frameworkless Frontend Development&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;button&gt;change everything to tamato !!&lt;/button&gt;\n       &lt;color-box&gt;&lt;/color-box&gt;\n       &lt;color-box color=&quot;navy&quot;&gt;&lt;/color-box&gt;\n       &lt;color-box color=&quot;green&quot;&gt;&lt;/color-box&gt;\n       &lt;color-box color=&quot;skyblue&quot;&gt;&lt;/color-box&gt;\n       &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>사용자 정의 요소도 DOM 요소이기 때문에 <code>HTMLElement</code>를 상속한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// Color.js\nexport default class Color extends HTMLElement {\n  // ... \n}</code>\n        </deckgo-highlight-code>\n<p><code>customElements.define()</code>는 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/CustomElementRegistry\">CustomElementRegistry</a>에 새로운 사용자 정의 요소를 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\nimport Color from &#39;./components/Color.js&#39;;\n\ncustomElements.define(&#39;color-box&#39;, Color);</code>\n        </deckgo-highlight-code>\n<p>사용자 정의 요소는 여러 생명주기 함수를 갖는다.</p>\n<ul>\n<li><code>connectedCallback</code>: 처음으로 DOM에 연결됐을 때 호출</li>\n<li><code>disconnectedCallback</code>: DOM으로부터 연결이 해제될 때 호출</li>\n<li><code>adoptedCallback</code>: 새로운 다큐먼트로 이동될 때 호출</li>\n<li><code>attributeChangedCallback</code>: 특정 속성이 변경될 때 호출</li>\n</ul>\n<p><code>attributeChangedCallback()</code>로 사용자 정의 요소의 <code>color</code> 속성이 변경될 때 자식 요소의 속성을 변경할 계획이다. 이 메서드는 <code>observedAttributes()</code>가 관찰하는 속성이 변경될 때만 호출된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// Color.js\n\nconst DEFAULT_COLOR = &#39;black&#39;;\n\nexport default class Color extends HTMLElement {\n  static get observedAttributes() {\n    return [&#39;color&#39;]\n  }\n\n  get color() {\n    return this.getAttribute(&#39;color&#39;) || DEFAULT_COLOR\n  }\n\n  set color(value) {\n    this.setAttribute(&#39;color&#39;, value)\n  }\n\n  attributeChangedCallback(name, prevState, state) {\n    if (!this.div) return;\n\n    if (name === &#39;color&#39;) {\n      this.div.style.color = state\n      this.div.textContent = state\n    }\n  }\n\n  connectedCallback() {\n    window.requestAnimationFrame(() =&gt; {\n      this.div = document.createElement(&#39;div&#39;);\n\n      this.div.textContent = this.color;\n      this.div.style.color = this.color;\n\n      this.appendChild(this.div);\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>버튼 요소에 모든 요소를 <code>tomato</code> 색으로 바꿔주는 이벤트 핸들러를 연결한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,9\">\n          <code slot=\"code\">// index.js\n\nimport Color from &#39;./components/color.js&#39;;\n\ncustomElements.define(&#39;color-box&#39;, Color);\n\nconst changeToTomato = () =&gt; document.querySelectorAll(&#39;color-box&#39;).forEach(div =&gt; div.color = &#39;tomato&#39;);\n\ndocument.querySelector(&#39;button&#39;).addEventListener(&#39;click&#39;, changeToTomato);</code>\n        </deckgo-highlight-code>\n<p>순서는 아래와 같다.</p>\n<ol>\n<li>버튼 클릭 이벤트 발생</li>\n<li>핸들러는 해당 요소의 <code>color</code> 속성 변경</li>\n<li><code>observedAttributes()</code>는 속성 변경 감지</li>\n<li><code>attributeChangedCallback()</code> 호출</li>\n<li><code>color</code> 속성에 따라 자식 요소의 스타일, 텍스트 변경</li>\n</ol>\n<br />\n<p>음.. 잘 된다.</p>\n<p><img src=\"/d9015deff7eba1f0b30e2727b3e5a8c6/color.gif\" alt=\"color\"></p>\n<h2 id=\"사용자-정의-요소로-구현한-투두-앱\" style=\"position:relative;\">사용자 정의 요소로 구현한 투두 앱<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%9C-%ED%88%AC%EB%91%90-%EC%95%B1\" aria-label=\"사용자 정의 요소로 구현한 투두 앱 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지난 챕터에서 만들었던 투두 앱을 사용자 정의 요소를 사용한 앱으로 변경한다.</p>\n<h3 id=\"사용자-정의-요소-등록\" style=\"position:relative;\">사용자 정의 요소 등록<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C-%EB%93%B1%EB%A1%9D\" aria-label=\"사용자 정의 요소 등록 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>HTML에 아래 사용자 정의 요소를 추가한다.</p>\n<ul>\n<li><code>&#x3C;custom-app /></code></li>\n<li><code>&#x3C;custom-todos /></code></li>\n</ul>\n<p>기존 루트 요소는 <code>&#x3C;custom-app /></code>요소가 대체한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"35 39\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-footer&quot;&gt;\n      &lt;footer class=&quot;footer&quot;&gt;\n        &lt;span class=&quot;counter&quot;&gt;&lt;/span&gt;\n        &lt;ul class=&quot;filters&quot;&gt;\n          &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;진행&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n      &lt;/footer&gt;\n    &lt;/template&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;li&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;삭제&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/li&gt; \n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;section class=&quot;todoapp&quot;&gt;\n        &lt;header&gt;\n          &lt;h1&gt;todos&lt;/h1&gt;\n          &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n        &lt;/header&gt;\n        &lt;section class=&quot;main&quot;&gt;\n          &lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label for=&quot;toggle-all&quot;&gt;전체 완료&lt;/label&gt;\n          &lt;custom-todos&gt;&lt;/custom-todos&gt;\n        &lt;/section&gt;\n      &lt;/section&gt;\n    &lt;/template&gt;\n    &lt;custom-app&gt;&lt;/custom-app&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>컨트롤러는 레지스트리에 사용자 정의 요소를 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,7\">\n          <code slot=\"code\">// index.js\n\nimport App from &#39;./components/App.js&#39;\nimport Todos from &#39;./components/Todos.js&#39;\n\nwindow.customElements.define(&#39;custom-app&#39;, App);\nwindow.customElements.define(&#39;custom-todos&#39;, Todos);</code>\n        </deckgo-highlight-code>\n<h3 id=\"dom에-연결될-때-하는-일\" style=\"position:relative;\">DOM에 연결될 때 하는 일<a href=\"#dom%EC%97%90-%EC%97%B0%EA%B2%B0%EB%90%A0-%EB%95%8C-%ED%95%98%EB%8A%94-%EC%9D%BC\" aria-label=\"dom에 연결될 때 하는 일 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>돔에 연결될 때 필요한 것들을 <code>connectedCallback()</code>에 적어보자. <code>&#x3C;custom-todos /></code>는 어떤 모양일까?<br>\n우선 각 할 일을 담을 목록이 필요하다. <code>&#x3C;ul /></code>을 간단한 템플릿으로 사용한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = &#39;&lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;&#39;;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>각 할 일 요소를 위한 구성은 이미 HMTL의 템플릿 요소로 있기 때문에 가져오기만 하면 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = &#39;&lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;&#39;;\n    this.item = document.getElementById(&#39;todo-item&#39;);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이벤트 핸들러도 연결한다. 이벤트 위임 방식으로 목록에 이벤트 핸들러를 할당한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,18\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = &#39;&lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;&#39;;\n    this.item = document.getElementById(&#39;todo-item&#39;);\n  \n    this.list = this.querySelector(&#39;ul&#39;);\n  \n    this.list.addEventListener(&#39;click&#39;, (e) =&gt; {\n        if (e.target.matches(&#39;button.destroy&#39;)) {\n          this.onDeleteButtonClick(e.target.dataset.index);\n        }\n    });\n  \n    this.list.addEventListener(&#39;change&#39;, (e) =&gt; {\n        if (e.target.matches(&#39;input.toggle&#39;)) {\n          this.onCheckboxClick(e.target.dataset.index);\n        }\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>마지막으로 상태에 따라 목록을 생성하고 갱신하는 <code>update()</code>를 호출한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...상동\n\n    this.update();\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>update()</code>는 새로운 목록을 채워주는 지난 챕터의 Todos 컴포넌트가 하던 역할을 그대로 하고 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  update() {\n    this.list.innerHTML = &#39;&#39;;\n\n    this.todos.map((todo, index) =&gt; {\n      const { text, completed } = todo;\n\n      const element = this.item.content.firstElementChild.cloneNode(true);\n\n      element.querySelector(&#39;label&#39;).textContent = text;\n\n      if (completed) {\n        element.classList.add(&#39;completed&#39;);\n        element.querySelector(&#39;input.toggle&#39;).checked = true;\n      }\n\n      element.querySelector(&#39;input.toggle&#39;).dataset.index = index;\n      element.querySelector(&#39;button.destroy&#39;).dataset.index = index;\n\n      return element\n    }).forEach((element) =&gt; {\n      this.list.appendChild(element)\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>update()</code>는 <code>this.todos</code>에 접근한다. 이 속성(property)은 사용자 정의 요소의 속성(attribute)으로도 할당되는 특징이 있다. 이 곳에 할 일 목록을 저장한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&lt;custom-todos todos=&quot;[]&quot;&gt; ... &lt;custom-todos /&gt;</code>\n        </deckgo-highlight-code>\n<p><code>todos</code>접근을 위한 게터와 세터를 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"10,20\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  update() {\n    // ...\n  }\n\n  get todos() {\n    if (!this.hasAttribute(&#39;todos&#39;)) {\n      return [];\n    }\n\n    return JSON.parse(this.getAttribute(&#39;todos&#39;));\n  }\n\n  set todos(value) {\n    this.setAttribute(&#39;todos&#39;, JSON.stringify(value));\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"관찰-대상이-갱신되면-하는-일\" style=\"position:relative;\">관찰 대상이 갱신되면 하는 일<a href=\"#%EA%B4%80%EC%B0%B0-%EB%8C%80%EC%83%81%EC%9D%B4-%EA%B0%B1%EC%8B%A0%EB%90%98%EB%A9%B4-%ED%95%98%EB%8A%94-%EC%9D%BC\" aria-label=\"관찰 대상이 갱신되면 하는 일 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>속성이 바뀔 때마다 새로운 할 일 요소를 동적으로 생성하기 위해  <code>attributeChangedCallback()</code>을 사용한다. <code>update()</code>를 실행하는 이 함수는 <code>observedAttributes()</code>가 관찰하는 <code>todos</code>속성이 바뀔 때만 호출된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  static get observedAttributes() {\n    return [&#39;todos&#39;];\n  }\n\n  attributeChangedCallback() {\n    if (!this.hasChildNodes()) return;\n\n    this.update();\n  }\n\n  // 생략\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"커스텀-이벤트는-옵저버-패턴의-구현\" style=\"position:relative;\">커스텀 이벤트는 옵저버 패턴의 구현?!<a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%8A%94-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4%EC%9D%98-%EA%B5%AC%ED%98%84\" aria-label=\"커스텀 이벤트는 옵저버 패턴의 구현 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>마지막으로 이벤트 핸들러를 선언한다. 이 곳에서는 이벤트가 발생하는 사실만을 알려주고 그 때 처리해야 하는 일은 다른 곳에서 결정하도록 하고 싶다면 어떻게 해야 할까? 커스텀 이벤트를 활용한 방법이 있다. 그 전에 먼저 이벤트 레지스트리를 등록한다. 구독하는 곳에서도 쉽게 접근할 수 있도록 컨트롤러에 선언한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,9\">\n          <code slot=\"code\">// index.js\n\nimport App from &#39;./components/App.js&#39;\nimport Todos from &#39;./components/Todos.js&#39;\n\nexport const events = {\n  deleteItem: &#39;deleteItem&#39;,\n  toggleCompleted: &#39;toggleCompleted&#39;,\n}\n\nwindow.customElements.define(&#39;custom-app&#39;, App);\nwindow.customElements.define(&#39;custom-todos&#39;, Todos);</code>\n        </deckgo-highlight-code>\n<p>이벤트 핸들러는 아래와 같다. 단순히 인덱스를 포함하는 커스텀 이벤트 객체를 생성하고 이벤트를 디스패치한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"20,41\">\n          <code slot=\"code\">import { events } from &quot;../index.js&quot;;\n\nexport default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  update() {\n    // ...\n  }\n\n  get todos() { \n    // ... \n  }\n\n  set todos(value) { \n    // ...\n  }\n\n  onDeleteButtonClick(index) {\n    const event = new CustomEvent(\n      events.deleteItem,\n      {\n        detail: {\n          index\n        }\n      }\n    )\n\n    this.dispatchEvent(event)\n  }\n\n  onCheckboxClick(index) {\n    const event = new CustomEvent(\n      events.toggleCompleted,\n      {\n        detail: {\n          index\n        }\n      }\n    )\n\n    this.dispatchEvent(event)\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이 곳에서는 이벤트 발생에 따라 ‘어떤 일을 해야 할지’에 관해 관심을 두지 않아도 된다. 한편 외부에서는 ‘이벤트가 발생하는 경로’에 관한 사실을 몰라도 된다. 자연스럽게 관심사를 분리하고 각자의 역할을 수행한다. 경우에 따라서 중복 코드도 줄일 수 있다. 사실 커스텀 이벤트를 처음 접할 때 그 효용에 관해서 의심을 가졌는데, 챕터의 예제를 보고 괜히 나온 API가 아니라는 느낌을 받았다. 커스텀 이벤트가 옵저버 패턴의 구현체라고 소개하는 글을 보기도 했다. 관심있으면 아래 링크를 참고하자.</p>\n<p><a href=\"https://stackoverflow.com/questions/57036994/how-are-custom-events-in-javascript-different-from-simply-calling-regular-functi\">How are custom events in JavaScript different from simply calling regular functions?</a></p>\n<p>앱 전체를 구성하는 <code>&#x3C;custom-app /></code>은 상태를 선언하고 todo-app 템플릿을 사용한다. 책에서는 <code>constructor()</code>에서 미리 상태와 템플릿을 선언하고 있지만, DOM에 처음 연결될 때 초기화해도 무리가 없을 것 같아 <code>connectedCallback()</code>이 그 책임을 갖도록 했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    this.state = {\n      todos: [],\n      filter: &#39;All&#39;\n    }\n\n    this.template = document.getElementById(&#39;todo-app&#39;);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>렌더링도 해야 한다. 특별한 내용이 있다면 세 개의 이벤트 중 두 개는 레지스트리에 등록된 커스텀 이벤트라는 사실이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"10,28\">\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    this.state = {\n      todos: [],\n      filter: &#39;All&#39;\n    }\n\n    this.template = document.getElementById(&#39;todo-app&#39;);\n\n    window.requestAnimationFrame(() =&gt; {\n      const content = this.template.content.firstElementChild.cloneNode(true);\n\n      this.appendChild(content);\n\n      this.querySelector(&#39;.new-todo&#39;).addEventListener(&#39;keypress&#39;, (e) =&gt; {\n        if (e.key === &#39;Enter&#39;) {\n          this.addItem(e.target.value);\n\n          e.target.value = &#39;&#39;;\n        }\n      })\n\n      this.list = this.querySelector(&#39;custom-todos&#39;);\n      this.list.addEventListener(events.deleteItem, (e) =&gt; this.deleteItem(e.detail.index));\n      this.list.addEventListener(events.toggleCompleted, (e) =&gt; this.toggleCompleted(e.detail.index));\n\n      this.sync();\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이벤트가 발생하면 어떤 일을 할지 이곳에서 정한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,30\">\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  addItem(text) {\n    const item = { text, completed: false };\n\n    this.state.todos.push(item);\n\n    this.sync();\n  }\n\n  deleteItem(index) {\n    this.state.todos.splice(index, 1);\n\n    this.sync();\n  }\n\n  toggleCompleted(index) {\n    const { todos } = this.state;\n\n    todos.splice(index, 1, {\n      text: todos[index].text,\n      completed: !todos[index].completed\n    });\n\n    this.state.todos = todos;\n    this.sync();\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>모든 메서드에서 호출하고 있는 <code>sync()</code>는 상태에 따라 <code>&#x3C;custom-todos /></code>의 속성을 갱신한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,10\">\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  sync() {\n    const { todos } = this.state;\n\n    this.list.todos = todos;\n  }\n\n  addItem(text) {\n    // ...\n  }\n\n  deleteItem(index) {\n    // ...\n  }\n\n  toggleCompleted(index) {\n    // ...\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"검증하기\" style=\"position:relative;\">검증하기<a href=\"#%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0\" aria-label=\"검증하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이제 할 일 추가, 삭제, 체크 그리고 체크의 해제 모두 잘 동작한다.</p>\n<p><img src=\"/845b1ca2a307ff1a3d48d7f70d092358/todos.gif\" alt=\"todos\"></p>\n<p>유사한 내용이라 자세히 다루진 않겠지만 todo-footer 템플릿을 사용하는 <code>&#x3C;custom-footer /></code>도 추가했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,9 14\">\n          <code slot=\"code\">import App from &#39;./components/App.js&#39;\nimport Footer from &#39;./components/Footer.js&#39;;\nimport Todos from &#39;./components/Todos.js&#39;\n\nexport const events = {\n  deleteItem: &#39;deleteItem&#39;,\n  toggleCompleted: &#39;toggleCompleted&#39;,\n  filterItem: &#39;filterItem&#39;,\n  clearCompleted: &#39;clearCompleted&#39;\n}\n\nwindow.customElements.define(&#39;custom-app&#39;, App);\nwindow.customElements.define(&#39;custom-todos&#39;, Todos);\nwindow.customElements.define(&#39;custom-footer&#39;, Footer);</code>\n        </deckgo-highlight-code>\n<p>이제 필터도 동작한다.</p>\n<p><img src=\"/d6de660de968d5500894ab1285f8700d/with_filter.gif\" alt=\"withFilter\"></p>\n<h2 id=\"관련-라이브러리\" style=\"position:relative;\">관련 라이브러리<a href=\"#%EA%B4%80%EB%A0%A8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\" aria-label=\"관련 라이브러리 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements\">MDN</a>에서 웹 컴포넌트의 추상화 레벨을 높인 여러 라이브러리를 소개하고 있는데 관심있다면 한 번 둘러보는 것을 추천한다. 나는 <a href=\"https://github.com/devpunks/snuggsi\">snuggsi</a>의 맛만 살짝 봤는데 괜찮은 경험이었다.</p>\n<ul>\n<li><a href=\"https://www.fast.design/docs/fast-element/getting-started/\">FASTElement</a></li>\n<li><a href=\"https://github.com/devpunks/snuggsi\">snuggsi</a></li>\n<li><a href=\"https://x-tag.github.io/\">X-Tag</a></li>\n<li><a href=\"https://slimjs.com/\">Slim.js</a></li>\n<li><a href=\"https://lit.dev/\">Lit</a></li>\n<li><a href=\"https://www.htmlelements.com/\">Smart</a></li>\n<li><a href=\"https://stenciljs.com/\">Stencil</a></li>\n<li><a href=\"https://github.com/WebReflection/hyperHTML-Element\">hyperHTML-Element</a></li>\n<li><a href=\"https://www.dataformsjs.com/\">DataFormsJS</a></li>\n<li><a href=\"https://tmorin.github.io/ceb/\">Custom-Element-Builder</a>.</li>\n</ul>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","excerpt":"웹 컴포넌트 웹 컴포넌트는 세 가지 주요 내용을 포함한다. HTML 템플릿: 마크업에 포함된 템플릿 요소를 화면에 그리진 않는다. 대신 자바스크립트가 템플릿을 사용해서 DOM을 동적으로 생성할 수 있다. Shadow DOM: Shadow DOM의 핵…","timeToRead":7,"headings":[{"id":"웹-컴포넌트","value":"웹 컴포넌트","depth":2},{"id":"사용자-정의-요소custom-element","value":"사용자 정의 요소(Custom Element)","depth":2},{"id":"사용자-정의-요소로-구현한-투두-앱","value":"사용자 정의 요소로 구현한 투두 앱","depth":2},{"id":"사용자-정의-요소-등록","value":"사용자 정의 요소 등록","depth":3},{"id":"dom에-연결될-때-하는-일","value":"DOM에 연결될 때 하는 일","depth":3},{"id":"관찰-대상이-갱신되면-하는-일","value":"관찰 대상이 갱신되면 하는 일","depth":3},{"id":"커스텀-이벤트는-옵저버-패턴의-구현","value":"커스텀 이벤트는 옵저버 패턴의 구현?!","depth":3},{"id":"검증하기","value":"검증하기","depth":3},{"id":"관련-라이브러리","value":"관련 라이브러리","depth":2},{"id":"출처","value":"출처","depth":2}],"frontmatter":{"created":"2023-02-19","updated":"2023-02-19","title":"4장_웹 컴포넌트"},"fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/4장_웹_컴포넌트"}}},"pageContext":{"slug":"/책/프레임워크_없는_프론트엔드_개발/4장_웹_컴포넌트"}},"staticQueryHashes":["1829208127","2328167765"],"slicesMap":{}}