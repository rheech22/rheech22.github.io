{"componentChunkName":"component---src-templates-post-tsx","path":"/frameworkless-2","result":{"data":{"markdownRemark":{"html":"<h2 id=\"문서-객체-모델dom\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%84%9C-%EA%B0%9D%EC%B2%B4-%EB%AA%A8%EB%8D%B8dom\" aria-label=\"문서 객체 모델dom permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문서 객체 모델(DOM)</h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction\">DOM</a>은 웹 어플리케이션의 조작 방법을 제공하는 API다. 웹 페이지는 HTML로 정의된 트리 구조를 갖는다. DOM은 이를 관리하는 방법이다.</p>\n<h2 id=\"컴포넌트-기반-애플리케이션\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-label=\"컴포넌트 기반 애플리케이션 permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 기반 애플리케이션</h2>\n<h3 id=\"렌더링-함수\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%95%A8%EC%88%98\" aria-label=\"렌더링 함수 permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 함수</h3>\n<p>순수 함수로 렌더링한다는 것은 DOM 요소가 애플리케이션의 상태에만 의존한다는 것을 의미한다.</p>\n<blockquote>\n<p>view = f(state)</p>\n</blockquote>\n<br >\n<p>투두리스트 앱을 만들었다. 책과 같이 <a href=\"https://todomvc.com/\">ToDoMVC</a>를 사용하지는 않고 좀 더 작은 뷰를 만들었다.<br>\n접근이 필요한 요소에는 클래스 속성을 부여한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  highlight-lines=\"12 14 16\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;section class=&quot;todoapp&quot;&gt;\n      &lt;header&gt;\n        &lt;h1&gt;todos&lt;/h1&gt;\n        &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n      &lt;/header&gt;\n      &lt;section class=&quot;main&quot;&gt;\n        &lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;\n      &lt;/section&gt;\n      &lt;footer class=&quot;footer&quot;&gt;\n        &lt;span class=&quot;todo-count&quot;&gt;&lt;/span&gt;\n        &lt;ul class=&quot;filters&quot;&gt;\n          &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;미완료&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n      &lt;/footer&gt;\n    &lt;/section&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>저자는 <a href=\"https://github.com/faker-js/faker\">faker-js</a>를 사용하지만 간단한 예제를 위해 서버에서 받는 데이터를 단순 가정했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const mockTodos = [\n  {\n    id: &#39;1&#39;,\n    text: &#39;빨래 널기&#39;,\n    completed: false,\n  },\n  {\n    id: &#39;2&#39;,\n    text: &#39;분리수거 하기&#39;,\n    completed: false,\n  },\n  {\n    id: &#39;3&#39;,\n    text: &#39;헬스장 가기&#39;,\n    completed: true,\n  }\n]</code>\n        </deckgo-highlight-code>\n<p><code>fetchTodos()</code>는 할 일 목록을 받아오는 API 호출 함수라고 하자.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const fetchTodos = () =&gt; mockTodos;\n\nconst state = {\n  todos: fetchTodos(),\n  filter: &#39;All&#39;\n}</code>\n        </deckgo-highlight-code>\n<p>렌더링 함수는 <code>requestAnimationFrame()</code>를 사용한다. 후술할 <code>appView()</code>를 통해 기존 뷰를 새로운 뷰로 대체한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const app = document.querySelector(&#39;.todoapp&#39;);\n\nwindow.requestAnimationFrame(() =&gt; {\n  const newApp = appView(app, state)\n  app.replaceWith(newApp)\n})</code>\n        </deckgo-highlight-code>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceWith\">replaceWith()</a>: 이 메서드는 특정 요소를 새로운 요소로 대체한다.</li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame\">requestAnimationFrame()</a>: <code>requestAnimationFrame()</code>는 다음 리페인트가 이벤트 루프에 스케쥴링되기 직전에 실행될 콜백을 브라우저에게 알린다. 이 메서드를 사용하면 메인 스레드를 차단하지 않고 브라우저 렌더링 성능에 최적화된 함수 호출이 가능하다.</li>\n</ul>\n<p><code>appView()</code>는 갱신된 요소를 반환한다. <code>targetElement</code>의 <code>list</code>, <code>counter</code>, <code>filters</code>를 갱신하고 모든 내용을 대체한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const appView = (targetElement, { todos, filter: currentFilter }) =&gt; {\n  const element = targetElement.cloneNode(true)\n\n  // get elements\n  const list = element.querySelector(&#39;.todo-list&#39;)\n  const counter = element.querySelector(&#39;.todo-count&#39;)\n  const filters = element.querySelector(&#39;.filters&#39;)\n\n  // new list\n  const newList = list.cloneNode(true);\n\n  newList.innerHTML = todos.map(({ text, completed }) =&gt; {\n    return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n    `\n  }).join(&#39;&#39;);\n\n  // new counter\n  const newCounter = counter.cloneNode(true);\n\n  const howManyLeft = todos.filter(todo =&gt; !todo.completed).length;\n\n  newCounter.textContent = `${howManyLeft}개 남음`;\n\n  // new filters\n  const newfilters = filters.cloneNode(true);\n  const filterList = newfilters.querySelectorAll(&#39;li a&#39;);\n\n  [...filterList].forEach(filter =&gt; {\n    if (filter.textContent === currentFilter) {\n      filter.classList.add(&#39;selected&#39;);\n    } else {\n      filter.classList.remove(&#39;selected&#39;);\n    }\n  });\n\n  // replace elements\n  list.replaceWith(newList);\n  counter.replaceWith(newCounter);\n  filters.replaceWith(newfilters);\n\n  return element\n}</code>\n        </deckgo-highlight-code>\n<p>브라우저에서 상태에 맞게 그려진 할 일 목록을 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cead9e3623d6cc5736da98f421fab587/f32b7/todos-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.172413793103445%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1UlEQVQoz6XRT4uDMBCHYb//l/K0ly172QjSZT1Ym41/UhUUq43mLQm0bI+mA8McAg+/mURCCOI4pus6rLUYY97qyEFVVTFNE9u2sa6rn6EVaa1pdMMwDCzLwjzPfrpyifd2tNkNc1uRZ4lIBFmWedwlfaC7EmKhHTXJ8ZvD54E0TT3qkgaB03RF1gUnldNeWvq+9/cMwTzoPqU4FYzD+PLwwPavjEXlF45fkttsHPGCBYBQ5h3JR8F1XIJXfYJlqfj9yShy+TbmQaUU8k9SN3Xwmv/BOw5uX7hbMmVFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"todos-1\"\n        title=\"todos-1\"\n        src=\"/static/cead9e3623d6cc5736da98f421fab587/31198/todos-1.png\"\n        srcset=\"/static/cead9e3623d6cc5736da98f421fab587/fe9c7/todos-1.png 174w,\n/static/cead9e3623d6cc5736da98f421fab587/39e45/todos-1.png 347w,\n/static/cead9e3623d6cc5736da98f421fab587/31198/todos-1.png 694w,\n/static/cead9e3623d6cc5736da98f421fab587/ee9b6/todos-1.png 1041w,\n/static/cead9e3623d6cc5736da98f421fab587/f32b7/todos-1.png 1136w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"중간-리팩토링\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EA%B0%84-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81\" aria-label=\"중간 리팩토링 permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중간 리팩토링</h3>\n<p>기능은 아직이지만 기본적인 모양은 완성했다. 하지만 코드에서 리팩토링 신호를 포착할 수 있다. 일단 뷰 함수가 너무 거대하기 때문에 읽기 어렵다. 갱신할 뷰가 추가되면 코드가 더 복잡해지는 건 분명해 보인다. 게다가 개별 요소(<code>todos</code>, <code>counter</code>, <code>filters</code>)를 새로운 것으로 대체하는 작업, 즉 내부 로직은 다르지만 같은 유형의 작업을 수행하고 있다. 하나의 책임을 갖는 함수들로 분리하면 좋을 것 같다.</p>\n<p>예를 들어 뷰 함수는 <code>targetElement</code>와 <code>state</code>를 받아 새로운 요소를 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const viewFunction = (targetElement, state) =&gt; newElement;</code>\n        </deckgo-highlight-code>\n<p>아래 모양의 뷰 함수들로 분리했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const counterView = (targetElement, { todos }) =&gt; {\n  const newCounter = targetElement.cloneNode(true);\n\n  const howManyLeft = todos.filter(todo =&gt; !todo.completed).length;\n\n  newCounter.textContent = `${howManyLeft}개 남음`;\n\n  return newCounter;\n}\n\nconst filterView = (targetElement, { filter: currentFilter }) =&gt; {\n  const newFilters = targetElement.cloneNode(true);\n  const filterList = newCounter.querySelectorAll(&#39;li a&#39;);\n\n  [...filterList].forEach(filter =&gt; {\n    if (filter.textContent === currentFilter) {\n      filter.classList.add(&#39;selected&#39;);\n    } else {\n      filter.classList.remove(&#39;selected&#39;);\n    }\n  })\n\n  return newFilters;\n}\n\nconst todosView = (targetElement, { todos }) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = todos.map(({ text, completed }) =&gt; {\n    return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n    `\n  }).join(&#39;&#39;);\n\n  return newTodoList\n}\n\nconst appView = (targetElement, state) =&gt; {\n  const element = targetElement.cloneNode(true)\n\n  const list = element.querySelector(&#39;.todo-list&#39;)\n  const counter = element.querySelector(&#39;.todo-count&#39;)\n  const filters = element.querySelector(&#39;.filters&#39;)\n\n  list.replaceWith(todosView(list, state))\n  counter.replaceWith(counterView(counter, state))\n  filters.replaceWith(filterView(filters, state))\n\n  return element\n}</code>\n        </deckgo-highlight-code>\n<p>소스 코드의 디렉토리, 파일만 잘 구분해도 설계는 확연하게 좋아질 수 있다. 관심사에 따라 디렉토리도 나눈다면 더 이해하기 쉬운 구조가 된다. 지금까지 작성한 코드가 컴포넌트 라이브러리의 초안이다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">root\n├── views\n│   ├── counterView.js\n│   ├── FilterView.js\n│   └── TodosView.js\n│   └── Appview.js\n├── index.html\n└── index.js</code>\n        </deckgo-highlight-code>\n<h3 id=\"컴포넌트-함수\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%95%A8%EC%88%98\" aria-label=\"컴포넌트 함수 permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 함수</h3>\n<blockquote>\n<p>컴포넌트 기반의 애플리케이션을 작성하려면 컴포넌트 간에 선언적인 방식으로 상호작용 해야 한다.</p>\n</blockquote>\n<br />\n<p>기존 <code>appView()</code>는 함수는 갱신이 필요한 뷰 함수를 직접 호출하고 있다. 이는 선언적 방식이라 할 수 없다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const appView = (targetElement, state) =&gt; {\n  const element = targetElement.cloneNode(true)\n\n  const list = element.querySelector(&#39;.todo-list&#39;)\n  const counter = element.querySelector(&#39;.todo-count&#39;)\n  const filters = element.querySelector(&#39;.filters&#39;)\n\n  list.replaceWith(todosView(list, state))\n  counter.replaceWith(counterView(counter, state))\n  filters.replaceWith(filterView(filters, state))\n\n  return element\n}</code>\n        </deckgo-highlight-code>\n<p>선언적 방식이라면 뭔가 '해 줘' 느낌이 나야 한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d1eca93795fdfb19256e0f0c431c9cec/edd00/do.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.37931034482759%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAIEAQMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAe9mFeS2gWIk2i3/xAAaEAACAgMAAAAAAAAAAAAAAAABAgAREBIy/9oACAEBAAEFAss2ocmk5eAC5//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABcRAAMBAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQIBAT8BJi1f/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAEQIDH/2gAIAQEABj8CqhGR/8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECExUf/aAAgBAQABPyFhgLGKqcv2J3QWxQaY/9oADAMBAAIAAwAAABC/IDz/xAAWEQEBAQAAAAAAAAAAAAAAAAABEEH/2gAIAQMBAT8QWbP/xAAXEQEBAQEAAAAAAAAAAAAAAAABABAR/9oACAECAQE/EBg9Jz//xAAcEAEAAgIDAQAAAAAAAAAAAAABABExQRAhgcH/2gAIAQEAAT8QTeajs9rjMBugvMC0DVPZa+TYDW2ENB73DKCmEDj/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"do\"\n        title=\"do\"\n        src=\"/static/d1eca93795fdfb19256e0f0c431c9cec/9c477/do.jpg\"\n        srcset=\"/static/d1eca93795fdfb19256e0f0c431c9cec/583d1/do.jpg 174w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/4d0aa/do.jpg 347w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/9c477/do.jpg 694w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/909c7/do.jpg 1041w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/edd00/do.jpg 1074w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br />\n<p><code>class</code> 대신 <code>data-component</code> 속성에 컴포넌트의 이름을 넣는다. 이제부터 뷰에서 <a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Howto/Use_data_attributes\">데이터 속성</a>을 사용한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  highlight-lines=\"12 15 16\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;section class=&quot;todoapp&quot;&gt;\n      &lt;header&gt;\n        &lt;h1&gt;todos&lt;/h1&gt;\n        &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n      &lt;/header&gt;\n      &lt;section class=&quot;main&quot;&gt;\n        &lt;ul data-component=&quot;todos&quot;&gt;&lt;/ul&gt;\n      &lt;/section&gt;\n      &lt;footer class=&quot;footer&quot;&gt;\n        &lt;span data-component=&quot;counter&quot;&gt;&lt;/span&gt;\n        &lt;ul data-component=&quot;filters&quot;&gt;\n          &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;미완료&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n      &lt;/footer&gt;\n    &lt;/section&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<br />\n<blockquote>\n<p>컴포넌트 라이브러리를 위한 또 다른 필수 조건은 레지스트리로, 레지스트리는 앱에서 사용할 수 있는 모든 컴포넌트의 인덱스이다.</p>\n</blockquote>\n<br />\n<p>레지스트리 키는 <code>data-component</code>속성과 일치한다. 레지스트리를 사용하면 컴포넌트 안에서 다른 컴포넌트를 사용할 수 있다. 재사용성은 컴포넌트 기반 애플리케이션의 필수 요소다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 레지스트리 예시\n\nconst registry = {\n  todos: Todos,\n  counter: Counter,\n  filters: Filters,\n}</code>\n        </deckgo-highlight-code>\n<p>컴포넌트의 느낌을 내고 싶어 기존 뷰 함수의 이름을 <code>PascalCase</code>로 변경했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  highlight-lines=\"1,2 12,13 28,29\">\n          <code slot=\"code\">// components/Counter.js\nconst Counter = (targetElement, { todos }) =&gt; {\n  const newCounter = targetElement.cloneNode(true);\n\n  const howManyLeft = todos.filter(todo =&gt; !todo.completed).length;\n\n  newCounter.textContent = `${howManyLeft}개 남음`;\n\n  return newCounter;\n}\n\n// components/Filters.js\nconst Filters = (targetElement, { filter: currentFilter }) =&gt; {\n  const newFilters = targetElement.cloneNode(true);\n  const filterList = newCounter.querySelectorAll(&#39;li a&#39;);\n\n  [...filterList].forEach(filter =&gt; {\n    if (filter.textContent === currentFilter) {\n      filter.classList.add(&#39;selected&#39;);\n    } else {\n      filter.classList.remove(&#39;selected&#39;);\n    }\n  })\n\n  return newFilters;\n}\n\n// components/Todos\nconst Todos = (targetElement, { todos }) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = todos.map(({ text, completed }) =&gt; {\n    return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n    `\n  }).join(&#39;&#39;);\n\n  return newTodoList\n}</code>\n        </deckgo-highlight-code>\n<p><code>appView()</code>의 구성은 더 이상 필요하지 않아 삭제하고, <code>fetchTodos()</code>는 <code>apis.js</code>로 분리했다. 그리고 레지스트리를 위한 공간인 <code>registry.js</code>를 추가한다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── Counter.js\n│   ├── Filters.js\n│   └── Todos.js\n├── index.html\n├── index.js\n└── registry.js</code>\n        </deckgo-highlight-code>\n<p>먼저 레지스트리 등록을 위한 빈 객체를 만들어 두었다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// registry.js\n\nconst registry = {};</code>\n        </deckgo-highlight-code>\n<p><code>addComponent()</code>는 레지스트리에 컴포넌트를 등록한다. <code>render()</code>는 고차 함수로서 컴포넌트를 미리 받아 놓고 새로운 상태로 갱신된 엘리먼트를 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// registry.js\n\nexport const addComponent = (name, component) =&gt; {\n  registry[name] = render(component);\n}</code>\n        </deckgo-highlight-code>\n<p><code>render()</code>를 좀 더 살펴보면,</p>\n<p>컴포넌트(기존 뷰 함수)를 실행시켜 새롭게 갱신된 엘리먼트를 리턴한다. 또한 <code>data-component</code> 속성을 갖는 모든 자식 요소를 찾는다. 만약 레지스트리에 등록된 요소라면 이를 갱신한다. 레지스트리에 등록된 컴포넌트는 <code>render()</code>로 래핑되어 <code>targetElement</code>과 <code>state</code>만 전달되면 lazy하게 실행될 준비가 되어있다. 재귀적 구성으로 루트만 렌더링하면 마지막 컴포넌트까지 모두 그린다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// registry.js\n\nconst render = (component) =&gt; {\n  return (targetElement, state) =&gt; {\n    const element = component(targetElement, state);\n\n    const children = element.querySelectorAll(&#39;[data-component]&#39;);\n\n    [...children].forEach((target) =&gt; {\n      const name = target.dataset.component;\n\n      const component = registry[name];\n\n      if (!component) return;\n\n      target.replaceWith(component(target, state))\n    })\n\n    return element;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>renderRoot()</code>는 최초 DOM 요소인 루트를 렌더링한다. <code>render()</code>는 <code>data-component</code> 속성을 가진 모든 자식 요소를 재귀적으로 갱신한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// registry.js\n\nexport const renderRoot = (root, state) =&gt; {\n  const clone = (root) =&gt; {\n    return root.cloneNode(true);\n  }\n\n  return render(clone)(root, state);\n}</code>\n        </deckgo-highlight-code>\n<p><code>registry.js</code>의 최종 모습은 아래와 같다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// registry.js\n\nconst registry = {};\n\nconst render = (component) =&gt; {\n  return (targetElement, state) =&gt; {\n    const element = component(targetElement, state);\n\n    const children = element.querySelectorAll(&#39;[data-component]&#39;);\n\n    [...children].forEach((target) =&gt; {\n      const name = target.dataset.component;\n\n      const component = registry[name];\n\n      if (!component) return;\n\n      target.replaceWith(component(target, state))\n    })\n\n    return element;\n  }\n}\n\nexport const addComponent = (name, component) =&gt; {\n  registry[name] = render(component);\n}\n\nexport const renderRoot = (root, state) =&gt; {\n  const clone = (root) =&gt; {\n    return root.cloneNode(true);\n  }\n\n  return render(clone)(root, state);\n}</code>\n        </deckgo-highlight-code>\n<p>메인 컨트롤러에서 레지스트리에 컴포넌트를 등록하는 과정이 있다. 동적 렌더링을 가정하려고 5초마다 새로운 할 일이 추가된 목록을 그리도록 했다. (이처럼 특정 주기마다 가상 루트 요소를 만든 다음 실제 요소로 바꾸는 방법은 대규모 프로젝트에서 성능을 저하시킬 수 있다.)</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  highlight-lines=\"17,20 22,29 31,45\">\n          <code slot=\"code\">// index.js\n\nimport { fetchTodos } from &quot;./apis.js&quot;;\n\nimport Todos from &#39;./components/Todos.js&#39;;\nimport Filters from &#39;./components/Filters.js&#39;;\nimport Counter from &#39;./components/Counter.js&#39;;\n\nimport { addComponent, renderRoot } from &#39;./registry.js&#39;\n\n// set state\nconst state = {\n  todos: fetchTodos(),\n  filter: &#39;All&#39;\n}\n\n// 레지스트리에 컴포넌트 등록\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\naddComponent(&#39;filters&#39;, Filters);\n\n// 동적 렌더링\nconst init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;.todoapp&#39;);\n\n    app.replaceWith(renderRoot(app, state))\n  })\n}\n\n// 5초마다 새로운 할 일이 추가된다고 가정\nwindow.setInterval(() =&gt; {\n  const index = state.todos.length + 1;\n\n  state.todos = [\n    {\n      id: `${index}`,\n      text: `새로운 할 일 ${index}`,\n      completed: false\n    },\n    ...state.todos,\n  ]\n\n  init();\n}, 5000)\n\ninit();</code>\n        </deckgo-highlight-code>\n<p>5초마다 새로운 할 일이 추가된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/336d7d584ca38749169c0d4ee512efa1/7960f/todos-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.49425287356321%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAzElEQVQoz6WTSwuDMBCE/f//S9CLaAUF46EYrK+C8RlFzZQNrRdPjQu7BEI+ZpislSQJXNfFOI6gUkrp/p3/LattWzRNg3Vdse87tm0zhmkgKRNCnN11nQYbK6SxLAsYY/B9H3EcY5omcyCp6fseQRDAcRwNllKaA+kR2Y6iCGEYoq5rHMdxw7IC+PuJRxwgZSnKsryXclVVyHN+uTBOGdjA+YyioGTV/X9Iw/MkbPv4As3VaeAwdGDsBSGWW1ZPIG1Jlj0h5XxZPRPgBzqjr+BSdNUOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"todos-2\"\n        title=\"todos-2\"\n        src=\"/static/336d7d584ca38749169c0d4ee512efa1/31198/todos-2.png\"\n        srcset=\"/static/336d7d584ca38749169c0d4ee512efa1/fe9c7/todos-2.png 174w,\n/static/336d7d584ca38749169c0d4ee512efa1/39e45/todos-2.png 347w,\n/static/336d7d584ca38749169c0d4ee512efa1/31198/todos-2.png 694w,\n/static/336d7d584ca38749169c0d4ee512efa1/ee9b6/todos-2.png 1041w,\n/static/336d7d584ca38749169c0d4ee512efa1/7960f/todos-2.png 1274w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"가상-dom\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-dom\" aria-label=\"가상 dom permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 DOM</h3>\n<p>가상 DOM의 핵심은 비교 알고리즘이다. 더 이상 전체 목록을 교체하지 않고 변경된 요소가 실제 DOM에 필요한 유일한 작업이라는 사실을 시스템이 이해하도록 하는 것이 가상 DOM의 목적이다.</p>\n<p>메인 컨트롤러에서 <code>replaceWith</code> 대신 <code>diff</code> 알고리즘을 사용한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// index.js\n\n// ...\n\nconst init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;.todoapp&#39;)\n    const newApp = registry.createRoot(app, state)\n    renderDiff(document.body, app, newApp)\n  })\n}\n\n// ...</code>\n        </deckgo-highlight-code>\n<p><code>renderDiff</code>는 부모 노드, 실제 노드, 가상 노드를 인자로 받아 재귀적으로 실행되는 함수다.</p>\n<p>실제 노드는 존재하지만 가상 노드가 없다면 그 실제 노드는 삭제 대상이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// renderDiff.js\n\nif (realNode &amp;&amp; !virtualNode) {\n    realNode.remove();\n    return;\n}</code>\n        </deckgo-highlight-code>\n<p>반대로 실제 노드는 없지만 가상 노드가 있다면 그 가상 노드는 추가 대상이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// renderDiff function\n\nif (!realNode &amp;&amp; virtualNode) {\n    parentNode.appendChild(virtualNode);\n    return;\n}</code>\n        </deckgo-highlight-code>\n<p>두 노드가 모두 존재하는 경우 변경 사항이 있을 때만 실제 노드를 대체한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">// renderDiff function\n\nif (isNodeChanged(virtualNode, realNode)) {\n    realNode.replaceWith(virtualNode);\n    return;\n}</code>\n        </deckgo-highlight-code>\n<p><code>isNodeChanged()</code>는 아래 사항들을 확인한다.</p>\n<ul>\n<li><code>attribute</code> 갯수가 다른가?</li>\n<li>하나 이상의 <code>attribute</code>가 변경되었는가?</li>\n<li>노드에 자식이 없다면 노드의 <code>textContent</code>가 다른가?</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const isNodeChanged = (n1, n2) =&gt; {\n  const { attributes: n1Attributes } = n1;\n  const { attributes: n2Attributes } = n2;\n\n  if (n1Attributes.length !== n2Attributes.length) {\n    return true;\n  }\n\n  const hasDifferentAttribute = [...n1Attributes]\n    .some(({ name }) =&gt; {\n      const n1Attribute = n1.getAttribute(name);\n      const n2Attribute = n2.getAttribute(name);\n\n      return n1Attribute !== n2Attribute;\n    })\n\n  if (hasDifferentAttribute) {\n    return true;\n  }\n\n  const hasChildren = n1.children.length !== 0 || n2.children.length !== 0;\n  const isTextContentDifferent = !hasChildren &amp;&amp; (n1.textContent !== n2.textContent);\n\n  if (isTextContentDifferent) {\n    return true\n  }\n\n  return false\n}</code>\n        </deckgo-highlight-code>\n<p>전체 <code>renderDiff()</code>는 이런 모습이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">const renderDiff = (\n  parentNode,\n  realNode,\n  virtualNode\n) =&gt; {\n  if (realNode &amp;&amp; !virtualNode) {\n    realNode.remove();\n    return;\n  }\n\n  if (!realNode &amp;&amp; virtualNode) {\n    parentNode.appendChild(virtualNode);\n    return;\n  }\n\n  if (isNodeChanged(virtualNode, realNode)) {\n    realNode.replaceWith(virtualNode);\n    return;\n  }\n\n  const realChildren = [...realNode.children];\n  const virtualChildren = [...virtualNode.children];\n\n  const max = Math.max(realChildren.length, virtualChildren.length);\n\n  for (let i = 0; i &lt; max; i++) {\n    renderDiff(\n      realNode,\n      realChildren[i],\n      virtualChildren[i]\n    )\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>최종 디렉토리 구조는 이렇다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── Counter.js\n│   ├── Filters.js\n│   └── Todos.js\n├── index.html\n├── index.js\n├── registry.js\n└── renderDiff.js</code>\n        </deckgo-highlight-code>\n<h2 id=\"렌더링-성능-모니터링\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-label=\"렌더링 성능 모니터링 permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 성능 모니터링</h2>\n<p>렌더링 엔진에서 중요한 요소 중 하나는 성능이다. 저자는 성능 모니터링을 위한 여러 도구를 소개한다.</p>\n<ul>\n<li>크롬 개발자 도구 - Show frame per seconds meter 메뉴 선택</li>\n<li><a href=\"https://github.com/Kevnz/stats.js\">stat.js</a> 라이브러리 활용하기</li>\n<li>커스텀 성능 위젯</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"nord\" line-numbers=\"true\"  highlight-lines=\"13,35\">\n          <code slot=\"code\">let panel;\nlet start;\nlet frames;\n\nconst create = () =&gt; {\n  const div = document.createElement(&#39;div&#39;);\n\n  // create panel wrapper\n\n  return div;\n}\n\nconst tick = () =&gt; {\n  frames++;\n\n  const now = window.performance.now();\n\n  if (now &gt;= start + 1000) {\n    panel.innerText = frames;\n    frames = 0;\n    start = now;\n  }\n\n  window.requestAnimationFrame(tick);\n}\n\nconst init = (parent = document.body) =&gt; {\n  panel = create();\n\n  window.requestAnimationFrame(() =&gt; {\n    start = window.performance.now();\n    parent.appendChild(panel);\n    tick();\n  })\n}\n\ninit();</code>\n        </deckgo-highlight-code>\n<h2 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","excerpt":"문서 객체 모델(DOM) DOM은 웹 어플리케이션의 조작 방법을 제공하는 API다. 웹 페이지는 HTML로 정의된 트리 구조를 갖는다. DOM은 이를 관리하는 방법이다. 컴포넌트 기반 애플리케이션 렌더링 함수 순수 함수로 렌더링한다는 것은 DOM 요…","timeToRead":12,"headings":[{"id":"문서-객체-모델dom","value":"문서 객체 모델(DOM)","depth":2},{"id":"컴포넌트-기반-애플리케이션","value":"컴포넌트 기반 애플리케이션","depth":2},{"id":"렌더링-함수","value":"렌더링 함수","depth":3},{"id":"중간-리팩토링","value":"중간 리팩토링","depth":3},{"id":"컴포넌트-함수","value":"컴포넌트 함수","depth":3},{"id":"가상-dom","value":"가상 DOM","depth":3},{"id":"렌더링-성능-모니터링","value":"렌더링 성능 모니터링","depth":2},{"id":"출처","value":"출처","depth":2}],"frontmatter":{"path":"/frameworkless-2","date":"2023-02-07","title":"2장_렌더링","tags":["javascript"],"series":"프레임워크 없는 프론트엔드 개발"}}},"pageContext":{"prev":{"path":"/frameworkless-3","title":"3장_DOM 이벤트 관리"},"next":{"path":"/frameworkless-1","title":"1장_프레임워크에 대한 이야기"}}},"staticQueryHashes":["2761876752"]}