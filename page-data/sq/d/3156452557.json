{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"f2d6ef06-3c10-52ea-8d12-9da71738523a","html":"<h1 id=\"요약\" style=\"position:relative;\">요약<a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>블로그를 위키 형식으로 구성해 보았다.</li>\n<li>Vimwiki를 사용하여 로컬에서 문서를 작성한다.</li>\n<li>문서는 개츠비를 통해 GitHub Pages에 배포된다.</li>\n<li>계층 구조로 문서를 관리하여 상위 문서를 모두 확인할 수 있다.</li>\n<li>문서의 변경 날짜와 히스토리를 쉽게 알 수 있다.</li>\n<li>커밋 시점에 Vimwiki 인덱스를 자동으로 갱신한다.</li>\n<li><a href=\"https://johngrib.github.io/wiki/my-wiki/\">이종립님의 위키</a>를 많이 참고했다.</li>\n</ul>\n<h1 id=\"why-wiki\" style=\"position:relative;\">WHY Wiki<a href=\"#why-wiki\" aria-label=\"why wiki permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>핑계에 불과하지만 블로그에서는 완성된 글에 대한 강박 비스무리한 것이 있었다. 티스토리에 글을 남기던 때보다 그 부담이 심했는데 그러다보니 미루기만 했다. 다양한 이유로 여러 차례 종립님의 블로그를 참고한 적이 있다. 위키 형식인 것이 인상 깊었는데 위키라면 조금은 부담없이 글을 남길 수 있을 것 같았다. 위키는 한 번 작성하고 끝나는 것이 아니라 꾸준히 내용을 보충하고 수정해야 하는 대상처럼 느껴지기 때문이 아닐까 싶다. 한편으로는 현재 내 실력으로는 고퀄리티의 글을 자주 작성하기는 어렵다고 생각했다. 결국 기록을 위한 나만의 위키를 만들어 보았다.</p>\n<h1 id=\"why-vimwiki\" style=\"position:relative;\">WHY Vimwiki<a href=\"#why-vimwiki\" aria-label=\"why vimwiki permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>Vimwiki를 사용하면 쉽게 문서와 그 링크를 만들 수 있다. 예를 들어 <code>바나나</code>라는 단어를 입력하고 엔터 키를 누르면 <code>[[바나나]]</code>로 바뀌면서 링크가 생성된다. 그리고 엔터 키를 한번 더 누르면 해당 문서로 이동하여 문서를 바로 작성할 수 있다. 이 글에서는 가능하면 종립님이 다루셨던 내용은 포함하지 않을 생각이다. 혹시라도 누군가 이 글을 참고할 계획이면 종립님의 글을 우선적으로 참고하길 바란다. 여기서는 개츠비 블로그를 위키 형식으로 바꾸고 Vimwiki를 접목시키는 내용을 주로 다루려고 한다.</p>\n<h1 id=\"vim-세팅\" style=\"position:relative;\">Vim 세팅<a href=\"#vim-%EC%84%B8%ED%8C%85\" aria-label=\"vim 세팅 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>종립님의 글을 참고하여 Vim과 Vimwiki를 위한 설정을 한다.</p>\n<ul>\n<li>Vimwiki 설치 및 설정(개츠비 파일 시스템의 경로를 위키 경로로 설정해야 함)</li>\n<li>Vim-startify 설치 및 설정</li>\n<li>frontmatter 자동완성 및 업데이트 항목 갱신 자동화 설정</li>\n</ul>\n<p>frontmatter에 포함하던 시리즈, 태그, 제목 및 경로를 사용하지 않기로 했다. 이젠 생성일자와 수정일자 항목만 필요하다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">function! Template()\n\n\tif line(&quot;$&quot;) &gt; 1\n\t\treturn\n\tendif\n\n\tlet l:template = []\n\tcall add(l:template, &#39;---&#39;)\n\tcall add(l:template, &#39;created: &#39; . strftime(&#39;%Y-%m-%d %H:%M:%S +0900&#39;))\n\tcall add(l:template, &#39;updated: &#39; . strftime(&#39;%Y-%m-%d %H:%M:%S +0900&#39;))\n\tcall add(l:template, &#39;---&#39;)\n\tcall add(l:template, &#39;&#39;)\n\tcall add(l:template, &#39;# &#39;)\n\tcall setline(1, l:template)\n\texecute &#39;normal! G&#39;\n\texecute &#39;normal! $&#39;\n\n\techom &#39;new wiki page has created&#39;\nendfunction</code>\n        </deckgo-highlight-code>\n<h1 id=\"개츠비에-필요한-노드-추가하기\" style=\"position:relative;\">개츠비에 필요한 노드 추가하기<a href=\"#%EA%B0%9C%EC%B8%A0%EB%B9%84%EC%97%90-%ED%95%84%EC%9A%94%ED%95%9C-%EB%85%B8%EB%93%9C-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\" aria-label=\"개츠비에 필요한 노드 추가하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>개츠비에서는 각 문서가 부모에 대한 정보를 가지고 있지 않아도 계층 구조를 구현할 수 있다. 노드를 생성할 때 파일 경로를 기반으로 <code>slug</code> 필드를 추가하여 이를 활용한다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// ./gatsby-node.ts\n\nexports.onCreateNode = ({ node, getNode, actions }: CreateNodeArgs) =&gt; {\n  const { createNodeField } = actions;\n  if (node.internal.type === &#39;MarkdownRemark&#39;) {\n    const slug = createFilePath({\n      node,\n      getNode,\n      basePath: &#39;pages&#39;,\n      trailingSlash: false\n    });\n\n    createNodeField({\n      node,\n      name: &#39;slug&#39;,\n      value: slug\n    });\n  }\n};</code>\n        </deckgo-highlight-code>\n<p>폴더명을 제목으로 사용하기 위해 <code>title</code> 필드도 추가한다. 언더스코어는 공백으로 대체했다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// ./gatsby-node.ts \n// ..이어서\n\n    createNodeField({\n      node,\n      name: &#39;title&#39;,\n      value: slug.split(&#39;/&#39;).slice(-1).pop()?.replaceAll(`_`, ` `)\n    });\n</code>\n        </deckgo-highlight-code>\n<p>이 방식을 위해서는 몇가지 규칙이 필요하다.</p>\n<ul>\n<li>폴더 이름을 지을 때 공백은 언더스코어 <code>_</code>로 대체한다.</li>\n<li><code>이름/index.md</code>과 같은 형태로 폴더 및 파일을 생성한다.</li>\n</ul>\n<p>언더스코어를 문서 제목에 자유롭게 포함시킬 수 없다는 문제가 있지만 당장 큰 불편함은 없을 것 같다. 폴더는 아래와 같이 구성한다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">/wikis\n├── 책\n│   ├── index.md\n│   └── 위대한_개츠비\n│       └── index.md\n</code>\n        </deckgo-highlight-code>\n<p>위대한 개츠비 문서의 주소는 <code>https://주소/책/위대한_개츠비</code>의 형식이 된다.</p>\n<h1 id=\"수정된-날짜-오름차순으로-정렬하기\" style=\"position:relative;\">수정된 날짜 오름차순으로 정렬하기<a href=\"#%EC%88%98%EC%A0%95%EB%90%9C-%EB%82%A0%EC%A7%9C-%EC%98%A4%EB%A6%84%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0\" aria-label=\"수정된 날짜 오름차순으로 정렬하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><code>updated</code> 필드를 기준으로 정렬된 문서를 요청하면 최근 수정된 문서를 상단에서 보여줄 수 있다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">\nconst GET_WIKIS = graphql`\n  query getWikis {\n    allMarkdownRemark(sort: { frontmatter: { updated: DESC } }) {\n      edges {\n        node {\n          id\n          html\n          fields {\n            slug\n            title\n          }\n          frontmatter {\n            created\n            updated\n          }\n        }\n      }\n    }\n  }\n`;\n</code>\n        </deckgo-highlight-code>\n<h1 id=\"상위-문서-보여주기\" style=\"position:relative;\">상위 문서 보여주기<a href=\"#%EC%83%81%EC%9C%84-%EB%AC%B8%EC%84%9C-%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0\" aria-label=\"상위 문서 보여주기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>파일 경로를 주소로 사용하고 있기 때문에 부모 경로를 보여주는 것은 어렵지 않다.</p>\n<p>아래에서 <code>child_1</code>의 slug는 <code>parent/child_1</code> 이다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">/wikis\n├── parent\n│   ├── index.md\n│   └── child_1\n│       └── index.md\n</code>\n        </deckgo-highlight-code>\n<p><code>slug</code>를 받아서 네비게이션 리스트로 변환하는 유틸을 사용한다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">\nconst getAncestors = (slug: string) =&gt; {\n  const segments = slug.split(&#39;/&#39;);\n\n  return segments\n    .slice(1, segments.length - 1)\n    .reduce&lt;{ path: string; value: string }[]&gt;((acc, cur, index) =&gt; {\n      const prevPath = acc[index - 1]?.path || &#39;&#39;;\n\n      return [\n        ...acc,\n        {\n          path: `${prevPath}/${cur}`,\n          value: cur.replaceAll(&#39;/&#39;, &#39;&#39;).replaceAll(&#39;_&#39;, &#39; &#39;)\n        }\n      ];\n    }, []);\n};\n</code>\n        </deckgo-highlight-code>\n<p>각 문서의 템플릿에서는 상위 문서 네비게이션을 제공할 수 있다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">\nconst navs = getAncestors(slug);\n\n// ... 생략\n\n&lt;nav&gt;\n\t{navs.length ? (\n              navs.map(({ path, value }, index, { length }) =&gt; (\n                &lt;div key={value}&gt;\n                  &lt;Link key={value} to={path}&gt;\n                    {value}\n                  &lt;/Link&gt;\n                  {Boolean(index + 1 &lt; length) &amp;&amp; &lt;ArrowThin /&gt;}\n                &lt;/div&gt;\n              ))\n            ) : (&lt;span&gt;ROOT&lt;/span&gt;)\n\t}\n&lt;/nav&gt;\n\n// ... 생략\n</code>\n        </deckgo-highlight-code>\n<h1 id=\"vimwiki-링크-a-태그로-바꿔주기\" style=\"position:relative;\">Vimwiki 링크 a 태그로 바꿔주기<a href=\"#vimwiki-%EB%A7%81%ED%81%AC-a-%ED%83%9C%EA%B7%B8%EB%A1%9C-%EB%B0%94%EA%BF%94%EC%A3%BC%EA%B8%B0\" aria-label=\"vimwiki 링크 a 태그로 바꿔주기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>Vimwiki의 <code>[[링크]]</code> 형식을 <code>&#x3C;a></code> 태그로 바꿔줘야 한다. 내 위키의 경우 모두 <code>index.md</code>를 포함하고 있어서 경로에서 이를 제거하고 타이틀을 추출해야 한다. 그리고 그 타이틀을 <code>&#x3C;a></code> 태그의 <code>textContent</code>로 넣고, 한편으로는 해당 주소로부터 상대적인 <code>href</code> 속성을 전달해야 한다. Vimwiki 링크 형식을 변환하는 유틸을 만들어 사용한다.</p>\n<deckgo-highlight-code language=\"ts\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">\nconst parseLinks = ({ contents, slug }: { contents: string; slug: string }) =&gt; {\n  return contents.replace(/\\[\\[([ㄱ-ㅎ가-힣\\w\\-_./]+?)\\]\\](?![\\S]*&lt;\\/code&gt;)/g, (_, value) =&gt; {\n    const title = value.replace(&#39;/index.md&#39;, &#39;&#39;);\n\n    const path = `${slug}/${title}`;\n\n    return `&lt;a href=${path}&gt;${title.replaceAll(&#39;_&#39;, &#39; &#39;)}&lt;/a&gt;`;\n  });\n};\n</code>\n        </deckgo-highlight-code>\n<p>코드 블럭에 포함된 경우에는 변환시키지 않으려고 다소 긴 정규 표현식을 사용했다. 문서 경로 -> 문서 제목 -> pathname 으로 사용하고 있기 때문에 어렵지 않게 Vimwiki 링크를 찾아낼 수 있지만 완전한 형태는 아니다. 인라인이 아닌 여러 줄의 코드 블럭에서는 패턴에 일치하는 경우 링크로 변환될 수 있다. 더 좋은 방법을 찾아봐야 한다.</p>\n<h1 id=\"마크다운-내-링크에서-라우터-사용하기\" style=\"position:relative;\">마크다운 내 링크에서 라우터 사용하기<a href=\"#%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EB%82%B4-%EB%A7%81%ED%81%AC%EC%97%90%EC%84%9C-%EB%9D%BC%EC%9A%B0%ED%84%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"마크다운 내 링크에서 라우터 사용하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>위 방법대로 변환된 링크를 클릭하면 실제 <code>&#x3C;a></code> 태그의 기본 동작대로 새로고침이 발생한다. 상대 경로의 경우 내부 리액트 라우터를 사용하도록 해야 한다. <a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-catch-link\">gatsby-plugin-catch-links</a> 개츠비 플러그인을 사용하면 내부 경로를 가진 링크를 gatsby-link로 대체할 수 있다.</p>\n<h1 id=\"vimwiki-인덱스-자동생성\" style=\"position:relative;\">Vimwiki 인덱스 자동생성<a href=\"#vimwiki-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9E%90%EB%8F%99%EC%83%9D%EC%84%B1\" aria-label=\"vimwiki 인덱스 자동생성 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>내 위키의 경우 Vimwiki의 인덱스에서 모든 문서를 생성하진 않고 하위 문서가 필요한 문서에서 바로 링크를 만들고 있다. 그렇기 때문에 깊은 곳에 있는 문서를 나중에 수정하려면 링크를 타고 들어가야 한다. 이런 불편함 때문에 루트에 해당하는 Vimwiki 인덱스에 모든 링크를 잘 정리할 필요가 있다. 하지만 문서를 하나 추가할 때마다 인덱스에 그 링크를 기록하는 건 꽤나 귀찮고 깜빡하기도 쉽다. 인덱스 문서를 자동으로 생성하기로 했다. 요구사항은 아래와 같다.</p>\n<ul>\n<li>모든 경로를 Vimwiki 링크로 작성한다.</li>\n<li>모든 링크를 이름 오름차순으로 정렬한다.</li>\n<li>문서 계층의 깊이에 따라 들여쓰기를 한다.</li>\n<li>커밋을 할 때마다 자동으로 문서를 갱신한다.</li>\n</ul>\n<p>프로젝트 루트 경로에 js 파일 하나를 추가했다. 일부 함수는 종립님의 스크립트를 참고했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">\n// generate_wiki_index.js\n\nconst fs = require(&#39;fs&#39;);\n\nconst target = &#39;src/wikis/index.md&#39;;\nconst list = [];\n\nfunction isDirectory(path) {\n  return fs.lstatSync(path).isDirectory();\n}\n\nfunction isMarkdown(fileName) {\n  return /\\.md$/.test(fileName);\n}\n\nfunction getFiles(path, list) {\n  fs.readdirSync(path).forEach((fileName) =&gt; {\n    const subPath = `${path}/${fileName}`;\n\n    if (isDirectory(subPath)) {\n      return getFiles(subPath, list);\n    }\n\n    if (isMarkdown(fileName) &amp;&amp; subPath !== target) {\n      return list.push(subPath);\n    }\n  });\n}\n\nfunction getVimWikiLinks(paths) {\n  return paths\n    .map((path) =&gt; path.replace(&#39;src/wikis/&#39;, &#39;&#39;).replace(&#39;/index.md&#39;, &#39;&#39;))\n    .sort()\n    .map((path) =&gt; {\n      const segments = path.split(&#39;/&#39;);\n      const depth = segments.length - 1;\n      const link = `* [[${segments.join(&#39;/&#39;)}${isMarkdown(path) ? &#39;&#39; : &#39;/index.md&#39;}]]`;\n\n      return link.padStart(link.length + depth, &#39;\\t&#39;);\n    });\n}\n\nconst deleteFile = (target) =&gt; {\n  fs.unlink(target, function (err) {\n    if (err) throw err;\n  });\n};\n\nconst createFile = (filename) =&gt; {\n  fs.open(filename, &#39;w&#39;, function (err) {\n    if (err) throw err;\n  });\n};\n\nconst appendFile = (target, value) =&gt; {\n  fs.appendFileSync(target, value + &#39;\\r\\n&#39;, function (err) {\n    if (err) throw err;\n  });\n};\n\nfunction appendLinks(target, links) {\n  appendFile(target, &#39;== VimWiki Index ==&#39; + &#39;\\r\\n&#39;);\n\n  links.forEach((link) =&gt; {\n    appendFile(target, link);\n  });\n}\n\ngetFiles(&#39;src/wikis&#39;, list);\n\ndeleteFile(target);\n\ncreateFile(target);\n\nappendLinks(target, getVimWikiLinks(list));\n</code>\n        </deckgo-highlight-code>\n<p>pre-commit을 활성화하고 커밋을 할 때마다 위 코드를 실행시키도록 한다.</p>\n<deckgo-highlight-code language=\"shell\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\"># $project_path/.git/hooks/pre-commit\n\n#!/bin/bash\n\nnode ./generate_wiki_index.js\n</code>\n        </deckgo-highlight-code>\n<p>커밋을 하면 아래와 같이 인덱스 문서를 생성한다.</p>\n<p><img src=\"https://github.com/rheech22/rheech22.github.io/assets/57756798/67e1c6c9-ee39-4c80-8d37-34265d10c887\" alt=\"index\"></p>","fields":{"slug":"/gatsby/개츠비와_Vimwiki_접목시키기","title":"개츠비와 Vimwiki 접목시키기"},"frontmatter":{"created":"2023-08-22 00:00:26 +0900","updated":"2023-08-27 03:33:15 +0900"}}},{"node":{"id":"61df1dd2-80d0-5a2b-9260-79f022ba9eb3","html":"<p>현상: 아이폰에서 블로그 메인 페이지를 들어가면 잠시 깜빡이는 현상과 함께 흰 화면만 출력되는 현상</p>\n<p>에러: <code>chrome://inspect</code>로 로그를 확인해보니 <code>RangeError: date value is not finite in DateTimeFormat.format()</code> 에러가 찍힘</p>\n<p>원인: ios에서는 <code>-</code> 날짜 구분자를 지원하지 않아서 발생하는 에러</p>\n<p>해결: 아래와 같이 하이픈 기호를 슬래시로 대체하여 사용</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">\nnew Intl.DateTimeFormat(&#39;en-GB&#39;, { dateStyle: &#39;medium&#39; })\n\t.format(new Date(date.replace(&#39;-&#39;, &#39;/&#39;)));\n</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/w3c/respec/issues/1357\">참고</a></p>\n<p>잘 되다가 갑자기 이런 에러가 발생한 이유는 아직도 잘 모르겠다.</p>","fields":{"slug":"/자바스크립트/아이폰에서_발생하는_DateTimeFormat_에러_해결_방법","title":"아이폰에서 발생하는 DateTimeFormat 에러 해결 방법"},"frontmatter":{"created":"2023-08-22 22:36:49 +0900","updated":"2023-08-22 22:44:41 +0900"}}},{"node":{"id":"bb5b02f7-795c-5f7c-af9b-c9e1e561c75a","html":"<ul>\n<li>[[아이폰에서_발생하는_DateTimeFormat_에러_해결_방법/index.md]]</li>\n</ul>","fields":{"slug":"/자바스크립트","title":"자바스크립트"},"frontmatter":{"created":"2023-08-22 22:34:22 +0900","updated":"2023-08-22 22:36:49 +0900"}}},{"node":{"id":"fa10aaa5-03d4-55b8-b29d-5ce896792674","html":"<h1 id=\"서버-사이드-렌더링\" style=\"position:relative;\">서버 사이드 렌더링<a href=\"#%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"서버 사이드 렌더링 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>서버 사이드 렌더링(Server-Side Rendering, SSR)은 웹 애플리케이션의 렌더링 방식 중 하나로, 웹 페이지의 구성 요소를 서버 측에서 생성하고, 클라이언트에게 보내는 방식을 의미한다. 흔히 클라이언트 사이드 렌더링(Client-Side Rendering, CSR)과 비교된다.</p>\n<h1 id=\"렌더링이란\" style=\"position:relative;\">렌더링이란?<a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4%EB%9E%80\" aria-label=\"렌더링이란 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>렌더링이라는 용어는 문맥에 따라 다르게 사용될 수 있기 때문에 혼동하지 않도록 주의해야 한다. 예를 들어, 브라우저에서는 HTML, CSS, Javascript 문서를 해석하여 화면에 그리는 모든 과정을 렌더링이라고 표현한다. SSR에서의 렌더링을 이런 의미로 생각하면 곤란하다. 서버가 브라우저의 화면을 그려주는 것은 아니기 때문이다. SSR의 렌더링은 서버가 개발자의 코드를 해석하여 초기 화면을 위한 HTML을 생성하는 과정으로 볼 수 있다.</p>\n<h1 id=\"왜-초기-화면일까\" style=\"position:relative;\">왜 초기 화면일까?<a href=\"#%EC%99%9C-%EC%B4%88%EA%B8%B0-%ED%99%94%EB%A9%B4%EC%9D%BC%EA%B9%8C\" aria-label=\"왜 초기 화면일까 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>SSR의 장점으로 가장 많이 언급되는 것은 초기 로딩이 빠르다는 것이다. 브라우저 입장에서는 서버가 자신이 할 일, 즉 초기 렌더링을 대신 해주었기 때문에 자신이 코드를 해석할 일이 줄어든 셈이다. 이는 DOM을 조작할 필요가 없는 페이지의 경우에는 서버가 보내준 문서가 곧 엔드 콘텐츠가 될 수 있다는 의미다. 반면 DOM을 조작이 잦은 페이지에서는 SSR은 초기 렌더링 이점을 누릴 수는 있지만, 상호작용에 따라 빈번하게 새로운 HTML 생성을 서버로 요청해야 하므로 성능 문제를 초래할 수 있다. 한편 CSR은 초기 렌더링이 상대적으로 느릴 뿐이지 렌더링된 이후에는 속도 면에서 장점이 있기 때문에 SSR과 CSR의 장점을 적절히 조합하는 것이 중요하다.</p>\n<h1 id=\"장점\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>초기 로딩이 빠르다. 자바스크립트를 해석하여 빈 문서로부터 모든 것을 그려야 하는 CSR과 다르게 서버에서 초기 렌더링을 책임지기 때문에 사용자는 빠르게 초기 화면을 볼 수 있다.</li>\n<li>검색 엔진 최적화에 좋다. 검색 엔진의 크롤러는 주로 HTML을 크롤링하는데, 서버에서 미리 만들어진 HTML이 바로 노출되므로 웹 페이지가 담고 있는 정보를 크롤러가 쉽게 수집할 수 있다.</li>\n<li>클라이언트의 성능이나 호환성에 제약을 덜 받는다. 성능의 장점은 서버의 컴퓨팅 성능이 클라이언트보다 더 좋을 때 누릴 수 있다.</li>\n</ul>\n<h1 id=\"단점\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>상호작용에 따라 화면이 전체적으로 렌더링될 수 있다. 이는 좋지 않은 사용자 경험으로 이어진다.</li>\n<li>웹 서버를 관리해야 한다. 리소스가 많아지고 트랙픽이 증가하면 이는 서버 부담으로 이어진다. 요청이 많아지는 경우 지연이 발생하여 오히려 초기 로딩이 느려질 수 있다.</li>\n</ul>\n<h1 id=\"언제-도입해야-할까\" style=\"position:relative;\">언제 도입해야 할까?<a href=\"#%EC%96%B8%EC%A0%9C-%EB%8F%84%EC%9E%85%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"언제 도입해야 할까 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>검색 엔진 최적화가 필요할 때</li>\n<li>동적 콘텐츠가 많지 않은 경우</li>\n<li>초기 로딩 속도가 중요한 경우</li>\n<li>서버의 강력한 성능이 필요한 경우</li>\n</ul>","fields":{"slug":"/웹/서버_사이드_렌더링","title":"서버 사이드 렌더링"},"frontmatter":{"created":"2023-08-22 14:28:06 +0900","updated":"2023-08-22 16:04:52 +0900"}}},{"node":{"id":"fe73e022-7f72-5cf3-9aea-e10d7b40fa1e","html":"<h1 id=\"web\" style=\"position:relative;\">Web<a href=\"#web\" aria-label=\"web permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>[[서버_사이드_렌더링/index.md]]</li>\n</ul>","fields":{"slug":"/웹","title":"웹"},"frontmatter":{"created":"2023-08-22 14:27:25 +0900","updated":"2023-08-22 14:28:06 +0900"}}},{"node":{"id":"9da028ff-380b-5f80-8466-8a3752fb06ff","html":"<h1 id=\"개츠비에-관한\" style=\"position:relative;\">개츠비에 관한<a href=\"#%EA%B0%9C%EC%B8%A0%EB%B9%84%EC%97%90-%EA%B4%80%ED%95%9C\" aria-label=\"개츠비에 관한 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>[[Gatsby_기술_블로그_개발_후기/index.md]]</li>\n<li>[[개츠비와_Vimwiki_접목시키기/index.md]]</li>\n</ul>","fields":{"slug":"/gatsby","title":"gatsby"},"frontmatter":{"created":"2023-08-14","updated":"2023-08-22 02:01:28 +0900"}}},{"node":{"id":"a6deae95-dcf1-5bdb-a1c5-9d9d7ebd907d","html":"<h2 id=\"상태-관리\" style=\"position:relative;\">상태 관리<a href=\"#%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC\" aria-label=\"상태 관리 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>애플리케이션의 다양한 요소를 연결하는 효과적인 데이터 관리 방법을 상태 관리라고 한다. <a href=\"https://redux.js.org/\">Redux</a>나 <a href=\"https://mobx.js.org/react-integration.html\">MobX</a>와 같은 상태 관리 전용 라이브러리도 있다. 그만큼이나 애플리케이션에서 중요한 축을 담당하고 있다. 상태 관리에 적합한 아키텍쳐를 선택한다면 애플리케이션을 건강하게 유지할 수 있다.</p>\n<br/>\n<h2 id=\"사전-준비\" style=\"position:relative;\">사전 준비<a href=\"#%EC%82%AC%EC%A0%84-%EC%A4%80%EB%B9%84\" aria-label=\"사전 준비 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>3장에서 구현했던 투두리스트 앱을 사용한다. 새로운 구현에 앞서 변경된 코드를 먼저 살펴본다.</p>\n<p>뷰</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;li&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;삭제&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/li&gt; \n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;section class=&quot;todoapp&quot;&gt;\n        &lt;header&gt;\n          &lt;h1&gt;todos&lt;/h1&gt;\n          &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n        &lt;/header&gt;\n        &lt;section class=&quot;main&quot;&gt;\n          &lt;button class=&quot;completed-all&quot; &gt;전체 완료&lt;/button&gt;\n          &lt;ul data-component=&quot;todos&quot;&gt;&lt;/ul&gt;\n        &lt;/section&gt;\n        &lt;footer class=&quot;footer&quot;&gt;\n          &lt;span data-component=&quot;counter&quot;&gt;&lt;/span&gt;\n          &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n        &lt;/footer&gt;\n      &lt;/section&gt;\n    &lt;/template&gt;\n    &lt;div id=&quot;root&quot;&gt;\n      &lt;div data-component=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>컨트롤러</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\n\nimport { fetchTodos } from &quot;./apis.js&quot;;\n\nimport App from &#39;./components/App.js&#39;;\nimport Todos from &#39;./components/Todos.js&#39;;\nimport Counter from &#39;./components/Counter.js&#39;;\n\nimport { addComponent, renderRoot } from &#39;./registry.js&#39;;\nimport renderDiff from &#39;./renderDiff.js&#39;;\n\nconst state = {\n  todos: fetchTodos(),\n}\n\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\n\nconst events = {\n  deleteItem: (index) =&gt; {\n    state.todos.splice(index, 1);\n    render();\n  },\n  addItem: (text) =&gt; {\n    state.todos.push({\n      text,\n      completed: false\n    })\n    render();\n  },\n  completedAll: () =&gt; {\n    state.todos = state.todos.map(todo =&gt; ({\n      ...todo,\n      completed: true\n    }))\n    render();\n  },\n  clearCompleted: () =&gt; {\n    state.todos = state.todos.filter(todo =&gt; !todo.completed);\n    render();\n  }\n}\n\nconst render = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state, events);\n\n    renderDiff(document.body, app, newApp);\n  })\n}\n\nrender();</code>\n        </deckgo-highlight-code>\n<p>App 컴포넌트</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">let template;\n\nconst getTemplate = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-app&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n}\n\nconst addEventListeners = (target, events) =&gt; {\n  target.querySelector(&#39;.new-todo&#39;).addEventListener(&#39;keypress&#39;, (e) =&gt; {\n    if (e.key === &#39;Enter&#39;) {\n      events.addItem(e.target.value);\n\n      e.target.value = &#39;&#39;\n    }\n  })\n\n  target.querySelector(&#39;.completed-all&#39;).addEventListener(&#39;click&#39;, () =&gt; {\n    events.completedAll();\n  })\n\n  target.querySelector(&#39;.clear-completed&#39;).addEventListener(&#39;click&#39;, () =&gt; {\n    events.clearCompleted();\n  })\n}\n\nexport default (targetElement, _, events) =&gt; {\n  const newApp = targetElement.cloneNode(true);\n\n  newApp.innerHTML = &#39;&#39;;\n\n  newApp.appendChild(getTemplate());\n\n  addEventListeners(newApp, events);\n\n  return newApp;\n}</code>\n        </deckgo-highlight-code>\n<p>사전 준비를 위해 변경한 내용은 아래와 같다. 나머지 코드는 동일하다.</p>\n<ul>\n<li>단순화를 위해 필터의 구성을 제거했다.</li>\n<li><code>init()</code>함수의 이름을 <code>render()</code>로 변경했다.</li>\n<li>전체 완료, 완료 삭제 이벤트를 추가했다.</li>\n</ul>\n<p>시작하기에 앞선 프로젝트의 구조는 이렇다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── App.js\n│   ├── Counter.js\n│   └── Todos.js\n├── index.html\n├── index.js\n├── registry.js\n└── renderDiff.js</code>\n        </deckgo-highlight-code>\n<br/>\n<h2 id=\"모델-뷰-컨트롤러\" style=\"position:relative;\">모델-뷰-컨트롤러<a href=\"#%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\" aria-label=\"모델 뷰 컨트롤러 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>상태를 컨트롤러에서 유지하는 것은 상태 관리의 좋은 방법은 아니다.</p>\n</blockquote>\n<p>애플리케이션의 상태는 모델이 관리한다. 상태 변경 함수 외에도 다음 구성이 있다.</p>\n<ul>\n<li><code>getState()</code>는 상태 복사본을 불변 객체로서 반환한다.</li>\n<li>객체의 깊은 복사를 위해 JSON 메서드를 활용한다. 이 방법은 속도가 느릴 수 있다.  (저자는 <a href=\"https://www.geeksforgeeks.org/lodash-_-clonedeep-method/\">lodash</a>에서 제공하는 <code>cloneDeep()</code>를 추천하고 있다.)</li>\n<li>모델은 초기 상태를 받는다. 만약 없다면 기본 값을 사용한다.</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// model/model.js\n\nconst INITIAL_STATE = {\n  todos: [],\n}\n\nexport default (initalState = INITIAL_STATE) =&gt; {\n  const state = cloneDeep(initalState)\n\n  const getState = () =&gt; {\n    return Object.freeze(cloneDeep(state))\n  }\n\n  const addItem = text =&gt; {\n    if (!text) return;\n\n    state.todos.push({\n      text,\n      completed: false\n    })\n  }\n\n  const deleteItem = index =&gt; {\n    if (index &lt; 0) return\n\n    if (!state.todos[index]) return\n\n    state.todos.splice(index, 1)\n  }\n\n  const completeAll = () =&gt; {\n    state.todos = state.todos.map(todo =&gt; ({\n      ...todo,\n      completed: true,\n    }))\n  }\n\n  const clearCompleted = () =&gt; {\n    state.todos = state.todos.filter(t =&gt; !t.completed)\n  }\n\n  return {\n    addItem,\n    deleteItem,\n    completeAll,\n    clearCompleted,\n    getState\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>컨트롤러는 모델을 사용할 뿐이다. 모델이 불변 객체를 제공하기 때문에 데이터를 조작하기 위해서는 모델이 제공하는 공개 메서드를 사용해야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"15,34 40 46\">\n          <code slot=\"code\">import { fetchTodos } from &quot;./apis.js&quot;;\n\nimport App from &#39;./components/App.js&#39;;\nimport Todos from &#39;./components/Todos.js&#39;;\nimport Counter from &#39;./components/Counter.js&#39;;\n\nimport { addComponent, renderRoot } from &#39;./registry.js&#39;;\nimport renderDiff from &#39;./renderDiff.js&#39;;\nimport modelFactory from &quot;./model/model.js&quot;;\n\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\n\nconst model = modelFactory({ todos: fetchTodos() });\n\nconst events = {\n  addItem: (text) =&gt; {\n    model.addItem(text);\n    render(model.getState());\n  },\n  deleteItem: (index) =&gt; {\n    model.deleteItem(index);\n    render(model.getState());\n  },\n  completeAll: () =&gt; {\n    model.completeAll();\n    render(model.getState());\n  },\n  clearCompleted: () =&gt; {\n    model.clearCompleted();\n    render(model.getState());\n  }\n}\n\nconst render = (state) =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state, events);\n\n    renderDiff(document.body, app, newApp);\n  })\n}\n\nrender(model.getState());</code>\n        </deckgo-highlight-code>\n<p>이는 고전적인 MVC 애플리케이션의 구현이다. 이 패턴은 아래와 같은 모양이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4d624dc6cd8ae6253c2da3c33f922395/7f15f/mvc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 108.04597701149426%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAABYlAAAWJQFJUiTwAAABh0lEQVR42q2UaYvCMBCG/f9/rCD9UBCxiIj33XrUHp6zPANZum2iW3cHgrYp78x7JC1pWM/n0/rfVEs+qMvlIkVRWPcaAy4WCxkOh7LZbGQ+n0uWZc0BDbU4jiWKIjkcDtLtdiVNU5nNZp9PeLvddEIWE06nUzmfz3+jfL/fdarBYKBTVs1pDIhmy+VSgbfbrRuQl2a905EJAe73++p4jbINxAUMEJOh58sJ8zxXgXEOOq809DxPp8RxKyAbq9VKc0VXnnGR8JYXU+FsGIYyGo1kMpnIbrerUwYMKuv1WjOGTkEQaDzYwwT2TFTG47H4vq+AvC8zUsDH46GAfLDf753HiqIhDQAHDImcpgBmKNDEZdTxeJROp2M17wdgkiSq4zvnYQB1J2C50OeVy9T1erU6XAs2hT5QMrTLgTcyEDHM+tWE0KneIOWm6IwZMOG3aqD1LJ9OJzXHLOihba/X0yjRsN1uf+e3FhvXVUVEoE8DssniGUOYDnDrWf7Par27qaumuC4NU18+07qvOnAb6QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mvc\"\n        title=\"\"\n        src=\"/static/4d624dc6cd8ae6253c2da3c33f922395/31198/mvc.png\"\n        srcset=\"/static/4d624dc6cd8ae6253c2da3c33f922395/fe9c7/mvc.png 174w,\n/static/4d624dc6cd8ae6253c2da3c33f922395/39e45/mvc.png 347w,\n/static/4d624dc6cd8ae6253c2da3c33f922395/31198/mvc.png 694w,\n/static/4d624dc6cd8ae6253c2da3c33f922395/ee9b6/mvc.png 1041w,\n/static/4d624dc6cd8ae6253c2da3c33f922395/c1bea/mvc.png 1388w,\n/static/4d624dc6cd8ae6253c2da3c33f922395/7f15f/mvc.png 1530w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br/>\n<h2 id=\"옵저버블-모델\" style=\"position:relative;\">옵저버블 모델<a href=\"#%EC%98%B5%EC%A0%80%EB%B2%84%EB%B8%94-%EB%AA%A8%EB%8D%B8\" aria-label=\"옵저버블 모델 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>MVC 기반으로 작성한 코드가 최적의 솔루션이라 할 수는 없는데 그 이유는</p>\n<ul>\n<li>상태 변경 후 렌더링을 수동으로 호출해야 한다.</li>\n<li>동작이 상태를 변경하지 않을 때에도 <code>render()</code>를 호출한다.</li>\n</ul>\n<p>저자는 이러한 문제 해결을 위해 옵저버 패턴을 소개한다. 옵저버블 모델은 게터 대신 <code>addChangeListener()</code>라는 메서드를 제공한다.</p>\n<ul>\n<li>모델은 리스너를 등록, 삭제할 수 있는 수단을 제공한다. - <code>addChangeListener()</code></li>\n<li>리스너를 실행하여 상태 변경을 통지한다. - <code>invokeListeners()</code></li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12,26 36 36 55 61\">\n          <code slot=\"code\">// model/model.js\n\nconst INITIAL_STATE = {\n  todos: [],\n}\n\nexport default (initalState = INITIAL_STATE) =&gt; {\n  const state = cloneDeep(initalState)\n\n  let listeners = []\n\n  const addChangeListener = (listener) =&gt; {\n    listeners.push(listener);\n\n    listener(freeze(state));\n\n    return () =&gt; {\n      listeners = listeners.filter(l =&gt; l !== listener);\n    }\n  }\n\n  const invokeListeners = () =&gt; {\n    const data = freeze(state);\n\n    listeners.forEach(l =&gt; l(data));\n  }\n\n  const addItem = text =&gt; {\n    if (!text) return;\n\n    state.todos.push({\n      text,\n      completed: false\n    })\n\n    invokeListeners();\n  }\n\n  const deleteItem = index =&gt; {\n    if (index &lt; 0) return\n\n    if (!state.todos[index]) return\n\n    state.todos.splice(index, 1)\n\n    invokeListeners();\n  }\n\n  const completeAll = () =&gt; {\n    state.todos = state.todos.map(todo =&gt; ({\n      ...todo,\n      completed: true,\n    }))\n\n    invokeListeners();\n  }\n\n  const clearCompleted = () =&gt; {\n    state.todos = state.todos.filter(t =&gt; !t.completed)\n\n    invokeListeners();\n  }\n\n  return {\n    addItem,\n    deleteItem,\n    completeAll,\n    clearCompleted,\n    addChangeListener\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이벤트 등록은 더 이상 컨트롤러의 관심사가 아니다. 모델에서 제공하는 메서드를 이벤트 핸들러에서 사용한다. 컨트롤러는 <code>render()</code>를 직접 실행하지 않고 리스너로 등록할 뿐이다. 코드가 훨씬 간결해졌다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// ... 생략\n\nconst model = modelFactory({ todos: fetchTodos() });\n\nconst {\n  addChangeListener,\n  ...events\n} = model;\n\nconst render = (state) =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state, events);\n\n    renderDiff(document.body, app, newApp);\n  })\n}\n\n// 리스너 전달\naddChangeListener(render);</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>옵저버블 모델은 모델의 공개 인터페이스를 수정하지 않고 컨트롤러에 새로운 기능을 추가하는 데 유용하다.</p>\n</blockquote>\n<p>무엇을 어떻게 할지는 컨트롤러가 정한다. 모델은 등록된 리스너를 실행할 뿐이다. 만약 상태 변경을 알리는 간단한 로거를 추가하고 싶다면 리스너를 추가하기만 하면 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">addChangeListener(state =&gt; {\n  console.log(`현재 시각 (${new Date()})`, state)\n})</code>\n        </deckgo-highlight-code>\n<br/>\n<h2 id=\"반응형-프로그래밍\" style=\"position:relative;\">반응형 프로그래밍<a href=\"#%EB%B0%98%EC%9D%91%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"반응형 프로그래밍 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>간단히 말하면 반응형 패러다임의 구현은 애플리케이션이 모델 변경, HTTP 요청, 사용자 동작, 탐색 등과 같은 이벤트를 방출할 수 있는 옵저버블로 동작하도록 구현하는 것을 의미한다.</p>\n</blockquote>\n<p>반응형 프로그래밍은 내게 아직 낯선 주제이다. 저자는 반응형 프로그래밍을 소개하는 안드레 스탈츠의 <a href=\"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\">글</a>을 추천한다. 위에서 만든 옵저버블 모델은 반응형 상태 관리의 예라고 할 수 있다. 하지만 여러 모델 객체를 갖고 있다면 옵저버블을 만들 수 있는 더 쉬운 방법이 필요하다. 이런 경우에 사용해 볼 수 있는 옵저버블 팩토리를 만들어 본다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// model/observable.js\n\nexport default (model, stateGetter) =&gt; {\n  let listeners = []\n\n  const addChangeListener = cb =&gt; {\n    listeners.push(cb)\n    cb(freeze(stateGetter()))\n\n    return () =&gt; {\n      listeners = listeners.filter(listener =&gt; listener !== cb)\n    }\n  }\n\n  const invokeListeners = () =&gt; {\n    const data = freeze(stateGetter())\n    listeners.forEach(listener =&gt; listener(data))\n  }\n\n  const wrapAction = originalAction =&gt; {\n    return (...args) =&gt; {\n      const value = originalAction(...args)\n      invokeListeners()\n      return value\n    }\n  }\n\n  const baseProxy = {\n\t\n    addChangeListener\n  }\n\n  return Object\n    .keys(model)\n    .filter(key =&gt; typeof model[key] === &#39;function&#39;)\n    .reduce((proxy, key) =&gt; {\n      const action = model[key]\n\n      return {\n        ...proxy,\n        [key]: wrapAction(action)\n      }\n    }, baseProxy)\n}</code>\n        </deckgo-highlight-code>\n<p>옵저버블 팩토리는 모델의 상태 변경 함수를 래핑하여 상태가 변경될 때마다 변경 사실을 알리도록 한다.<br>\n이제 모델은 옵저버블 객체 생성을 위한 로직을 다루지 않는다. 대신 옵저버블 팩토리로 래핑된 자신을 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"47\">\n          <code slot=\"code\">// model/model.js\n\nimport observableFactory from &quot;./observable.js&quot;\n\nconst INITIAL_STATE = {\n  todos: [],\n}\n\nexport default (initalState = INITIAL_STATE) =&gt; {\n  const state = cloneDeep(initalState)\n\n  const addItem = text =&gt; {\n    if (!text) return;\n\n    state.todos.push({\n      text,\n      completed: false\n    })\n  }\n\n  const deleteItem = index =&gt; {\n    if (index &lt; 0) return\n\n    if (!state.todos[index]) return\n\n    state.todos.splice(index, 1);\n  }\n\n  const completeAll = () =&gt; {\n    state.todos = state.todos.map(todo =&gt; ({\n      ...todo,\n      completed: true,\n    }))\n  }\n\n  const clearCompleted = () =&gt; {\n    state.todos = state.todos.filter(t =&gt; !t.completed)\n  }\n\n  const model = {\n    addItem,\n    deleteItem,\n    completeAll,\n    clearCompleted,\n  }\n\n  return observableFactory(model, () =&gt; state);\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"네이티브-프록시\" style=\"position:relative;\">네이티브 프록시<a href=\"#%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9D%EC%8B%9C\" aria-label=\"네이티브 프록시 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트의 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy API</a>를 사용하면 객체에 대한 프록시를 만들 수 있다. 프록시란 ‘대리’의 의미로 여기서 프록시 객체는 어떤 객체의 대리인 역할을 수행한다. 객체가 갖는 기본적인 작업을 가로채서 그 방법을 다시 정의한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const user = {\n  id: &#39;1&#39;,\n  name: &#39;aiden&#39;,\n}\n\nconst handler = {\n  get(target, prop) {\n    return target[prop] + &#39; by Proxy&#39;;\n  }\n}\n\nconst userProxy = new Proxy(user, handler);\n\nconsole.log(userProxy.id); // 1 by Proxy\nconsole.log(userProxy.name); // aiden by Proxy</code>\n        </deckgo-highlight-code>\n<p>프록시를 활용한 옵저버블 팩토리를 좀 더 간단하게 만들 수 있다. 프록시 생성자는 대상 객체와 핸들러 객체를 받는다. 여기서 대상 객체는 상태가 되고 핸들러 객체는 상태가 변경할 때마다 변경 사실을 알리는 세터를 포함한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default (initialState) =&gt; {\n  let listeners = [];\n\n  const proxy = new Proxy(cloneDeep(initialState), {\n    set: (target, prop, value) =&gt; {\n      target[prop] = value\n      listeners.forEach(listener =&gt; listener(freeze(proxy)))\n      return true\n    }\n  })\n\n  proxy.addChangeListener = cb =&gt; {\n    listeners.push(cb)\n    cb(freeze(proxy))\n    return () =&gt; {\n      listeners = listeners.filter(listener =&gt; listener !== cb)\n    }\n  }\n\n  return proxy\n}</code>\n        </deckgo-highlight-code>\n<p>이제 팩토리는 모델 전체를 래핑하는 대신 상태의 프록시를 반환한다. 모델은 상태를 직접 변경할 수 없고 프록시를 통해 변경해야 한다. 그렇기 때문에 상태를 직접 수정하는 메서드를 사용할 수 없음에 유의해야 한다. 변경을 위해서는 새로운 속성으로 교체해야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8 13,16\">\n          <code slot=\"code\">import observableFactory from &quot;./observable.js&quot;\n\nconst INITIAL_STATE = {\n  todos: [],\n}\n\nexport default (initalState = INITIAL_STATE) =&gt; {\n  const state = observableFactory(initalState);\n\n  const addItem = text =&gt; {\n    if (!text) return;\n\n    state.todos = [\n      ...state.todos,\n      { text, completed: false }\n    ]\n  }\n\n  const deleteItem = index =&gt; {\n    if (index &lt; 0) return\n\n    if (!state.todos[index]) return\n\n    state.todos = state.todos.filter((todo, i) =&gt; {\n      return i !== index\n    });\n  }\n\n  const completeAll = () =&gt; {\n    state.todos = state.todos.map(todo =&gt; ({\n      ...todo,\n      completed: true,\n    }))\n  }\n\n  const clearCompleted = () =&gt; {\n    state.todos = state.todos.filter(t =&gt; !t.completed)\n  }\n\n  return {\n    addChangeListener: state.addChangeListener,\n    addItem,\n    deleteItem,\n    completeAll,\n    clearCompleted,\n  }\n}</code>\n        </deckgo-highlight-code>\n<br/>\n<h2 id=\"이벤트-버스\" style=\"position:relative;\">이벤트 버스<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EC%8A%A4\" aria-label=\"이벤트 버스 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>이벤트 버스는 이벤트 주도 아키텍쳐(Event-Driven Architecture)를 구현하는 하나의 방법이다.</p>\n</blockquote>\n<p>이벤트 버스 패턴을 사용해 상태를 관리하는 방법이다. 리덕스를 사용해 봤다면 이 패턴과 아주 유사하다는 사실을 알 수 있다. 이벤트는 발생한 상황을 식별하는 이름과 이벤트 처리를 위한 정보를 담는 payload를 포함한다. (마치 리덕스의 액션과 같다).</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const event = { type: &#39;ADD_ITEM&#39;, payload: item }</code>\n        </deckgo-highlight-code>\n<p>이벤트 버스는 이벤트를 받아 처리한다. 기본 개념은 단일 객체가 모든 이벤트를 처리한다는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6f1d008c688bb71e55ec23f733dfc8e6/06868/eventbus.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.60919540229885%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABe0lEQVR42pWU666CQAyEff/nM+GHISKiAgIqolwUar4mNYvCuTRpYMt2tp3pspA/2jAMX+uu677iC3fxfD6lKApJkkROp5P0fa9JWZbJ8XhUb9tW42mayuFwkDiOpWmaMaCdAgie57kCl2Upt9tNgUgE+Hw+K8B+v5ftditBEOg+wxlV+Hg85HK5aDKgVIJVVaWJ1+tVk3Bim81G98+2bAYg4K5BA5S4FkXR+9BJQGsdbuDONSj4TOaQSUCAIBsQKoMbuGNNnBg8EoO/uq71CS28u2ovjCO4IIEnXFERIux2u7eaJpaJhxj3+/2dOwL85Afj5OVyqYIgANVOGaCoPwK0E6mCynBmjVbtids3nL3kAEbrIw7hiSqNRzat12tth7hxScu0x7vt5fuIwykjkYrsZHf451r/EZDqmDObRwOETzj7FyAq+74vYRhqy3Y7eCeO6lb5r4B28WmXkeHOwhEO0Gq1Es/zdIw+/zSzFdKmzZdbCSKwRpQ5Hl9kT94zHBDDGAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eventbus\"\n        title=\"\"\n        src=\"/static/6f1d008c688bb71e55ec23f733dfc8e6/31198/eventbus.png\"\n        srcset=\"/static/6f1d008c688bb71e55ec23f733dfc8e6/fe9c7/eventbus.png 174w,\n/static/6f1d008c688bb71e55ec23f733dfc8e6/39e45/eventbus.png 347w,\n/static/6f1d008c688bb71e55ec23f733dfc8e6/31198/eventbus.png 694w,\n/static/6f1d008c688bb71e55ec23f733dfc8e6/ee9b6/eventbus.png 1041w,\n/static/6f1d008c688bb71e55ec23f733dfc8e6/c1bea/eventbus.png 1388w,\n/static/6f1d008c688bb71e55ec23f733dfc8e6/06868/eventbus.png 1974w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이벤트 버스는 옵저버블 팩토리와 달리 모델을 래핑하지 않고 모델을 받아 사용한다. <code>dispatch()</code>는 이벤트에 따라 상태를 갱신하고 상태의 변경을 알린다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// model/eventBus.js\n\nexport default (model) =&gt; {\n  let listeners = []\n  let state = model()\n\n  const subscribe = listener =&gt; {\n    listeners.push(listener)\n\n    return () =&gt; {\n      listeners = listeners.filter(l =&gt; l !== listener)\n    }\n  }\n\n  const invokeSubscribers = () =&gt; {\n    const data = freeze(state)\n    listeners.forEach(listener =&gt; l(data))\n  }\n\n  const dispatch = event =&gt; {\n    const newState = model(state, event)\n\n    if (!newState) {\n      throw new Error(&#39;model should always return a value&#39;)\n    }\n\n    if (newState === state) {\n      return\n    }\n\n    state = newState\n\n    invokeSubscribers()\n  }\n\n  return {\n    subscribe,\n    dispatch,\n    getState: () =&gt; freeze(state)\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>모델은 이벤트에 따라 매핑된 메서드를 갖는다. 각 메서드는 직접 상태를 조작한다. 모델을 사용하는 곳에서는 이전 상태와 함께 이벤트 객체를 전달해야 한다. 유효한 이벤트라면 모델은 새로운 상태를 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"54,75\">\n          <code slot=\"code\">// model/model.js\n\nconst INITIAL_STATE = {\n  todos: [],\n}\n\nconst addItem = (state, event) =&gt; {\n  const { text } = event.payload;\n\n  if (!text) return;\n\n  return {\n    ...state,\n    todos: [\n      ...state.todos,\n      { text, completed: false }\n    ]\n  }\n}\n\nconst deleteItem = (state, event) =&gt; {\n  const { index } = event.payload;\n\n  if (index &lt; 0) return state;\n\n  if (!state.todos[index]) {\n    return state;\n  }\n\n  return {\n    ...state,\n    todos: state.todos.filter((_, i) =&gt; i !== index)\n  }\n}\n\nconst completeAll = (state, event) =&gt; {\n\n  return {\n    ...state,\n    todos: state.todos.map(todo =&gt; ({\n      ...todo,\n      completed: true,\n    }))\n  }\n}\n\nconst clearCompleted = (state, event) =&gt; {\n  return {\n    ...state,\n    todos: state.todos.filter(t =&gt; !t.completed)\n  }\n}\n\nconst methods = {\n  ADD_ITEM: addItem,\n  DELETE_ITEM: deleteItem,\n  COMPLETE_ALL: completeAll,\n  CLEAR_COMPLETED: clearCompleted\n}\n\nexport default (initalState = INITIAL_STATE) =&gt; {\n  return (prevState, event) =&gt; {\n    if (!prevState) {\n      return cloneDeep(initalState)\n    }\n\n    const currentModifier = methods[event.type]\n\n    if (!currentModifier) {\n      return prevState\n    }\n\n    return currentModifier(prevState, event)\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>컨트롤러는 이벤트 버스를 사용한다. <code>render()</code>를 리스너로 등록하고 처음에만 <code>render()</code>를 직접 실행한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"9,10 16 22 24\">\n          <code slot=\"code\">// index.js\n\n// import 구문 생략\n\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\n\nconst model = modelFactory({ todos: fetchTodos() });\nconst eventBus = eventBusFactory(model);\n\nconst render = (state) =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state, eventBus.dispatch);\n\n    renderDiff(document.body, app, newApp);\n  })\n}\n\neventBus.subscribe(render);\n\nrender(eventBus.getState());</code>\n        </deckgo-highlight-code>\n<p>이벤트 생성자는 이벤트 객체를 생성한다. 상태 변경에 필요한 정보가 있다면 이벤트 타입과 함께 payload에 정보를 실어야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// model/eventCreator.js\n\nconst EVENT_TYPES = Object.freeze({\n  ADD_ITEM: &#39;ADD_ITEM&#39;,\n  DELETE_ITEM: &#39;DELETE_ITEM&#39;,\n  COMPLETE_ALL: &#39;COMPLETE_ALL&#39;,\n  CLEAR_COMPLETED: &#39;CLEAR_COMPLETED&#39;\n})\n\nexport default {\n  addItem: (text) =&gt; ({\n    type: EVENT_TYPES.ADD_ITEM,\n    payload: text\n  }),\n  deleteItem: (index) =&gt; ({\n    type: EVENT_TYPES.DELETE_ITEM,\n    payload: index\n  }),\n  completeAll: () =&gt; ({\n    type: EVENT_TYPES.COMPLETE_ALL\n  }),\n  clearCompleted: () =&gt; ({\n    type: EVENT_TYPES.CLEAR_COMPLETED\n  }),\n}</code>\n        </deckgo-highlight-code>\n<p>예를 들어, App 컴포넌트는 <code>dispatch()</code>를 통해 이벤트 발생을 알린다. 이 때 <code>dispatch()</code>의 인자로 전달하는 이벤트 객체는 이벤트 생성자로 만든다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"1 16,17 23,24 28,29\">\n          <code slot=\"code\">import eventCreator from &quot;../model/eventCreator.js&quot;;\n\nlet template;\n\nconst getTemplate = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-app&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n}\n\nconst addEventListeners = (target, dispatch) =&gt; {\n  target.querySelector(&#39;.new-todo&#39;).addEventListener(&#39;keypress&#39;, (e) =&gt; {\n    if (e.key === &#39;Enter&#39;) {\n      const event = eventCreator.addItem({ text: e.target.value });\n      dispatch(event);\n      e.target.value = &#39;&#39;\n    }\n  })\n\n  target.querySelector(&#39;.completed-all&#39;).addEventListener(&#39;click&#39;, () =&gt; {\n    const event = eventCreator.completeAll();\n    dispatch(event);\n  })\n\n  target.querySelector(&#39;.clear-completed&#39;).addEventListener(&#39;click&#39;, () =&gt; {\n    const event = eventCreator.clearCompleted();\n    dispatch(event);\n  })\n}\n\nexport default (targetElement, _, dispatch) =&gt; {\n  const newApp = targetElement.cloneNode(true);\n\n  newApp.innerHTML = &#39;&#39;;\n\n  newApp.appendChild(getTemplate());\n\n  addEventListeners(newApp, dispatch);\n\n  return newApp;\n}</code>\n        </deckgo-highlight-code>\n<br/>\n<h2 id=\"상태-관리-전략-비교\" style=\"position:relative;\">상태 관리 전략 비교<a href=\"#%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5-%EB%B9%84%EA%B5%90\" aria-label=\"상태 관리 전략 비교 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 다뤘던 상태 관리 전략을 간단하게 비교한다. 어떤 전략이 항상 좋다고 할 수는 없다.</p>\n<h3 id=\"mvc\" style=\"position:relative;\">MVC<a href=\"#mvc\" aria-label=\"mvc permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>MVC 패턴은 구현이 쉽고 관심사 분리에도 좋다. 그러나 모델, 뷰, 컨트롤러 중 어디에도 넣기 어려운 회색 영역이 존재하기 쉽다. 그래서 엄격하게 구현하는 것에 어려움이 따른다. 확장성도 좋다고 할 수 없다.</p>\n<h3 id=\"반응형-프로그래밍-1\" style=\"position:relative;\">반응형 프로그래밍<a href=\"#%EB%B0%98%EC%9D%91%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-1\" aria-label=\"반응형 프로그래밍 1 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>추상화를 통해 코드의 일관성을 유지할 수 있다. 하지만 모든 객체를 옵저버블한 객체로서 다루는 것은 쉽지 않다. 게다가 애플리케이션이 커지면서 추상화가 감당하기 어려운 내용이 생긴다면 확장성에 문제가 발생할 수 있다.</p>\n<h3 id=\"이벤트-버스-1\" style=\"position:relative;\">이벤트 버스<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EC%8A%A4-1\" aria-label=\"이벤트 버스 1 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>옵저버블 패턴에 비해 상대적으로 구현이 단순하고 한 곳에서 모든 이벤트를 처리하기에 확장성도 좋다. 하지만 이벤트 발생에 따라 화면에 변경된 데이터가 반영되기까지 여러 단계를 거쳐야 하는 다변성을 갖는다. 이런 이유때문에 내부적으로 다른 상태 관리 전략을 채택하는 곳이 있다면 결국 코드의 일관성을 지키기 어렵다.</p>\n<br/>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/7장_상태_관리","title":"7장 상태 관리"},"frontmatter":{"created":"2023-03-12","updated":"2023-08-22 00:39:27 +0900"}}},{"node":{"id":"944b135c-c136-546f-816a-5ea46c420c82","html":"<h2 id=\"싱글-페이지-애플리케이션\" style=\"position:relative;\">싱글 페이지 애플리케이션<a href=\"#%EC%8B%B1%EA%B8%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-label=\"싱글 페이지 애플리케이션 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>SPA는 하나의 HTML 페이지로 실행되는 애플리케이션이다. 사용자가 다른 화면으로 이동할 때 뷰를 동적으로 재구성하여 보여주기 때문에 사용자가 경험할 수 있는 지연을 감소시키고 일반적으로 더 나은 UX를 제공할 수 있다.</p>\n<br />\n<h2 id=\"라우팅-시스템\" style=\"position:relative;\">라우팅 시스템<a href=\"#%EB%9D%BC%EC%9A%B0%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-label=\"라우팅 시스템 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>라우팅 시스템은 SPA를 구축하는데 크게 기여한다. 라우팅 시스템은 최소 두 가지 요소를 갖는다.</p>\n<ul>\n<li>경로 목록을 수집하는 레지스트리</li>\n<li>현재 URL의 리스너</li>\n</ul>\n<p>라우터는 URL이 변경될 때마다 해당 경로에 바인딩된 컴포넌트로 기존의 것을 대체한다.</p>\n<br />\n<h2 id=\"프래그먼트-식별자를-이용한-라우터-구현\" style=\"position:relative;\">프래그먼트 식별자를 이용한 라우터 구현<a href=\"#%ED%94%84%EB%9E%98%EA%B7%B8%EB%A8%BC%ED%8A%B8-%EC%8B%9D%EB%B3%84%EC%9E%90%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%9D%BC%EC%9A%B0%ED%84%B0-%EA%B5%AC%ED%98%84\" aria-label=\"프래그먼트 식별자를 이용한 라우터 구현 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프래그먼트 식별자를 알기 위해선 URI(Uniform Resource Identifier)를 먼저 알아야 한다. URI란 인터넷 자원 식별자다. 여기서 인터넷 자원은 리소스, 즉 HTTP 요청 대상이다. URL은 우리가 가장 자주 접할 수 있는 URI 형식으로 포트, 도메인 네임, 경로, 쿼리 등과 같은 정보를 포함한다. 프래그먼트 식별자도 그 중 하나로 <code>#</code>으로 시작하는 부분이다. 프래그먼트는 웹 문서의 특정 섹션을 식별하는 목적으로 사용한다. 브라우저는 프래그먼트로 식별된 요소를 브라우저 뷰포트의 가장 상단으로 스크롤한다.</p>\n<p>프래그먼트를 포함한 링크를 <code>&#x3C;nav /></code>에 포함시킨다. 본문이 담길 컨테이너는 <code>&#x3C;main/></code>이 된다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8 9 11\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;link rel=&quot;shortcut icon&quot; href=&quot;../favicon.ico&quot; /&gt;\n    &lt;title&gt;router&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;nav&gt;\n      &lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt;\n      &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt;\n    &lt;/nav&gt;\n    &lt;main&gt;&lt;/main&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>각 페이지에 들어갈 내용이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4,14\">\n          <code slot=\"code\">// pages.js\n\nexport default container =&gt; {\n  const home = () =&gt; {\n    container.textContent = &#39;This is Home page&#39;\n  }\n\n  const about = () =&gt; {\n    container.textContent = &#39;This is About page&#39;\n  }\n\n  const notFound = () =&gt; {\n    container.textContent = &#39;Page Not Found !&#39;\n  }\n\n  return {\n    home,\n    about,\n    notFound\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>중요한 것은 라우터다. 처음 언급했듯이 URL 변경을 감지하는 리스너와 경로 목록이 담긴 레지스트리가 필요하다. <code>start()</code>는 <code>checkRoutes()</code>를 실행, 또한 <code>hashchange</code>이벤트에 대한 핸들러로 <code>checkRoutes()</code>를 할당한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,13\">\n          <code slot=\"code\">// router.js\n\nexport default () =&gt; {\n  const router = {};\n\n  router.start = () =&gt; {\n    window.addEventListener(&#39;hashchange&#39;, checkRoutes);\n\n    if (!window.location.hash) {\n      window.location.hash = &#39;#/&#39;\n    }\n\n    checkRoutes();\n  }\n\n  return router;\n}</code>\n        </deckgo-highlight-code>\n<p><code>checkRoute()</code>는 현재 주소가 레지스트리에 등록되었는지 검사한다. 만약 등록된 주소라면 해당 루트의 컴포넌트를 바인딩하고 그렇지 않다면 <code>notFound()</code>를 실행한다. <code>setNotFound()</code>로 <code>notFound()</code>를 위한 컴포넌트를 연결하지 않았다면 빈 객체를 리턴하기 때문에 화면에는 아무 일도 일어나지 않는다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"9,27\">\n          <code slot=\"code\">// router.js\n\nexport default () =&gt; {\n   \n  // ... 생략\n\n  const routes = [];\n\n  const checkRoutes = () =&gt; {\n    const currentRoute = routes.find(route =&gt; {\n      return route.fragment === window.location.hash;\n    })\n\n    if (!currentRoute) {\n      notFound();\n      return;\n    }\n\n    currentRoute.component();\n  }\n\n  let notFound = () =&gt; {};\n\n  router.setNotFound = cb =&gt; {\n    notFound = cb;\n    return router;\n  }\n\n  return router;\n}</code>\n        </deckgo-highlight-code>\n<p>router의 마지막 메서드로 레지스트리 등록을 위한 <code>addRoutes()</code>를 추가한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"29,35\">\n          <code slot=\"code\">export default () =&gt; {\n  const router = {};\n\n  router.start = () =&gt; {\n    window.addEventListener(&#39;hashchange&#39;, checkRoutes);\n\n    if (!window.location.hash) {\n      window.location.hash = &#39;#/&#39;\n    }\n\n    checkRoutes();\n  }\n\n  const routes = [];\n\n  const checkRoutes = () =&gt; {\n    const currentRoute = routes.find(route =&gt; {\n      return route.fragment === window.location.hash;\n    })\n\n    if (!currentRoute) {\n      notFound();\n      return;\n    }\n\n    currentRoute.component();\n  }\n\n  router.addRoutes = routeList =&gt; {\n    Object.entries(routeList).map(([fragment, component]) =&gt; {\n      routes.push({ fragment, component });\n    })\n\n    return router;\n  }\n\n  let notFound = () =&gt; { };\n\n  router.setNotFound = cb =&gt; {\n    notFound = cb;\n    return router;\n  }\n\n  return router;\n}</code>\n        </deckgo-highlight-code>\n<p>컨트롤러에서 경로 레지스트리를 구성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"10,18\">\n          <code slot=\"code\">import createPage from &#39;./pages.js&#39;;\nimport createRouter from &#39;./router.js&#39;;\n\nconst container = document.querySelector(&#39;main&#39;);\n\nconst pages = createPage(container);\n\nconst router = createRouter();\n\nconst routes = {\n  &#39;#/&#39;: pages.home,\n  &#39;#/about&#39;: pages.about,\n}\n\nrouter\n  .addRoutes(routes)\n  .setNotFound(pages.notFound)\n  .start();</code>\n        </deckgo-highlight-code>\n<p>동작하는 해시 라우터</p>\n<p><img src=\"/ee7ee8deedc18415f660c30b020491ac/router.gif\" alt=\"router\"></p>\n<p>라우터 흐름은 이렇다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f11febe4aac370873e4920a8d2f470b1/302a4/flow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98.27586206896551%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAADL0lEQVR42pWUTU8TURSG+SMuXLjzL5iYoImRKEaNK9cudKGJO5VEIyggokbFKCooH8W20EKNprSF1pZ+z0w7/ZiZTqcfoIKIv+H1nNtSRQjg4uTembnz3nOe897bZpSL+Dt0s4BqvYS1H3V8X61ida0molzV6dvWtTtF279ilZoBXziI+0OvMPh6FAPDI3j05h2SmTTKFV2s2bdgsZTHt+8VPHr7DgeOnMHhkxdxqP0CDh49C49vHrVlE9r/CHJJZkVDUklhyuPBq8kpjDqcmHTPQi1mUbK0/ZVcojBpMUeZokYM19frKOgqVr6WxbxKKPYSawkW9ByyhYwQiEopXHvmxJUnDlwamMLVZ9Nifmdkbn9N4ayi6QRBTyGTl/ElGcfNYTeuD83g8iAJPmVBO7rfe7a5QRNRbI4Ntm3MhZnxyF20qgbqdYNKNaHSBqVyAcsrJmEwtrAuE+uvy7xWxwqNPDetpmCCBHkHnRdTaNRttSgjpcQgZRLIa9k/dmGfkicDKQm3xufR51xEj30Bd2w+xNVsU1BOkkjjB81Q8SnwGcOTY7B7ZjBin8So3YZQLAi1oCCcjEHJpvByLoD2u06c7nejo9eF490O2kTeLsiZqJSRpKYQS0UQl5Yg0zxPDdN4QyrXqmpYTMu4bfOja9yLG2Pz6JrwIZnLbi2ZBZlNhUpiZlliqBk51Mgy/I4Z/d2YSk0Xa9gdFn1vNUUIUoYsxhy88TQWJQXOQAjeWEJk409KIoOS1eQsEmg0NEOW4zlX1yq5YORFp3rsAZzqc+HcgBud/Y3x/EMXTtybRo/NiwyjkJLiHxaLJKICx+YpagnyObYow6Akw7YQhSMUx5tPQUz4l+AIJjDmj4pvFVpjmI3TJeIfDC0fsh14IXtqY9XErx8WTF3B6oqOn/S8sVYW/tzztmHBOGWYp+Nn0osg8RrxRjDuj+G520/jEj4sxjHmiyKiKILzbkdQCMqqRFwSUHNpPJ4JCF4dvdPkMRc6H7hwfnAWx+468OLjF8F502K7Xl8szFeXqudFJhElg7CsIEQRpucQdT2j5bYx21FwkwvbwbAaXtwpSvu4vn4DrwRH3FFxjbcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"flow\"\n        title=\"\"\n        src=\"/static/f11febe4aac370873e4920a8d2f470b1/31198/flow.png\"\n        srcset=\"/static/f11febe4aac370873e4920a8d2f470b1/fe9c7/flow.png 174w,\n/static/f11febe4aac370873e4920a8d2f470b1/39e45/flow.png 347w,\n/static/f11febe4aac370873e4920a8d2f470b1/31198/flow.png 694w,\n/static/f11febe4aac370873e4920a8d2f470b1/ee9b6/flow.png 1041w,\n/static/f11febe4aac370873e4920a8d2f470b1/302a4/flow.png 1080w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br />\n<h2 id=\"정규식을-통한-경로-매개변수-추출\" style=\"position:relative;\">정규식을 통한 경로 매개변수 추출<a href=\"#%EC%A0%95%EA%B7%9C%EC%8B%9D%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B2%BD%EB%A1%9C-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%B6%94%EC%B6%9C\" aria-label=\"정규식을 통한 경로 매개변수 추출 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>경로 매개변수(path parameter)는 URL에서 리소스를 식별해야 할 때 사용한다.</p>\n<p>다음 경로에서 123은 유저의 식별자다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">https://example.com/users/123</code>\n        </deckgo-highlight-code>\n<p>이를 <code>id</code>라는 매개변수로 표현한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">https://example.com/users/:id</code>\n        </deckgo-highlight-code>\n<p>매개변수를 갖는 경로를 레지스트리에 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,7\">\n          <code slot=\"code\">const routes = {\n  &#39;#/&#39;: pages.home,\n  &#39;#/about&#39;: pages.about,\n  &#39;#/users&#39;: pages.users,\n  &#39;#/users/:id&#39;: pages.userDetail,\n  &#39;#/users/:id/:anotherId&#39;: pages.userAnotherDetail,\n  &#39;#/users/:id/:anotherId/:theOtherId&#39;: pages.userTheOtherDetail,\n}</code>\n        </deckgo-highlight-code>\n<p>매개변수를 포함한 경로에 매핑하는 컴포넌트는 인자를 받는다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12,18\">\n          <code slot=\"code\">export default container =&gt; {\n  // ...\n\n  const users = () =&gt; {\n    container.textContent = &#39;This is Users page&#39;\n  }\n\n  const userDetail = ({ id }) =&gt; {\n    container.textContent = `This is User Detail Page with ID: ${id}`\n  }\n\n  const userAnotherDetail = ({ id, anotherId }) =&gt; {\n    container.textContent = `This is User Another Detail Page with ID: ${id}, another ID: ${anotherId}`\n  }\n\n  const userTheOtherDetail = ({ id, anotherId, theOtherId }) =&gt; {\n    container.textContent = `This is User Another Detail Page with ID: ${id}, another ID: ${anotherId}, theOtherId: ${theOtherId}`\n  }\n\n  // ...\n}</code>\n        </deckgo-highlight-code>\n<p><code>addRoutes()</code>는 이제 경로를 그대로 푸시하는 대신 경로 매개변수를 담는 리스트인 <code>params</code>와 경로 탐색을 위한 정규표현식인 <code>testRegExp</code>을 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"3 7\">\n          <code slot=\"code\">router.addRoutes = routeList =&gt; {\n  Object.entries(routeList).map(([fragment, component]) =&gt; {\n    const params = [];\n\n    // ... 중략\n\n    routes.push({ component, params, testRegExp });\n  })\n\n  return router;\n}</code>\n        </deckgo-highlight-code>\n<p><code>replace()</code>는 어떤 패턴에 일치하는 일부, 또는 모든 부분이 교체된 새로운 문자열을 반환한다. 어떤 경우에 일부를 교체하고, 또는 모두를 교체할까? 만약 첫 번째 인자가 문자열이라면 첫 번째로 일치하는 문자열만을 교체한다. 만약 일치하는 모두를 교체하고 싶다면 <code>replaceAll()</code>을 사용해야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const newStr = str.replace(regexp|substr, newSubstr|function)</code>\n        </deckgo-highlight-code>\n<p>한편, 첫 번째 인자가 정규식이라면 정규식의 플래그에 따라 일치하는 부분을 일부 또는 모두 교체한다. 두 번째 인자로는 대체 문자열 또는 함수를 받는다. 만약 함수라면 함수의 첫 번째 인자로 매치된 문자열, 두 번째 인자부터는 정규 표현식의 캡쳐 그룹에 속한 문자열이 주어진다. 이외에도 매치된 문자열의 index, 조사된 전체 문자열을 매개변수로 갖는다. 자세한 내용은 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/replace\">MDN</a>을 참고하자. 이 함수의 매개변수 갯수는 정규식에 따라 달라진다는 점에 유의하자.</p>\n<p><code>parsedFragment</code>는</p>\n<ul>\n<li><code>fragment</code>에서 <code>/:(\\w+)/</code>정규 표현식을 활용하여 각 경로의 매개변수를 찾는다.</li>\n<li>각 경로 매개변수를 <code>params</code>에 담는다.</li>\n<li>각 경로 매개변수를 또 다른 정규 표현식을 문자열로 나타낸 <code>'([^\\\\/]+)'</code>로 대체한다.</li>\n<li><code>/</code>를 <code>\\/</code>로 대체한다.</li>\n</ul>\n<p>최종 문자열에 행의 시작과 끝을 나타내는 앵커를 붙인 후 새로운 정규표현식 <code>testRegExp</code>을 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"2,16\">\n          <code slot=\"code\">router.addRoutes = routeList =&gt; {\n  const ROUTE_PARAMETER_REGEXP = /:(\\w+)/g;\n  const URL_FRAGMENT_REGEXP = &#39;([^\\\\/]+)&#39;;\n  \n  Object.entries(routeList).map(([fragment, component]) =&gt; {\n    const params = [];\n\n    const parsedFragment = fragment\n      .replace(ROUTE_PARAMETER_REGEXP, (_, param) =&gt; {\n        params.push(param);\n\n        return URL_FRAGMENT_REGEXP;\n      })\n      .replace(/\\//g, &#39;\\\\/&#39;);\n\n    const testRegExp = new RegExp(`^${parsedFragment}$`);\n\n    routes.push({ component, params, testRegExp });\n  })\n\n  return router;\n}</code>\n        </deckgo-highlight-code>\n<p>만약 <code>fragment</code>가 <code>#/users/:id/:anotherId</code>라면</p>\n<ul>\n<li><code>id</code>와 <code>anotherId</code>를 <code>params</code>에 담는다.</li>\n<li>매개변수는 <code>'([^\\\\/]+)'</code>가 대체하여 <code>#/users/([^\\\\/]+)/([^\\\\/]+)</code>와 같은 모양이 된다.</li>\n<li><code>/</code>를 대체하면 <code>#\\/users\\/([^\\\\/]+)\\/([^\\\\/]+)</code>이 된다.</li>\n<li>최종적으로 <code>testRegExp</code>는 <code>^#\\/users\\/([^\\\\/]+)\\/([^\\\\/]+)$</code>와 같은 정규 표현식이 된다.</li>\n</ul>\n<p>이제 <code>hashChange</code>이벤트가 발생하면, <code>routes</code>를 순회하며 각 <code>route</code>의 유효성을 검증하고  <code>extractUrlParams()</code>를 통해 해당 루트에 필요한 파라미터를 추출한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7 15\">\n          <code slot=\"code\">const checkRoutes = () =&gt; {\n  const { hash } = window.location;\n\n  const currentRoute = routes.find(route =&gt; {\n    const { testRegExp } = route;\n\n    return testRegExp.test(hash);\n  })\n\n  if (!currentRoute) {\n    notFound();\n    return;\n  }\n\n  const urlParams = extractUrlParams(currentRoute, hash);\n\n  // ...\n}</code>\n        </deckgo-highlight-code>\n<p><code>extractUrlParams()</code>는 정규 표현식으로 실제 주소에서 파라미터에 대응하는 값을 추출한다. 만약, <code>users/:id/:anotherId</code>의 형식에 <code>users/1/2</code>와 같은 실제 주소라면 <code>{ id: 1, anotherId: 2}</code>를 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,16\">\n          <code slot=\"code\">const extractUrlParams = (route, hash) =&gt; {\n  if (route.param?.length === 0) {\n    return {}\n  }\n\n  const params = {};\n\n  const matches = hash.match(route.testRegExp);\n\n  matches.shift();\n\n  matches.forEach((paramValue, index) =&gt; {\n    const paramName = route.params[index];\n\n    params[paramName] = paramValue;\n  })\n\n  return params;\n}</code>\n        </deckgo-highlight-code>\n<p>컴포넌트에 추출한 파라미터를 넣고 실행한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"17\">\n          <code slot=\"code\">const checkRoutes = () =&gt; {\n  const { hash } = window.location;\n\n  const currentRoute = routes.find(route =&gt; {\n    const { testRegExp } = route;\n\n    return testRegExp.test(hash);\n  })\n\n  if (!currentRoute) {\n    notFound();\n    return;\n  }\n\n  const urlParams = extractUrlParams(currentRoute, hash);\n\n  currentRoute.component(urlParams);\n}</code>\n        </deckgo-highlight-code>\n<p>동작하는 매개변수 탐색<br>\n<img src=\"/feb01d5e27ce4f5c92bf217a8b95b264/params.gif\" alt=\"params\"></p>\n<br />\n<h2 id=\"히스토리-api를-이용한-라우터\" style=\"position:relative;\">히스토리 API를 이용한 라우터<a href=\"#%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-api%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%9D%BC%EC%9A%B0%ED%84%B0\" aria-label=\"히스토리 api를 이용한 라우터 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>히스토리 라우터는 프래그먼트 식별자를 사용하지 않는다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,13\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;link rel=&quot;shortcut icon&quot; href=&quot;../favicon.ico&quot; /&gt;\n    &lt;title&gt;router&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;nav&gt;\n      &lt;a data-navigation href=&quot;/&quot;&gt;home&lt;/a&gt;\n      &lt;a data-navigation href=&quot;/about&quot;&gt;about&lt;/a&gt;\n      &lt;a data-navigation href=&quot;/users&quot;&gt;users&lt;/a&gt;\n      &lt;a data-navigation href=&quot;/users/1&quot;&gt;user(1)&lt;/a&gt;\n      &lt;a data-navigation href=&quot;/users/1/2&quot;&gt;user(1)-2&lt;/a&gt;\n      &lt;a data-navigation href=&quot;/users/3/4/5&quot;&gt;user(3)-4-5&lt;/a&gt;\n    &lt;/nav&gt;\n    &lt;main&gt;&lt;/main&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>링크를 클릭할 때 기대하는 동작은 해당 경로에 매핑된 구성을 보여주는 것이다. 하지만 링크 요소를 클릭하는 경우 실제 주소에 요청을 날리기 때문에 404 에러가 발생한다. 이런 이유로 <code>data</code> 속성으로  네비게이션 속성을 갖는 <code>a</code>태그를 식별하고 클릭 이벤트의 기본 동작을 방지하는 방식을 사용한다. 그리고 URL의 변경되는 것을 감지할 수 있는 DOM 이벤트가 없기 때문에 <code>setInterval()</code>을 사용하여 변경을 주기적으로 확인한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7 12,15\">\n          <code slot=\"code\">const TICKTIME = 250;\nconst NAVIGATION = &#39;a[data-navigation]&#39;;\n\nrouter.start = () =&gt; {\n  checkRoutes();\n\n  window.setInterval(checkRoutes, TICKTIME)\n\n  document.body.addEventListener(&#39;click&#39;, (e) =&gt; {\n    const { target } = e;\n\n    if (target.matches(NAVIGATION)) {\n      e.preventDefault();\n      router.navigate(target.href);\n    }\n  })\n}</code>\n        </deckgo-highlight-code>\n<p>경로도 프래그먼트 식별자 없이 정의한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const routes = {\n  &#39;/&#39;: pages.home,\n  &#39;/about&#39;: pages.about,\n  &#39;/users&#39;: pages.users,\n  &#39;/users/:id&#39;: pages.userDetail,\n  &#39;/users/:id/:anotherId&#39;: pages.userAnotherDetail,\n  &#39;/users/:id/:anotherId/:theOtherId&#39;: pages.userTheOtherDetail,\n}</code>\n        </deckgo-highlight-code>\n<p>동작하는 히스토리 라우터<br>\n<img src=\"/26ef032f0978ef7a6028114a4083b36c/history.gif\" alt=\"history\"></p>\n<br/>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/6장_라우터","title":"6장 라우터"},"frontmatter":{"created":"2023-03-04","updated":"2023-08-22 00:39:19 +0900"}}},{"node":{"id":"f27808c3-f2ea-59f9-972b-aaaf7ed6dc64","html":"<h2 id=\"ajaxasynchronous-javascript-and-xml\" style=\"position:relative;\">AJAX(Asynchronous Javascript and XML)<a href=\"#ajaxasynchronous-javascript-and-xml\" aria-label=\"ajaxasynchronous javascript and xml permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/Guide/AJAX\">AJAX</a> 애플리케이션의 핵심은 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest\">XMLHttpRequest</a> 객체다. AJAX에서는 X는 XML을 나타낸다. 그만큼 과거에는 주로 XML형식의 데이터를 수신했다. 최근에는 JSON 객체를 주로 사용하는데 MDN에서는 그 이유를 JSON 객체가 자바스크립트의 일부이고 더 가볍기 때문이라고 설명한다.</p>\n<br/>\n<h2 id=\"http-인터페이스\" style=\"position:relative;\">HTTP 인터페이스<a href=\"#http-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"http 인터페이스 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>저자는 소프트웨어 디자인의 가장 중요한 원칙 중 하나를 소개한다.</p>\n<blockquote>\n<p>구현이 아닌 인터페이스로 프로그래밍하라.<br>\n- Gang of Four</p>\n</blockquote>\n<br/>\n<p>여러 곳에서 HTTP 클라이언트 API로 네트워크 요청을 하는 아주 거대한 애플리케이션이 있다고 가정해 보자. 만약 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Fetch_API\">Fetch API</a>를 사용하다가 <a href=\"https://axios-http.com/\">Axios</a>로 교체해야 하는 순간이 온다면, 비용이 큰 매우 지루한 작업을 해야만 한다.</p>\n<blockquote>\n<p>라이브러리를 사용할 때는 이에 대한 인터페이스를 생성하라. 필요시 새로운 라이브러리로 쉽게 변경할 수 있다.</p>\n</blockquote>\n<br/>\n<p>예를 들어 어떤 함수는 직접 네트워크를 요청하지 않고 모델 객체가 제공하는 메서드로 원하는 것을 얻는다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\n\nimport todo from &#39;./todo.js&#39;;\n\nconst getTodoList = async () =&gt; {\n  const result = await todos.list()\n  // do something\n}</code>\n        </deckgo-highlight-code>\n<p>모델은 HTTP 인터페이스를 통해 모델의 특정 데이터를 제공하는 메서드를 갖는다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// todo.js\n\nimport http from &#39;./http.js&#39;;\n\nconst list = () =&gt; http.get(BASE_URL);</code>\n        </deckgo-highlight-code>\n<p>HTTP 인터페이스는 실제 사용하고 있는 HTTP 클라이언트 API를 래핑하고 내부 구현을 감춘다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// http.js\n\nconst request = async params =&gt; {\n  const {\n    method = &#39;GET&#39;,\n    url,\n    headers = {},\n    body\n  } = params\n\n  const config = {\n    url,\n    method,\n    headers,\n    data: body\n  }\n\n  return axios(config)\n}\n\nconst get = async (url, headers) =&gt; {\n  const response = await request({\n    url,\n    headers,\n    method: &#39;GET&#39;\n  })\n\n  return response.data\n}\n\n// post, delete 기타 등등...</code>\n        </deckgo-highlight-code>\n<br/>\n<h2 id=\"회사-코드에-모델-레이어-추가를--제안했다\" style=\"position:relative;\">회사 코드에 모델 레이어 추가를  제안했다<a href=\"#%ED%9A%8C%EC%82%AC-%EC%BD%94%EB%93%9C%EC%97%90-%EB%AA%A8%EB%8D%B8-%EB%A0%88%EC%9D%B4%EC%96%B4-%EC%B6%94%EA%B0%80%EB%A5%BC--%EC%A0%9C%EC%95%88%ED%96%88%EB%8B%A4\" aria-label=\"회사 코드에 모델 레이어 추가를  제안했다 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"기존-코드의-문제점\" style=\"position:relative;\">기존 코드의 문제점<a href=\"#%EA%B8%B0%EC%A1%B4-%EC%BD%94%EB%93%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"기존 코드의 문제점 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 챕터를 읽을 당시 내가 맡던 회사 프로젝트는 마침 몇가지 문제를 갖고 있었다.</p>\n<ul>\n<li>데이터 의존도가 매우 높다. 같은 데이터 모델을 공유하기 위해 서버의 인터페이스를 가급적 그대로 사용하는 편이지만 그렇기 때문에 서버 인터페이스의 작은 변경에도 취약한 구조를 가진다. 데이터 특성상 그 깊이도 매우 깊다. 자료의 인터페이스가 바뀌면 커스텀 훅부터 뷰 컴포넌트까지 모두 바꿔줘야 하는 경우가 잦다.</li>\n<li>커스텀 훅이 매우 비대하다. 상태 관리 외에도 데이터 요청, 에러 핸들링 등의 역할을 수행하고 있다. 커스텀 훅의 책임이 많은 만큼 테스트를 작성하는 것도 어렵다.</li>\n<li>여러 커스텀 훅, 심지어 컴포넌트에서도 HTTP 클라이언트 API(<code>Apollo Client</code>)를 직접 사용하고 있다. 같은 모델에 대한 데이터를 요청하는 코드가 여러 곳에 산재되어 코드 응집도(?)가 낮아 유지 보수가 어렵다. 이런 경우 중복 코드가 많아질 수 있다. 테스트를 작성할 때마다 <code>Apollo Client</code>를 모킹해야 한다.</li>\n<li>HTTP 클라이언트 라이브러리에 관한 의존도가 높다. 만약 <code>Apollo Client</code>가 아닌 다른 라이브러리를 사용하게 된다면 관련 코드를 모두 찾아내어 수정해야 한다.</li>\n</ul>\n<p>신입 개발자로서 제안한다는 것이 부담스러웠지만 그간 겪었던 불편함, 나중에 겪게 될 수도 있는 고통이 염려되어 조심스럽게 간단한 예시와 함께 PR을 올렸다. 내가 제안한 것은 모델이란 하나의 계층을 추가하여 커스텀 훅이나 컴포넌트로부터 네트워크 요청이라는 책임을 분리하자는 내용이었다. 책에서 봤던 모델 계층을 활용하지만 당장은 큰 변화처럼 느껴지는 HTTP 인터페이스 구현체는 고려하지 않았다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d1f48bab998e06d8a067ed121e3c6630/8b936/model.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.20689655172414%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACJ0lEQVR42q1U2ZLaMBDks8C2JMuyjQ/O5TDHLhvMsQYqFPz/Q2dGxMsWD0nYykOXJNeoZ6Z7rIbnefifaDx1wfXgOi6tLgSdGXy23x4JhRAWj/uvEErCDzWkVnAVkUkPyvgWdbwldFoOHMe5rZ/7Flz3npmrMGkEP9LI+x3MXucoCKYdQrcNdGxsTMMj5nSYI+llSPoZ0sFtnw47n0E1aZjFdi2KAuefZ1QfFSajMbQJ4MfBjdAVHibLAtvtFsfTEavVCrvdFvvqA0ESUpADpZSFySLoQGO9XmO/32Mxn1viKImhqHJLKH0KJl0G/QHO5zPmszmOhyPG0zEkaeP/JuPggFrmJNPFDIvVK6bzGdbbElHeJimCOyGX2+v1cDqdsFwucblcMJqMKZF/c5a0ZCgyQ3NrWiJpB2SGgqeFJRNS2lhLGLCovo+qqlCWJTblxurC1QhPQFIwQ1gDW2g2W8iNhqAkLdo7zbuBDSEFTCe2+rAZ7S4jhckjawqPg1TSEsd5gu6kb43rvXSRk3EZgc+KEjDpHwe7bpXB4xRS0mJW4FAdsCNTfry/43q9kt4Tq7f3N8JHcu7Cp0reVm9Yb0qUZEhJa0gu8yze5vCffzvXtmVYV6omSWM75B4Zw2TsxVMV1lWyMYFUeIlixMqH4ZFiQ9xvPA4OXcyMwajbxWI8xmw0wjBLEdakzxLypVjTT5AkGHU6Fr02DTWNlPut5+tB06+PR41f0BdeARA/pqkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"model.png\"\n        title=\"\"\n        src=\"/static/d1f48bab998e06d8a067ed121e3c6630/31198/model.png\"\n        srcset=\"/static/d1f48bab998e06d8a067ed121e3c6630/fe9c7/model.png 174w,\n/static/d1f48bab998e06d8a067ed121e3c6630/39e45/model.png 347w,\n/static/d1f48bab998e06d8a067ed121e3c6630/31198/model.png 694w,\n/static/d1f48bab998e06d8a067ed121e3c6630/ee9b6/model.png 1041w,\n/static/d1f48bab998e06d8a067ed121e3c6630/8b936/model.png 1368w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>예를 들어, <code>useTodoList()</code>는 <code>todo</code>모델이 제공하는 메서드로 데이터를 받는다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4,10\">\n          <code slot=\"code\">const useTodoList = () =&gt; {\n  const [todoList, setTodoList] = useState&lt;TodoList&gt;();\n\n  useEffect(() =&gt; {\n    (async () =&gt; {\n      const todoList = await todo.list();\n\n      setTodoList(todoList);\n    })();\n  }, []);\n\n  return {\n    todoList\n  };\n};</code>\n        </deckgo-highlight-code>\n<p>다만, 모델 객체는 컴포넌트나 훅이 아니기 때문에 Apollo Client에서 제공하는 훅을 사용할 수 없었다. 그래서 core API를 사용해야만 했는데 query, mutation은 큰 어려움이 없었지만 subscription의 경우 사용하는 곳에서 명시적으로 unsubscribe를 해야 한다는 문제가 있었다. 물론 방법이야 있겠지만 당시에는 찾지 못했다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,31\">\n          <code slot=\"code\">import { client } from &#39;@clients/apollo/client&#39;;\n\ninterface TodoModel {\n  list: (upcreated: (data: TodoList) =&gt; void) =&gt; Subscription;\n  item: (todoId: string) =&gt; Promise&lt;Todo&gt;;\n}\n\nconst todo: TodoModel = {\n  list: (update) =&gt; {\n    return client.subscribe({ query: GET_TODO_LIST }).subscribe({\n      next({ data }) {\n        const todoList = data.todos.map((todo) =&gt; {\n          return {\n            // 인터페이스에 맞게 데이터 매핑, 구조 분해 할당\n          };\n        });\n\n        update(todoList);\n      }\n    });\n  },\n  item: async (todoId: string) =&gt; {\n    const response = await client.query({ query: GET_TODO, variables: { todoId } });\n\n    const todo = await response.data.todos[0];\n\n    return {\n       // 인터페이스에 맞게 데이터 매핑, 구조 분해 할당\n    };\n  },\n};\n\nexport default todo;</code>\n        </deckgo-highlight-code>\n<p>그럼에도 불구하고 내가 생각한 모델 계층을 분리하여 얻는 이점은 이랬다.</p>\n<ul>\n<li>데이터 의존도가 낮아진다. 목 데이터 제공, API 새로 붙이기, API 교체 작업 등은 모델 계층에서만 하면 되기 때문이다. 모델 계층에서 원하는 형태의 데이터를 전달하기 때문에 데이터 출처나 소싱 방법이 바뀌더라도 커스텀 훅과 컴포넌트의 코드는 그대로 유지할 수 있다.</li>\n<li>커스텀 훅에서 데이터 요청 로직이 분리됨에 따라 테스트 코드 작성이 비교적 쉽다. <code>MockProvider</code>에 길게 선언된 mock 객체를 전달하여 테스트하는 방식보다 모델 객체를 단순 모킹하는 것이 더 편리하다.</li>\n<li>모델 중심으로 코드가 모여있기 때문에 유지 보수가 편리하고 가독성이 좋다. 중복 코드도 제거할 수 있다.</li>\n<li>HTTP 클라이언트 라이브러리에 관한 의존도가 낮다. 다른 라이브러리를 사용하게 되더라도 교체가 쉽다.</li>\n<li>변경에 보다 더 유연하게 대처할 수 있으면서도 현재 구조에서 크게 공수가 들지 않는 방법이다.</li>\n</ul>\n<p>염려하는 부분도 있었다. 그건 Apollo client에서 제공하는 훅을 사용하지 않기 때문에 낯선 코드를 접해야 하고 예상치 못한 문제를 만날 수 있다는 것과 적은 지식을 바탕으로 제안한 내용이라 좋은 방법이 아닐 가능성이 다분하다는 사실이었다.</p>\n<h3 id=\"내가-놓쳤던-부분-그리고-후기\" style=\"position:relative;\">내가 놓쳤던 부분 그리고 후기<a href=\"#%EB%82%B4%EA%B0%80-%EB%86%93%EC%B3%A4%EB%8D%98-%EB%B6%80%EB%B6%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%9B%84%EA%B8%B0\" aria-label=\"내가 놓쳤던 부분 그리고 후기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>결과적으로 내가 제안한 모양이 그대로 수용되진 않았다. 그러나 내 제안에 관한 오랜 논의를 거쳤고 그 중에는 내가 납득할 만한 이유가 있었다. 우선, 사용하는 곳에서 명시적으로 subscription을 해제해야 하는 부분이 아쉽다. 무엇보다 Apollo에서 제공하는 Hook 사용을 포기할 만큼의 장점이 느껴지진 않았다. 이는 충분히 공감하는 내용이었고 apollo의 core API를 사용하면서 어떤 문제가 발생할지 예측할 수 없다. 그리고 나중에 든 생각이지만 유지보수까지 고려한다면 API의 공식 문서에서도 제공하지 않는 내용이 가까운 미래에 혼란을 초래할 수도 있다는 생각이 들었다.</p>\n<p>하지만 소득이 적진 않았다. 서버 인터페이스에 대한 의존도를 낮춰야 한다는 사실에 대해서는 충분한 공감대가 형성됐기 때문이다. 팀장님과 논의 끝에 모델 계층을 추가하는 대신 API 계층을 추가했다. 그 형태는 React Hook의 형태가 됐다. Apollo에서 제공하는 훅을 사용해야 했기 때문이다. 하지만 이것만으로는 초기 목적 중 하나인 모델 중심으로 코드를 관리하고자 했던 바램을 이룰 수 없었다. 그래서 데이터 모델에 따라 디렉토리를 구분하여 API hook을 관리하도록 했다. 논의 끝에 최종적으로 합의된 내용은 아래와 같다.</p>\n<ol>\n<li>통신 로직을 <code>API hook</code>의 형태로 하나의 계층으로서 분리한다.\n<ul>\n<li><code>apollo</code>에서 제공하는 <code>hook</code>을 사용할 수 있음</li>\n<li>사용하는 곳에서 섭스크립션을 명시적으로 해제하지 않아도 됨</li>\n<li>관심사 또는 계층 분리 가능</li>\n<li>커스텀 훅의 테스트 용이성 확보</li>\n</ul>\n</li>\n<li><code>API hook</code>은 하나 이상의 <code>adapter</code> 함수를 가질 수 있다.\n<ul>\n<li>만약 adapter가 비대해지면 또 하나의 계층으로도 분리 가능</li>\n</ul>\n</li>\n<li>디렉토리 구조는 <code>src/apis/todos</code>와 같이 데이터 중심으로 분리한다.\n<ul>\n<li>기존 <code>src/hooks</code>과 통신 훅을 분리</li>\n<li>통신 로직을 디렉토리로 구분 및 관리하여 중복된 훅 생성 방지할 수 있음</li>\n</ul>\n</li>\n</ol>\n<p>사실 작업하면서 느꼈던 불편함을 빠르게 해소하고 싶어 가볍게 제안한건데 논의가 길어지면서 충분히 단단한 내용을 준비하지 못한 것에 대해 반성하기도 했다. 하지만 당시 내 실력으로 더 고민하는 것보다 문제를 공유하고 팀원들과 함께 고민하고 싶은 마음이 더 컸기 때문에 너무 오래 끌지 않은 것이 결국 더 좋은 판단이었다는 생각을 했다. 불편함을 공유하고 서버 인터페이스에 대한 종속성 문제를 적시에 해결하려는 주 목적을 달성했기 때문이다.</p>\n<br/>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/5장_HTTP_요청","title":"5장 HTTP 요청"},"frontmatter":{"created":"2023-02-26","updated":"2023-08-22 00:39:12 +0900"}}},{"node":{"id":"80221fe7-7c33-5092-8344-7ad36a23e685","html":"<h2 id=\"웹-컴포넌트\" style=\"position:relative;\">웹 컴포넌트<a href=\"#%EC%9B%B9-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"웹 컴포넌트 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>웹 컴포넌트는 세 가지 주요 내용을 포함한다.</p>\n<ul>\n<li>HTML 템플릿: 마크업에 포함된 템플릿 요소를 화면에 그리진 않는다. 대신 자바스크립트가 템플릿을 사용해서 DOM을 동적으로 생성할 수 있다.</li>\n<li>Shadow DOM: Shadow DOM의 핵심은 캡슐화로 메인 DOM 트리로부터 독립적인 DOM을 생성할 수 있다. <code>&#x3C;input /></code>, <code>&#x3C;video /></code>와 같은 기본 요소에도 Shadow DOM이 숨겨져 있다.</li>\n<li>Custom Elelment: 사용자 정의 요소를 만들고 제어할 수 있는 API로 이 챕터에서 주로 다룰 주제이다.</li>\n</ul>\n<h2 id=\"사용자-정의-요소custom-element\" style=\"position:relative;\">사용자 정의 요소(Custom Element)<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8Ccustom-element\" aria-label=\"사용자 정의 요소custom element permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저 간단한 사용자 정의 요소를 만들어 보자.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&lt;color-box&gt;&lt;/color-box&gt;</code>\n        </deckgo-highlight-code>\n<p>주의 사항</p>\n<ul>\n<li>이름에는 반드시 하이픈(-)이 들어가야 한다.</li>\n<li>태그를 잘 닫아주어야 한다.</li>\n</ul>\n<p>어떻게 사용할까? HTML에 사용자 정의 요소를 추가한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,11\">\n          <code slot=\"code\">&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=&quot;shortcut icon&quot; href=&quot;../favicon.ico&quot; /&gt;\n        &lt;title&gt;Frameworkless Frontend Development&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;button&gt;change everything to tamato !!&lt;/button&gt;\n       &lt;color-box&gt;&lt;/color-box&gt;\n       &lt;color-box color=&quot;navy&quot;&gt;&lt;/color-box&gt;\n       &lt;color-box color=&quot;green&quot;&gt;&lt;/color-box&gt;\n       &lt;color-box color=&quot;skyblue&quot;&gt;&lt;/color-box&gt;\n       &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>사용자 정의 요소도 DOM 요소이기 때문에 <code>HTMLElement</code>를 상속한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// Color.js\nexport default class Color extends HTMLElement {\n  // ... \n}</code>\n        </deckgo-highlight-code>\n<p><code>customElements.define()</code>는 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/CustomElementRegistry\">CustomElementRegistry</a>에 새로운 사용자 정의 요소를 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\nimport Color from &#39;./components/Color.js&#39;;\n\ncustomElements.define(&#39;color-box&#39;, Color);</code>\n        </deckgo-highlight-code>\n<p>사용자 정의 요소는 여러 생명주기 함수를 갖는다.</p>\n<ul>\n<li><code>connectedCallback</code>: 처음으로 DOM에 연결됐을 때 호출</li>\n<li><code>disconnectedCallback</code>: DOM으로부터 연결이 해제될 때 호출</li>\n<li><code>adoptedCallback</code>: 새로운 다큐먼트로 이동될 때 호출</li>\n<li><code>attributeChangedCallback</code>: 특정 속성이 변경될 때 호출</li>\n</ul>\n<p><code>attributeChangedCallback()</code>로 사용자 정의 요소의 <code>color</code> 속성이 변경될 때 자식 요소의 속성을 변경할 계획이다. 이 메서드는 <code>observedAttributes()</code>가 관찰하는 속성이 변경될 때만 호출된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// Color.js\n\nconst DEFAULT_COLOR = &#39;black&#39;;\n\nexport default class Color extends HTMLElement {\n  static get observedAttributes() {\n    return [&#39;color&#39;]\n  }\n\n  get color() {\n    return this.getAttribute(&#39;color&#39;) || DEFAULT_COLOR\n  }\n\n  set color(value) {\n    this.setAttribute(&#39;color&#39;, value)\n  }\n\n  attributeChangedCallback(name, prevState, state) {\n    if (!this.div) return;\n\n    if (name === &#39;color&#39;) {\n      this.div.style.color = state\n      this.div.textContent = state\n    }\n  }\n\n  connectedCallback() {\n    window.requestAnimationFrame(() =&gt; {\n      this.div = document.createElement(&#39;div&#39;);\n\n      this.div.textContent = this.color;\n      this.div.style.color = this.color;\n\n      this.appendChild(this.div);\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>버튼 요소에 모든 요소를 <code>tomato</code> 색으로 바꿔주는 이벤트 핸들러를 연결한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,9\">\n          <code slot=\"code\">// index.js\n\nimport Color from &#39;./components/color.js&#39;;\n\ncustomElements.define(&#39;color-box&#39;, Color);\n\nconst changeToTomato = () =&gt; document.querySelectorAll(&#39;color-box&#39;).forEach(div =&gt; div.color = &#39;tomato&#39;);\n\ndocument.querySelector(&#39;button&#39;).addEventListener(&#39;click&#39;, changeToTomato);</code>\n        </deckgo-highlight-code>\n<p>순서는 아래와 같다.</p>\n<ol>\n<li>버튼 클릭 이벤트 발생</li>\n<li>핸들러는 해당 요소의 <code>color</code> 속성 변경</li>\n<li><code>observedAttributes()</code>는 속성 변경 감지</li>\n<li><code>attributeChangedCallback()</code> 호출</li>\n<li><code>color</code> 속성에 따라 자식 요소의 스타일, 텍스트 변경</li>\n</ol>\n<br />\n<p>음.. 잘 된다.</p>\n<p><img src=\"/d9015deff7eba1f0b30e2727b3e5a8c6/color.gif\" alt=\"color\"></p>\n<h2 id=\"사용자-정의-요소로-구현한-투두-앱\" style=\"position:relative;\">사용자 정의 요소로 구현한 투두 앱<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%9C-%ED%88%AC%EB%91%90-%EC%95%B1\" aria-label=\"사용자 정의 요소로 구현한 투두 앱 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지난 챕터에서 만들었던 투두 앱을 사용자 정의 요소를 사용한 앱으로 변경한다.</p>\n<h3 id=\"사용자-정의-요소-등록\" style=\"position:relative;\">사용자 정의 요소 등록<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C-%EB%93%B1%EB%A1%9D\" aria-label=\"사용자 정의 요소 등록 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>HTML에 아래 사용자 정의 요소를 추가한다.</p>\n<ul>\n<li><code>&#x3C;custom-app /></code></li>\n<li><code>&#x3C;custom-todos /></code></li>\n</ul>\n<p>기존 루트 요소는 <code>&#x3C;custom-app /></code>요소가 대체한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"35 39\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-footer&quot;&gt;\n      &lt;footer class=&quot;footer&quot;&gt;\n        &lt;span class=&quot;counter&quot;&gt;&lt;/span&gt;\n        &lt;ul class=&quot;filters&quot;&gt;\n          &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;진행&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n      &lt;/footer&gt;\n    &lt;/template&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;li&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;삭제&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/li&gt; \n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;section class=&quot;todoapp&quot;&gt;\n        &lt;header&gt;\n          &lt;h1&gt;todos&lt;/h1&gt;\n          &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n        &lt;/header&gt;\n        &lt;section class=&quot;main&quot;&gt;\n          &lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label for=&quot;toggle-all&quot;&gt;전체 완료&lt;/label&gt;\n          &lt;custom-todos&gt;&lt;/custom-todos&gt;\n        &lt;/section&gt;\n      &lt;/section&gt;\n    &lt;/template&gt;\n    &lt;custom-app&gt;&lt;/custom-app&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>컨트롤러는 레지스트리에 사용자 정의 요소를 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,7\">\n          <code slot=\"code\">// index.js\n\nimport App from &#39;./components/App.js&#39;\nimport Todos from &#39;./components/Todos.js&#39;\n\nwindow.customElements.define(&#39;custom-app&#39;, App);\nwindow.customElements.define(&#39;custom-todos&#39;, Todos);</code>\n        </deckgo-highlight-code>\n<h3 id=\"dom에-연결될-때-하는-일\" style=\"position:relative;\">DOM에 연결될 때 하는 일<a href=\"#dom%EC%97%90-%EC%97%B0%EA%B2%B0%EB%90%A0-%EB%95%8C-%ED%95%98%EB%8A%94-%EC%9D%BC\" aria-label=\"dom에 연결될 때 하는 일 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>돔에 연결될 때 필요한 것들을 <code>connectedCallback()</code>에 적어보자. <code>&#x3C;custom-todos /></code>는 어떤 모양일까?<br>\n우선 각 할 일을 담을 목록이 필요하다. <code>&#x3C;ul /></code>을 간단한 템플릿으로 사용한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = &#39;&lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;&#39;;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>각 할 일 요소를 위한 구성은 이미 HMTL의 템플릿 요소로 있기 때문에 가져오기만 하면 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = &#39;&lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;&#39;;\n    this.item = document.getElementById(&#39;todo-item&#39;);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이벤트 핸들러도 연결한다. 이벤트 위임 방식으로 목록에 이벤트 핸들러를 할당한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,18\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = &#39;&lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;&#39;;\n    this.item = document.getElementById(&#39;todo-item&#39;);\n  \n    this.list = this.querySelector(&#39;ul&#39;);\n  \n    this.list.addEventListener(&#39;click&#39;, (e) =&gt; {\n        if (e.target.matches(&#39;button.destroy&#39;)) {\n          this.onDeleteButtonClick(e.target.dataset.index);\n        }\n    });\n  \n    this.list.addEventListener(&#39;change&#39;, (e) =&gt; {\n        if (e.target.matches(&#39;input.toggle&#39;)) {\n          this.onCheckboxClick(e.target.dataset.index);\n        }\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>마지막으로 상태에 따라 목록을 생성하고 갱신하는 <code>update()</code>를 호출한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...상동\n\n    this.update();\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>update()</code>는 새로운 목록을 채워주는 지난 챕터의 Todos 컴포넌트가 하던 역할을 그대로 하고 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  update() {\n    this.list.innerHTML = &#39;&#39;;\n\n    this.todos.map((todo, index) =&gt; {\n      const { text, completed } = todo;\n\n      const element = this.item.content.firstElementChild.cloneNode(true);\n\n      element.querySelector(&#39;label&#39;).textContent = text;\n\n      if (completed) {\n        element.classList.add(&#39;completed&#39;);\n        element.querySelector(&#39;input.toggle&#39;).checked = true;\n      }\n\n      element.querySelector(&#39;input.toggle&#39;).dataset.index = index;\n      element.querySelector(&#39;button.destroy&#39;).dataset.index = index;\n\n      return element\n    }).forEach((element) =&gt; {\n      this.list.appendChild(element)\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>update()</code>는 <code>this.todos</code>에 접근한다. 이 속성(property)은 사용자 정의 요소의 속성(attribute)으로도 할당되는 특징이 있다. 이 곳에 할 일 목록을 저장한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">&lt;custom-todos todos=&quot;[]&quot;&gt; ... &lt;custom-todos /&gt;</code>\n        </deckgo-highlight-code>\n<p><code>todos</code>접근을 위한 게터와 세터를 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"10,20\">\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  update() {\n    // ...\n  }\n\n  get todos() {\n    if (!this.hasAttribute(&#39;todos&#39;)) {\n      return [];\n    }\n\n    return JSON.parse(this.getAttribute(&#39;todos&#39;));\n  }\n\n  set todos(value) {\n    this.setAttribute(&#39;todos&#39;, JSON.stringify(value));\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"관찰-대상이-갱신되면-하는-일\" style=\"position:relative;\">관찰 대상이 갱신되면 하는 일<a href=\"#%EA%B4%80%EC%B0%B0-%EB%8C%80%EC%83%81%EC%9D%B4-%EA%B0%B1%EC%8B%A0%EB%90%98%EB%A9%B4-%ED%95%98%EB%8A%94-%EC%9D%BC\" aria-label=\"관찰 대상이 갱신되면 하는 일 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>속성이 바뀔 때마다 새로운 할 일 요소를 동적으로 생성하기 위해  <code>attributeChangedCallback()</code>을 사용한다. <code>update()</code>를 실행하는 이 함수는 <code>observedAttributes()</code>가 관찰하는 <code>todos</code>속성이 바뀔 때만 호출된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class Todos extends HTMLElement {\n  static get observedAttributes() {\n    return [&#39;todos&#39;];\n  }\n\n  attributeChangedCallback() {\n    if (!this.hasChildNodes()) return;\n\n    this.update();\n  }\n\n  // 생략\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"커스텀-이벤트는-옵저버-패턴의-구현\" style=\"position:relative;\">커스텀 이벤트는 옵저버 패턴의 구현?!<a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%8A%94-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4%EC%9D%98-%EA%B5%AC%ED%98%84\" aria-label=\"커스텀 이벤트는 옵저버 패턴의 구현 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>마지막으로 이벤트 핸들러를 선언한다. 이 곳에서는 이벤트가 발생하는 사실만을 알려주고 그 때 처리해야 하는 일은 다른 곳에서 결정하도록 하고 싶다면 어떻게 해야 할까? 커스텀 이벤트를 활용한 방법이 있다. 그 전에 먼저 이벤트 레지스트리를 등록한다. 구독하는 곳에서도 쉽게 접근할 수 있도록 컨트롤러에 선언한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,9\">\n          <code slot=\"code\">// index.js\n\nimport App from &#39;./components/App.js&#39;\nimport Todos from &#39;./components/Todos.js&#39;\n\nexport const events = {\n  deleteItem: &#39;deleteItem&#39;,\n  toggleCompleted: &#39;toggleCompleted&#39;,\n}\n\nwindow.customElements.define(&#39;custom-app&#39;, App);\nwindow.customElements.define(&#39;custom-todos&#39;, Todos);</code>\n        </deckgo-highlight-code>\n<p>이벤트 핸들러는 아래와 같다. 단순히 인덱스를 포함하는 커스텀 이벤트 객체를 생성하고 이벤트를 디스패치한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"20,41\">\n          <code slot=\"code\">import { events } from &quot;../index.js&quot;;\n\nexport default class Todos extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  update() {\n    // ...\n  }\n\n  get todos() { \n    // ... \n  }\n\n  set todos(value) { \n    // ...\n  }\n\n  onDeleteButtonClick(index) {\n    const event = new CustomEvent(\n      events.deleteItem,\n      {\n        detail: {\n          index\n        }\n      }\n    )\n\n    this.dispatchEvent(event)\n  }\n\n  onCheckboxClick(index) {\n    const event = new CustomEvent(\n      events.toggleCompleted,\n      {\n        detail: {\n          index\n        }\n      }\n    )\n\n    this.dispatchEvent(event)\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이 곳에서는 이벤트 발생에 따라 ‘어떤 일을 해야 할지’에 관해 관심을 두지 않아도 된다. 한편 외부에서는 ‘이벤트가 발생하는 경로’에 관한 사실을 몰라도 된다. 자연스럽게 관심사를 분리하고 각자의 역할을 수행한다. 경우에 따라서 중복 코드도 줄일 수 있다. 사실 커스텀 이벤트를 처음 접할 때 그 효용에 관해서 의심을 가졌는데, 챕터의 예제를 보고 괜히 나온 API가 아니라는 느낌을 받았다. 커스텀 이벤트가 옵저버 패턴의 구현체라고 소개하는 글을 보기도 했다. 관심있으면 아래 링크를 참고하자.</p>\n<p><a href=\"https://stackoverflow.com/questions/57036994/how-are-custom-events-in-javascript-different-from-simply-calling-regular-functi\">How are custom events in JavaScript different from simply calling regular functions?</a></p>\n<p>앱 전체를 구성하는 <code>&#x3C;custom-app /></code>은 상태를 선언하고 todo-app 템플릿을 사용한다. 책에서는 <code>constructor()</code>에서 미리 상태와 템플릿을 선언하고 있지만, DOM에 처음 연결될 때 초기화해도 무리가 없을 것 같아 <code>connectedCallback()</code>이 그 책임을 갖도록 했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    this.state = {\n      todos: [],\n      filter: &#39;All&#39;\n    }\n\n    this.template = document.getElementById(&#39;todo-app&#39;);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>렌더링도 해야 한다. 특별한 내용이 있다면 세 개의 이벤트 중 두 개는 레지스트리에 등록된 커스텀 이벤트라는 사실이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"10,28\">\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    this.state = {\n      todos: [],\n      filter: &#39;All&#39;\n    }\n\n    this.template = document.getElementById(&#39;todo-app&#39;);\n\n    window.requestAnimationFrame(() =&gt; {\n      const content = this.template.content.firstElementChild.cloneNode(true);\n\n      this.appendChild(content);\n\n      this.querySelector(&#39;.new-todo&#39;).addEventListener(&#39;keypress&#39;, (e) =&gt; {\n        if (e.key === &#39;Enter&#39;) {\n          this.addItem(e.target.value);\n\n          e.target.value = &#39;&#39;;\n        }\n      })\n\n      this.list = this.querySelector(&#39;custom-todos&#39;);\n      this.list.addEventListener(events.deleteItem, (e) =&gt; this.deleteItem(e.detail.index));\n      this.list.addEventListener(events.toggleCompleted, (e) =&gt; this.toggleCompleted(e.detail.index));\n\n      this.sync();\n    })\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이벤트가 발생하면 어떤 일을 할지 이곳에서 정한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,30\">\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  addItem(text) {\n    const item = { text, completed: false };\n\n    this.state.todos.push(item);\n\n    this.sync();\n  }\n\n  deleteItem(index) {\n    this.state.todos.splice(index, 1);\n\n    this.sync();\n  }\n\n  toggleCompleted(index) {\n    const { todos } = this.state;\n\n    todos.splice(index, 1, {\n      text: todos[index].text,\n      completed: !todos[index].completed\n    });\n\n    this.state.todos = todos;\n    this.sync();\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>모든 메서드에서 호출하고 있는 <code>sync()</code>는 상태에 따라 <code>&#x3C;custom-todos /></code>의 속성을 갱신한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,10\">\n          <code slot=\"code\">export default class App extends HTMLElement {\n  connectedCallback() {\n    // ...\n  }\n\n  sync() {\n    const { todos } = this.state;\n\n    this.list.todos = todos;\n  }\n\n  addItem(text) {\n    // ...\n  }\n\n  deleteItem(index) {\n    // ...\n  }\n\n  toggleCompleted(index) {\n    // ...\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"검증하기\" style=\"position:relative;\">검증하기<a href=\"#%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0\" aria-label=\"검증하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이제 할 일 추가, 삭제, 체크 그리고 체크의 해제 모두 잘 동작한다.</p>\n<p><img src=\"/845b1ca2a307ff1a3d48d7f70d092358/todos.gif\" alt=\"todos\"></p>\n<p>유사한 내용이라 자세히 다루진 않겠지만 todo-footer 템플릿을 사용하는 <code>&#x3C;custom-footer /></code>도 추가했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"8,9 14\">\n          <code slot=\"code\">import App from &#39;./components/App.js&#39;\nimport Footer from &#39;./components/Footer.js&#39;;\nimport Todos from &#39;./components/Todos.js&#39;\n\nexport const events = {\n  deleteItem: &#39;deleteItem&#39;,\n  toggleCompleted: &#39;toggleCompleted&#39;,\n  filterItem: &#39;filterItem&#39;,\n  clearCompleted: &#39;clearCompleted&#39;\n}\n\nwindow.customElements.define(&#39;custom-app&#39;, App);\nwindow.customElements.define(&#39;custom-todos&#39;, Todos);\nwindow.customElements.define(&#39;custom-footer&#39;, Footer);</code>\n        </deckgo-highlight-code>\n<p>이제 필터도 동작한다.</p>\n<p><img src=\"/d6de660de968d5500894ab1285f8700d/with_filter.gif\" alt=\"withFilter\"></p>\n<h2 id=\"관련-라이브러리\" style=\"position:relative;\">관련 라이브러리<a href=\"#%EA%B4%80%EB%A0%A8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\" aria-label=\"관련 라이브러리 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements\">MDN</a>에서 웹 컴포넌트의 추상화 레벨을 높인 여러 라이브러리를 소개하고 있는데 관심있다면 한 번 둘러보는 것을 추천한다. 나는 <a href=\"https://github.com/devpunks/snuggsi\">snuggsi</a>의 맛만 살짝 봤는데 괜찮은 경험이었다.</p>\n<ul>\n<li><a href=\"https://www.fast.design/docs/fast-element/getting-started/\">FASTElement</a></li>\n<li><a href=\"https://github.com/devpunks/snuggsi\">snuggsi</a></li>\n<li><a href=\"https://x-tag.github.io/\">X-Tag</a></li>\n<li><a href=\"https://slimjs.com/\">Slim.js</a></li>\n<li><a href=\"https://lit.dev/\">Lit</a></li>\n<li><a href=\"https://www.htmlelements.com/\">Smart</a></li>\n<li><a href=\"https://stenciljs.com/\">Stencil</a></li>\n<li><a href=\"https://github.com/WebReflection/hyperHTML-Element\">hyperHTML-Element</a></li>\n<li><a href=\"https://www.dataformsjs.com/\">DataFormsJS</a></li>\n<li><a href=\"https://tmorin.github.io/ceb/\">Custom-Element-Builder</a>.</li>\n</ul>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/4장_웹_컴포넌트","title":"4장 웹 컴포넌트"},"frontmatter":{"created":"2023-02-19","updated":"2023-08-22 00:38:57 +0900"}}},{"node":{"id":"5471f45f-70a8-5db2-949b-fd9669116b02","html":"<h2 id=\"이벤트-라이프사이클\" style=\"position:relative;\">이벤트 라이프사이클<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4\" aria-label=\"이벤트 라이프사이클 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Event\">Event</a> 인터페이스는 DOM 내에 위치한 이벤트로 계층 구조를 이룬다. 그 종류에 따라 이벤트 인터페이스를 상속하는 좀 더 구체적인 이벤트 인터페이스로 구현될 수 있다.</p>\n<p>이벤트 라이프 사이클은 3단계로 구성된다.</p>\n<ol>\n<li>캡쳐 단계: 이벤트가 html부터 목표 요소로 이동한다.</li>\n<li>목표 단계: 이벤트가 목표 요소에 도달한다.</li>\n<li>버블 단계: 이벤트가 목표 요소로부터 html로 이동한다.</li>\n</ol>\n<p>부모와 자식 요소에 이벤트 핸들러가 모두 연결되어 있다면, 자식 요소에서 이벤트가 발생할 때 부모 요소의 이벤트 핸들러도 실행된다. 이를 이벤트 버블링이라 한다. 기본적으로 발생하는 이 현상을 막기 위해서는 <code>stopPropagation()</code> 메서드를 사용해야 한다.</p>\n<p>부모와 자식의 이벤트 핸들러 중 무엇이 먼저 실행되는지는 <code>useCapture</code> 옵션이 결정한다. 만약 <code>useCapture</code>가 <code>false</code>라면 버블링 단계에서 이벤트 핸들러를 실행한다. 즉 자식의 이벤트 핸들러부터 실행한다. 반면, <code>useCapture</code>가 <code>true</code>인 경우 캡쳐 단계에서 이벤트 핸들러를 실행하기 때문에 부모의 이벤트 핸들러부터 실행한다.</p>\n<h2 id=\"이벤트-핸들러-연결하기\" style=\"position:relative;\">이벤트 핸들러 연결하기<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"이벤트 핸들러 연결하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"on-속성으로-이벤트-핸들러-연결\" style=\"position:relative;\">On* 속성으로 이벤트 핸들러 연결<a href=\"#on-%EC%86%8D%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%97%B0%EA%B2%B0\" aria-label=\"on 속성으로 이벤트 핸들러 연결 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>쉽고 지저분한 방법, 하나의 DOM 요소에 하나의 핸들러만 할당할 수 없다.</p>\n<h3 id=\"addeventlistener로-이벤트-핸들러-연결\" style=\"position:relative;\">addEventListener로 이벤트 핸들러 연결<a href=\"#addeventlistener%EB%A1%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%97%B0%EA%B2%B0\" aria-label=\"addeventlistener로 이벤트 핸들러 연결 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\">addEventListener()</a>로 하나의 DOM 요소에 여러 이벤트 핸들러를 연결할 수 있다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\">removeEventListener()</a>로 이벤트 핸들러를 제거하여 메모리 누수를 방지할 수도 있다.</p>\n<h2 id=\"커스텀-이벤트\" style=\"position:relative;\">커스텀 이벤트<a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8\" aria-label=\"커스텀 이벤트 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/CustomEvent/CustomEvent\">Custom Event</a>를 만들 수도 있다.</p>\n<p>아래 핸들러는 인풋 값의 길이가 5를 넘어가면 커스텀 이벤트를 생성 및 실행한다. 생성자의 첫 번째 인자에는 이벤트 이름, 두 번째 인자로는 <code>detail</code> 속성을 포함하는 옵션을 전달할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const handleChangeInput = (e) =&gt; {\n  const { length } = e.target.value;\n\n  if (length &lt; 5) {\n    console.log(&#39;default event&#39;);\n  } else {\n    input.dispatchEvent(new CustomEvent(&#39;customEvent&#39;, {\n      detail: { time: new Date().getTime() }\n    }))\n  }\n}\n\ninput.addEventListener(&#39;input&#39;, handleChangeInput);\ninput.addEventListener(&#39;customEvent&#39;, (e) =&gt; log(e.target.value, e.detail.time))</code>\n        </deckgo-highlight-code>\n<h2 id=\"기존-투두리스트-애플리케이션의-문제점\" style=\"position:relative;\">기존 투두리스트 애플리케이션의 문제점<a href=\"#%EA%B8%B0%EC%A1%B4-%ED%88%AC%EB%91%90%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"기존 투두리스트 애플리케이션의 문제점 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지난 챕터에서 만들었던 애플리케이션은 할 일 요소를 문자열로 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,18\">\n          <code slot=\"code\">const Todos = todo =&gt; {\n  const {\n    text,\n    completed\n  } = todo\n\n  return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;input class=&quot;edit&quot; value=&quot;${text}&quot;&gt;\n      &lt;/li&gt;`\n}</code>\n        </deckgo-highlight-code>\n<p>그러나 문자열에는 <code>addEventListener()</code>로 이벤트 핸들러를 추가할 수 없다. 다른 방법을 알아보자.</p>\n<h2 id=\"createelement-api\" style=\"position:relative;\">createElement API<a href=\"#createelement-api\" aria-label=\"createelement api permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// source: MDN\n\nfunction addElement () {\n  // create a new div element\n  var newDiv = document.createElement(&quot;div&quot;);\n  // and give it some content\n  var newContent = document.createTextNode(&quot;환영합니다!&quot;);\n  // add the text node to the newly created div\n  newDiv.appendChild(newContent);\n\n  // add the newly created element and its content into the DOM\n  var currentDiv = document.getElementById(&quot;div1&quot;);\n  document.body.insertBefore(newDiv, currentDiv);\n}</code>\n        </deckgo-highlight-code>\n<p><code>createElement API</code>를 사용하여 새로운 DOM 노드를 생성할 수 있다. 이 방식은 가독성이 그리 좋지 않고 유지보수가 어렵다는 단점이 있다.</p>\n<h2 id=\"template-element\" style=\"position:relative;\">Template element<a href=\"#template-element\" aria-label=\"template element permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>&#x3C;template /></code>요소는 동적으로 DOM 노드를 생성하는 수단이다. 이 요소는 페이지를 불러오는 순간에는 렌더링되지 않는다. 대신 자바스크립트가 <code>&#x3C;template /></code>기반의 돔 노드를 생성할 수 있다. 컴포넌트 함수에서 문자열로 만들던 내용을 지우고 <code>&#x3C;template /></code> 을 작성한다.</p>\n<p>두 개의 템플릿을 추가했다.</p>\n<ol>\n<li>할 일 요소 구성을 담는 todo-item 템플릿</li>\n<li>전체 앱의 구성을 담는 todo-app 템플릿</li>\n</ol>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,36\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;li&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;&lt;/label&gt;\n          &lt;button class=&quot;destroy&quot;&gt;삭제&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/li&gt; \n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;section class=&quot;todoapp&quot;&gt;\n        &lt;header&gt;\n          &lt;h1&gt;todos&lt;/h1&gt;\n          &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n        &lt;/header&gt;\n        &lt;section class=&quot;main&quot;&gt;\n          &lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot;&gt;\n          &lt;label for=&quot;toggle-all&quot;&gt;전체 완료&lt;/label&gt; \n          &lt;ul data-component=&quot;todos&quot;&gt;&lt;/ul&gt;\n        &lt;/section&gt;\n        &lt;footer class=&quot;footer&quot;&gt;\n          &lt;span data-component=&quot;counter&quot;&gt;&lt;/span&gt;\n          &lt;ul data-component=&quot;filters&quot;&gt;\n            &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;미완료&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n          &lt;/ul&gt;\n          &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n        &lt;/footer&gt;\n      &lt;/section&gt;\n    &lt;/template&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p><code>Todo</code> 컴포넌트는 더 이상 문자열을 리턴하지 않는다. <code>state.todos</code>를 순회하며 새로운 할 일 목록을 구성하고 반환한다. <code>createNewTodo()</code>는 각각의 할 일을 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"6,8\">\n          <code slot=\"code\">const Todos = (targetElement, { todos }) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = &#39;&#39;;\n\n  todos\n    .map((todo, index) =&gt; createNewTodo(todo, index))\n    .forEach((todo) =&gt; newTodoList.appendChild(todo));\n\n  return newTodoList\n}</code>\n        </deckgo-highlight-code>\n<p><code>createNewTodo()</code>는 할 일의 내용과 속성을 채워준다. <code>todoElement()</code>는 DOM 요소를 생성한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,14\">\n          <code slot=\"code\">const createNewTodo = (todo, index) =&gt; {\n  const {\n    text,\n    completed\n  } = todo;\n\n  const element = todoElement();\n\n  element.querySelector(&#39;label&#39;).textContent = text;\n\n  if (completed) {\n    element.classList.add(&#39;completed&#39;);\n    element.querySelector(&#39;input.toggle&#39;).checked = true;\n  }\n\n  return element;\n}</code>\n        </deckgo-highlight-code>\n<p><code>todoElement()</code>는 템플릿을 복제한 요소를 반환한다. 이처럼 템플릿을 재사용하면서 DOM을 동적으로 생성할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5\">\n          <code slot=\"code\">let template;\n\nconst todoElement = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-item&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n};</code>\n        </deckgo-highlight-code>\n<p>App 컴포넌트는 전체 구성을 담는 todo-app 템플릿을 복제하여 DOM을 생성한다.</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5 16\">\n          <code slot=\"code\">let template;\n\nconst getTemplate = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-app&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n}\n\nexport default (targetElement) =&gt; {\n  const newApp = targetElement.cloneNode(true);\n\n  newApp.innerHTML = &#39;&#39;;\n\n  newApp.appendChild(getTemplate());\n\n  return newApp;\n}</code>\n        </deckgo-highlight-code>\n<p>App 컴포넌트도 다른 컴포넌트와 마찬가지로 레지스트리에 등록한다.</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\n\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\naddComponent(&#39;filters&#39;, Filters);</code>\n        </deckgo-highlight-code>\n<p>뷰에도 App 컴포넌트가 들어갈 자리가 필요하다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12,14\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;template id=&quot;todo-item&quot;&gt;\n      &lt;!-- 생략 --&gt;\n    &lt;/template&gt;\n    &lt;template id=&quot;todo-app&quot;&gt;\n      &lt;!-- 생략 --&gt;\n    &lt;/template&gt;\n    &lt;div id=&quot;root&quot;&gt;\n      &lt;div data-component=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>렌더링 함수는 <code>.todoapp</code>이 아닌 <code>root div</code>에 접근한다.</p>\n<deckgo-highlight-code language=\"tsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state);\n\n    renderDiff(document.body, app, newApp);\n  })\n}</code>\n        </deckgo-highlight-code>\n<p>이전과 같이 할 일 목록을 보여준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b810508f1bf24ac8cee2256a4889c006/6bbf7/todos.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 96.55172413793103%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAABlUlEQVR42q2U226CUBBF+f8v8dnGF1NN1MRL1UYwxFsUkQipUCKCCHLZnTnWpm8W6SQDgYTFnpk9R9put+j3+yJXqxXiOC6VEgNrtRrq9ToGgwE48jzHsyHxx1mWIU1Tcee/JEkinu/vCgE/DgesNxuYpgnbtgXkcrkgDEORQRAUgkqn00nAOp0OxuMxhsMhPM8TKu99KQRkRdfrFY7jCIWu6wrY0z3kCytgKCtTFAXL5RLr9RoHaoeqqtjtdsWAURTB/XThHT2MRiNMJhPMZjMsFgv0ej1Mp1MYhiHKf+QCAeSyg9CH5ZhQZEX4UdM0zOdzAWJ4s9mE7/t/A+ZJDv2g4XXxgrf+UJS5oclz6cbOQKvVwn6/LzYUTu4lJw+FVXBymefz+afch0DTsiDLMrrdLnhr/mVTbmaOyMhXlGD9tk1M1vBpnzPyYvatsgQwTSMagIdqNUWjwf3MyylkoKoeUakkZJm0XMm3AeTksYyGkpHJyzVRsmjK7VabtuOdDoeesE8pILtf13XaW5vMa5U6GDi+AKPjxYkuIYVHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"todos.png\"\n        title=\"\"\n        src=\"/static/b810508f1bf24ac8cee2256a4889c006/31198/todos.png\"\n        srcset=\"/static/b810508f1bf24ac8cee2256a4889c006/fe9c7/todos.png 174w,\n/static/b810508f1bf24ac8cee2256a4889c006/39e45/todos.png 347w,\n/static/b810508f1bf24ac8cee2256a4889c006/31198/todos.png 694w,\n/static/b810508f1bf24ac8cee2256a4889c006/6bbf7/todos.png 716w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>최종 프로젝트 구성은 아래와 같다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── App.js\n│   ├── Counter.js\n│   ├── Filters.js\n│   └── Todos.js\n├── index.html\n├── index.js\n├── registry.js\n└── renderDiff.js</code>\n        </deckgo-highlight-code>\n<h2 id=\"이벤트-추가하기\" style=\"position:relative;\">이벤트 추가하기<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\" aria-label=\"이벤트 추가하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금은 버튼만 존재할 뿐 할 일 추가와 같은 이벤트는 발생하지 않는다. 이벤트 추가를 위해 이벤트 레지스트리를 생성하고 등록한다. 이제 모든 컴포넌트 함수는 세 번째 파라미터로 이벤트 레지스트리 <code>events</code>를 받는다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"16,28 34\">\n          <code slot=\"code\">// index.js\n\n// set state\nconst state = {\n  todos: fetchTodos(),\n  filter: &#39;All&#39;\n}\n\n// 컴포넌트 레지스트리 등록\naddComponent(&#39;app&#39;, App);\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\naddComponent(&#39;filters&#39;, Filters);\n\n// 이벤트 레지스트리 등록\nconst events = {\n  deleteItem: (index) =&gt; {\n    state.todos.splice(index, 1);\n    init()\n  },\n  addItem: (text) =&gt; {\n    state.todos.push({\n      text,\n      completed: false\n    })\n    init()\n  }\n}\n\nconst init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;#root&#39;);\n\n    const newApp = renderRoot(app, state, events);\n\n    renderDiff(document.body, app, newApp);\n  })\n}\n\ninit();</code>\n        </deckgo-highlight-code>\n<p>이벤트 레지스트리에서 필요한 이벤트 함수를 꺼내 이벤트 핸들러로 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"11,19 28\">\n          <code slot=\"code\">let template;\n\nconst getTemplate = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-app&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n}\n\nconst addKeypressEventListener = (targetElement, events) =&gt; {\n  targetElement.querySelector(&#39;.new-todo&#39;).addEventListener(&#39;keypress&#39;, (e) =&gt; {\n    if (e.key === &#39;Enter&#39;) {\n      events.addItem(e.target.value);\n\n      e.target.value = &#39;&#39;\n    }\n  })\n}\n\nexport default (targetElement, _, events) =&gt; {\n  const newApp = targetElement.cloneNode(true);\n\n  newApp.innerHTML = &#39;&#39;;\n\n  newApp.appendChild(getTemplate());\n\n  addKeypressEventListener(newApp, events);\n\n  return newApp;\n}</code>\n        </deckgo-highlight-code>\n<p>Todo 컴포넌트에서도 할 일 삭제 이벤트 핸들러를 등록한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"26 28\">\n          <code slot=\"code\">let template;\n\nconst todoElement = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-item&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n};\n\nconst createNewTodo = (todo, index, events) =&gt; {\n  const {\n    text,\n    completed\n  } = todo;\n\n  const element = todoElement();\n\n  element.querySelector(&#39;label&#39;).textContent = text;\n\n  if (completed) {\n    element.classList.add(&#39;completed&#39;);\n    element.querySelector(&#39;input.toggle&#39;).checked = true;\n  }\n\n  const handler = () =&gt; events.deleteItem(index);\n\n  element.querySelector(&#39;button.destroy&#39;).addEventListener(&#39;click&#39;, handler);\n\n  return element;\n}\n\nconst Todos = (targetElement, { todos }, events) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = &#39;&#39;;\n\n  todos\n    .map((todo, index) =&gt; createNewTodo(todo, index, events))\n    .forEach((todo) =&gt; newTodoList.appendChild(todo));\n\n  return newTodoList\n}\n\nexport default Todos;</code>\n        </deckgo-highlight-code>\n<h2 id=\"이벤트-위임하기\" style=\"position:relative;\">이벤트 위임하기<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84%ED%95%98%EA%B8%B0\" aria-label=\"이벤트 위임하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Todo 컴포넌트는 각 할 일 요소에 이벤트 핸들러를 연결한다. 만약 이벤트 위임을 활용하면 여러 요소를 담는 목록에 하나의 이벤트 핸들러만 할당하여 모든 이벤트를 처리할 수 있다.</p>\n<br>\n<hr>\n<p><a href=\"https://ko.javascript.info/event-delegation\">출처: https://ko.javascript.info/event-delegation</a></p>\n<p>이벤트 위임이란?</p>\n<blockquote>\n<p>이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있습니다.</p>\n</blockquote>\n<p>이벤트 위임의 장점</p>\n<ul>\n<li>많은 핸들러를 할당하지 않아도 되기 때문에 초기화가 단순해지고 메모리가 절약됩니다.</li>\n<li>요소를 추가하거나 제거할 때 해당 요소에 할당된 핸들러를 추가하거나 제거할 필요가 없기 때문에 코드가 짧아집니다.</li>\n<li><code>innerHTML</code>이나 유사한 기능을 하는 스크립트로 요소 덩어리를 더하거나 뺄 수 있기 때문에 DOM 수정이 쉬워집니다.</li>\n</ul>\n<p>이벤트 위임의 단점</p>\n<ul>\n<li>이벤트 위임을 사용하려면 이벤트가 반드시 버블링 되어야 합니다. 하지만 몇몇 이벤트는 버블링 되지 않습니다. 그리고 낮은 레벨에 할당한 핸들러엔 <code>event.stopPropagation()</code>를 쓸 수 없습니다.</li>\n<li>컨테이너 수준에 할당된 핸들러가 응답할 필요가 있는 이벤트이든 아니든 상관없이 모든 하위 컨테이너에서 발생하는 이벤트에 응답해야 하므로 CPU 작업 부하가 늘어날 수 있습니다. 그런데 이런 부하는 무시할만한 수준이므로 실제로는 잘 고려하지 않습니다.</li>\n</ul>\n<hr>\n<br>\n<p>먼저 각 버튼에 인덱스를 부여하고 할 일 목록에 이벤트 리스너를 등록한다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/matches\">Element.matches()</a> 메서드를 통해 삭제 버튼임을 식별하고 필요한 일을 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"26 40,44\">\n          <code slot=\"code\">let template;\n\nconst todoElement = () =&gt; {\n  if (!template) {\n    template = document.getElementById(&#39;todo-item&#39;);\n  }\n\n  return template.content.firstElementChild.cloneNode(true);\n};\n\nconst createNewTodo = (todo, index, events) =&gt; {\n  const {\n    text,\n    completed\n  } = todo;\n\n  const element = todoElement();\n\n  element.querySelector(&#39;label&#39;).textContent = text;\n\n  if (completed) {\n    element.classList.add(&#39;completed&#39;);\n    element.querySelector(&#39;input.toggle&#39;).checked = true;\n  }\n\n  element.querySelector(&#39;button.destroy&#39;).dataset.index = index;\n\n  return element;\n}\n\nconst Todos = (targetElement, { todos }, events) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = &#39;&#39;;\n\n  todos\n    .map((todo, index) =&gt; createNewTodo(todo, index, events))\n    .forEach((todo) =&gt; newTodoList.appendChild(todo));\n\n  newTodoList.addEventListener(&#39;click&#39;, (e) =&gt; {\n    if (e.target.matches(&#39;button.destroy&#39;)) {\n      events.deleteItem(e.target.dataset.index);\n    }\n  })\n\n  return newTodoList\n}\n\nexport default Todos;</code>\n        </deckgo-highlight-code>\n<p>리스트가 아주 길다면 이 같은 이벤트 위임 방식은 성능과 메모리 사용성을 개선시킬 수 있다.</p>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/3장_DOM_이벤트_관리","title":"3장 DOM 이벤트 관리"},"frontmatter":{"created":"2023-02-12","updated":"2023-08-22 00:37:49 +0900"}}},{"node":{"id":"b16b7a9b-930c-5824-bf26-fe25150cc6e9","html":"<h2 id=\"문서-객체-모델dom\" style=\"position:relative;\">문서 객체 모델(DOM)<a href=\"#%EB%AC%B8%EC%84%9C-%EA%B0%9D%EC%B2%B4-%EB%AA%A8%EB%8D%B8dom\" aria-label=\"문서 객체 모델dom permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction\">DOM</a>은 웹 어플리케이션의 조작 방법을 제공하는 API다. 웹 페이지는 HTML로 정의된 트리 구조를 갖는다. DOM은 이를 관리하는 방법이다.</p>\n<h2 id=\"컴포넌트-기반-애플리케이션\" style=\"position:relative;\">컴포넌트 기반 애플리케이션<a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-label=\"컴포넌트 기반 애플리케이션 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"렌더링-함수\" style=\"position:relative;\">렌더링 함수<a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%95%A8%EC%88%98\" aria-label=\"렌더링 함수 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>순수 함수로 렌더링한다는 것은 DOM 요소가 애플리케이션의 상태에만 의존한다는 것을 의미한다.</p>\n<blockquote>\n<p>view = f(state)</p>\n</blockquote>\n<br >\n<p>투두리스트 앱을 만들었다. 책과 같이 <a href=\"https://todomvc.com/\">ToDoMVC</a>를 사용하지는 않고 좀 더 작은 뷰를 만들었다.<br>\n접근이 필요한 요소에는 클래스 속성을 부여한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12 14 16\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;section class=&quot;todoapp&quot;&gt;\n      &lt;header&gt;\n        &lt;h1&gt;todos&lt;/h1&gt;\n        &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n      &lt;/header&gt;\n      &lt;section class=&quot;main&quot;&gt;\n        &lt;ul class=&quot;todo-list&quot;&gt;&lt;/ul&gt;\n      &lt;/section&gt;\n      &lt;footer class=&quot;footer&quot;&gt;\n        &lt;span class=&quot;todo-count&quot;&gt;&lt;/span&gt;\n        &lt;ul class=&quot;filters&quot;&gt;\n          &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;미완료&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n      &lt;/footer&gt;\n    &lt;/section&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p>저자는 <a href=\"https://github.com/faker-js/faker\">faker-js</a>를 사용하지만 간단한 예제를 위해 서버에서 받는 데이터를 단순 가정했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const mockTodos = [\n  {\n    id: &#39;1&#39;,\n    text: &#39;빨래 널기&#39;,\n    completed: false,\n  },\n  {\n    id: &#39;2&#39;,\n    text: &#39;분리수거 하기&#39;,\n    completed: false,\n  },\n  {\n    id: &#39;3&#39;,\n    text: &#39;헬스장 가기&#39;,\n    completed: true,\n  }\n]</code>\n        </deckgo-highlight-code>\n<p><code>fetchTodos()</code>는 할 일 목록을 받아오는 API 호출 함수라고 하자.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const fetchTodos = () =&gt; mockTodos;\n\nconst state = {\n  todos: fetchTodos(),\n  filter: &#39;All&#39;\n}</code>\n        </deckgo-highlight-code>\n<p>렌더링 함수는 <code>requestAnimationFrame()</code>를 사용한다. 후술할 <code>appView()</code>를 통해 기존 뷰를 새로운 뷰로 대체한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const app = document.querySelector(&#39;.todoapp&#39;);\n\nwindow.requestAnimationFrame(() =&gt; {\n  const newApp = appView(app, state)\n  app.replaceWith(newApp)\n})</code>\n        </deckgo-highlight-code>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceWith\">replaceWith()</a>: 이 메서드는 특정 요소를 새로운 요소로 대체한다.</li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame\">requestAnimationFrame()</a>: <code>requestAnimationFrame()</code>는 다음 리페인트가 이벤트 루프에 스케쥴링되기 직전에 실행될 콜백을 브라우저에게 알린다. 이 메서드를 사용하면 메인 스레드를 차단하지 않고 브라우저 렌더링 성능에 최적화된 함수 호출이 가능하다.</li>\n</ul>\n<p><code>appView()</code>는 갱신된 요소를 반환한다. <code>targetElement</code>의 <code>list</code>, <code>counter</code>, <code>filters</code>를 갱신하고 모든 내용을 대체한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const appView = (targetElement, { todos, filter: currentFilter }) =&gt; {\n  const element = targetElement.cloneNode(true)\n\n  // get elements\n  const list = element.querySelector(&#39;.todo-list&#39;)\n  const counter = element.querySelector(&#39;.todo-count&#39;)\n  const filters = element.querySelector(&#39;.filters&#39;)\n\n  // new list\n  const newList = list.cloneNode(true);\n\n  newList.innerHTML = todos.map(({ text, completed }) =&gt; {\n    return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n    `\n  }).join(&#39;&#39;);\n\n  // new counter\n  const newCounter = counter.cloneNode(true);\n\n  const howManyLeft = todos.filter(todo =&gt; !todo.completed).length;\n\n  newCounter.textContent = `${howManyLeft}개 남음`;\n\n  // new filters\n  const newfilters = filters.cloneNode(true);\n  const filterList = newfilters.querySelectorAll(&#39;li a&#39;);\n\n  [...filterList].forEach(filter =&gt; {\n    if (filter.textContent === currentFilter) {\n      filter.classList.add(&#39;selected&#39;);\n    } else {\n      filter.classList.remove(&#39;selected&#39;);\n    }\n  });\n\n  // replace elements\n  list.replaceWith(newList);\n  counter.replaceWith(newCounter);\n  filters.replaceWith(newfilters);\n\n  return element\n}</code>\n        </deckgo-highlight-code>\n<p>브라우저에서 상태에 맞게 그려진 할 일 목록을 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cead9e3623d6cc5736da98f421fab587/f32b7/todos-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.172413793103445%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAyUlEQVR42q3QzQ6CMBAEYN7/pUw4ysULkaCVIgVsoQUElJ/QUYgxMZ4sbrI9fp1Zy/d92LYNIQSmaULf9xiGwXgtpRQYY2jbFvNorZc1nQXM8xx1Xb9/6brOHJxrzojgGTzPA6UUTdMYp7T0pFG1JTyyh7N14LouCCEfJ/gJHIcRXF1A2AE85ciyDFVVmVeWUiIMQ8hcGiX6Ap8ERFLguEvR38fVqDU/PCqw21Bc1e0FrkhYlAVCGuF8SlbXXcA4jhEEAeKE/QV8ADOyX7Wx+iBZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"todos-1\"\n        title=\"\"\n        src=\"/static/cead9e3623d6cc5736da98f421fab587/31198/todos-1.png\"\n        srcset=\"/static/cead9e3623d6cc5736da98f421fab587/fe9c7/todos-1.png 174w,\n/static/cead9e3623d6cc5736da98f421fab587/39e45/todos-1.png 347w,\n/static/cead9e3623d6cc5736da98f421fab587/31198/todos-1.png 694w,\n/static/cead9e3623d6cc5736da98f421fab587/ee9b6/todos-1.png 1041w,\n/static/cead9e3623d6cc5736da98f421fab587/f32b7/todos-1.png 1136w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"중간-리팩토링\" style=\"position:relative;\">중간 리팩토링<a href=\"#%EC%A4%91%EA%B0%84-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81\" aria-label=\"중간 리팩토링 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>기능은 아직이지만 기본적인 모양은 완성했다. 하지만 코드에서 리팩토링 신호를 포착할 수 있다. 일단 뷰 함수가 너무 거대하기 때문에 읽기 어렵다. 갱신할 뷰가 추가되면 코드가 더 복잡해지는 건 분명해 보인다. 게다가 개별 요소(<code>todos</code>, <code>counter</code>, <code>filters</code>)를 새로운 것으로 대체하는 작업, 즉 내부 로직은 다르지만 같은 유형의 작업을 수행하고 있다. 하나의 책임을 갖는 함수들로 분리하면 좋을 것 같다.</p>\n<p>예를 들어 뷰 함수는 <code>targetElement</code>와 <code>state</code>를 받아 새로운 요소를 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const viewFunction = (targetElement, state) =&gt; newElement;</code>\n        </deckgo-highlight-code>\n<p>아래 모양의 뷰 함수들로 분리했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const counterView = (targetElement, { todos }) =&gt; {\n  const newCounter = targetElement.cloneNode(true);\n\n  const howManyLeft = todos.filter(todo =&gt; !todo.completed).length;\n\n  newCounter.textContent = `${howManyLeft}개 남음`;\n\n  return newCounter;\n}\n\nconst filterView = (targetElement, { filter: currentFilter }) =&gt; {\n  const newFilters = targetElement.cloneNode(true);\n  const filterList = newCounter.querySelectorAll(&#39;li a&#39;);\n\n  [...filterList].forEach(filter =&gt; {\n    if (filter.textContent === currentFilter) {\n      filter.classList.add(&#39;selected&#39;);\n    } else {\n      filter.classList.remove(&#39;selected&#39;);\n    }\n  })\n\n  return newFilters;\n}\n\nconst todosView = (targetElement, { todos }) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = todos.map(({ text, completed }) =&gt; {\n    return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n    `\n  }).join(&#39;&#39;);\n\n  return newTodoList\n}\n\nconst appView = (targetElement, state) =&gt; {\n  const element = targetElement.cloneNode(true)\n\n  const list = element.querySelector(&#39;.todo-list&#39;)\n  const counter = element.querySelector(&#39;.todo-count&#39;)\n  const filters = element.querySelector(&#39;.filters&#39;)\n\n  list.replaceWith(todosView(list, state))\n  counter.replaceWith(counterView(counter, state))\n  filters.replaceWith(filterView(filters, state))\n\n  return element\n}</code>\n        </deckgo-highlight-code>\n<p>소스 코드의 디렉토리, 파일만 잘 구분해도 설계는 확연하게 좋아질 수 있다. 관심사에 따라 디렉토리도 나눈다면 더 이해하기 쉬운 구조가 된다. 지금까지 작성한 코드가 컴포넌트 라이브러리의 초안이다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">root\n├── views\n│   ├── counterView.js\n│   ├── FilterView.js\n│   └── TodosView.js\n│   └── Appview.js\n├── index.html\n└── index.js</code>\n        </deckgo-highlight-code>\n<h3 id=\"컴포넌트-함수\" style=\"position:relative;\">컴포넌트 함수<a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%95%A8%EC%88%98\" aria-label=\"컴포넌트 함수 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>컴포넌트 기반의 애플리케이션을 작성하려면 컴포넌트 간에 선언적인 방식으로 상호작용 해야 한다.</p>\n</blockquote>\n<br />\n<p>기존 <code>appView()</code>는 함수는 갱신이 필요한 뷰 함수를 직접 호출하고 있다. 이는 선언적 방식이라 할 수 없다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const appView = (targetElement, state) =&gt; {\n  const element = targetElement.cloneNode(true)\n\n  const list = element.querySelector(&#39;.todo-list&#39;)\n  const counter = element.querySelector(&#39;.todo-count&#39;)\n  const filters = element.querySelector(&#39;.filters&#39;)\n\n  list.replaceWith(todosView(list, state))\n  counter.replaceWith(counterView(counter, state))\n  filters.replaceWith(filterView(filters, state))\n\n  return element\n}</code>\n        </deckgo-highlight-code>\n<p>선언적 방식이라면 뭔가 '해 줘' 느낌이 나야 한다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d1eca93795fdfb19256e0f0c431c9cec/edd00/do.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 91.37931034482759%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAIDBAEF/8QAFwEBAAMAAAAAAAAAAAAAAAAAAQACA//aAAwDAQACEAMQAAAB97sc4alaMRQuGj//xAAaEAACAgMAAAAAAAAAAAAAAAABAgASEBEy/9oACAEBAAEFAss1Q5NU5eADc//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABcRAQEBAQAAAAAAAAAAAAAAAAEQETH/2gAIAQIBAT8BXI9n/8QAFxABAQEBAAAAAAAAAAAAAAAAAQAQIP/aAAgBAQAGPwLkiM//xAAaEAEAAgMBAAAAAAAAAAAAAAABABEQITFR/9oACAEBAAE/IWDgLGKoaL9i7TuOQMf/2gAMAwEAAgADAAAAEIfovP/EABYRAQEBAAAAAAAAAAAAAAAAAAEQQf/aAAgBAwEBPxBZs//EABcRAQADAAAAAAAAAAAAAAAAAAEAEBH/2gAIAQIBAT8QGB0t/8QAHBABAAIDAQEBAAAAAAAAAAAAAQARITFBEHHh/9oACAEBAAE/EG3upcfGvNwnhe5hgqpyX8iZFtbWEbQc9gmCTtef/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"do\"\n        title=\"\"\n        src=\"/static/d1eca93795fdfb19256e0f0c431c9cec/9c477/do.jpg\"\n        srcset=\"/static/d1eca93795fdfb19256e0f0c431c9cec/583d1/do.jpg 174w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/4d0aa/do.jpg 347w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/9c477/do.jpg 694w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/909c7/do.jpg 1041w,\n/static/d1eca93795fdfb19256e0f0c431c9cec/edd00/do.jpg 1074w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br />\n<p><code>class</code> 대신 <code>data-component</code> 속성에 컴포넌트의 이름을 넣는다. 이제부터 뷰에서 <a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Howto/Use_data_attributes\">데이터 속성</a>을 사용한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12 15 16\">\n          <code slot=\"code\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;todos&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;section class=&quot;todoapp&quot;&gt;\n      &lt;header&gt;\n        &lt;h1&gt;todos&lt;/h1&gt;\n        &lt;input class=&quot;new-todo&quot; placeholder=&quot;할 일 적기&quot; autofocus&gt;\n      &lt;/header&gt;\n      &lt;section class=&quot;main&quot;&gt;\n        &lt;ul data-component=&quot;todos&quot;&gt;&lt;/ul&gt;\n      &lt;/section&gt;\n      &lt;footer class=&quot;footer&quot;&gt;\n        &lt;span data-component=&quot;counter&quot;&gt;&lt;/span&gt;\n        &lt;ul data-component=&quot;filters&quot;&gt;\n          &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;전체&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;미완료&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;완료&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;button class=&quot;clear-completed&quot;&gt;완료 삭제&lt;/button&gt;\n      &lt;/footer&gt;\n    &lt;/section&gt;\n    &lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<br />\n<blockquote>\n<p>컴포넌트 라이브러리를 위한 또 다른 필수 조건은 레지스트리로, 레지스트리는 앱에서 사용할 수 있는 모든 컴포넌트의 인덱스이다.</p>\n</blockquote>\n<br />\n<p>레지스트리 키는 <code>data-component</code>속성과 일치한다. 레지스트리를 사용하면 컴포넌트 안에서 다른 컴포넌트를 사용할 수 있다. 재사용성은 컴포넌트 기반 애플리케이션의 필수 요소다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// 레지스트리 예시\n\nconst registry = {\n  todos: Todos,\n  counter: Counter,\n  filters: Filters,\n}</code>\n        </deckgo-highlight-code>\n<p>컴포넌트의 느낌을 내고 싶어 기존 뷰 함수의 이름을 <code>PascalCase</code>로 변경했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"1,2 12,13 28,29\">\n          <code slot=\"code\">// components/Counter.js\nconst Counter = (targetElement, { todos }) =&gt; {\n  const newCounter = targetElement.cloneNode(true);\n\n  const howManyLeft = todos.filter(todo =&gt; !todo.completed).length;\n\n  newCounter.textContent = `${howManyLeft}개 남음`;\n\n  return newCounter;\n}\n\n// components/Filters.js\nconst Filters = (targetElement, { filter: currentFilter }) =&gt; {\n  const newFilters = targetElement.cloneNode(true);\n  const filterList = newCounter.querySelectorAll(&#39;li a&#39;);\n\n  [...filterList].forEach(filter =&gt; {\n    if (filter.textContent === currentFilter) {\n      filter.classList.add(&#39;selected&#39;);\n    } else {\n      filter.classList.remove(&#39;selected&#39;);\n    }\n  })\n\n  return newFilters;\n}\n\n// components/Todos\nconst Todos = (targetElement, { todos }) =&gt; {\n  const newTodoList = targetElement.cloneNode(true);\n\n  newTodoList.innerHTML = todos.map(({ text, completed }) =&gt; {\n    return `\n      &lt;li ${completed ? &#39;class=&quot;completed&quot;&#39; : &#39;&#39;}&gt;\n        &lt;div class=&quot;view&quot;&gt;\n          &lt;input \n            ${completed ? &#39;checked&#39; : &#39;&#39;}\n            class=&quot;toggle&quot; \n            type=&quot;checkbox&quot;&gt;\n          &lt;label&gt;${text}&lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/li&gt;\n    `\n  }).join(&#39;&#39;);\n\n  return newTodoList\n}</code>\n        </deckgo-highlight-code>\n<p><code>appView()</code>의 구성은 더 이상 필요하지 않아 삭제하고, <code>fetchTodos()</code>는 <code>apis.js</code>로 분리했다. 그리고 레지스트리를 위한 공간인 <code>registry.js</code>를 추가한다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── Counter.js\n│   ├── Filters.js\n│   └── Todos.js\n├── index.html\n├── index.js\n└── registry.js</code>\n        </deckgo-highlight-code>\n<p>먼저 레지스트리 등록을 위한 빈 객체를 만들어 두었다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// registry.js\n\nconst registry = {};</code>\n        </deckgo-highlight-code>\n<p><code>addComponent()</code>는 레지스트리에 컴포넌트를 등록한다. <code>render()</code>는 고차 함수로서 컴포넌트를 미리 받아 놓고 새로운 상태로 갱신된 엘리먼트를 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// registry.js\n\nexport const addComponent = (name, component) =&gt; {\n  registry[name] = render(component);\n}</code>\n        </deckgo-highlight-code>\n<p><code>render()</code>를 좀 더 살펴보면,</p>\n<p>컴포넌트(기존 뷰 함수)를 실행시켜 새롭게 갱신된 엘리먼트를 리턴한다. 또한 <code>data-component</code> 속성을 갖는 모든 자식 요소를 찾는다. 만약 레지스트리에 등록된 요소라면 이를 갱신한다. 레지스트리에 등록된 컴포넌트는 <code>render()</code>로 래핑되어 <code>targetElement</code>과 <code>state</code>만 전달되면 lazy하게 실행될 준비가 되어있다. 재귀적 구성으로 루트만 렌더링하면 마지막 컴포넌트까지 모두 그린다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// registry.js\n\nconst render = (component) =&gt; {\n  return (targetElement, state) =&gt; {\n    const element = component(targetElement, state);\n\n    const children = element.querySelectorAll(&#39;[data-component]&#39;);\n\n    [...children].forEach((target) =&gt; {\n      const name = target.dataset.component;\n\n      const component = registry[name];\n\n      if (!component) return;\n\n      target.replaceWith(component(target, state))\n    })\n\n    return element;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><code>renderRoot()</code>는 최초 DOM 요소인 루트를 렌더링한다. <code>render()</code>는 <code>data-component</code> 속성을 가진 모든 자식 요소를 재귀적으로 갱신한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// registry.js\n\nexport const renderRoot = (root, state) =&gt; {\n  const clone = (root) =&gt; {\n    return root.cloneNode(true);\n  }\n\n  return render(clone)(root, state);\n}</code>\n        </deckgo-highlight-code>\n<p><code>registry.js</code>의 최종 모습은 아래와 같다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// registry.js\n\nconst registry = {};\n\nconst render = (component) =&gt; {\n  return (targetElement, state) =&gt; {\n    const element = component(targetElement, state);\n\n    const children = element.querySelectorAll(&#39;[data-component]&#39;);\n\n    [...children].forEach((target) =&gt; {\n      const name = target.dataset.component;\n\n      const component = registry[name];\n\n      if (!component) return;\n\n      target.replaceWith(component(target, state))\n    })\n\n    return element;\n  }\n}\n\nexport const addComponent = (name, component) =&gt; {\n  registry[name] = render(component);\n}\n\nexport const renderRoot = (root, state) =&gt; {\n  const clone = (root) =&gt; {\n    return root.cloneNode(true);\n  }\n\n  return render(clone)(root, state);\n}</code>\n        </deckgo-highlight-code>\n<p>메인 컨트롤러에서 레지스트리에 컴포넌트를 등록하는 과정이 있다. 동적 렌더링을 가정하려고 5초마다 새로운 할 일이 추가된 목록을 그리도록 했다. (이처럼 특정 주기마다 가상 루트 요소를 만든 다음 실제 요소로 바꾸는 방법은 대규모 프로젝트에서 성능을 저하시킬 수 있다.)</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"17,20 22,29 31,45\">\n          <code slot=\"code\">// index.js\n\nimport { fetchTodos } from &quot;./apis.js&quot;;\n\nimport Todos from &#39;./components/Todos.js&#39;;\nimport Filters from &#39;./components/Filters.js&#39;;\nimport Counter from &#39;./components/Counter.js&#39;;\n\nimport { addComponent, renderRoot } from &#39;./registry.js&#39;\n\n// set state\nconst state = {\n  todos: fetchTodos(),\n  filter: &#39;All&#39;\n}\n\n// 레지스트리에 컴포넌트 등록\naddComponent(&#39;todos&#39;, Todos);\naddComponent(&#39;counter&#39;, Counter);\naddComponent(&#39;filters&#39;, Filters);\n\n// 동적 렌더링\nconst init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;.todoapp&#39;);\n\n    app.replaceWith(renderRoot(app, state))\n  })\n}\n\n// 5초마다 새로운 할 일이 추가된다고 가정\nwindow.setInterval(() =&gt; {\n  const index = state.todos.length + 1;\n\n  state.todos = [\n    {\n      id: `${index}`,\n      text: `새로운 할 일 ${index}`,\n      completed: false\n    },\n    ...state.todos,\n  ]\n\n  init();\n}, 5000)\n\ninit();</code>\n        </deckgo-highlight-code>\n<p>5초마다 새로운 할 일이 추가된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/336d7d584ca38749169c0d4ee512efa1/7960f/todos-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.49425287356321%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAvklEQVR42q2Syw6DIBBF/f8/87ExxoWGRW3EmmgFjKQowi3QfoE4C0hmcXIfkzRNgzRNIaWEH2stYiZhjGGaJiiloLXGcRxxQK9sXVcIIcA5D/95nteBxphgt67rYL2qqij7P+Am4bMsyxJd12Hf9ziFC1+QFzmyLEPf9/C7y0D/vDgFeRAMdIAvKaqUcRydqqfLy4TMos8G0CBkA6X2XwRigcaVoVAU5h6gEAxtS1126h7gPL+d3ac7lQ/umC9yyrAb4xZSaAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"todos-2\"\n        title=\"\"\n        src=\"/static/336d7d584ca38749169c0d4ee512efa1/31198/todos-2.png\"\n        srcset=\"/static/336d7d584ca38749169c0d4ee512efa1/fe9c7/todos-2.png 174w,\n/static/336d7d584ca38749169c0d4ee512efa1/39e45/todos-2.png 347w,\n/static/336d7d584ca38749169c0d4ee512efa1/31198/todos-2.png 694w,\n/static/336d7d584ca38749169c0d4ee512efa1/ee9b6/todos-2.png 1041w,\n/static/336d7d584ca38749169c0d4ee512efa1/7960f/todos-2.png 1274w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"가상-dom\" style=\"position:relative;\">가상 DOM<a href=\"#%EA%B0%80%EC%83%81-dom\" aria-label=\"가상 dom permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가상 DOM의 핵심은 비교 알고리즘이다. 더 이상 전체 목록을 교체하지 않고 변경된 요소가 실제 DOM에 필요한 유일한 작업이라는 사실을 시스템이 이해하도록 하는 것이 가상 DOM의 목적이다.</p>\n<p>메인 컨트롤러에서 <code>replaceWith</code> 대신 <code>diff</code> 알고리즘을 사용한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// index.js\n\n// ...\n\nconst init = () =&gt; {\n  window.requestAnimationFrame(() =&gt; {\n    const app = document.querySelector(&#39;.todoapp&#39;)\n    const newApp = registry.createRoot(app, state)\n    renderDiff(document.body, app, newApp)\n  })\n}\n\n// ...</code>\n        </deckgo-highlight-code>\n<p><code>renderDiff</code>는 부모 노드, 실제 노드, 가상 노드를 인자로 받아 재귀적으로 실행되는 함수다.</p>\n<p>실제 노드는 존재하지만 가상 노드가 없다면 그 실제 노드는 삭제 대상이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// renderDiff.js\n\nif (realNode &amp;&amp; !virtualNode) {\n    realNode.remove();\n    return;\n}</code>\n        </deckgo-highlight-code>\n<p>반대로 실제 노드는 없지만 가상 노드가 있다면 그 가상 노드는 추가 대상이다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// renderDiff function\n\nif (!realNode &amp;&amp; virtualNode) {\n    parentNode.appendChild(virtualNode);\n    return;\n}</code>\n        </deckgo-highlight-code>\n<p>두 노드가 모두 존재하는 경우 변경 사항이 있을 때만 실제 노드를 대체한다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">// renderDiff function\n\nif (isNodeChanged(virtualNode, realNode)) {\n    realNode.replaceWith(virtualNode);\n    return;\n}</code>\n        </deckgo-highlight-code>\n<p><code>isNodeChanged()</code>는 아래 사항들을 확인한다.</p>\n<ul>\n<li><code>attribute</code> 갯수가 다른가?</li>\n<li>하나 이상의 <code>attribute</code>가 변경되었는가?</li>\n<li>노드에 자식이 없다면 노드의 <code>textContent</code>가 다른가?</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const isNodeChanged = (n1, n2) =&gt; {\n  const { attributes: n1Attributes } = n1;\n  const { attributes: n2Attributes } = n2;\n\n  if (n1Attributes.length !== n2Attributes.length) {\n    return true;\n  }\n\n  const hasDifferentAttribute = [...n1Attributes]\n    .some(({ name }) =&gt; {\n      const n1Attribute = n1.getAttribute(name);\n      const n2Attribute = n2.getAttribute(name);\n\n      return n1Attribute !== n2Attribute;\n    })\n\n  if (hasDifferentAttribute) {\n    return true;\n  }\n\n  const hasChildren = n1.children.length !== 0 || n2.children.length !== 0;\n  const isTextContentDifferent = !hasChildren &amp;&amp; (n1.textContent !== n2.textContent);\n\n  if (isTextContentDifferent) {\n    return true\n  }\n\n  return false\n}</code>\n        </deckgo-highlight-code>\n<p>전체 <code>renderDiff()</code>는 이런 모습이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const renderDiff = (\n  parentNode,\n  realNode,\n  virtualNode\n) =&gt; {\n  if (realNode &amp;&amp; !virtualNode) {\n    realNode.remove();\n    return;\n  }\n\n  if (!realNode &amp;&amp; virtualNode) {\n    parentNode.appendChild(virtualNode);\n    return;\n  }\n\n  if (isNodeChanged(virtualNode, realNode)) {\n    realNode.replaceWith(virtualNode);\n    return;\n  }\n\n  const realChildren = [...realNode.children];\n  const virtualChildren = [...virtualNode.children];\n\n  const max = Math.max(realChildren.length, virtualChildren.length);\n\n  for (let i = 0; i &lt; max; i++) {\n    renderDiff(\n      realNode,\n      realChildren[i],\n      virtualChildren[i]\n    )\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>최종 디렉토리 구조는 이렇다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">root\n├── apis.js\n├── components\n│   ├── Counter.js\n│   ├── Filters.js\n│   └── Todos.js\n├── index.html\n├── index.js\n├── registry.js\n└── renderDiff.js</code>\n        </deckgo-highlight-code>\n<h2 id=\"렌더링-성능-모니터링\" style=\"position:relative;\">렌더링 성능 모니터링<a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81\" aria-label=\"렌더링 성능 모니터링 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>렌더링 엔진에서 중요한 요소 중 하나는 성능이다. 저자는 성능 모니터링을 위한 여러 도구를 소개한다.</p>\n<ul>\n<li>크롬 개발자 도구 - Show frame per seconds meter 메뉴 선택</li>\n<li><a href=\"https://github.com/Kevnz/stats.js\">stat.js</a> 라이브러리 활용하기</li>\n<li>커스텀 성능 위젯</li>\n</ul>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"13,35\">\n          <code slot=\"code\">let panel;\nlet start;\nlet frames;\n\nconst create = () =&gt; {\n  const div = document.createElement(&#39;div&#39;);\n\n  // create panel wrapper\n\n  return div;\n}\n\nconst tick = () =&gt; {\n  frames++;\n\n  const now = window.performance.now();\n\n  if (now &gt;= start + 1000) {\n    panel.innerText = frames;\n    frames = 0;\n    start = now;\n  }\n\n  window.requestAnimationFrame(tick);\n}\n\nconst init = (parent = document.body) =&gt; {\n  panel = create();\n\n  window.requestAnimationFrame(() =&gt; {\n    start = window.performance.now();\n    parent.appendChild(panel);\n    tick();\n  })\n}\n\ninit();</code>\n        </deckgo-highlight-code>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/2장_렌더링","title":"2장 렌더링"},"frontmatter":{"created":"2023-02-07","updated":"2023-08-22 00:37:43 +0900"}}},{"node":{"id":"24d6d934-ce6d-5bc8-a0f3-83c24129e072","html":"<h2 id=\"책-소개\" style=\"position:relative;\">책 소개<a href=\"#%EC%B1%85-%EC%86%8C%EA%B0%9C\" aria-label=\"책 소개 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<div style=\"width: 300px; margin-right: auto;\">\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0412438031b86e2d2994c03a72a3c71a/6a068/book_cover.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 125.28735632183907%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAGQAAAwEBAQAAAAAAAAAAAAAAAAEEAwIF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQMA/9oADAMBAAIQAxAAAAHzK5tjRAVl3vKhYhP/xAAbEAACAgMBAAAAAAAAAAAAAAAAAQIDEBESIP/aAAgBAQABBQKuPROiCRUNYi9Dsb8//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQIQEf/aAAgBAwEBPwGZEzqZ/8QAGBEAAgMAAAAAAAAAAAAAAAAAAhABESH/2gAIAQIBAT8BItVQv//EABsQAAEEAwAAAAAAAAAAAAAAAAEAEBEhICKh/9oACAEBAAY/AkdjTFGQ9nmP/8QAGxABAQADAAMAAAAAAAAAAAAAAREAECEgMYH/2gAIAQEAAT8hBI4jlI1184pCHLp2xlyw2X34v//aAAwDAQACAAMAAAAQ+CmO/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/ENBAmDP/xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QQQRZ1J//xAAcEAEAAgIDAQAAAAAAAAAAAAABESEAEDFBkdH/2gAIAQEAAT8QXlIiIxOwKMXM/NDtBJ4G8hA09xq1BTickBowHHunDX//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"book_cover\"\n        title=\"\"\n        src=\"/static/0412438031b86e2d2994c03a72a3c71a/9c477/book_cover.jpg\"\n        srcset=\"/static/0412438031b86e2d2994c03a72a3c71a/583d1/book_cover.jpg 174w,\n/static/0412438031b86e2d2994c03a72a3c71a/4d0aa/book_cover.jpg 347w,\n/static/0412438031b86e2d2994c03a72a3c71a/9c477/book_cover.jpg 694w,\n/static/0412438031b86e2d2994c03a72a3c71a/6a068/book_cover.jpg 960w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n</div> \n<p>서점에서 제목에 끌려 집어 들었던 책인데 내용이 좋아 한 번 정리하고 싶었다. 번역이 아쉽다는 평이 있고 실제로 좀 그렇기도 하지만, 나와 같이 별 생각없이 프레임워크를 사용해왔던 주니어 개발자라면 한 번 읽어보는 것을 추천한다.</p>\n<h2 id=\"프레임워크란\" style=\"position:relative;\">프레임워크란?<a href=\"#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%9E%80\" aria-label=\"프레임워크란 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>무언가를 만들 수 있는 지지 구조</p>\n<h2 id=\"프레임워크-vs-라이브러리\" style=\"position:relative;\">프레임워크 VS 라이브러리<a href=\"#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-vs-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC\" aria-label=\"프레임워크 vs 라이브러리 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프레임워크는 코드를 호출하지만 라이브러리는 코드에 의해 호출된다.</p>\n<h2 id=\"프레임워크-방식\" style=\"position:relative;\">프레임워크 방식<a href=\"#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EB%B0%A9%EC%8B%9D\" aria-label=\"프레임워크 방식 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://ko.reactjs.org/\">리액트 공식 홈페이지</a>에는 리액트를 ‘사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리’라고 소개하고 있다. 리액트의 핵심은 선언적 패러다임이다. 개발자는 돔을 직접 조작하는 대신 구성 요소의 상태를 변경한다. 그러면 리액트가 대신 돔을 조작해주는 식이다. 저자는 이러한 이유로 리액트를 프레임워크라고 믿는다.</p>\n<h2 id=\"프레임워크-연혁\" style=\"position:relative;\">프레임워크 연혁<a href=\"#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%97%B0%ED%98%81\" aria-label=\"프레임워크 연혁 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>2006년 <a href=\"https://ko.wikipedia.org/wiki/%EC%A1%B4_%EB%A0%88%EC%8B%9D\">존 레식</a>이 개발한 제이쿼리는 모든 자바스크립트 프레임워크의 모체가 됐다.</p>\n<p>2009년 <a href=\"https://dev.to/mhevery\">미스코 헤브리</a>가 개발한 앵귤러JS의 가장 주목할 만한 기능은 데이터 바인딩이다. 모델이 바뀌면 뷰가 바뀐다. 뷰가 바뀌면 모델이 바뀐다.</p>\n<p>2011년 페이스북이 만들어 2013년에 공개한 리액트는 현재 가장 인기있는 프레임워크다. 선언적 패턴이 가장 큰 특징이다. 상태를 변경하면 돔을 바꾸는 일은 리액트가 한다.</p>\n<h2 id=\"기술부채\" style=\"position:relative;\">기술부채<a href=\"#%EA%B8%B0%EC%88%A0%EB%B6%80%EC%B1%84\" aria-label=\"기술부채 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로젝트에 기능을 추가할 때 여러 옵션이 있다. 어떤 것은 빠르지만 지저분하고 반면 어떤 것은 느리지만 잘 설계되어 있다. 어떤 기술적 결정은 기술 부채를 낳는다. 지저분한 옵션일 수록 더 많은 부채를 안기고 부채는 시간이 지남에 따라 이자와 함께 기하급수적으로 늘어난다.</p>\n<p>모든 프레임워크는 기술부채를 갖고 있다. 프레임워크가 무료라고 생각하는 것은 순진한 생각이다. 미래에 코드 변경이 어렵다는 측면에서 모든 프레임워크에서는 비용이 발생한다. 프레임워크의 아키텍처 그 자체에 이미 비용을 포함하고 있다. 시간이 지난 후에 외부적 요인에 의해 소프트웨어의 변경이 필요하다면 프레임워크가 장애물이 될 수 있다. 하지만 프레임워크의 사용을 반대하는 것이 저자의 목적은 아니다. 합리적 이유로 선택한 프레임워크는 좋은 투자가 될 수 있고 이는 자산이 될 수 있다.</p>\n<h2 id=\"출처\" style=\"position:relative;\">출처<a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><em>프란세스코 스트라츨로, <a href=\"https://search.shopping.naver.com/book/search?bookTabType=ALL&#x26;pageIndex=1&#x26;pageSize=40&#x26;query=%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%EC%97%86%EB%8A%94%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EA%B0%9C%EB%B0%9C&#x26;sort=REL\">『프레임워크 없는 프론트엔드 개발』</a>, 에이콘 출판(2021.01.21.)</em></p>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발/1장_프레임워크에_대한_이야기","title":"1장 프레임워크에 대한 이야기"},"frontmatter":{"created":"2023-01-29","updated":"2023-08-22 00:37:30 +0900"}}},{"node":{"id":"00974a22-06ab-5270-a9c1-b99d7b609de6","html":"<h1 id=\"프레임워크-없는-프론트엔드-개발\" style=\"position:relative;\">프레임워크 없는 프론트엔드 개발<a href=\"#%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%97%86%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C\" aria-label=\"프레임워크 없는 프론트엔드 개발 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>[[1장_프레임워크에_대한_이야기/index.md]]</li>\n<li>[[2장_렌더링/index.md]]</li>\n<li>[[3장_DOM_이벤트_관리/index.md]]</li>\n<li>[[4장_웹_컴포넌트/index.md]]</li>\n<li>[[5장_HTTP_요청/index.md]]</li>\n<li>[[6장_라우터/index.md]]</li>\n<li>[[7장_상태_관리/index.md]]</li>\n</ul>","fields":{"slug":"/책/프레임워크_없는_프론트엔드_개발","title":"프레임워크 없는 프론트엔드 개발"},"frontmatter":{"created":"2023-08-14","updated":"2023-08-22 00:37:13 +0900"}}},{"node":{"id":"3897c8cf-2598-5c5a-87d8-6f6754a11825","html":"<h1 id=\"읽었거나-읽고-있는-책들\" style=\"position:relative;\">읽었거나 읽고 있는 책들<a href=\"#%EC%9D%BD%EC%97%88%EA%B1%B0%EB%82%98-%EC%9D%BD%EA%B3%A0-%EC%9E%88%EB%8A%94-%EC%B1%85%EB%93%A4\" aria-label=\"읽었거나 읽고 있는 책들 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>[[프레임워크_없는_프론트엔드_개발/index.md]]</li>\n</ul>","fields":{"slug":"/책","title":"책"},"frontmatter":{"created":"2023-08-14","updated":"2023-08-22 00:37:07 +0900"}}},{"node":{"id":"f7de5498-0c33-537d-b9d7-e81346e3806c","html":"<h2 id=\"custom-date-picker를-위한-인풋\" style=\"position:relative;\">Custom Date Picker를 위한 인풋<a href=\"#custom-date-picker%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%92%8B\" aria-label=\"custom date picker를 위한 인풋 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>웹에서 커스텀한 Date Picker를 보여주고 싶다면, 원하는 구성을 직접 만들거나 라이브러리를 활용해야 할 것이다. MUI 같은 라이브러리는 연, 월, 일을 구분하는 구분자를 자동으로 추가하고 유효성도 잘 체크하는 구성을 제공하지만 내게 필요했던 range date picker는 유료여서 채택할 수 없었다. 결국 <code>react-datepicker</code>를 골랐는데 이 라이브러리가 제공하는 인풋에는 아무 문자나 입력할 수 있다는 아쉬움이 있었다. 유효하지 않은 입력을 제한하고 날짜 형식을 자동으로 잡아줘야 했는데 이번 글에 그 목적을 달성하기 위해 공부한 정규 표현식에 관한 내용을 담았다. 최대한 간단한 형태의 예제로 소개할 생각이다 .</p>\n<p>내가 원하는 날짜 형식은 <code>yyyy.MM.dd - yyyy.MM.dd</code>와 같은 형식이다.</p>\n<p><code>date</code> 타입의 인풋은 커스텀하는데 한계가 많기 때문에 커스텀한 달력들은 대부분 <code>text</code> 타입을 사용한다.</p>\n<deckgo-highlight-code language=\"html\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4\">\n          <code slot=\"code\">// index.html\n\n&lt;body&gt;\n  &lt;input type=&quot;text&quot;/&gt;\n  &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;</code>\n        </deckgo-highlight-code>\n<h2 id=\"숫자만-입력-받기\" style=\"position:relative;\">숫자만 입력 받기<a href=\"#%EC%88%AB%EC%9E%90%EB%A7%8C-%EC%9E%85%EB%A0%A5-%EB%B0%9B%EA%B8%B0\" aria-label=\"숫자만 입력 받기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>인풋에서는 숫자 입력만 받고 싶다. <code>keydown</code> 이벤트 핸들러에서 숫자 입력이 아닌 경우에 이벤트의 기본 동작을 제한한다. <code>match()</code> 메서드는 문자열이 정규식에 매칭되는지 검사한다. 만약 매칭된다면 문자열이 포함된 배열을 반환하고, 없다면 <code>null</code>을 반환한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"3,7\">\n          <code slot=\"code\">const input = document.querySelector(&#39;input&#39;);\n\ninput.addEventListener(&#39;keydown&#39;, (e) =&gt; {\n  if (!e.key.match(/\\d/g)) {\n    e.preventDefault();\n  }\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li>정규 표현식에는 메타 문자라는 것이 있는데 주로 쓰이는 <strong>문자 집합</strong>들을 대체하는 특수 문자라고 생각하면 쉽다. <code>\\d</code>도 메타 문자 중 하나로 숫자를 나타낸다. 이 문자는<code>[0-9]</code>와 같은 의미를 가진다.</li>\n<li><code>/\\d/g</code>와 같이 사용하는 <code>g</code>플래그는 일치하는 모든 패턴을 찾는다. 만약 이 플래그가 없다면 패턴과 일치하는 첫 번째 결과만을 반환한다.</li>\n</ul>\n<h2 id=\"whitelist-만들기\" style=\"position:relative;\">Whitelist 만들기<a href=\"#whitelist-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"whitelist 만들기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>숫자 외에도 커서 이동을 위한 방향 키, 폼 제출을 위한 엔터 키, 그리고 삭제를 위한 백스페이스 키도 입력이 가능해야 한다. 입력 가능한 키를 하나의 정규 표현식 그룹에 담는다. 입력된 키가 <code>whitelist</code>에 속하지 않으면 이벤트의 기본 동작을 막는다. 정규 표현식의 <code>test()</code>메서드는 주어진 문자열이 정규식을 만족하는지 검사한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">input.addEventListener(&#39;keydown&#39;, (e) =&gt; {\n  const whitelist = /(\\d|ArrowLeft|ArrowRight|Backspace|Enter)/;\n\n  if (!whitelist.test(e.key)) {\n    e.preventDefault();\n  }\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li>앵커는 행의 시작과 끝 지점을 나타낸다. <code>^</code>은 행의 시작을 의미하고 <code>$</code>는 행의 끝을 의미한다. <code>apple</code>과 완전히 일치하는 문자열을 찾고 싶다면 <code>^apple$</code>와 같이 두 앵커로 감싸준다.</li>\n</ul>\n<h2 id=\"자동으로-점-찍어주기\" style=\"position:relative;\">자동으로 점 찍어주기<a href=\"#%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A0%90-%EC%B0%8D%EC%96%B4%EC%A3%BC%EA%B8%B0\" aria-label=\"자동으로 점 찍어주기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>숫자 입력만 받기 때문에 자동으로 점을 찍어줘야 한다. 먼저 시도해 볼 것은 8자리의 숫자를 입력할 때 <code>yyyy.mm.dd</code>와 같은 형태가 되는 것이다. <code>replace()</code>의 두 번째 매개변수 타입이 <code>string</code>이라면 해당 문자열은 특수한 교체 패턴을 포함할 수 있다. 아래의 <code>'$1.$2.$3'</code>처럼 <code>$n</code>의 패턴이 놓인 자리에는 정규 표현식 내 소괄호로 묶인 <code>n</code>번째 그룹에 매치된 문자열을 삽입한다. 만약 정규 표현식을 각각 (4자리), (2자리), (2자리) 숫자로 묶인 세 캡쳐링 그룹으로 구성한다면, <code>11112233</code>와 같은 문자열을 <code>1111.22.33</code>로 대체한다. 앞서 말했듯이 문자열이 포함하는 특수 교체 패턴에 각 그룹에 매치된 문자열을 삽입하기 때문이다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date.replace(/^(\\d{4})(\\d{2})(\\d{2})$/g, &#39;$1.$2.$3&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li>캡쳐링 그룹(capturing group)은 소괄호로 묶인 영역을 의미한다. 캡쳐링 그룹을 사용하면 매치된 부분 문자열을 따로 추출할 수 있다. 캡쳐링된 문자열은 <code>$n</code>과 같은 특수 패턴을 활용하여 추출할 수 있다.</li>\n<li>수량자(quantity)는 패턴이 나타날 수 있는 횟수를 지정해 준다. 수량자는 다음과 같이 사용할 수 있다.\n<ul>\n<li><code>*</code>: 0개 이상</li>\n<li><code>+</code>: 1개 이상</li>\n<li><code>?</code>: 0개 또는 1개</li>\n<li><code>{n}</code>: n개</li>\n<li><code>{n,}</code>: n개 이상</li>\n<li><code>{n,m}</code>: n개 이상, m개 이하</li>\n</ul>\n</li>\n<li>예를 들어, <code>/\\d{2,4}/</code> 패턴은 2자리에서 4자리의 숫자에 매치된다. <code>/\\d+/</code> 패턴은 1개 이상의 숫자에 매치된다. <code>/\\d*/</code> 패턴은 0개 이상의 숫자에 매치된다. <code>/\\d?/</code> 패턴은 0개 또는 1개의 숫자에 매치된다.</li>\n</ul>\n<p><em><strong>구현</strong></em></p>\n<p>8자리 숫자를 입력하면 원하는 자리에 점을 찍어주고 있다.</p>\n<p><img src=\"/5223507fe603f60a2f7a06add8a9f987/regex1.gif\" alt=\"regex1\"></p>\n<p>그러나 사실 내가 원했던 것은 8자리를 모두 입력하지 않더라도 필요한 시점에 점이 찍히는 것이다. 수량자를 변경해보자. 각 그룹이 0개의 숫자부터 캡쳐링할 수 있도록 수량자를 조절한다. 하지만 이렇게만 하면 <code>1..</code>처럼 점이 연속으로 찍히고 그 다음 입력은 마지막 자리에 붙게 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date.replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p>포맷을 바꿔주기 전 숫자를 제외한 문자를 제거하면 최종적으로 원하는 위치에 점을 찍어준다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"5\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date\n    .replace(/[^0-9]/g, &#39;&#39;)\n    .replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p>하지만 여전히 입력 중에는 문자열의 끝에 두 개 이상의 점이 붙는다. 이를 방지하기 위해 정규식을 하나 더 추가한다. 이 정규식은 연속된 점을 삭제한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  date = date\n    .replace(/[^0-9]/g, &#39;&#39;)\n    .replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;)\n    .replace(/(\\.{2})/g, &#39;&#39;);\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>구현</strong></em></p>\n<p>이제는 입력 중에도 원하는 위치에 점을 잘 찍는다.</p>\n<p><img src=\"/c545acf53d5e72cdd246b8b4fe69e34d/regex2.gif\" alt=\"regex2\"></p>\n<h2 id=\"입력-구분하기\" style=\"position:relative;\">입력 구분하기<a href=\"#%EC%9E%85%EB%A0%A5-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0\" aria-label=\"입력 구분하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지는 백스페이스로 삭제를 하더라도 정규식 패턴에 의해 점이 다시 찍히기 때문에 삭제 기능이 동작하지 않았다. 삭제를 할 때는 자동 포맷팅을 하지 않도록 해야 한다. 이런 경우에 <code>InputEvent</code> 인터페이스가 제공하는 <code>inputType</code> 속성을 사용할 수 있다. <code>inputType</code>속성은 타이핑에 의한 <strong>텍스트 주입</strong>이라면 <code>“insertText”</code> 값을 갖는다. 입력을 추가할 때만 <code>replace()</code>를 호출한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"4 9\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n  \n  if (e.inputType === &#39;insertText&#39;) {\n    date = date\n      .replace(/[^0-9]/g, &#39;&#39;)\n      .replace(/^(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, &#39;$1.$2.$3&#39;)\n      .replace(/(\\.{2})/g, &#39;&#39;);\n  }\n  \n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<h2 id=\"날짜-범위를-위한-정규-표현식\" style=\"position:relative;\">날짜 범위를 위한 정규 표현식<a href=\"#%EB%82%A0%EC%A7%9C-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D\" aria-label=\"날짜 범위를 위한 정규 표현식 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>단일 인풋으로 하나의 날짜가 아닌, 특정 기간을 입력 받아야 한다면 좀 더 많은 정규 표현식이 필요하다. 서두에 언급했듯이 당초 원했던 것은 <code>yyyy.MM.dd - yyyy.MM.dd</code>와 같은 형식이다. 먼저 하이픈(-)과 같은 날짜 구분자를 추가해야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"7,9\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n  \n  if (e.inputType === &#39;insertText&#39;) {\n    date = date\n      .replace(/[^0-9]/g, &#39;&#39;)\n      .replace(\n        /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, \n        &#39;$1.$2.$3 - $4.$5.$6&#39;\n      )\n      .replace(/(\\.{2})/g, &#39;&#39;);\n  }\n  \n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>구현</strong></em></p>\n<p>이렇게만 해도 어느 정도는 잘 된다.</p>\n<p><img src=\"/b20b7e62ead6759826be330309aa4658/regex3.gif\" alt=\"regex3\"></p>\n<p>다만 날짜를 모두 지우거나 종료 날짜가 없음에도 보여주고 있는 하이픈(-)을 지우고 싶다. 정규식을 하나 더 추가한다. 부정 전방 탐색을 사용하여 뒤에 <code>숫자</code>, 또는 <code>공백 + 숫자</code>가 오지 않는 하이픈에 대한 매칭을 수행한다. 하이픈의 앞뒤에는 공백 문자가 0개 이상 올 수 있다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  highlight-lines=\"12\">\n          <code slot=\"code\">input.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  if (e.inputType === &#39;insertText&#39;) {\n     date = date\n       .replace(/[^0-9]/g, &#39;&#39;)\n       .replace(\n        /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, \n        &#39;$1.$2.$3 - $4.$5.$6&#39;\n       )\n       .replace(/(\\.{2})/g, &#39;&#39;)\n       .replace(/\\s*-\\s*(?!\\s*\\d)/g, &#39;&#39;)\n  }\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p><em><strong>About Regex</strong></em></p>\n<ul>\n<li><code>\\s</code> 메타 문자는 공백 문자를 의미한다. 반면, <code>\\S</code> 는 공백 문자가 아닌 모든 문자를 의미한다.</li>\n<li>전방 탐색(positive lookahead)은 정규 표현식에서 일치하는 부분 문자열을 제외한 부분에 대해 매칭을 수행하는 것을 말한다. 글로 보는 것보다 실제 동작을 보는 것이 더 이해하기 쉬운데 예를 들어, <code>q(?=u)</code>는 <code>u</code> 오른쪽에 둔 <code>q</code>를 매칭한다. 이 정규식은 <code>quiet</code>에서 <code>q</code>에 대해 매칭을 수행하지만, <code>Qantas</code>와 같은 문자열에서는 매칭을 수행하지 않는다.</li>\n<li>부정 전방 탐색(negative lookahead)은 전방 탐색의 반대로 생각하면 쉽다. 예를 들어, <code>q(?!u)</code>는 오른쪽에 <code>u</code>가 나오지 않는 <code>q</code>에 대해 매칭을 수행한다. 이 정규식은 <code>Iraq</code>에서 <code>q</code>와 <code>Qantas</code>에서 <code>q</code>에 대해 매칭을 수행하지만, <code>quiet</code>에서는 매칭을 수행하지 않는다</li>\n</ul>\n<p><em><strong>구현</strong></em></p>\n<p>이제 원하는 모습이 됐다.</p>\n<p><img src=\"/ea18063d0507505c943e5bb18436b912/regex4.gif\" alt=\"regex4\"></p>\n<h2 id=\"코드-리팩토링\" style=\"position:relative;\">코드 리팩토링<a href=\"#%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81\" aria-label=\"코드 리팩토링 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>replace()</code>의 호출을 위한 중복 코드를 제거하고 정규 표현식과 대체 문자열/패턴을 분리하면 코드가 더 읽기 좋아질 것 같아 리팩토링을 했다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const regexPatterns = [\n  { regex: /[^0-9]/g, replaceWith: &#39;&#39; },\n  { \n    regex: /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, \n    replaceWith: &#39;$1.$2.$3 - $4.$5.$6&#39; \n  },\n  { regex: /(\\.{2})/g, replaceWith: &#39;.&#39; },\n  { regex: /\\s*-\\s*(?!\\s*\\d)/g, replaceWith: &#39;&#39; },\n]\n\ninput.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  if (e.inputType === &#39;insertText&#39;) {\n     date = regexPatterns.reduce((inputValue, pattern) =&gt; \n              inputValue.replace(pattern.regex, pattern.replaceWith), date\n            );\n  }\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<h2 id=\"남아있는-한계-부제-유효하지-않은-입력-값-수정-방지하기\" style=\"position:relative;\">남아있는 한계 (부제: 유효하지 않은 입력 값 수정 방지하기)<a href=\"#%EB%82%A8%EC%95%84%EC%9E%88%EB%8A%94-%ED%95%9C%EA%B3%84-%EB%B6%80%EC%A0%9C-%EC%9C%A0%ED%9A%A8%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9E%85%EB%A0%A5-%EA%B0%92-%EC%88%98%EC%A0%95-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0\" aria-label=\"남아있는 한계 부제 유효하지 않은 입력 값 수정 방지하기 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사용자가 순서대로 지우고 순서대로 입력한다면 문제될 것이 없지만, 만약 커서를 옮겨 날짜 구분자를 지우고 입력하거나, 두 개 이상의 숫자를 지우고 입력하면 결국 날짜 형식이 망가질 수 있다. 이런 경우를 최대한 제한하기 위해 여러 정규식을 추가해 봤다.</p>\n<p>각 정규식에 대한 설명은 주석으로 대체한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">const regexPatterns = [\n  // &#39;yyyy.mm.dd - yyyy.mm.dd&#39;에서 separator를 제거 후 입력 방지:\n  // (1) 왼쪽에 숫자가 있고 (2)왼쪽에 separator는 없는, (3 - matched) yyyy.mm.dd , (3 - matched) 그룹을 제거\n  { regex: /(?&lt;=\\d\\s?)(?&lt;!(-\\s?))(\\d{4}\\.\\d{2}\\.\\d{2}$)/g, replaceWith: &#39;&#39; },\n  // &#39;yyyy.mm.dd&#39;에서 왼쪽 점을 제거 후 입력 방지:\n  // (1) 왼쪽에 4자리 숫자가 있는, (2 - matched) 3자리 숫자에 (3) 오른쪽에 점(.)과 2자리 숫자도 있다면, (2 - matched) 그룹을 &#39;01&#39;로 대체\n  { regex: /(?&lt;=(\\d{4}))(\\d{3})(?=\\.\\d{2})/g, replaceWith: &#39;01&#39; },\n  // &#39;yyyy.mm.dd&#39;에서 오른쪽 점을 제거 후 입력 방지:\n  // (1) 왼쪽에 4자리 숫자 + 점(.) + 2자리 숫자가 있는, (2 - matched) 3자리 숫자가 있다면, (2 - matched) 그룹을 &#39;.01&#39;로 대체\n  { regex: /(?&lt;=(\\d{4}\\.\\d{2}))(\\d{3})/g, replaceWith: &#39;01&#39; },\n  // 커서 이동 후 separator의 왼쪽 공백 문자를 다른 문자로 대체하는 입력 방지\n  { regex: /(?&lt;=(^\\d{4}\\.\\d{2}\\.\\d{2}))(\\d)(?=-)/g, replaceWith: &#39;&#39; },\n  // year 영역에 커서 이동 &gt; 2개 이상 삭제 &gt; 입력할 때 숫자 당겨지는 현상 방지: year 영역은 최소 4자리로 맞추기\n  { regex: /\\d{1,4}(?=\\.\\d{2}\\.\\d{2})/g, replaceWith: (match) =&gt; match.padEnd(4, &#39;0&#39;) },\n  // month 영역에 커서 이동 &gt; 2개 이상 삭제 &gt; 입력할 때 숫자 당겨지는 현상 방지: month 영역은 최소 2자리로 맞추기\n  { regex: /(?&lt;=(\\.))\\d{1,2}(?=\\.\\d{2})/g, replaceWith: (match) =&gt; match.padEnd(2, &#39;0&#39;) },\n  // date 영역에 커서 이동 &gt; 2개 이상 삭제 &gt; 입력할 때 숫자 당겨지는 현상 방지: 시작 날짜의 date 영역은 최소 2자리로 맞추기\n  { regex: /(?&lt;=\\.)(\\d{1,2})(?=[\\s-])/g, replaceWith: (match) =&gt; match.padEnd(2, &#39;0&#39;) },\n  { regex: /[^0-9]/g, replaceWith: &#39;&#39; },\n  { regex: /^(\\d{0,4})(\\d{0,2})(\\d{0,2})(\\d{0,4})(\\d{0,2})(\\d{0,2})$/g, replaceWith: &#39;$1.$2.$3 - $4.$5.$6&#39; },\n  { regex: /(\\.{2})/g, replaceWith: &#39;&#39; },\n  { regex: /\\s*-\\s*(?!\\s*\\d)/g, replaceWith: &#39;&#39; },\n]\n\ninput.addEventListener(&#39;input&#39;, (e) =&gt; {\n  let date = e.target.value;\n\n  if (e.inputType === &#39;insertText&#39;) {\n     date = regexPatterns.reduce((inputValue, pattern) =&gt; \n      inputValue.replace(pattern.regex, pattern.replaceWith), date);\n  }\n\n  input.value = date;\n})</code>\n        </deckgo-highlight-code>\n<p>다만 이렇게 여러 정규식을 추가하는 것이 과연 좋은 방법일까? 여전히 커버하지 못하는 엣지 케이스가 있다. 정규식보다는 인풋의 입력 영역을 나누거나, 좀 더 명확한 방법으로 해결할 필요가 있다고 느꼈다. 아마도 MUI의 <code>&#x3C;DateField /></code>와 같은 모습이라면 좋을 것 같은데 나중에 더 좋은 방법을 찾게 되면 기록으로 남기고 싶다.</p>","fields":{"slug":"/정규표현식/정규_표현식으로_날짜_자동_포맷팅하기","title":"정규 표현식으로 날짜 자동 포맷팅하기"},"frontmatter":{"created":"2023-03-28","updated":"2023-08-22 00:37:02 +0900"}}},{"node":{"id":"83951a8e-960c-5d0a-8a10-8910c6dd8f8a","html":"<h1 id=\"정규표현식\" style=\"position:relative;\">정규표현식<a href=\"#%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D\" aria-label=\"정규표현식 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>[[정규_표현식으로_날짜_자동_포맷팅하기/index.md]]</li>\n</ul>","fields":{"slug":"/정규표현식","title":"정규표현식"},"frontmatter":{"created":"2023-08-14","updated":"2023-08-22 00:36:57 +0900"}}},{"node":{"id":"74ecfe25-e201-5beb-a3f3-8114e615f494","html":"<blockquote>\n<p>이 블로그의 전신인 <a href=\"https://github.com/rheech22/gatsby-starter-github-theme-blog\">gatsby-starter-github-theme-blog</a>의 제작 후기입니다.</p>\n</blockquote>\n<br />\n<h2 id=\"1-블로그를-직접-만들게-된-이유\" style=\"position:relative;\">1. 블로그를 직접 만들게 된 이유<a href=\"#1-%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EA%B2%8C-%EB%90%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"1 블로그를 직접 만들게 된 이유 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>개발을 공부를 하며 티스토리에 기록을 남기곤 했다. 오픈된 공간에 학습한 내용을 보관하거나 느낀 바를 회고하는 경험은 새로웠다. 정보를 공유할 수 있다는 점에서 매력적이란 생각이 들었다. 그러나 취업 이후로는 부족한 시간을 핑계삼아 더 이상 관심을 두지 않았다. 그저 미루기만 했다. 티스토리는 또 다른 핑계 중 하나였다. 충분히 편리했지만 커스텀에는 분명 한계가 있었고 왠지 정이 가질 않았다. 하여 직접 만들자는 생각을 하기 시작했다. 내가 만들었으니 더 큰 애착을 가질 수도 있겠지. 새롭게 얻게 되는 지식과 경험을 기대하기도 했다.</p>\n<br />\n<h2 id=\"2-사전-목표\" style=\"position:relative;\">2. 사전 목표<a href=\"#2-%EC%82%AC%EC%A0%84-%EB%AA%A9%ED%91%9C\" aria-label=\"2 사전 목표 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>만들기 전 몇 가지 계획을 세웠다.</p>\n<ul>\n<li>개츠비 사용 - 새로운 프레임워크를 접하고 익숙한 스택인 리액트로 빠르게 개발하기</li>\n<li>타입스크립트 사용 - 아직 어설프게 사용하고 있는 타입스크립트와 좀 더 친해지기</li>\n<li>심플한 디자인으로 구현</li>\n<li>다크 모드</li>\n<li>검색 엔진 최적화</li>\n<li><a href=\"https://pages.github.com/\">GitHub Pages</a> 배포</li>\n</ul>\n<p>개발 중에 한 가지가 더 늘었다.</p>\n<ul>\n<li>다른 사람도 사용할 수 있는 프로젝트로 만들기</li>\n</ul>\n<br />\n<h2 id=\"3-블로그-소개\" style=\"position:relative;\">3. 블로그 소개<a href=\"#3-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%86%8C%EA%B0%9C\" aria-label=\"3 블로그 소개 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"요약\" style=\"position:relative;\">요약<a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><a href=\"https://github.com/rheech22/gatsby-starter-github-theme-blog\">gatsby-starter-github-theme-blog</a>는 기술 블로그를 위한 Gatsby 스타터다.</p>\n<ul>\n<li>github 테마, 심플, 반응형 디자인</li>\n<li>마크다운 with 코드 하이라이팅</li>\n<li>키워드, 태그, 연재물 검색</li>\n<li>프로그레시브 웹 앱(PWA)</li>\n<li>검색 엔진 최적화(SEO)</li>\n<li>Google Analystics</li>\n<li>github 댓글</li>\n<li>다크모드</li>\n<li>CICD</li>\n</ul>\n<br />\n<h3 id=\"github-테마\" style=\"position:relative;\">GitHub 테마<a href=\"#github-%ED%85%8C%EB%A7%88\" aria-label=\"github 테마 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.14942528735632%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKklEQVR42p2S3U7DMAyF+/7ikjcAcQGsaztawSNwxwNwBZoQiEHbpPl3Dm46pGmr0JgVJ5Ijfz52kq2aByyrGnlZo6rvUZQNzs8ucHl1jZtlhduiQl6ssNj6srxDWTXI+W6xE885njMnw55Fivh6k/CeQDGCF+J0k3ZhFNbdB4Q3mLMshIBd995DKAmlNIyx0Frh87tHJwSC81i373h8fcLz5gUUCPv52VwVIQdY55JCipSKaGNgvYPVFka7X8GHCueCnTTopZ6qEqW2p5MgGdayWzoaGCEGw67hucUQpszI1BE6qv7LDh8lKdRohcIwKJ6h4ZZ5tqzWBZ/A/wKOyJaBm26AYphzEySmecYTgUKj64f00hMQCRYinQJEmqHkdq11268UQHScwh9eyQPcxMfikwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"github\"\n        title=\"\"\n        src=\"/static/0efc4f9c801424810a357b6fc99677ad/31198/github.png\"\n        srcset=\"/static/0efc4f9c801424810a357b6fc99677ad/fe9c7/github.png 174w,\n/static/0efc4f9c801424810a357b6fc99677ad/39e45/github.png 347w,\n/static/0efc4f9c801424810a357b6fc99677ad/31198/github.png 694w,\n/static/0efc4f9c801424810a357b6fc99677ad/ee9b6/github.png 1041w,\n/static/0efc4f9c801424810a357b6fc99677ad/c1bea/github.png 1388w,\n/static/0efc4f9c801424810a357b6fc99677ad/2b8ee/github.png 5090w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\n디자인은 GitHub를 상당 부분 참고했다. 특히 서치 바, 프로필, 태그, 색상 등에서 그 흔적을 많이 느낄 수 있다. 심플함을 가진 레퍼런스를 찾던 중 가장 많이 방문하는 곳 중 하나인 GitHub를 떠올린 것이다. 어쩌면 지겹게 느껴질 수 있지만 그만큼 익숙하기 때문에 거부감이 없는 테마라 생각했다. 이 밖에도 <a href=\"https://beta.reactjs.org/\">React Docs Beta</a>, 벨로퍼트님의 <a href=\"https://velog.io/\">velog</a> 등에서 영감을 받았다.</p>\n<br />\n<h3 id=\"반응형-디자인\" style=\"position:relative;\">반응형 디자인<a href=\"#%EB%B0%98%EC%9D%91%ED%98%95-%EB%94%94%EC%9E%90%EC%9D%B8\" aria-label=\"반응형 디자인 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div style=\"width: 200px; margin-left: auto; margin-right: auto\">\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f7fe32f9e70a3cc254e23352289f4825/e17e5/rs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 202.29885057471267%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGu0lEQVR42p1XW2xcRxk+sZs4tnfPOXvulz3n7NW7Xtvx7tq79nrX67Udr+1cnFtjpyFVRVUQUFUCiQee4ImHCrAUeABEJKiqPEGlNiSiVVWEQI2aqhfV6kNbghR4QIAoSOUBNZHOxz+zsROndt1i6ddcduabf873zTdjYb1QmDtbqfz3mcuX8YfXXgtfff11lMbGIAgCurq6eLkV+7rR1b2f18vj47hOY1+9cSP88aVLOFkuf/z9fH5BWNH157+3vo4PPvjj7WtXr+HNN9/C+g/WUalU0Gg0wub0dNiaaVHMhDOsbM2GkxMT4cWLF7GxsYGXfvMirly5cue7Tz+NY4ZxVVh23HdlN0B+pBxSIMgWkBwYxlCxiqFSFZnBUd6+P1ifnx6E5iR4mRsuhaLpYtl13xNauvknLz+Mp77+zfDU6hfw2BNfhWYnkBsqo1xtQDE89EkG+mVzW0QVGxHFQvv4aRw5sRoKvSIW4vFbQsswbvYZLkw3FUqaC8tL85UV0+OhWj4tEOwYKoXuJFk9PKiYmDOMW7Rl529Cnww5Zoei6iBCq0ciCqKihihrxyxE9whJscOH+uUO4PlUEgwwRtlFogQk6ZDSoxC9PCI0iE04GNXQ06/gYERFL9UPUL2H6pt9HDAS6wAuWtZfuqIqRFEPY5kiBr7zDDI/u4HgR7+Dff5blLGB4vgU5hdX0GgtotacR3NuEVPNBTRm22jOL0M1/LCbZWgaf2Zb/us+tkpUDcvf/gXqr/wLg5c3kHt2A4PP3YJ+/Mso5EdQrDYxXJpAJj+K1MAI/NQgDy+Zh6y6YTdlOM8yXEsm77AtK/S9yt/4Ic78/iM8fv0/OP3y37F6/SOsXHwOycwQ0vmOVKx4Cv3Eep+obwXbchdluGzb/xRW7wLGVBvtC1/Dk796A0/+9AX85MpvcfXX1/Clx7+CIFNAqVLHaHkSw6MVVOstZEmLjECR5CMrDvEg4azvQzjpxf8t9McgEsszSydQqk4hkU6gXC6h0ZyG6WeJGJv06EPW44hRyEQgkxjrZ3qkLXPAM54XCsdc9x/7iC1JNsIeEmckIsE2bdiWQ8xbiIgqj35in5c8NApSBBHG+mguhH4GSBmuJRN3hF4Zuj8KPVODlp6EaA0g5hchOwWoiTL1TUCyslCDErXHqJ+OXaoK2cpROQE9KFKGYmfLnJReCe7IMvzJC/AqazALC3BLp6BnpxEfOwNvfJVA64hXVmEXV2DkZhFMPQYlKMMeWYI1MB3uI8AjjvOhsOJ5HzJSnKF2aBbaUBJVAj7PgZVEBfaho9AydQ7iTTwCNTkJa6gNh4BFPUB/VIZIn2tL2HOGeZNR7owshcnmEzR4EfpAkzJ4FInGFwloBtbwEuLl0wTcgDN6nIhghJido0ekSIpzT4dz5DbddHZjRjKUzDStmoBEK8tUl60MRC3gbUlPUt2HaCQ4yINneT+RM2+aLEPjJgOUFCuMMlu6L0SyJ5FP6JQiz2ZnczhAKuCA81uAdrg5gE1kJpDKjZDXncXswlHUW206z8f5cWOnQ7wvyw6g9mCG9wBZsONFHoniWA1Dh8aRzR/CIDn65tH7ZIZ7ALJjxU6FHeQJOEOmm4JBJetjv+0KOL8LIP+ORIhdfhhatgWDtOkQ01HFu8fw5wLcJIFYFTWPB68/wPCuW5ZVJ2SDPxGxTbbvljuMYXM/c4bMWRiQpDmcjD0z/HRAC63DR7CwfBJHT67i8PKJXS+pPQEZkxpdoew+KY7XSDJjdE/XqS/4dJbndhS2w82TGarlZUkuKbqfExR0JHXGsrO7sLdnSK8BOkKKX4Jfu4CgThZFtmWQC/m1R+GOn4WaqpF8TiEWH+Zj2Zw9tkxskqV3zCHNDYGbA7UlM0W/xUk+ZBTccT6rbLiwjU6wBdhn4IZhcPls9e0kmx2PnmJvBRc3XbESZc3Kbb9/HpZZBn2iwRmdbR9DixyHvbpYn6j8P7IhEbtBhjtMbqiIdG4YA4Ui4kGWbjx99wwPO87Nrp2ETR9dJ3dxE3lYfo7qaXKeHIz4AL0LnR0zPOy6t4Ql2353f1TdBsiyMwfn4NDNF6NLKV45R/fKESjJGuLV83Td1u9K5h5gD7UXbft9Yc33XzhIlza9DW9L3OI7IWvspUBCJpeJkcvIOrVJMjGDJKTFcf9YIuxODz0FH/b8a8LPG7X5MU37+KGIjAOiFu6nH9iFwx6QXb3RuxHZVmdXJhvDgs1hc0uqdvvS1FRbYH/Pz842n8rl3n4kEYTnkolwLR4P1zx/j/B4nPP9kOa+80v6F4Fh/Q8pXkyL9rwsTAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"smaill\"\n        title=\"\"\n        src=\"/static/f7fe32f9e70a3cc254e23352289f4825/e17e5/rs.png\"\n        srcset=\"/static/f7fe32f9e70a3cc254e23352289f4825/fe9c7/rs.png 174w,\n/static/f7fe32f9e70a3cc254e23352289f4825/39e45/rs.png 347w,\n/static/f7fe32f9e70a3cc254e23352289f4825/e17e5/rs.png 400w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n</div> \n<div style=\"width: 300px; margin-left: auto; margin-right: auto\">\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d00d5e6c57d16a63b880dd069d082642/61016/rm.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.50574712643677%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAAAsTAAALEwEAmpwYAAAERUlEQVR42pVVy67bVBTNhLY3cezEdl6O33ldO3He9k2TUqlqBR/AhCmM4DsYIDHkTgoDBEx4qCN6i8SUf2GABIgiHkWNvNj7xMl1UqTCYOmcs4+9fM5ea28X1uv15WKx+D1Jkp/iOP4lTgj7kbBcLgg8T8Rc7OWwXC5/3mw2z1ar1XZz584Hhfl88dfDjz7Gp599nn7x5Vf45vEVHl89+c+4evItvn70KP3w8hJRNP610Ol2n2/uvZ4yBqNF6vejtO30U9M738EPUncQpV4Obn90gN0N00G0TIezC9iO80fB8zvbSs2E1nAgawbK1SakSgMlWUfxTIZUrKBU1nBWprVcEyjRvsTPZVD0dlpWm3Ac91nBJ0J+WFLqgogJyzRXmh6sd9+H+vZ7aHbHCKMFusEU3fMJ6i2XPlhDmZ/fIS1KKhzX/VMQ8hdl1SC06JRtFEsq2vN7eOO7H/DW9z9i/eY7sO0eLD+E2rCzm7RQpufFWG2lklKDaVm/CcKirNEJdfpSTYCv2zA7WN59gNfu34fnD6A1bTTbHhS6Gr/MJ5MqdYEjQs91t1VrjObwATQvRq23geYuUbUmkJsBysYISjuiPYrZM6gU12mu2lMRU+2JuPI1oeduK0YAvbNGhYg1dwGl7kHWLSg1h2AfQ8Tt3b6+W1OqcoS+v5WrDZwPOeFjcaUzUrWUKVokwYTi5QxybtxDqael6xP6W0U3EIxj9IdzON0h2u4A5EEByw92c4rZnVDsu70RHALv8domr5bpUKaZEVb0NqL5OsNtRLMVhoxpgrEYLxDSB2fJq+iFM0Hs9SNB6IoPRBmhySr7W4mk50Rr7pxyY0JmLx6hJTzKthKmJ5+e4Ng2HMwTCD/+P+RVphySUafxHbpWcjjNKUpZJf1bnA6Rsh9zhC0MJzERLtELxuiR2j0qs344F0J1qNw4dxzbxWdizWXIc8PuC5Uty94RcgkNpnfRGa3QG2/QH69J6XNqGDbqhge96RxQozrOrxkkqjihINzlsAGFKqJihKiaEZRWAEltCy/uEy+9KMT1Hl2ZS/Ha2GTmlulnNcqon6j8UqTSgVD40KCczEVD4G7CKWChGOzRKvXL/JqRn1d0c+fDvCjRLMF0sUI0jTEiQ3PlcOL3AuxHIUYmjACJxh2eT3og5F7ohGtYwRp2uIHhT6imWy+cZH9Kgdxa4m6zv/Le2CXVgqRRd6n7opPIJwZ/ieGPReH7s/cMu0vKXnca9tbpuEP98H/ZxevHovCxJ8sNwklCXeWcc8IdRHQda995eDyBlXUjw+4d5fC5Qv+RgMqOCUez26IEuUWJdkUQHaVLa5/XQyIKRNzOoNbtjNB+yt3m77NyDZozFy2ezc3/mBv0+7xZrOLGmYJXbskCPOfYzRIh2+fxlqSmRWrK9Nd7Wojj5JMwHGI0nqajaAKBUURjhlEO+Vh0tE6DIMTFxcXDfwCjzQiMk4vYRwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"medium\"\n        title=\"\"\n        src=\"/static/d00d5e6c57d16a63b880dd069d082642/31198/rm.png\"\n        srcset=\"/static/d00d5e6c57d16a63b880dd069d082642/fe9c7/rm.png 174w,\n/static/d00d5e6c57d16a63b880dd069d082642/39e45/rm.png 347w,\n/static/d00d5e6c57d16a63b880dd069d082642/31198/rm.png 694w,\n/static/d00d5e6c57d16a63b880dd069d082642/ee9b6/rm.png 1041w,\n/static/d00d5e6c57d16a63b880dd069d082642/c1bea/rm.png 1388w,\n/static/d00d5e6c57d16a63b880dd069d082642/61016/rm.png 1770w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n</div> \n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f654d563b1743f261e25b830ec7a4a7e/1d243/rl.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.47126436781609%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEklEQVR42n2RTU8TURSGu+iCJm6aoGFa2gkQEzVs1Jg40RA3M7hqrMZ/4JYu2LHwhyArCRo3xoUkth1I2yUIrRQTP5BFFVri2M7Mbct8de7rnWFoKRFP8mZOcs489z3nhEIsOI67PRZPOlNXr2Ocn6Tx5AQ8XYklmRK4zI3/U6NjccolJsDFkxY3OnordBrRaFRYWXlFy1/2sLFdodXqZ3za2cXmVhkbH7dR2aky7Z5TFVvlCv22t4/FF0suw9ztA29O8cLLt+/ps80Olr+2KII47nahqSp6vd6QHMfxv5Zl+b25XG4YeGd6Wlhafk1TmedYfPPOb3JdF2q7i1pDwW9FgRLIy5vNFnRC0GqdPJ7NZoeBsRgv5PN5WvvxHUeHh/TUomGa6DCXFwVz6bcWCgU3HA6fBcaE9bU1v9hznP7IeruNnwd1KMyRqmrQNB26TqDpXq71HZZKpWEgz4Af5HXaZsV626F/DNcHdk0HDd2AQoz+3s7u0bJtH1gsFhkwMgxclYu0bgM11aYH5ARoGgYs0wDYEs4fxj/KRcBEYvK+HIzMjkFpsEXSOcb+ryM0lCYIOwJhKyAkEMtbqtYfeWTk0r2BQ54XZFkeAIMdmrYDYliwe/S/R/EcRiKBw7m5hRvp9NPMzMwDKoqzEKVZygRJeghRlCAxpdOPkUo98moDeb2iRL0+9q+bSj3JzM8vXPsLDppZ/Ei4AUoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"large\"\n        title=\"\"\n        src=\"/static/f654d563b1743f261e25b830ec7a4a7e/31198/rl.png\"\n        srcset=\"/static/f654d563b1743f261e25b830ec7a4a7e/fe9c7/rl.png 174w,\n/static/f654d563b1743f261e25b830ec7a4a7e/39e45/rl.png 347w,\n/static/f654d563b1743f261e25b830ec7a4a7e/31198/rl.png 694w,\n/static/f654d563b1743f261e25b830ec7a4a7e/ee9b6/rl.png 1041w,\n/static/f654d563b1743f261e25b830ec7a4a7e/c1bea/rl.png 1388w,\n/static/f654d563b1743f261e25b830ec7a4a7e/1d243/rl.png 3856w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>반응형 디자인은 크게 세 구간으로 나뉜다. 가장 큰 사이즈에서는 왼쪽 영역에 프로필, 태그, 연재 목록을 보여준다. 중간 크기에서는 연재물 영역을 제외하고 프로필과 태그를 상단에 배치한다. 작은 사이즈에서는 포스트의 미리보기 내용을 제외한다. 연재물과 태그가 일정 수준 이상으로 많아지는 경우에 대해서는 여전히 고민할 필요가 있다.</p>\n<br />\n<h3 id=\"주야간-모드\" style=\"position:relative;\">주야간 모드<a href=\"#%EC%A3%BC%EC%95%BC%EA%B0%84-%EB%AA%A8%EB%93%9C\" aria-label=\"주야간 모드 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><img src=\"/d05a7acb7657e0dca675bbb645a5eac1/switch.gif\" alt=\"darkmode\"></p>\n<p>심플하기 때문에 재미없게 느껴지기도 한다.<br>\n그래서 주야간 모드 버튼에 나름 신경을 썼는데 해놓고 보니 좀 식상한 것 같기도...</p>\n<br />\n<h3 id=\"lighthouse\" style=\"position:relative;\">Lighthouse<a href=\"#lighthouse\" aria-label=\"lighthouse permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.839080459770116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA50lEQVR42j2OSU7DQBBFfYsgEg9dPbjdbXcsHGdgVJAQ4QJEbLj/LR4dL1h8PZVK9eoXIgpRghZB1Q3l1nF3GakGyypzM3esn3vW54Fq8qy+RnSwvHxc8DHS1DVKKVSjFhbGGoyxOGuRLJRdpP55Qk+Z10fU6zbLEvef+UmWb64npLNcfr+JY6IqS0IM7B4mjDYU2gi+zcLW5W8NMfTM854+DszTjtQnDvsjp8NpaZHSlrpqGGKPiKYsa8Zx5P38Ruc9xa2Zs44QHCl4vNO0Rv2ztZKPPSkneIvP88K8v3FJ6LDZo7XmDw2WdvecXItKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"lighthouse\"\n        title=\"\"\n        src=\"/static/09a27031816ab4bdd9fcbe99c031eeb4/31198/lighthouse.png\"\n        srcset=\"/static/09a27031816ab4bdd9fcbe99c031eeb4/fe9c7/lighthouse.png 174w,\n/static/09a27031816ab4bdd9fcbe99c031eeb4/39e45/lighthouse.png 347w,\n/static/09a27031816ab4bdd9fcbe99c031eeb4/31198/lighthouse.png 694w,\n/static/09a27031816ab4bdd9fcbe99c031eeb4/ee9b6/lighthouse.png 1041w,\n/static/09a27031816ab4bdd9fcbe99c031eeb4/c1bea/lighthouse.png 1388w,\n/static/09a27031816ab4bdd9fcbe99c031eeb4/46cee/lighthouse.png 1687w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span><br>\nLighthouse 100점을 달성하면 크롬에서 폭죽이 터진다. 항상 100점이 나오는 것은 아니지만 개츠비 앱에서는 쉽게 고득점을 받을 수 있다. 크롬에서 부족한 점을 잘 알려주기 때문에 문제를 파악하고 수정하는 것은 어렵지 않다. SEO도 개츠비에서 제공하는 <a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-react-helmet/\">gatsby-plugin-react-helmet</a> 플러그인이나 <a href=\"https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/\">Head API</a>를 활용하여 <code>&#x3C;head /></code> 태그 내에 원하는 <code>&#x3C;meta /></code> 태그를 쉽게 포함시킬 수 있다. 폭죽을 보기 위해서는 모든 영역이 100점인 것 이외에도 <a href=\"https://developer.mozilla.org/ko/docs/Web/Progressive_web_apps/Introduction\">PWA(Progressive Web App)</a>의 조건을 만족해야 한다. PWA로 구현하면 일부 화면에서 오프라인 모드를 제공할 수 있고 디바이스 홈 화면에 아이콘 추가 등이 가능하다. 이 역시 후술하는 플러그인으로 쉽게 구현이 가능하다.</p>\n<br />\n<h2 id=\"4-내가-경험했던-개츠비\" style=\"position:relative;\">4. 내가 경험했던 개츠비<a href=\"#4-%EB%82%B4%EA%B0%80-%EA%B2%BD%ED%97%98%ED%96%88%EB%8D%98-%EA%B0%9C%EC%B8%A0%EB%B9%84\" aria-label=\"4 내가 경험했던 개츠비 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>개츠비는 훌륭한 DX(Development Experience)를 제공한다. 적은 경험으로도 다양한 편의성을 제공하는 유용한 프레임워크라는 사실 정도는 느낄 수 있었다.</p>\n<br />\n<h3 id=\"다양한-렌더링-옵션\" style=\"position:relative;\">다양한 렌더링 옵션<a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%98%B5%EC%85%98\" aria-label=\"다양한 렌더링 옵션 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>개츠비에 대해 검색하면 정적 사이트 생성 도구라는 단어를 쉽게 찾아볼 수 있지만 다른 렌더링 옵션도 제공한다. 블로그는 정적 사이트 생성으로도 충분하겠지만 다른 선택지가 있다는 점이 마음에 들었다.</p>\n<ul>\n<li>SSG(Static Site Generation)</li>\n<li>DSG(Deferred Static Generation)</li>\n<li>SSR(Server Side Rendering)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/927ef49dc4ab4269a5e8c87d6739097a/d165a/ssg-diagram.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.32183908045977%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB3FrFkImn/8QAGBABAQEBAQAAAAAAAAAAAAAAAgEDABH/2gAIAQEAAQUC85KZgbFztZLnkDD/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAEA/9oACAECAQE/ASQv/8QAGRABAAMBAQAAAAAAAAAAAAAAAQAQETEC/9oACAEBAAY/AusfTyabSNf/xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMYFBUf/aAAgBAQABPyHZaOxyFHYs0GskqG5iMAPfs//aAAwDAQACAAMAAAAQB8//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEx/9oACAEDAQE/EDsht//EABcRAQEBAQAAAAAAAAAAAAAAAAEAESH/2gAIAQIBAT8QwpsF5f/EABwQAQACAgMBAAAAAAAAAAAAAAEAESFBMVFh8P/aAAgBAQABPxBOAFt0JSG1Uyy1DYBYwZ+YCuLvuWEGFg1s6iuwW8nR7P/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ssg-diagram\"\n        title=\"\"\n        src=\"/static/927ef49dc4ab4269a5e8c87d6739097a/9c477/ssg-diagram.jpg\"\n        srcset=\"/static/927ef49dc4ab4269a5e8c87d6739097a/583d1/ssg-diagram.jpg 174w,\n/static/927ef49dc4ab4269a5e8c87d6739097a/4d0aa/ssg-diagram.jpg 347w,\n/static/927ef49dc4ab4269a5e8c87d6739097a/9c477/ssg-diagram.jpg 694w,\n/static/927ef49dc4ab4269a5e8c87d6739097a/909c7/ssg-diagram.jpg 1041w,\n/static/927ef49dc4ab4269a5e8c87d6739097a/8d810/ssg-diagram.jpg 1388w,\n/static/927ef49dc4ab4269a5e8c87d6739097a/d165a/ssg-diagram.jpg 1400w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\n정적 사이트란 미리 생성된 HTML을 제공하는 형태의 사이트를 말한다. 개츠비는 기본적으로 SSG로 생성된 페이지를 CDN을 통해 제공한다. 동적 사이트와 달리 빌드 타임에 미리 만들어진 파일을 제공하기 때문에 HTML을 받아온 이후로는 동적인 네트워크 통신이 거의 발생하지 않는다. 방문자는 상대적으로 빠른 페이지 로딩을 경험할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0c66620c7ea66f7f08ec19cab31d2a13/d165a/dsg-diagram.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.47126436781609%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAG4u1PbfMgn/8QAGhABAAIDAQAAAAAAAAAAAAAAAQIRAAMEE//aAAgBAQABBQKs27vIGzOsEjCNf//EABcRAQEBAQAAAAAAAAAAAAAAAAEAIQL/2gAIAQMBAT8B4Bdsv//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ASf/xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQAiFB/9oACAEBAAY/AukabHWNf//EABwQAAMAAgMBAAAAAAAAAAAAAAABESExQVFhkf/aAAgBAQABPyGFXfoRa2TklxtUawVFdilzcbz4f//aAAwDAQACAAMAAAAQNz//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEx/9oACAEDAQE/ECJxJq//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAECAQE/ECL2cv/EABwQAQADAAIDAAAAAAAAAAAAAAEAESFhcTFRwf/aAAgBAQABPxBxBbeL5H639NQwkBUeS4XhnWTcKmmvEMB2dDWh74n/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"dsg-diagram\"\n        title=\"\"\n        src=\"/static/0c66620c7ea66f7f08ec19cab31d2a13/9c477/dsg-diagram.jpg\"\n        srcset=\"/static/0c66620c7ea66f7f08ec19cab31d2a13/583d1/dsg-diagram.jpg 174w,\n/static/0c66620c7ea66f7f08ec19cab31d2a13/4d0aa/dsg-diagram.jpg 347w,\n/static/0c66620c7ea66f7f08ec19cab31d2a13/9c477/dsg-diagram.jpg 694w,\n/static/0c66620c7ea66f7f08ec19cab31d2a13/909c7/dsg-diagram.jpg 1041w,\n/static/0c66620c7ea66f7f08ec19cab31d2a13/8d810/dsg-diagram.jpg 1388w,\n/static/0c66620c7ea66f7f08ec19cab31d2a13/d165a/dsg-diagram.jpg 1400w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nDSG 옵션으로 일부 페이지의 생성을 지연시킬 수 있다. 예를 들어 트래픽이 거의 없는 페이지는 생성을 미뤘다가 요청이 발생할 때 만들어 제공한다. 처음부터 모든 페이지를 준비하지 않기 때문에 초기 빌드 시간이 오래 걸리는 SSG의 단점을 보완할 수 있다. 다만 빌드 이후에도 요청에 대응할 수 있는 서버가 실행 중이어야 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7c6eea7162dc472bb260180809aba437/d165a/ssr-diagram.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.36781609195403%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAdwnFlqh/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEDERP/2gAIAQEAAQUCwpXkk9RSSoJYv//EABcRAAMBAAAAAAAAAAAAAAAAAAEQESH/2gAIAQMBAT8BNmL/xAAXEQADAQAAAAAAAAAAAAAAAAABEBEh/9oACAECAQE/ARLq/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERQRD/2gAIAQEABj8C0VTE+K4Q/8QAGhABAQEAAwEAAAAAAAAAAAAAAREAMUFhUf/aAAgBAQABPyGLyL7ioFxfcLkwwSeMRjom/9oADAMBAAIAAwAAABAoP//EABgRAAMBAQAAAAAAAAAAAAAAAAARIQFB/9oACAEDAQE/ELOjGqf/xAAYEQACAwAAAAAAAAAAAAAAAAAAEQEhcf/aAAgBAgEBPxDIJTo//8QAHRABAAMAAwADAAAAAAAAAAAAAQARITFBYVFxgf/aAAgBAQABPxBDlFh8ol7MxLz9ghwID6SiqynruE37Vk5+5qMEF8J//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ssr-diagram\"\n        title=\"\"\n        src=\"/static/7c6eea7162dc472bb260180809aba437/9c477/ssr-diagram.jpg\"\n        srcset=\"/static/7c6eea7162dc472bb260180809aba437/583d1/ssr-diagram.jpg 174w,\n/static/7c6eea7162dc472bb260180809aba437/4d0aa/ssr-diagram.jpg 347w,\n/static/7c6eea7162dc472bb260180809aba437/9c477/ssr-diagram.jpg 694w,\n/static/7c6eea7162dc472bb260180809aba437/909c7/ssr-diagram.jpg 1041w,\n/static/7c6eea7162dc472bb260180809aba437/8d810/ssr-diagram.jpg 1388w,\n/static/7c6eea7162dc472bb260180809aba437/d165a/ssr-diagram.jpg 1400w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span><br>\nSSR 옵션도 제공한다. 개츠비에서는 다른 두 옵션의 사용을 권장하지만 필요에 따라 최신화된 페이지를 제공해야 한다면 <code>getServerData</code>함수의 호출로 써드파티에 데이터를 요청할 수 있다.</p>\n<br />\n<h3 id=\"react와-graphql\" style=\"position:relative;\">React와 GraphQL<a href=\"#react%EC%99%80-graphql\" aria-label=\"react와 graphql permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 694px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/07250c1d3f3699de63cc06d66c57c650/57e3f/GraphiQL.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.57471264367817%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABL0lEQVR42pWS6U7DMBCE+/7vws8+CxKHhMrRA1NaH2t7bWcYp1VQVEB0pVEcZ/15NrsL5wS1NVhrYd73fHocKQmCGCMSJSLcs7DOncX1URA+dijJoNZWwKi1Lhd2T6C28XAQxdAGDANG4azGPYkJMeWTcoZ4xWH1gnh4ZEIagTnn5SITUnNhYkSpDT9FYwVB4gid5BP89nZ0yPgGKuG1tP6C3+ICyMsDHbrtA0pcT0DmERg7sCLrNcDuMMNtVlD/PAEZLDmwZL0SSIUQkOXYv84dhs80NuVah95R5pUl7+ZAHwhkF0sp7Ozwb2BwCvt2hxxWc6Cwwx34V/SLek5PG9VnTrlnn7iw83/oJBkOpkkpGc6iodMLqaqhQ0N3JzE3uGzc5t6orA3v2Pap0aw3X49nDCLAtrpyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"GraphiQL\"\n        title=\"\"\n        src=\"/static/07250c1d3f3699de63cc06d66c57c650/31198/GraphiQL.png\"\n        srcset=\"/static/07250c1d3f3699de63cc06d66c57c650/fe9c7/GraphiQL.png 174w,\n/static/07250c1d3f3699de63cc06d66c57c650/39e45/GraphiQL.png 347w,\n/static/07250c1d3f3699de63cc06d66c57c650/31198/GraphiQL.png 694w,\n/static/07250c1d3f3699de63cc06d66c57c650/ee9b6/GraphiQL.png 1041w,\n/static/07250c1d3f3699de63cc06d66c57c650/c1bea/GraphiQL.png 1388w,\n/static/07250c1d3f3699de63cc06d66c57c650/57e3f/GraphiQL.png 2598w\"\n        sizes=\"(max-width: 694px) 100vw, 694px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n개츠비는 리액트를 기반으로 GraphQL을 적극 활용하고 있는 프레임워크다. 둘 다 회사에서 사용하고 있는 메인 스택이기 때문에 익숙해질 수 있다는 점에 있어서 고민해야 할 이유는 그리 많지 않았다. GraphQL을 사용하는 방식도 흥미롭다. GraphQL로 원하는 모양의 데이터를 쿼리할 수 있지만 네트워크 요청은 발생하지 않는다. 개츠비는 빌드 시점에 모든 데이터를 수집하고 스키마를 추론하여 데이터를 생성한다. 개발 환경에서 GraphiQL도 제공하기 때문에 직접 쿼리를 날려 보고 Docs도 확인할 수 있다.</p>\n<br />\n<h3 id=\"graphql-typegen\" style=\"position:relative;\">GraphQL TypeGen<a href=\"#graphql-typegen\" aria-label=\"graphql typegen permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>타입스크립트를 활용하고 있다면 자동으로 타입을 생성해 주는 <a href=\"https://www.gatsbyjs.com/docs/how-to/local-development/graphql-typegen/\">TypeGen</a>을 추천한다. 다만 모든 타입을 <code>nullable</code>로 생성하기 때문에 무수한 옵셔널 체이닝을 강제한다는 단점이 있지만 그것에서 벗어날 방법이 없는 것은 아니다. 설정 파일에서 GraphQL 스키마를 커스텀할 할 수 있기 때문에 <a href=\"https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/\">공식 문서</a>를 참고하여 타입을 다시 정의하면 된다. 참고로 TypeGen은 개츠비 4.15버젼 이후부터 지원한다.</p>\n<br />\n<h3 id=\"유용한-플러그인\" style=\"position:relative;\">유용한 플러그인<a href=\"#%EC%9C%A0%EC%9A%A9%ED%95%9C-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8\" aria-label=\"유용한 플러그인 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>다양한 플러그인은 개츠비의 강점이다.</p>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-sharp\">gatsby-plugin-sharp</a> - 최적화된 이미지를 제공한다.</li>\n<li><a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-manifest/\">gatsby-plugin-menifest</a> - 프로그레시브 웹 앱을 구현을 위한 <a href=\"https://developer.mozilla.org/ko/docs/Web/Manifest\">매니페스트</a>를 제공한다. 아이콘, 파비콘 등을 자동으로 생성하고 디바이스 홈 화면에 바로가기를 추가할 수 있도록 한다.</li>\n<li><a href=\"https://www.gatsbyjs.com/plugins/gatsby-remark-autolink-headers\">gatsby-remark-autolink-headers</a> - 마크 다운 제목에 자동으로 링크를 붙여준다.</li>\n<li><a href=\"https://www.gatsbyjs.com/plugins/gatsby-plugin-offline\">gatsby-plugin-offline</a> - 오프라인 기능을 제공한다.</li>\n</ul>\n<p>이 밖에도 코드 하이라이팅, 사이트맵 생성 등 유용하게 활용할 수 있는 <a href=\"https://www.gatsbyjs.com/plugins/#top-plugins\">플러그인</a>이 정말 많다.</p>\n<br />\n<h3 id=\"hydration\" style=\"position:relative;\">Hydration<a href=\"#hydration\" aria-label=\"hydration permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>개츠비는 기본적으로 리액트의 <a href=\"https://ko.reactjs.org/docs/react-dom-client.html#hydrateroot\">hydraton</a>을 사용한다. hydraton은 쉽게 말해 빌드 타임에 만들어진 마크업을 먼저 보여주고 나중에 스크립트를 붙이는 방식이다. 물이 더해져 다른 물질로 변하는 화학적 현상을 hydraton이라고 하는데 여기서는 자바스크립트가 물이고 단순 마크업에서 리액트 컴포넌트가 되는 과정을 hydraton(또는 rehydration)에 비유한 것 같다. 클라이언트 사이드 렌더링은 서버로부터 JS 번들을 다운받고, 파싱하고, 평가하느라 초기 로딩 속도가 느리고 검색 엔진 최적화에 상대적으로 불리하다. 반면 서버 사이드 렌더링에서는 이미 만들어진 마크업을 빠르게 보여줄 수 있기 때문에 <a href=\"https://web.dev/interactive/\">TTI</a>가 높고 검색 엔진 최적화에 유리하다. 전형적인 리액트 개발 환경에서 서버 사이드 렌더링을 경험해 본 적이 없기 때문에 생소한 개념이었는데 개츠비 공식문서에 자세한 설명이 되어 있어 조금이나마 이해할 수 있었다.</p>\n<p>하이드레이션 때문에 발생하는 문제도 있다. <a href=\"https://beta.reactjs.org/apis/react-dom/hydrate#avoiding-unavoidable-hydration-mismatches\">hydration mismatches</a> 또는 <a href=\"https://blog.logrocket.com/fixing-gatsbys-rehydration-issue/\">rehydration issue</a>라고 한다. 이미 생성된 마크업을 먼저 보여주기 때문에 발생하는 문제로, 만약 첫 화면에서 자바스크립트 코드로 로컬 스토리지의 데이터를 가져와 무언가를 다르게 보여줘야 한다면 결과는 기대처럼 보여지지 않을 가능성이 높다. 왜냐하면 초기에 로딩된 페이지에는 수분이 없기 때문이다. 개츠비로 개발을 하다 보면 로컬 개발 환경과 배포된 페이지가 초기 화면에서 다르게 보이는 것을 종종 경험할 수 있다. 그리고 이런 문제가 새로고침, 혹은 페이지 전환 후에는 발생하지 않는다는 점도 발견할 수 있다. 만약 이 현상을 겪었다면 앞서 언급한 내용을 경험한 셈이다. 나의 경우에는 초기 화면에서 특정 스타일 코드가 먹히지 않는 현상이 있었는데 <code>useEffect</code>를 통해 해결할 수 있었다. 배포 전에 <code>gatsby develop</code>이 아닌 <code>gatsby build &#x26;&#x26; gatsby serve</code>로 실행된 화면에서 한번 더 확인하는 것이 좋다.</p>\n<br />\n<h2 id=\"5-참고\" style=\"position:relative;\">5. 참고<a href=\"#5-%EC%B0%B8%EA%B3%A0\" aria-label=\"5 참고 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여러 훌륭한 프로젝트에서 영감을 받았다. 이미 언급한 바와 같이 GitHub의 디자인을 참고했다. 이외에도 <a href=\"https://hudi.blog/gatsby-starter-hoodie-dev-log/\">Hudi님의 블로그</a>, 그 곳에서 언급된 <a href=\"https://junhobaik.github.io/\">Junho Baik님의 블로그</a>, 그리고 여러 지식을 공유하는 <a href=\"https://jeonghwan-kim.github.io/\">김정환님의 블로그</a>를 참고했다. 개츠비 사용 방법, 블로그의 요구사항, 심플하고 미니멀한 디자인 등에 큰 도움을 받았다.</p>\n<br />\n<h2 id=\"6-계획\" style=\"position:relative;\">6. 계획<a href=\"#6-%EA%B3%84%ED%9A%8D\" aria-label=\"6 계획 permalink\" class=\"header-anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여전히 숙제가 많이 남아있다. 실제 사용 경험이 거의 없기 때문에 내가 직접 사용하면서 경험하게 될 문제를 해결해야 한다. RSS Feed, MDX 지원도 고려하고 있다. (혹시 제가 만든 앱을 사용하시는 분이 계시다면 피드백은 언제라도 환영입니다 😀)</p>","fields":{"slug":"/gatsby/Gatsby_기술_블로그_개발_후기","title":"Gatsby 기술 블로그 개발 후기"},"frontmatter":{"created":"2022-11-14","updated":"2023-08-22 00:35:57 +0900"}}}]}}}