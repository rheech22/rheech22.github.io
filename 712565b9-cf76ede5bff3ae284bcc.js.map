{"version":3,"file":"712565b9-cf76ede5bff3ae284bcc.js","mappings":";0MAQA,MAAMA,EAAkB,CACvB,WACA,YACA,aACA,gBACA,qBACA,QACA,mBACA,sBACA,UACA,YACA,eACA,qBACA,uBACA,qBACA,QACA,aACA,kBACA,WACA,cACA,SACA,cACA,MACA,cACA,iBACA,iBACA,0BACA,WACA,MACA,SACA,YACA,eACA,YACA,cACA,UACA,YACA,eACA,QACA,aACA,gBACA,oBACA,YACA,WACA,gBACA,mBACA,oBACA,uBACA,cACA,YACA,eACA,mBAQD,MAAMC,EAOL,WAAAC,CAAaC,GAQZC,KAAKC,cAAgB,IAAIC,QAOzBF,KAAKG,QAAUH,KAAKI,aAAcL,GAOlCC,KAAKK,cAAgD,IAAjCN,EAAQO,OAAOC,cAOnCP,KAAKJ,gBAAkBA,EAQvBI,KAAKQ,SAAW,CAEjB,CAQA,mBAAAC,CAAqBC,GAIpB,OAAwB,IAFDV,KAAKC,cAAcU,IAAKD,KAI9CV,KAAKY,oBAAqBF,IAEnB,EAMT,CAQA,mBAAAE,CAAqBF,GAEpB,IAAIG,EAAOb,KAAKC,cAAca,IAAKJ,GAEnC,QAAcK,IAATF,EAAqB,CAEzB,MAAM,SAAEG,EAAQ,SAAEC,EAAQ,OAAEX,GAAWI,EA8BvC,GA5BAG,EAAO,CACNI,SAAUjB,KAAKkB,gBAAiBD,GAChCD,SAAU,CACTG,WAAYnB,KAAKoB,kBAAmBJ,EAASG,YAC7CE,aAAcL,EAASM,MAAQN,EAASM,MAAMC,QAAU,KACxDC,UAAW,CAAEC,MAAOT,EAASQ,UAAUC,MAAOC,MAAOV,EAASQ,UAAUE,QAEzEC,YAAarB,EAAOsB,YAAYC,SAG5BvB,EAAOwB,SAEXjB,EAAKiB,OAASxB,EAAOwB,OAAOD,SAIxBvB,EAAOyB,wBAEXlB,EAAKkB,sBAAwBzB,EAAOyB,sBAAsBC,SAI9B,OAAxBtB,EAAauB,SAEjBpB,EAAKU,QAAUb,EAAauB,OAAOV,SAI/BV,EAAKI,SAASiB,aAAe,EAAI,CAErC,MAAM,MAAEC,EAAK,OAAEC,GAAW1B,EAAa2B,QAEvCxB,EAAKyB,YAAcH,EACnBtB,EAAK0B,aAAeH,CAErB,CAEApC,KAAKC,cAAcuC,IAAK9B,EAAcG,EAEvC,CAEA,OAAOA,CAER,CASA,iBAAAO,CAAmBD,GAElB,MAAMsB,EAAiB,CAAC,EAExB,IAAM,MAAMC,KAAQvB,EAAa,CAEhC,MAAMwB,EAAYxB,EAAYuB,GAE9BD,EAAgBC,GAAS,CACxBnB,QAASoB,EAAUpB,QAGrB,CAEA,OAAOkB,CAER,CASA,YAAArC,CAAcL,GAEb,MAAMkB,EAAWlB,EAAQkB,SAEzB,IAAM,MAAM2B,KAAY3B,EAEvB,GAAKA,EAAU2B,IAAc3B,EAAU2B,GAAWC,OACjD,OAAO,EAIT,OAAgD,OAA3C9C,EAAQ+C,SAASC,MAAMC,iBAA6E,OAAjDjD,EAAQ+C,SAASC,MAAME,qBAKhF,CASA,eAAA/B,CAAiBD,GAEhB,MAAMJ,EAAO,CAAC,EAEd,IAAM,MAAM+B,KAAY5C,KAAKJ,gBAAkB,CAE9C,MAAMsD,EAAQjC,EAAU2B,GAEnBM,UAEiB,iBAAVA,QAAsCnC,IAAhBmC,EAAMrB,OAEd,IAApBqB,EAAMC,UAEVtC,EAAM+B,GAAa,CAAEQ,GAAIF,EAAME,GAAI7B,QAAS2B,EAAM3B,SAIlDV,EAAM+B,GAAaM,EAAMrB,QAM1BhB,EAAM+B,GAAaM,EAIrB,CAEA,OAAOrC,CAER,CAQA,MAAAwC,CAAQ3C,GAEP,MAAM,OAAEJ,EAAM,SAAEW,EAAQ,SAAED,GAAaN,EAEjC4C,EAAmBtD,KAAKY,oBAAqBF,GAInD,IAAmE,IAA9D4C,EAAiB3B,YAAY0B,OAAQ/C,EAAOsB,aAIhD,OAFA0B,EAAiB3B,YAAY4B,KAAMjD,EAAOsB,cAEnC,EAMR,MAAM4B,EAAeF,EAAiBrC,SAEtC,IAAM,MAAM2B,KAAYY,EAAe,CAEtC,MAAMN,EAAQM,EAAcZ,GACtBa,EAAWxC,EAAU2B,GAE3B,QAAsB7B,IAAjBmC,EAAMG,QAEV,IAAkC,IAA7BH,EAAMG,OAAQI,GAIlB,OAFAP,EAAMK,KAAME,IAEL,OAIF,IAA4B,IAAvBA,EAASN,WAEpB,GAAKD,EAAME,KAAOK,EAASL,IAAMF,EAAM3B,UAAYkC,EAASlC,QAK3D,OAHA2B,EAAME,GAAKK,EAASL,GACpBF,EAAM3B,QAAUkC,EAASlC,SAElB,OAIF,GAAK2B,IAAUO,EAIrB,OAFAD,EAAcZ,GAAaa,GAEpB,CAIT,CAEA,GAAKD,EAAatB,aAAe,EAAI,CAEpC,MAAM,MAAEC,EAAK,OAAEC,GAAW1B,EAAa2B,QAEvC,GAAKiB,EAAiBhB,cAAgBH,GAASmB,EAAiBf,eAAiBH,EAKhF,OAHAkB,EAAiBhB,YAAcH,EAC/BmB,EAAiBf,aAAeH,GAEzB,CAIT,CAIA,MAAMsB,EAAqBJ,EAAiBtC,SACtCG,EAAaH,EAASG,WACtBwC,EAAmBD,EAAmBvC,WAEtCyC,EAAuBC,OAAOC,KAAMH,GACpCI,EAAwBF,OAAOC,KAAM3C,GAE3C,GAAKyC,EAAqBI,SAAWD,EAAsBC,OAG1D,OADAV,EAAiBtC,SAASG,WAAanB,KAAKoB,kBAAmBD,IACxD,EAMR,IAAM,MAAMuB,KAAQkB,EAAuB,CAE1C,MAAMK,EAAsBN,EAAkBjB,GACxCC,EAAYxB,EAAYuB,GAE9B,QAAmB3B,IAAd4B,EAIJ,cADOgB,EAAkBjB,IAClB,EAIR,GAAKuB,EAAoB1C,UAAYoB,EAAUpB,QAG9C,OADA0C,EAAoB1C,QAAUoB,EAAUpB,SACjC,CAIT,CAIA,MAAMD,EAAQN,EAASM,MACjB4C,EAAqBR,EAAmBrC,aACxC8C,EAAsB7C,EAAQA,EAAMC,QAAU,KAEpD,GAAK2C,IAAuBC,EAG3B,OADAT,EAAmBrC,aAAe8C,GAC3B,EAMR,GAAKT,EAAmBlC,UAAUC,QAAUT,EAASQ,UAAUC,OAASiC,EAAmBlC,UAAUE,QAAUV,EAASQ,UAAUE,MAIjI,OAFAgC,EAAmBlC,UAAUC,MAAQT,EAASQ,UAAUC,MACxDiC,EAAmBlC,UAAUE,MAAQV,EAASQ,UAAUE,OACjD,EAMR,GAAK4B,EAAiBvB,sBAAwB,CAE7C,IAAIqC,GAAe,EAEnB,IAAM,IAAIC,EAAI,EAAGA,EAAIf,EAAiBvB,sBAAsBiC,OAAQK,IAE9Df,EAAiBvB,sBAAuBsC,KAAQ/D,EAAOyB,sBAAuBsC,KAElFD,GAAe,GAMjB,GAAKA,EAAe,OAAO,CAE5B,CAIA,OAAKd,EAAiBxB,SAEoC,IAApDwB,EAAiBxB,OAAOuB,OAAQ/C,EAAOwB,SAE3CwB,EAAiBxB,OAAOyB,KAAMjD,EAAOwB,SAE9B,IAQoB,OAAxBpB,EAAauB,SAEjBqB,EAAiB/B,QAAUb,EAAauB,OAAOV,UAIzC,EAER,CASA,YAAA+C,CAAc5D,EAAc6D,GAE3B,GAAKvE,KAAKG,SAAWH,KAAKK,cAAgBL,KAAKS,oBAAqBC,GACnE,OAAO,EAER,MAAM,SAAEF,GAAa+D,EAErB,GAAKvE,KAAKQ,WAAaA,EAItB,OAFAR,KAAKQ,SAAWA,GAET,EAIR,MAAMgE,GAA0C,IAA/B9D,EAAaJ,OAAOmE,OAC/BC,EAAmC,OAAxBhE,EAAauB,SAAkD,IAA/BvB,EAAauB,OAAOwC,QAAmBzE,KAAKY,oBAAqBF,GAAea,UAAYb,EAAauB,OAAOV,QAEjK,GAAKiD,GAAYE,EAChB,OAAO,EAIR,OAFiD,IAAhC1E,KAAKqD,OAAQ3C,EAI/B,EAWD,SAASiE,EAAQzB,EAAO0B,EAAO,GAE9B,IAAIC,EAAK,WAAaD,EAAME,EAAK,WAAaF,EAE9C,GAAK1B,aAAiB6B,MAErB,IAAM,IAAWC,EAAPX,EAAI,EAAQA,EAAInB,EAAMc,OAAQK,IAEvCW,EAAM9B,EAAOmB,GACbQ,EAAKI,KAAKC,KAAML,EAAKG,EAAK,YAC1BF,EAAKG,KAAKC,KAAMJ,EAAKE,EAAK,iBAM3B,IAAM,IAAWG,EAAPd,EAAI,EAAOA,EAAInB,EAAMc,OAAQK,IAEtCc,EAAKjC,EAAMkC,WAAYf,GACvBQ,EAAKI,KAAKC,KAAML,EAAKM,EAAI,YACzBL,EAAKG,KAAKC,KAAMJ,EAAKK,EAAI,YAW3B,OALAN,EAAKI,KAAKC,KAAML,EAAOA,IAAO,GAAM,YACpCA,GAAMI,KAAKC,KAAMJ,EAAOA,IAAO,GAAM,YACrCA,EAAKG,KAAKC,KAAMJ,EAAOA,IAAO,GAAM,YACpCA,GAAMG,KAAKC,KAAML,EAAOA,IAAO,GAAM,YAE9B,YAAe,QAAUC,IAASD,IAAO,EAEjD,CASA,MAAMQ,EAAeC,GAASX,EAAQW,GAShCC,EAAcC,GAAWb,EAAQa,GASjCC,EAAS,IAAKC,IAAYf,EAAQe,GAUxC,SAASC,EAAerF,EAAQsF,GAAQ,GAEvC,MAAMC,EAAS,IAEQ,IAAlBvF,EAAOuC,SAEXgD,EAAOC,KAAMxF,EAAO8C,IACpB9C,EAASA,EAAOyF,WAIjB,IAAM,MAAM,SAAEnD,EAAQ,UAAEoD,KAAeC,EAAiB3F,GAEvDuF,EAAOC,KAAMD,EAAQlB,EAAQ/B,EAASZ,MAAO,GAAK,IAAOgE,EAAUE,YAAaN,IAIjF,OAAOjB,EAAQkB,EAEhB,CAWA,SAAUI,EAAiBE,EAAMC,GAAS,GAEzC,IAAM,MAAMxD,KAAYuD,EAAO,CAG9B,IAAoC,IAA/BvD,EAASyD,WAAY,KAAiB,SAE3C,MAAM/F,EAAS6F,EAAMvD,GAErB,IAAiC,IAA5BmC,MAAMuB,QAAShG,GAEnB,IAAM,IAAI+D,EAAI,EAAGA,EAAI/D,EAAO0D,OAAQK,IAAO,CAE1C,MAAMkC,EAAQjG,EAAQ+D,GAEjBkC,KAA4B,IAAjBA,EAAM1D,QAAmBuD,GAAkC,mBAAjBG,EAAMH,eAEzD,CAAExD,WAAUtB,MAAO+C,EAAG2B,UAAWO,GAIzC,MAEM,GAAKjG,IAA4B,IAAlBA,EAAOuC,YAEtB,CAAED,WAAUoD,UAAW1F,QAEvB,GAAuB,iBAAXA,EAElB,IAAM,MAAMkG,KAAelG,EAAS,CAEnC,MAAMiG,EAAQjG,EAAQkG,GAEjBD,KAA4B,IAAjBA,EAAM1D,QAAmBuD,GAAkC,mBAAjBG,EAAMH,eAEzD,CAAExD,WAAUtB,MAAOkF,EAAaR,UAAWO,GAInD,CAIF,CAED,CAEA,MAAME,EAA+B,IAAIC,IAAK,CAC7C,CAAE,EAAG,SACL,CAAE,EAAG,QACL,CAAE,EAAG,QACL,CAAE,EAAG,QACL,CAAE,EAAG,QACL,CAAE,GAAI,UAGDC,EAA+B,IAAIzG,QASzC,SAAS0G,EAAmB5C,GAE3B,OAAOyC,EAAe3F,IAAKkD,EAE5B,CA8DA,SAAS6C,EAAc3D,GAEtB,GAAKA,QAAwC,OAAO,KAEpD,MAAM4D,SAAgB5D,EAEtB,OAAsB,IAAjBA,EAAML,OAEH,OAEe,WAAXiE,EAEJ,QAEe,YAAXA,EAEJ,OAEe,WAAXA,EAEJ,SAEe,aAAXA,EAEJ,UAEwB,IAApB5D,EAAM6D,UAEV,QAEwB,IAApB7D,EAAM8D,UAEV,QAEwB,IAApB9D,EAAM+D,UAEV,QAEwB,IAApB/D,EAAMgE,UAEV,QAEwB,IAApBhE,EAAMiE,UAEV,QAEsB,IAAlBjE,EAAMkE,QAEV,QAEIlE,aAAiBmE,YAErB,cAID,IAER,CAUA,SAASC,EAAkBC,KAAS7B,GAEnC,MAAM8B,EAAQD,EAAOA,EAAKvF,OAAS,QAAMjB,EAUzC,OARuB,IAAlB2E,EAAO1B,SAEI,SAAVwD,EAAmB9B,EAAS,CAAEA,EAAQ,GAAKA,EAAQ,IACpC,SAAV8B,EAAmB9B,EAAS,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,IACtD,SAAV8B,IAAmB9B,EAAS,CAAEA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,MAI1E,UAAT6B,EAEG,IAAI,SAAU7B,GAEA,SAAV8B,EAEJ,IAAI,SAAY9B,GAEF,SAAV8B,EAEJ,IAAI,SAAY9B,GAEF,SAAV8B,EAEJ,IAAI,SAAY9B,GAEF,SAAV8B,EAEJ,IAAI,SAAY9B,GAEF,SAAV8B,EAEJ,IAAI,SAAY9B,GAEH,SAAT6B,EAEJ7B,EAAQ,KAAO,EAEA,UAAT6B,GAAiC,QAATA,GAA+B,SAATA,EAEpD7B,EAAQ,IAAO,EAEF,WAAT6B,EAEJ7B,EAAQ,IAAO,GAEF,gBAAT6B,EAEJE,EAAqB/B,EAAQ,IAI9B,IAER,CAQA,SAASgC,EAAmBpH,GAE3B,IAAIO,EAAO8F,EAAe7F,IAAKR,GAS/B,YAPcS,IAATF,IAEJA,EAAO,CAAC,EACR8F,EAAenE,IAAKlC,EAAQO,IAItBA,CAER,CASA,SAAS8G,EAAqBC,GAE7B,IAAIC,EAAQ,GAEZ,MAAMrC,EAAQ,IAAIsC,WAAYF,GAE9B,IAAM,IAAIvD,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAElCwD,GAASE,OAAOC,aAAcxC,EAAOnB,IAItC,OAAO4D,KAAMJ,EAEd,CASA,SAASJ,EAAqBS,GAE7B,OAAOJ,WAAWK,KAAMC,KAAMF,IAAUG,GAAKA,EAAEjD,WAAY,KAAMkD,MAElE,CA2BA,MAAMC,EAAkB,CACvBC,OAAQ,SACRC,SAAU,YAWLC,EAAiB,CACtBC,KAAM,OACNC,MAAO,QACPC,OAAQ,SACRC,OAAQ,UAmCHC,EAAa,CAClBC,UAAW,WACXC,WAAY,YACZC,WAAY,aAGPC,EAAsB,CAAE,WAAY,UACpCC,EAAqB,CAAE,QAAS,UAAW,YAC3CC,EAAe,IAAKF,EAAqB,WACzCG,EAAmB,CAAE,IAAK,IAAK,IAAK,KAE1C,IAAIC,EAAU,EAOd,MAAMC,UAAa,MAElB,eAAWjC,GAEV,MAAO,MAER,CAOA,WAAAzH,CAAa2J,EAAW,MAEvBC,QAQA1J,KAAKyJ,SAAWA,EAQhBzJ,KAAK2J,WAAajB,EAAeC,KAQjC3I,KAAK4J,iBAAmBlB,EAAeC,KAQvC3I,KAAK6J,gBAAkBnB,EAAeC,KAQtC3I,KAAK8J,KAAO,MAAUC,eAStB/J,KAAKuB,QAAU,EAUfvB,KAAKgK,QAAS,EASdhK,KAAK6C,QAAS,EAWd7C,KAAKiK,UAAY,KASjBjK,KAAKkK,iBAAmB,EAExBrG,OAAOsG,eAAgBnK,KAAM,KAAM,CAAEkD,MAAOqG,KAE7C,CASA,eAAIa,CAAalH,IAED,IAAVA,GAEJlD,KAAKuB,SAIP,CAQA,QAAIgG,GAEH,OAAOvH,KAAKF,YAAYyH,IAEzB,CASA,QAAA8C,CAAUC,EAAUX,GAKnB,OAHA3J,KAAK2J,WAAaA,EAClB3J,KAAKuK,OAASD,EAASE,KAAMxK,KAAK+F,WAE3B/F,IAER,CASA,aAAAyK,CAAeH,GAEd,OAAOtK,KAAKqK,SAAUC,EAAU5B,EAAeE,MAEhD,CASA,cAAA8B,CAAgBJ,GAEf,OAAOtK,KAAKqK,SAAUC,EAAU5B,EAAeG,OAEhD,CASA,cAAA8B,CAAgBL,GAEf,OAAOtK,KAAKqK,SAAUC,EAAU5B,EAAeI,OAEhD,CAQA,WAAA8B,CAAaN,GAIZ,OAFAtK,KAAK6K,gBAAkBP,EAASE,KAAMxK,KAAK+F,WAEpC/F,IAER,CAQA,OAAA+F,GAIC,OAAO/F,KAAK8K,MAAQ9K,IAErB,CASA,eAAA6K,GAEC,OAAO7K,IAER,CAUA,QAAA+K,GAEC,OAAO/K,KAAKgK,MAEb,CAQA,YAAEgB,GAED,IAAM,MAAM,UAAEhF,KAAeC,EAAiBjG,YAEvCgG,CAIR,CAMA,OAAAiF,GAECjL,KAAKkL,cAAe,CAAE3D,KAAM,WAE7B,CAcA,QAAA4D,CAAUb,GAETA,EAAUtK,MAEV,IAAM,MAAMgG,KAAahG,KAAKgL,cAE7BhF,EAAUmF,SAAUb,EAItB,CAQA,WAAApE,CAAaN,GAAQ,GAWpB,OAPe,KAFfA,EAAQA,GAAS5F,KAAKuB,UAAYvB,KAAKkK,mBAEG,OAAnBlK,KAAKiK,YAE3BjK,KAAKiK,UAAYxE,EAAQE,EAAe3F,KAAM4F,GAAS5F,KAAKoL,kBAC5DpL,KAAKkK,iBAAmBlK,KAAKuB,SAIvBvB,KAAKiK,SAEb,CAOA,cAAAmB,GAEC,OAAO,CAER,CAOA,QAAAC,GAEC,OAAOrL,IAER,CAUA,OAAAsL,GAEC,OAAOtL,KAAK8J,IAEb,CAOA,aAAAyB,GAEC,OAAOvL,KAAK2J,UAEb,CAOA,mBAAA6B,GAEC,OAAOxL,KAAK4J,gBAEb,CAOA,kBAAA6B,GAEC,OAAOzL,KAAK6J,eAEb,CAUA,cAAA6B,CAAgB3L,GAEf,MAAMwH,EAAOvH,KAAK2L,YAAa5L,GAG/B,OAFoBA,EAAQ2L,eAAgBnE,EAI7C,CAQA,WAAAoE,CAAa5L,GAEZ,MAAM6L,EAAiB7L,EAAQ8L,kBAAmB7L,MAElD,OAAK4L,EAAeE,WAEZF,EAAeE,WAAWH,YAAa5L,GAIxCC,KAAKyJ,QAEb,CAWA,SAAAsC,CAAWhM,GAEV,MAAMiM,EAAOhM,KAAKsL,QAASvL,GAG3B,OAFqBA,EAAQkM,gBAAiBD,IAEvBhM,IAExB,CAUA,KAAAkM,CAAOnM,GAEN,MAAM6L,EAAiB7L,EAAQ8L,kBAAmB7L,MAElD,IAAIsB,EAAQ,EAEZ,IAAM,MAAM0E,KAAahG,KAAKgL,cAE7BY,EAAgB,OAAStK,KAAa0E,EAMvC,OAAO4F,EAAeE,YAAc,IAErC,CAQA,OAAAK,CAASpM,GAIR,GAAoB,IAFDA,EAAQqM,cAAepM,MAElB,CAIvB,MAAM4L,EAAiB7L,EAAQ8L,kBAAmB7L,MAElD,IAAM,MAAMgG,KAAanC,OAAOgC,OAAQ+F,GAElC5F,IAAkC,IAArBA,EAAUnD,QAE3BmD,EAAUqG,MAAOtM,EAMpB,CAED,CAUA,QAAAuM,CAAUvM,EAASwM,GAElB,MAAM,WAAET,GAAe/L,EAAQ8L,kBAAmB7L,MAElD,GAAK8L,IAAoC,IAAtBA,EAAWjJ,OAE7B,OAAOiJ,EAAWO,MAAOtM,EAASwM,EAIpC,CAUA,YAAAC,GAECC,QAAQC,KAAM,qBAEf,CAUA,WAAAC,GAECF,QAAQC,KAAM,qBAEf,CAUA,MAAAnC,GAECkC,QAAQC,KAAM,qBAEf,CAUA,KAAAL,CAAOtM,EAASwM,EAAS,MAExB,MAAMK,EAAU5M,KAAK+L,UAAWhM,GAEhC,GAAKC,OAAS4M,EAEb,OAAOA,EAAQP,MAAOtM,EAASwM,GAIhCxM,EAAQ8M,QAAS7M,MACjBD,EAAQ+M,SAAU9M,MAOlB,IAAI+M,EAAS,KAEb,MAAMC,EAAajN,EAAQkN,gBAE3B,GAAoB,UAAfD,EAAyB,CAE7BhN,KAAK6K,gBAAiB9K,GAEtB,MAAMmN,EAAanN,EAAQ8L,kBAAmB7L,MAE9C,IAAgC,IAA3BkN,EAAWC,YAAuB,CAItCD,EAAWC,aAAc,EAEzB,MAAMrB,EAAa9L,KAAKkM,MAAOnM,GACzBqN,EAAetB,IAAoC,IAAtBA,EAAWjJ,OAS9C,IAAM,MAAMmD,KAAanC,OAAOgC,OAAQqH,GAElClH,IAAkC,IAArBA,EAAUnD,QAE3BmD,EAAUqG,MAAOtM,GAMdqN,GAEJtB,EAAWO,MAAOtM,GAInBmN,EAAWpB,WAAaA,CAEzB,CAED,MAAO,GAAoB,YAAfkB,EAEXhN,KAAKmM,QAASpM,QAER,GAAoB,aAAfiN,EAA4B,CAIvC,GAFgD,IAAzBhN,KAAKsM,SAAStI,OAEf,CAErB,MAAMuD,EAAOvH,KAAK2L,YAAa5L,GACzBsN,EAAWtN,EAAQuN,gBAAiBtN,MAE1C+M,EAASM,EAASE,aAEFxM,IAAXgM,GAEJA,EAAS/M,KAAKsM,SAAUvM,IAAa,GAErCsN,EAASE,QAAUR,QAEehM,IAAvBsM,EAASG,gBAAyDzM,IAA9BhB,EAAQsC,QAAQoL,WAE/D1N,EAAQ2N,qBAAsB1N,KAAMD,EAAQsC,QAAQoL,WAIrDV,EAAShN,EAAQ4N,OAAQZ,EAAQxF,EAAMgF,EAExC,MAECQ,EAAS/M,KAAKsM,SAAUvM,EAASwM,IAAY,EAI/C,CAKA,OAHAxM,EAAQ6N,YAAa5N,MACrBD,EAAQ8N,kBAAmB7N,MAEpB+M,CAER,CAOA,oBAAAe,GAEC,OAAO7H,EAAiBjG,KAEzB,CAOA,SAAA+N,CAAWC,GAEV,MAAMC,EAAejO,KAAK8N,uBAEpBI,EAAa,CAAC,EAEpB,IAAM,MAAM,SAAEtL,EAAQ,MAAEtB,EAAK,UAAE0E,KAAeiI,OAE9BlN,IAAVO,QAE4BP,IAA3BmN,EAAYtL,KAEhBsL,EAAYtL,GAAauL,OAAOC,UAAW9M,GAAU,GAAK,CAAC,GAI5D4M,EAAYtL,GAAYtB,GAAU0E,EAAUI,OAAQ4H,EAAKK,MAAOvE,MAIhEoE,EAAYtL,GAAaoD,EAAUI,OAAQ4H,EAAKK,MAAOvE,KAMpDjG,OAAOC,KAAMoK,GAAalK,OAAS,IAEvCgK,EAAKE,WAAaA,EAIpB,CAOA,WAAAI,CAAaN,GAEZ,QAAyBjN,IAApBiN,EAAKE,WAA2B,CAEpC,MAAMnL,EAAQiL,EAAKK,KAAKtL,MAExB,IAAM,MAAMH,KAAYoL,EAAKE,WAE5B,GAAKnJ,MAAMuB,QAAS0H,EAAKE,WAAYtL,IAAe,CAEnD,MAAM2L,EAAa,GAEnB,IAAM,MAAMzE,KAAQkE,EAAKE,WAAYtL,GAEpC2L,EAAWzI,KAAM/C,EAAO+G,IAIzB9J,KAAM4C,GAAa2L,CAEpB,MAAO,GAA4C,iBAAhCP,EAAKE,WAAYtL,GAA0B,CAE7D,MAAM4L,EAAc,CAAC,EAErB,IAAM,MAAMhI,KAAewH,EAAKE,WAAYtL,GAAa,CAExD,MAAMkH,EAAOkE,EAAKE,WAAYtL,GAAY4D,GAE1CgI,EAAahI,GAAgBzD,EAAO+G,EAErC,CAEA9J,KAAM4C,GAAa4L,CAEpB,KAAO,CAEN,MAAM1E,EAAOkE,EAAKE,WAAYtL,GAE9B5C,KAAM4C,GAAaG,EAAO+G,EAE3B,CAIF,CAED,CAQA,MAAA1D,CAAQiI,GAEP,MAAM,KAAEvE,EAAI,KAAEvC,GAASvH,KACjByO,OAAoB1N,IAATsN,GAAsC,iBAATA,EAEzCI,IAEJJ,EAAO,CACNK,SAAU,CAAC,EACXC,OAAQ,CAAC,EACT5L,MAAO,CAAC,IAOV,IAAIlC,EAAOwN,EAAKtL,MAAO+G,GAyBvB,SAAS8E,EAAkBC,GAE1B,MAAMhJ,EAAS,GAEf,IAAM,MAAMiJ,KAAOD,EAAQ,CAE1B,MAAMhO,EAAOgO,EAAOC,UACbjO,EAAKkO,SACZlJ,EAAOC,KAAMjF,EAEd,CAEA,OAAOgF,CAER,CAEA,QAvCc9E,IAATF,IAEJA,EAAO,CACNiJ,OACAvC,OACA8G,OACAU,SAAU,CACTxN,QAAS,IACTgG,KAAM,OACNyH,UAAW,iBAIG,IAAXP,IAAkBJ,EAAKtL,MAAOlC,EAAKiJ,MAASjJ,GAEjDb,KAAK+N,UAAWlN,UAETA,EAAKwN,MAsBRI,EAAS,CAEb,MAAMC,EAAWE,EAAkBP,EAAKK,UAClCC,EAASC,EAAkBP,EAAKM,QAChC5L,EAAQ6L,EAAkBP,EAAKtL,OAEhC2L,EAAS1K,OAAS,IAAInD,EAAK6N,SAAWA,GACtCC,EAAO3K,OAAS,IAAInD,EAAK8N,OAASA,GAClC5L,EAAMiB,OAAS,IAAInD,EAAKkC,MAAQA,EAEtC,CAEA,OAAOlC,CAER,EAUD,MAAMoO,UAAyBzF,EAE9B,eAAWjC,GAEV,MAAO,kBAER,CAQA,WAAAzH,CAAaqG,EAAM+I,GAElBxF,QAOA1J,KAAKmG,KAAOA,EAOZnG,KAAKkP,UAAYA,EASjBlP,KAAKmP,oBAAqB,CAE3B,CAQA,WAAAxD,CAAa5L,GAEZ,OAAOC,KAAKmG,KAAKuF,eAAgB3L,EAElC,CAEA,QAAAuM,CAAUvM,GAKT,MAAO,GAHaC,KAAKmG,KAAKkG,MAAOtM,OAChBC,KAAKkP,UAAU7C,MAAOtM,EAAS,WAIrD,EAWD,MAAMqP,UAAoB5F,EAEzB,eAAWjC,GAEV,MAAO,aAER,CAQA,WAAAzH,CAAaqG,EAAMkJ,GAElB3F,QAOA1J,KAAKmG,KAAOA,EAOZnG,KAAKqP,UAAYA,CAElB,CASA,WAAA1D,CAAa5L,GAEZ,MAAMuP,EAActP,KAAKmG,KAAKwF,YAAa5L,GAE3C,IAAIsP,EAAY,KAEhB,IAAM,MAAME,KAAmBvP,KAAKqP,UAAUG,MAAO,KAEjC,OAAdH,GAAsBtP,EAAQ0P,cAAeH,KAAkBvP,EAAQ0P,cAAeF,KAE1FF,EAAYE,GAMd,OAAOF,CAER,CAEA,SAAAtB,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKwO,UAAYrP,KAAKqP,SAEvB,CAEA,WAAAf,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKqP,UAAYxO,EAAKwO,SAEvB,CAEA,QAAA/C,CAAUvM,EAASwM,GAElB,MAAMpG,EAAOnG,KAAKmG,KACZoB,EAAOvH,KAAK2L,YAAa5L,GAEzBwN,EAAUpH,EAAKkG,MAAOtM,EAASwH,GAErC,OAAOxH,EAAQ4N,OAAQJ,EAAShG,EAAMgF,EAEvC,EAYD,MAAMmD,UAAiBlG,EAEtB,eAAWjC,GAEV,MAAO,UAER,CAOA,WAAAzH,CAAa2J,EAAW,MAEvBC,MAAOD,GASPzJ,KAAK2P,YAAa,CAEnB,CAQA,eAAAC,CAAiB7P,GAEhB,OAAOA,EAAQuN,gBAAiBtN,MAAO6P,WAAa,CAErD,CAEA,KAAAxD,CAAOtM,EAASwM,GAIf,GAAoB,aAFDxM,EAAQkN,gBAEM,CAEhC,MAAM1F,EAAOxH,EAAQ+P,cAAe9P,KAAK2L,YAAa5L,EAASwM,IACzDc,EAAWtN,EAAQuN,gBAAiBtN,MAE1C,QAA+Be,IAA1BsM,EAAS0C,aAEb,OAAOhQ,EAAQ4N,OAAQN,EAAS0C,aAAcxI,EAAMgF,GAE9C,GAAc,SAAThF,GAA8B,SAAXgF,GAAqBvM,KAAK4P,gBAAiB7P,GAAY,CAErF,MAAMwN,EAAU7D,MAAM2C,MAAOtM,EAASwH,GAEhCyI,EAAUjQ,EAAQkQ,eAAgBjQ,KAAM,KAAMuH,GAC9CwI,EAAehQ,EAAQmQ,gBAAiBF,GAO9C,OALAjQ,EAAQoQ,gBAAiB,GAAGJ,OAAkBxC,IAAWvN,MAEzDqN,EAASE,QAAUA,EACnBF,EAAS0C,aAAeA,EAEjBhQ,EAAQ4N,OAAQN,EAAS0C,aAAcxI,EAAMgF,EAErD,CAED,CAEA,OAAO7C,MAAM2C,MAAOtM,EAASwM,EAE9B,EAWD,MAAM6D,UAAiBV,EAEtB,eAAWnI,GAEV,MAAO,UAER,CAQA,WAAAzH,CAAaiD,EAAQ,GAAI0G,EAAW,MAEnCC,MAAOD,GAOPzJ,KAAK+C,MAAQA,CAEd,CASA,WAAA4I,CAAa5L,GAEZ,OAAuB,OAAlBC,KAAKyJ,SAEF1J,EAAQ+P,cAAe9P,KAAKyJ,UAI7B1J,EAAQ6G,kBAAmB5G,KAAK+C,MAAMsN,QAAQ,CAAE3O,EAAO4O,IAAS5O,EAAQ3B,EAAQ0P,cAAea,EAAI3E,YAAa5L,KAAa,GAErI,CAEA,QAAAuM,CAAUvM,EAASwM,GAElB,MAAMhF,EAAOvH,KAAK2L,YAAa5L,GACzBgD,EAAQ/C,KAAK+C,MAEbwN,EAAgBxQ,EAAQyQ,iBAAkBjJ,GAE1CkJ,EAAgB,GAEtB,IAAM,MAAMC,KAAS3N,EAAQ,CAE5B,IAAI4N,EAAeD,EAAMrE,MAAOtM,GAEhC,MAAM6Q,EAAqB7Q,EAAQyQ,iBAAkBE,EAAM/E,YAAa5L,IAEnE6Q,IAAuBL,IAE3BI,EAAe5Q,EAAQ4N,OAAQgD,EAAcC,EAAoBL,IAIlEE,EAAc3K,KAAM6K,EAErB,CAEA,MAAMpD,EAAU,GAAIxN,EAAQ8Q,QAAStJ,OAAakJ,EAAcK,KAAM,UAEtE,OAAO/Q,EAAQ4N,OAAQJ,EAAShG,EAAMgF,EAEvC,EAID,MAAMwE,EAA0BzH,EAAiBwH,KAAM,IAavD,MAAME,UAAkBxH,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAQA,WAAAzH,CAAaqG,EAAM8K,EAAa,KAE/BvH,QAOA1J,KAAKmG,KAAOA,EAOZnG,KAAKiR,WAAaA,EASlBjR,KAAKkR,aAAc,CAEpB,CAOA,eAAAC,GAEC,IAAIC,EAAepR,KAAKiR,WAAWjN,OAEnC,IAAM,MAAMqE,KAAKrI,KAAKiR,WAErBG,EAAenM,KAAKoM,IAAK/H,EAAiBgI,QAASjJ,GAAM,EAAG+I,GAI7D,OAAOA,CAER,CAQA,gBAAAZ,CAAkBzQ,GAEjB,OAAOA,EAAQyQ,iBAAkBxQ,KAAKmG,KAAKwF,YAAa5L,GAEzD,CAQA,WAAA4L,CAAa5L,GAEZ,OAAOA,EAAQ6G,kBAAmB5G,KAAKiR,WAAWjN,OAAQhE,KAAKwQ,iBAAkBzQ,GAElF,CAEA,QAAAuM,CAAUvM,EAASwM,GAElB,MAAMpG,EAAOnG,KAAKmG,KACZoL,EAAiBxR,EAAQ0P,cAAetJ,EAAKwF,YAAa5L,IAEhE,IAAIwN,EAAU,KAEd,GAAKgE,EAAiB,EAAI,CAEzB,IAAIhK,EAAO,KAEcvH,KAAKmR,mBAELI,IAIxBhK,EAAOxH,EAAQ6G,kBAAmB5G,KAAKmR,kBAAmBnR,KAAKwQ,iBAAkBzQ,KAIlF,MAAMyR,EAAcrL,EAAKkG,MAAOtM,EAASwH,GAMxCgG,EAJIvN,KAAKiR,WAAWjN,SAAWuN,GAAkBvR,KAAKiR,aAAeF,EAAwB/O,MAAO,EAAGhC,KAAKiR,WAAWjN,QAI7GjE,EAAQ4N,OAAQ6D,EAAajK,EAAMgF,GAInCxM,EAAQ4N,OAAQ,GAAG6D,KAAexR,KAAKiR,aAAcjR,KAAK2L,YAAa5L,GAAWwM,EAI9F,MAICgB,EAAUpH,EAAKkG,MAAOtM,EAASwM,GAIhC,OAAOgB,CAER,CAEA,SAAAQ,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKoQ,WAAajR,KAAKiR,UAExB,CAEA,WAAA3C,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKiR,WAAapQ,EAAKoQ,UAExB,EAeD,MAAMQ,UAAgB/B,EAErB,eAAWnI,GAEV,MAAO,SAER,CASA,WAAAzH,CAAa4R,EAAYT,EAAYU,GAEpCjI,QAOA1J,KAAK0R,WAAaA,EAOlB1R,KAAKiR,WAAaA,EAOlBjR,KAAK2R,WAAaA,CAEnB,CAQA,WAAAhG,CAAa5L,GAEZ,OAAOC,KAAK0R,WAAW/F,YAAa5L,EAErC,CAEA,QAAAuM,CAAUvM,GAET,MAAM,WAAE2R,EAAU,WAAET,EAAU,WAAEU,GAAe3R,KAEzC4R,EAAa5R,KAAK2L,YAAa5L,GAE/B8R,EAAgB9R,EAAQyQ,iBAAkBmB,EAAWhG,YAAa5L,IAClE+R,EAAa/R,EAAQ6G,kBAAmBqK,EAAWjN,OAAQ6N,GAE3DE,EAAgBJ,EAAWtF,MAAOtM,EAAS+R,GAC3CE,EAAgBN,EAAWrF,MAAOtM,EAAS6R,GAE3C5N,EAASjE,EAAQ0P,cAAemC,GAChCnB,EAAgB,GAEtB,IAAM,IAAIpM,EAAI,EAAGA,EAAIL,EAAQK,IAAO,CAEnC,MAAM4N,EAAY3I,EAAkBjF,GAE/B4N,IAAchB,EAAY,IAE9BR,EAAc3K,KAAMiM,GAEpB1N,GAAK4M,EAAWjN,OAAS,GAIzByM,EAAc3K,KAAMkM,EAAgB,IAAMC,EAI5C,CAEA,MAAO,GAAIlS,EAAQ8Q,QAASe,OAAmBnB,EAAcK,KAAM,SAEpE,EAmBD,MAAMoB,UAAiBxC,EAEtB,eAAWnI,GAEV,MAAO,UAER,CAQA,WAAAzH,CAAa4R,EAAYT,GAExBvH,QAOA1J,KAAK0R,WAAaA,EAOlB1R,KAAKiR,WAAaA,CAEnB,CAQA,WAAAtF,CAAa5L,GAEZ,OAAOC,KAAK0R,WAAW/F,YAAa5L,EAErC,CAEA,QAAAuM,CAAUvM,GAET,MAAM,WAAEkR,EAAU,WAAES,GAAe1R,KAE7B4R,EAAa5R,KAAK2L,YAAa5L,GAC/BiS,EAAgBN,EAAWrF,MAAOtM,GAElCoS,EAAcpS,EAAQkQ,eAAgBjQ,MACtCoS,EAAiBrS,EAAQmQ,gBAAiBiC,GAEhDpS,EAAQoQ,gBAAiBiC,EAAiB,MAAQJ,EAAehS,MAEjE,MAAMgE,EAASjE,EAAQ0P,cAAemC,GAChCnB,EAAgB,GAEtB,IAAI4B,EAAiB,EAErB,IAAM,IAAIhO,EAAI,EAAGA,EAAIL,EAAQK,IAAO,CAEnC,MAAM4N,EAAY3I,EAAkBjF,GAE/B4N,IAAchB,EAAYoB,IAE9B5B,EAAc3K,KAAM,SAAasM,EAAiB,IAAMH,GAExDI,KAIA5B,EAAc3K,KAAMsM,EAAiB,IAAMH,EAI7C,CAEA,MAAO,GAAIlS,EAAQ8Q,QAASe,OAAmBnB,EAAcK,KAAM,SAEpE,EASD,MAAMwB,UAAkB9I,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAQA,WAAAzH,CAAaoD,EAAOuG,EAAW,MAE9BC,MAAOD,GASPzJ,KAAKuS,aAAc,EAOnBvS,KAAKkD,MAAQA,EAQblD,KAAKwS,UAAY,IAElB,CAEA,WAAA7G,GAEC,OAAuB,OAAlB3L,KAAKyJ,SAEF5C,EAAc7G,KAAKkD,OAIpBlD,KAAKyJ,QAEb,CAYA,YAAAgJ,CAAc1S,GAEb,OAAOC,KAAK2L,YAAa5L,EAE1B,CAUA,YAAA2S,CAAcF,GAIb,OAFAxS,KAAKwS,UAAYA,EAEVxS,IAER,CAEA,SAAA+N,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKqC,MAAQlD,KAAKkD,MAEblD,KAAKkD,OAASlD,KAAKkD,MAAMyP,UAAU9R,EAAKqC,MAAQlD,KAAKkD,MAAMyP,WAEhE9R,EAAK+R,UAAY/L,EAAc7G,KAAKkD,OACpCrC,EAAK4I,SAAWzJ,KAAKyJ,SAEG,gBAAnB5I,EAAK+R,YAA8B/R,EAAKqC,MAAQyE,EAAqB9G,EAAKqC,QAE/ErC,EAAK2R,UAAYxS,KAAKwS,SAEvB,CAEA,WAAAlE,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKyJ,SAAW5I,EAAK4I,SACrBzJ,KAAKkD,MAAQ6B,MAAMuB,QAASzF,EAAKqC,OAAUoE,EAAkBzG,EAAK+R,aAAc/R,EAAKqC,OAAUrC,EAAKqC,MAEpGlD,KAAKwS,UAAY3R,EAAK2R,WAAa,KAE9BxS,KAAKkD,OAASlD,KAAKkD,MAAM2P,YAAY7S,KAAKkD,MAAQlD,KAAKkD,MAAM2P,UAAWhS,EAAKqC,OAEnF,CAEA,QAAAoJ,GAECG,QAAQC,KAAM,qBAEf,EASD,MAAMoG,UAAkBR,EAEvB,eAAW/K,GAEV,MAAO,WAER,CAQA,WAAAzH,CAAaoD,EAAOuG,EAAW,MAE9BC,MAAOxG,EAAOuG,GASdzJ,KAAK+S,aAAc,CAEpB,CAQA,aAAAC,CAAejT,GAEd,OAAOA,EAAQiT,cAAehT,KAAK2L,YAAa5L,GAAWC,KAAKkD,MAEjE,CAEA,QAAAoJ,CAAUvM,EAASwM,GAElB,MAAMhF,EAAOvH,KAAK2L,YAAa5L,GAE/B,OAAOA,EAAQ4N,OAAQ3N,KAAKgT,cAAejT,GAAWwH,EAAMgF,EAE7D,EAMD,IAAI0G,EAAe,KAEnB,MAAMC,EAAe,IAAIxM,IAEzB,SAASyM,EAAmBzQ,EAAM0Q,GAEjC,GAAKF,EAAavS,IAAK+B,GAEtB+J,QAAQC,KAAM,mCAAoChK,SAFnD,CAOA,GAA4B,mBAAhB0Q,EAA6B,MAAM,IAAIC,MAAO,gBAAiB3Q,uBAE3EwQ,EAAa1Q,IAAKE,EAAM0Q,EAJxB,CAMD,CAEA,MAAME,EAAiBC,GAAWA,EAAMC,QAAS,OAAQ,KAAMA,QAAS,OAAQ,KAAMA,QAAS,OAAQ,KAAMA,QAAS,OAAQ,KACxHC,EAAwBF,GAAWD,EAAcC,GAAQ/D,MAAO,IAAKkE,OAAO5C,KAAM,IAElF6C,EAAoB,CAEzB,KAAAzH,CAAO0H,EAAalO,GAEnB,MAAMmO,EAASnO,EAAOoO,QAEtB,OAAOF,EAAaG,GAAaF,MAAanO,EAE/C,EAEA,GAAA5E,CAAKqF,EAAM6N,EAAMC,GAEhB,GAAqB,iBAATD,QAAsCjT,IAAjBoF,EAAM6N,GAAuB,CAE7D,IAA0B,IAArB7N,EAAK+N,aAAiC,WAATF,EAEjC,MAAO,IAAKtO,KAEXuN,EAAakB,OAAQF,KAAYvO,GAE1BuO,GAIF,GAAKf,EAAavS,IAAKqT,GAAS,CAEtC,MAAMZ,EAAcF,EAAapS,IAAKkT,GAEtC,OAAO7N,EAAK+N,YAAc,IAAKxO,IAAYuO,EAAQG,IAAKhB,KAAgB1N,IAAa,IAAKA,IAAY0N,EAAaa,KAAYvO,EAEhI,CAAO,GAAc,SAATsO,EAEX,OAAO7N,EAED,GAAK6N,EAAKK,SAAU,WAAcnB,EAAavS,IAAKqT,EAAKhS,MAAO,EAAGgS,EAAKhQ,OAAS,IAAsB,CAE7G,MAAMoP,EAAcF,EAAapS,IAAKkT,EAAKhS,MAAO,EAAGgS,EAAKhQ,OAAS,IAEnE,OAAOmC,EAAK+N,YAAc,IAAKxO,IAAYuO,EAAQE,OAAQzO,EAAQ,GAAK0N,KAAgB1N,IAAa,IAAKA,IAAYuO,EAAQE,OAAQf,EAAaa,KAAYvO,GAEhK,CAAO,IAA8C,IAAzC,wBAAwB4O,KAAMN,GAMzC,OAFAA,EAAOV,EAAcU,GAEdO,GAAY,IAAIvD,EAAWiD,EAASD,IAErC,IAAiD,IAA5C,2BAA2BM,KAAMN,GAM5C,OAFAA,EAAOP,EAAqBO,EAAKhS,MAAO,GAAIwS,eAEnCtR,GAAWqR,GAAY,IAAI9C,EAAStL,EAAM6N,EAAM9Q,IAEnD,IAAkD,IAA7C,4BAA4BoR,KAAMN,GAM7C,OAFAA,EAAOP,EAAqBO,EAAKhS,MAAO,GAAIwS,eAErC,IAAMD,GAAY,IAAIrC,EAAUqC,GAAYpO,GAAQ6N,IAErD,GAAc,UAATA,GAA6B,WAATA,GAA8B,UAATA,EAQpD,MAJc,UAATA,EAAmBA,EAAO,IACZ,WAATA,EAAoBA,EAAO,IAClB,UAATA,IAAmBA,EAAO,KAE7BO,GAAY,IAAIvD,EAAW7K,EAAM6N,IAElC,IAA8B,IAAzB,QAAQM,KAAMN,GAIzB,OAAOO,GAAY,IAAItF,EAAkBgF,EAAS,IAAInB,EAAW3E,OAAQ6F,GAAQ,SAInF,CAEA,OAAOS,QAAQ3T,IAAKqF,EAAM6N,EAAMC,EAEjC,EAEA,GAAAzR,CAAK2D,EAAM6N,EAAM9Q,EAAO+Q,GAEvB,MAAqB,iBAATD,QAAsCjT,IAAjBoF,EAAM6N,KAIQ,IAAzC,wBAAwBM,KAAMN,IAA4B,UAATA,GAA6B,WAATA,GAA8B,UAATA,IAA6C,IAAzB,QAAQM,KAAMN,GAU3HS,QAAQjS,IAAK2D,EAAM6N,EAAM9Q,EAAO+Q,IARrCA,EAASD,GAAOG,OAAQjR,IAEjB,EAQV,GAIKwR,EAAsB,IAAIxU,QAC1ByU,EAA+B,IAAIzU,QAmCnC0U,EAAoB,SAAWC,EAASC,EAAU,MAEvD,IAAM,MAAMpS,KAAQmS,EAEnBA,EAASnS,GAAS6R,GAAYM,EAASnS,GAAQoS,GAIhD,OAAOD,CAER,EAEME,EAAkB,SAAWvP,EAAOsP,EAAU,MAEnD,MAAME,EAAMxP,EAAMxB,OAElB,IAAM,IAAIK,EAAI,EAAGA,EAAI2Q,EAAK3Q,IAEzBmB,EAAOnB,GAAMkQ,GAAY/O,EAAOnB,GAAKyQ,GAItC,OAAOtP,CAER,EAEMyP,EAAkB,SAAWC,EAAWC,EAAQ,KAAMC,EAAS,KAAMC,EAAW,MAErF,MAAMC,EAAenP,GAAUoO,GAAyB,OAAbc,EAAoBxR,OAAOsQ,OAAQhO,EAAMkP,GAAalP,GAEjG,OAAe,OAAVgP,EAEG,IAAKzP,IAEJ4P,EAAY,IAAIJ,KAAcK,GAAW7P,KAI3B,OAAX0P,GAEXA,EAASb,GAAYa,GAEd,IAAK1P,IAEJ4P,EAAY,IAAIJ,EAAWC,KAAUI,GAAW7P,GAAU0P,KAM3D,IAAK1P,IAEJ4P,EAAY,IAAIJ,EAAWC,KAAUI,GAAW7P,IAM1D,EAEM8P,EAAsB,SAAWN,KAAcxP,GAEpD,OAAO6O,GAAY,IAAIW,KAAcK,GAAW7P,IAEjD,EAEA,MAAM+P,UAA+BjM,EAEpC,WAAA1J,CAAa4V,EAAYxH,GAExBxE,QAEA1J,KAAK0V,WAAaA,EAClB1V,KAAKkO,WAAaA,CAEnB,CAEA,WAAAvC,CAAa5L,GAEZ,OAAOC,KAAK0V,WAAWjM,UAAYzJ,KAAK2V,cAAe5V,GAAU4L,YAAa5L,EAE/E,CAEA,IAAA6V,CAAM7V,GAEL,MAAM,WAAE2V,EAAU,WAAExH,GAAelO,KAE7BkN,EAAanN,EAAQ8L,kBAAmB6J,GAC9C,GAAKxI,EAAW2I,WAAa,OAAO3I,EAAW2I,WAI/C,IAAI9I,EAAS,KAEb,GAAK2I,EAAWI,OAAS,CAExB,IAAIC,EAAwBpB,EAA6B7T,IAAKf,EAAQD,kBAEvCiB,IAA1BgV,IAEJA,EAAwB,IAAI7V,QAE5ByU,EAA6BnS,IAAKzC,EAAQD,YAAaiW,IAIxD,IAAIC,EAAeD,EAAsBjV,IAAK4U,QAExB3U,IAAjBiV,IAEJA,EAAezB,GAAYxU,EAAQkW,kBAAmBP,IAEtDK,EAAsBvT,IAAKkT,EAAYM,IAIH,OAAhCjW,EAAQmW,qBAEZnW,EAAQmW,oBAAoBC,SAASrQ,KAAMkQ,GAI5CjJ,EAASwH,GAAYyB,EAAaJ,KAAM1H,GAEzC,KAAO,CAEN,MAAMkI,EAASV,EAAWU,OACpBtK,EAA4B,OAAfoC,EAAsBkI,EAAQlI,EAAYnO,GAAYqW,EAAQrW,GAEjFgN,EAASwH,GAAYzI,EAEtB,CAQA,OANK4J,EAAWW,OAEfnJ,EAAW2I,WAAa9I,GAIlBA,CAER,CAEA,aAAA4I,CAAe5V,GAEd,MAAMmN,EAAanN,EAAQ8L,kBAAmB7L,MAQ9C,OAN+B,OAA1BkN,EAAWpB,aAEfoB,EAAWpB,WAAa9L,KAAKsW,YAAavW,IAIpCmN,EAAWpB,UAEnB,CAEA,KAAAI,CAAOnM,GAEN,OAAOC,KAAK2V,cAAe5V,EAE5B,CAEA,WAAAuW,CAAavW,GAMZ,OAJAA,EAAQwW,WAERxW,EAAQyW,MAAM1K,WAAa9L,KAAK4V,KAAM7V,GAE/BA,EAAQ0W,aAEhB,CAEA,QAAAnK,CAAUvM,EAASwM,GAIlB,OAFmBvM,KAAK2V,cAAe5V,GAErBsM,MAAOtM,EAASwM,EAEnC,EAID,MAAMmK,UAA2BlN,EAEhC,WAAA1J,CAAasW,EAAQ3M,GAEpBC,MAAOD,GAEPzJ,KAAKoW,OAASA,EACdpW,KAAK8V,OAAS,KAEd9V,KAAKgK,QAAS,EAEdhK,KAAKqW,MAAO,CAEb,CAEA,SAAAM,CAAWb,GAIV,OAFA9V,KAAK8V,OAASA,EAEP9V,IAER,CAEA,IAAA4V,CAAM/B,EAAS,MAId,OAFAE,GAAaF,GAENU,GAAY,IAAIkB,EAAwBzV,KAAM6T,GAEtD,CAEA,KAAA3H,GAEC,OAAOlM,KAAK4V,MAEb,EAID,MAAMgB,EAAQ,EAAE,GAAO,GACjBC,GAAQ,CAAE,EAAG,EAAG,EAAG,GACnBC,GAAO,EAAI,GAAK,GAChBC,GAAS,CAAE,GAAK,IAAK,EAAI,EAAG,KAAM,IAAK9R,KAAK+R,GAAc,EAAV/R,KAAK+R,GAAQ,EAAI/R,KAAK+R,GAAI,EAAI/R,KAAK+R,GAAI,GAAgB,EAAV/R,KAAK+R,IAAU/R,KAAK+R,GAAK,GAEtHC,GAAgB,IAAIvQ,IAC1B,IAAM,MAAMwQ,MAAQN,EAAQK,GAAczU,IAAK0U,GAAM,IAAIpE,EAAWoE,KAEpE,MAAMC,GAAgB,IAAIzQ,IAC1B,IAAM,MAAM0Q,MAAQP,GAAQM,GAAc3U,IAAK4U,GAAM,IAAItE,EAAWsE,GAAM,SAE1E,MAAMC,GAAe,IAAI3Q,IAAK,IAAKyQ,IAAgBG,KAAKC,GAAM,IAAIzE,EAAWyE,EAAGrU,MAAO,UACvF,IAAM,MAAMsU,MAAOV,GAAOO,GAAa7U,IAAKgV,GAAK,IAAI1E,EAAW0E,GAAK,QAErE,MAAMC,GAAiB,IAAI/Q,IAAK,IAAK2Q,IAAeC,KAAKC,GAAM,IAAIzE,EAAWyE,EAAGrU,UACjF,IAAM,MAAMwU,MAASX,GAASU,GAAejV,IAAKkV,GAAO,IAAI5E,EAAW4E,KACxE,IAAM,MAAMA,MAASX,GAASU,GAAejV,KAAOkV,GAAO,IAAI5E,GAAa4E,KAE5E,MAAMC,GAAY,CAAET,KAAMD,GAAeG,KAAMD,GAAeL,KAAMO,GAAcK,MAAOD,IAEnFG,GAAqB,IAAIlR,IAAK,IAAKuQ,MAAkBQ,KAErDI,GAAe,CAAE3U,EAAOqE,IAExBqQ,GAAmBjX,IAAKuC,GAErB0U,GAAmB9W,IAAKoC,IAEH,IAAjBA,EAAML,OAEVK,EAIA,IAAI4P,EAAW5P,EAAOqE,GAoBzBuQ,GAAc,SAAWvQ,EAAMwQ,EAAW,MAE/C,MAAO,IAAKrS,KAQX,IANuB,IAAlBA,EAAO1B,SAAoB,CAAE,OAAQ,QAAS,MAAO,QAASmS,SAAU5O,IAAU7B,EAAOsS,OAAOC,GAA0B,iBAAVA,OAEpHvS,EAAS,CAAE4B,EAAkBC,KAAS7B,KAIhB,IAAlBA,EAAO1B,QAA6B,OAAb+T,GAAqBA,EAASpX,IAAK+E,EAAQ,IAEtE,OAAO6O,GAAYwD,EAASjX,IAAK4E,EAAQ,KAI1C,GAAuB,IAAlBA,EAAO1B,OAAe,CAE1B,MAAMmC,EAAO0R,GAAcnS,EAAQ,GAAK6B,GACxC,MAjCqB,CAAEpB,IAEzB,IAEC,OAAOA,EAAKwF,aAEb,CAAE,MAAQuM,GAET,MAED,GAuBOC,CAAiBhS,KAAWoB,EAAcgN,GAAYpO,GACpDoO,GAAY,IAAInF,EAAajJ,EAAMoB,GAE3C,CAEA,MAAMxE,EAAQ2C,EAAO4R,KAAKW,GAASJ,GAAcI,KACjD,OAAO1D,GAAY,IAAInE,EAAUrN,EAAOwE,GAAQ,CAIlD,EAIM6Q,GAAYC,GAAoB,iBAANA,GAAwB,OAANA,EAAaA,EAAEnV,MAAQmV,EAInEC,GAAqBpV,GAAW,MAAEA,EAA4CA,EAAMuG,UAAYvG,EAAMmM,YAAgC,iBAAVnM,EAAqBA,EAAQ,MAAW,KAI1K,SAASqV,GAAYnC,EAAQ3M,GAE5B,OAAO,IAAI+O,MAAO,IAAI9B,EAAoBN,EAAQ3M,GAAYkK,EAE/D,CAEA,MAAMY,GAAa,CAAEvP,EAAK8P,EAAU,OApWX,SAAW2D,EAAK3D,EAAU,MAElD,MAAMvN,EAAOV,EAAc4R,GAE3B,GAAc,SAATlR,EAAkB,CAEtB,IAAIgN,EAAaG,EAAoB5T,IAAK2X,GAW1C,YAToB1X,IAAfwT,IAEJA,EAAa,IAAIiE,MAAOC,EAAK9E,GAE7Be,EAAoBlS,IAAKiW,EAAKlE,GAC9BG,EAAoBlS,IAAK+R,EAAYA,IAI/BA,CAER,CAAO,OAAmB,OAAZO,IAA+B,UAATvN,GAA6B,YAATA,IAA4BA,GAAiB,WAATA,GAA8B,WAATA,EAEzGgN,GAAYsD,GAAcY,EAAK3D,IAElB,WAATvN,EAEJmR,GAAID,GAILA,CAER,CAqUwDE,CAAkB3T,EAAK8P,GACzEf,GAAc,CAAE/O,EAAK8P,EAAU,OAAU,IAAIF,EAAmB5P,EAAK8P,GACrES,GAAY,CAAEvQ,EAAK8P,EAAU,OAAU,IAAIC,EAAiB/P,EAAK8P,GACjE8D,GAAY,IAAKlT,IAAY,IAAIuP,KAAoBvP,GACrDmT,GAAgB,IAAKnT,IAAY,IAAI8P,KAAwB9P,GAE7DgT,GAAK,CAAEtC,EAAQ3M,KAEpB,MAAMiM,EAAa,IAAI6C,GAAYnC,EAAQ3M,GAErCqP,EAAK,IAAKpT,KAEf,IAAImO,EAcJ,OAZAE,GAAarO,GAIZmO,EAFInO,EAAQ,IAAOA,EAAQ,GAAI7C,OAEtB,IAAK6C,GAILA,EAAQ,GAIXgQ,EAAWE,KAAM/B,EAAQ,EAsBjC,OAlBAiF,EAAGpD,WAAaA,EAEhBoD,EAAGnC,UAAcb,IAEhBJ,EAAWiB,UAAWb,GAEfgD,GAIRA,EAAGzC,KAAO,KAETX,EAAWW,MAAO,EAEXyC,GAIDA,CAAE,EAaV3F,EAAmB,YAAchN,IAEhCA,EAAK6D,QAAS,EAEP7D,KAMR,MAAM4S,GAAoBvC,IAEzBvD,EAAeuD,CAAK,EAIfwC,GAAkB,IAAM/F,EAExBgG,GAAK,IAAKvT,IAAYuN,EAAagG,MAAOvT,GAEhD,SAASwT,GAAQ/S,GAIhB,OAFK8M,GAAeA,EAAamB,IAAKjO,GAE/BA,CAER,CAEAgN,EAAmB,SAAU+F,IAI7B,MAAMC,GAAQ,IAAIrB,GAAa,SAEzBJ,GAAQ,IAAII,GAAa,QAASH,GAAUD,OAC5CF,GAAM,IAAIM,GAAa,MAAOH,GAAUb,MACxCM,GAAO,IAAIU,GAAa,OAAQH,GAAUP,MAC1CF,GAAO,IAAIY,GAAa,OAAQH,GAAUT,MAE1CkC,GAAO,IAAItB,GAAa,QACxBuB,GAAQ,IAAIvB,GAAa,SACzBwB,GAAQ,IAAIxB,GAAa,SACzByB,GAAQ,IAAIzB,GAAa,SAEzB0B,GAAO,IAAI1B,GAAa,QACxB2B,GAAQ,IAAI3B,GAAa,SACzB4B,GAAQ,IAAI5B,GAAa,SACzB6B,GAAQ,IAAI7B,GAAa,SAEzB8B,GAAO,IAAI9B,GAAa,QACxB+B,GAAQ,IAAI/B,GAAa,SACzBgC,GAAQ,IAAIhC,GAAa,SACzBiC,GAAQ,IAAIjC,GAAa,SAEzBkC,GAAO,IAAIlC,GAAa,QACxBmC,GAAO,IAAInC,GAAa,QACxBoC,GAAO,IAAIpC,GAAa,QAK9B3E,EAAmB,UAAWgG,IAC9BhG,EAAmB,UAAWuE,IAC9BvE,EAAmB,QAASqE,IAC5BrE,EAAmB,SAAUiE,IAC7BjE,EAAmB,SAAU+D,IAC7B/D,EAAmB,SAAUiG,IAC7BjG,EAAmB,UAAWkG,IAC9BlG,EAAmB,UAAWmG,IAC9BnG,EAAmB,UAAWoG,IAC9BpG,EAAmB,SAAUqG,IAC7BrG,EAAmB,UAAWsG,IAC9BtG,EAAmB,UAAWuG,IAC9BvG,EAAmB,UAAWwG,IAC9BxG,EAAmB,SAAUyG,IAC7BzG,EAAmB,UAAW0G,IAC9B1G,EAAmB,UAAW2G,IAC9B3G,EAAmB,UAAW4G,IAC9B5G,EAAmB,SAAU6G,IAC7B7G,EAAmB,SAAU8G,IAC7B9G,EAAmB,SAAU+G,IAI7B,MAAMC,GAAwBvB,GAAW3J,GACnCmL,GAAU,CAAEjU,EAAMkU,IAAW9F,GAAY,IAAInF,EAAamF,GAAYpO,GAAQkU,IAGpFlH,EAAmB,UAAWgH,IAC9BhH,EAAmB,UAAWiH,IAiB9B,MAAME,WAAyB9Q,EAE9B,eAAWjC,GAEV,MAAO,kBAER,CASA,WAAAzH,CAAa4C,EAAM6X,GAAS,EAAOC,EAAQ,GAE1C9Q,MAAO,UAOP1J,KAAK0C,KAAOA,EAQZ1C,KAAKua,OAASA,EASdva,KAAKwa,MAAQA,EASbxa,KAAKya,gBAAiB,CAEvB,CAEA,SAAA1M,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAK6B,KAAO1C,KAAK0C,KACjB7B,EAAKU,QAAUvB,KAAKuB,QACpBV,EAAK0Z,OAASva,KAAKua,MAEpB,CAEA,WAAAjM,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAK0C,KAAO7B,EAAK6B,KACjB1C,KAAKuB,QAAUV,EAAKU,QACpBvB,KAAKua,OAAS1Z,EAAK0Z,MAEpB,EAWD,MAAMG,GAAiBhY,GAAU,IAAI4X,GAAkB5X,GAUjDiY,GAAqB,CAAEjY,EAAM8X,EAAQ,IAAO,IAAIF,GAAkB5X,GAAM,EAAM8X,GAO9EI,GAA2BD,GAAoB,SAO/CE,GAA4BF,GAAoB,UAOhDG,GAA4BJ,GAAc,UAShD,MAAMK,WAAoBzI,EAEzB,eAAW/K,GAEV,MAAO,aAER,CAQA,WAAAzH,CAAaoD,EAAOuG,EAAW,MAE9BC,MAAOxG,EAAOuG,GASdzJ,KAAKgb,eAAgB,EAQrBhb,KAAK0C,KAAO,GASZ1C,KAAKib,UAAYH,EAElB,CAQA,KAAAI,CAAOxY,GAIN,OAFA1C,KAAK0C,KAAOA,EAEL1C,IAER,CAQA,QAAAmb,CAAUC,GAIT,OAFApb,KAAKib,UAAYG,EAEVpb,IAER,CAOA,QAAAqb,GAEC,OAAOrb,KAAKib,SAEb,CASA,cAAAK,CAAgBvb,GAEf,OAAOC,KAAKsL,QAASvL,EAEtB,CAEA,QAAAsK,CAAUC,EAAUX,GAEnB,MAAMmB,EAAO9K,KAAK+F,UAIlB,OAFAuE,EAAWA,EAASE,KAAMM,GAEnBpB,MAAMW,UAAYkR,IAExB,MAAMrY,EAAQoH,EAAUiR,EAAOzQ,QAEhB/J,IAAVmC,IAEJlD,KAAKkD,MAAQA,EAEd,GAEGyG,EAEL,CAEA,QAAA2C,CAAUvM,EAASwM,GAElB,MAAMhF,EAAOvH,KAAK2L,YAAa5L,GAEzBiM,EAAOhM,KAAKsb,eAAgBvb,GAElC,IAAIyb,EAAazb,EAAQkM,gBAAiBD,QAEtBjL,IAAfya,IAEJzb,EAAQ0b,YAAazb,KAAMgM,GAE3BwP,EAAaxb,MAId,MAAM0b,EAAiBF,EAAW/I,aAAc1S,GAE1C4b,EAAc5b,EAAQ6b,mBAAoBJ,EAAYE,EAAgB3b,EAAQ8b,YAAa7b,KAAK0C,MAAQ3C,EAAQsC,QAAQ6Y,OACxHnL,EAAehQ,EAAQmQ,gBAAiByL,GAI9C,YAF+B5a,IAA1BhB,EAAQsC,QAAQ6Y,cAA6Bnb,EAAQsC,QAAQ6Y,MAE3Dnb,EAAQ4N,OAAQoC,EAAcxI,EAAMgF,EAE5C,EAYD,MAAMuP,GAAU,CAAEC,EAAMC,KAEvB,MAAMvS,EAAW6O,GAAkB0D,GAAQD,GAGrC7Y,EAAU6Y,IAAwB,IAAhBA,EAAKlZ,OAAsBkZ,EAAK5V,MAAQ4V,EAAK5V,KAAKjD,OAAW6Y,EAAK7Y,MAAQ6Y,EAElG,OAAOxH,GAAY,IAAIwG,GAAa7X,EAAOuG,GAAY,EAkBxD,MAAMwS,WAAqBzS,EAE1B,eAAWjC,GAEV,MAAO,cAER,CASA,WAAAzH,CAAa2J,EAAU/G,EAAO,KAAMwZ,GAAU,GAE7CxS,MAAOD,GASPzJ,KAAK0C,KAAOA,EAQZ1C,KAAKkc,QAAUA,EASflc,KAAKmc,gBAAiB,CAEvB,CAEA,OAAA7Q,CAASvL,GAER,OAAOC,KAAK0C,MAAQgH,MAAM4B,QAASvL,EAEpC,CAQA,QAAAgL,GAEC,OAAO,CAER,CAEA,QAAAuB,CAAUvM,GAET,IAAIiQ,EAaJ,OAXsB,IAAjBhQ,KAAKkc,SAETlM,EAAUjQ,EAAQqc,mBAAoBpc,KAAMA,KAAK0C,MACjDsN,EAAQqM,oBAAqB,GAI7BrM,EAAUjQ,EAAQkQ,eAAgBjQ,KAAMA,KAAK0C,MAIvC3C,EAAQmQ,gBAAiBF,EAEjC,EAYD,MAAMpN,GAAW,CAAE2E,EAAM7E,IAAU6R,GAAY,IAAI0H,GAAc1U,EAAM7E,IAUjE4Z,GAAkB,CAAE/U,EAAM7E,IAAU6R,GAAY,IAAI0H,GAAc1U,EAAM7E,GAAM,IAO9E6Z,GAA6B1D,GAAeoD,GAAc,OAAQ,gBAOlEO,GAAyB3D,GAAeoD,GAAc,OAAQ,iBAO9DQ,GAA0B5D,GAAeoD,GAAc,QAAS,aAOhES,GAA0B7D,GAAeoD,GAAc,QAAS,aAOhEU,GAA0B9D,GAAeoD,GAAc,QAAS,aAOhEW,GAAmC/D,GAAeoD,GAAc,QAAS,sBAOzEY,GAAsBhE,GAAeoD,GAAc,OAAQ,SAO3Da,GAA+BjE,GAAeoD,GAAc,QAAS,kBAOrEc,GAA4BlE,GAAeoD,GAAc,QAAS,eAOlEe,GAA+BnE,GAAeoD,GAAc,QAAS,kBAOrEgB,GAAqCpE,GAAeoD,GAAc,QAAS,wBAO3EiB,GAAuBrE,GAAeoD,GAAc,QAAS,UAO7DkB,GAA2BtE,GAAeoD,GAAc,QAAS,cAOjEmB,GAA4BvE,GAAeoD,GAAc,OAAQ,eAOjEoB,GAA4BxE,GAAeoD,GAAc,OAAQ,eAOjEqB,GAA8BzE,GAAeoD,GAAc,QAAS,iBAOpEsB,GAA4B1E,GAAeoD,GAAc,QAAS,eAOlEuB,GAA0B3E,GAAeoD,GAAc,QAAS,aAOhE1P,GAAuBsM,GAAeoD,GAAc,OAAQ,UAO5DwB,GAAyB5E,GAAeoD,GAAc,QAAS,YAO/DyB,GAAwB7E,GAAeoD,GAAc,QAAS,WAc9D0B,GAAoB9E,GAAeoD,GAAc,QAAS,OAO1D/Z,GAA6B2W,GAAeoD,GAAc,QAAS,gBAOnE2B,GAA0B/E,GAAeoD,GAAc,QAAS,aAOhE4B,GAAoChF,GAAeoD,GAAc,QAAS,uBAO1E6B,GAAiCjF,GAAeoD,GAAc,QAAS,oBAOvE8B,GAA2BlF,GAAeoD,GAAc,QAAS,cAUvE,MAAM+B,WAAmBtO,EAExB,eAAWnI,GAEV,MAAO,YAER,CAQA,WAAAzH,CAAa6R,EAAYD,GAExBhI,QAOA1J,KAAK2R,WAAaA,EAOlB3R,KAAK0R,WAAaA,CAEnB,CAQA,eAAA9B,GAEC,OAAO,CAER,CAEA,WAAAjE,CAAa5L,EAASwM,GAErB,MAAkB,SAAXA,EAAoBvM,KAAK2R,WAAWhG,YAAa5L,GAAY,MAErE,CASA,gBAAAke,CAAkBle,GAEjB,MAAM,WAAE4R,GAAe3R,KAEvB,IAAgD,IAA3CD,EAAQme,YAAa,kBAA+BvM,EAAWT,aAAeS,EAAWV,WAAWjN,OAAS,EAAI,CAErH,MAAMma,EAAepe,EAAQ0P,cAAekC,EAAWxL,KAAKwF,YAAa5L,IAGzE,OAF8BuJ,EAAiBwH,KAAM,IAAK9O,MAAO,EAAGmc,KAAmBxM,EAAWV,UAInG,CAEA,OAAO,CAER,CAEA,QAAA3E,CAAUvM,EAASwM,GAElB,MAAM,WAAEoF,EAAU,WAAED,GAAe1R,KAE7Bie,EAAmBje,KAAKie,iBAAkBle,GAE1C+R,EAAaH,EAAWhG,YAAa5L,GAErCqe,EAASzM,EAAWtP,QAAS,CAAE8R,QAAQ,IAAS9H,MAAOtM,GACvDse,EAAS3M,EAAWrF,MAAOtM,EAAS+R,GAEpCF,EAAaF,EAAW/F,YAAa5L,GAErCsN,EAAWtN,EAAQuN,gBAAiBtN,MAI1C,IAAIuN,EAEJ,IAA8B,IAAzBF,EAASF,YAEG,SAAXZ,IAEJgB,EAAU6Q,QAIL,GAAKH,EAAmB,CAE9B,MAAMK,EAAYve,EAAQkQ,eAAgBjQ,KAAM,KAAM8R,GAChDM,EAAiBrS,EAAQmQ,gBAAiBoO,GAEhDve,EAAQoQ,gBAAiB,GAAIiC,OAAsBiM,IAAWre,MAE9D,MAAMue,EAAa5M,EAAWxL,KAAK9D,QAAS,CAAE8R,QAAQ,IAAS9H,MAAOtM,GAEtE,IAAM,IAAIsE,EAAI,EAAGA,EAAIsN,EAAWV,WAAWjN,OAAQK,IAAO,CAEzD,MAAM4N,EAAYN,EAAWV,WAAY5M,GAEzCtE,EAAQoQ,gBAAiB,GAAIoO,KAAgBtM,OAAiBG,MAAqB/N,MAAQrE,KAE5F,CAEgB,SAAXuM,IAEJgB,EAAU6Q,EAIZ,MAEC7Q,EAAU,GAAI6Q,OAAcC,IAEZ,SAAX9R,GAAoC,SAAfqF,IAEzB7R,EAAQoQ,gBAAiB5C,EAASvN,MAElB,SAAXuM,IAEJgB,EAAU6Q,IAUb,OAFA/Q,EAASF,aAAc,EAEhBpN,EAAQ4N,OAAQJ,EAASuE,EAAYvF,EAE7C,EAYD,MAAM4H,GAAuByE,GAAWoF,IAExC7K,EAAmB,SAAUgB,IAS7B,MAAMqK,WAAyB9O,EAE9B,eAAWnI,GAEV,MAAO,kBAER,CAQA,WAAAzH,CAAakW,EAAe,KAAMyI,EAAa,CAAC,GAE/C/U,QAQA1J,KAAKgW,aAAeA,EAQpBhW,KAAKye,WAAaA,CAEnB,CAQA,aAAAC,CAAeD,GAId,OAFAze,KAAKye,WAAaA,EAEXze,IAER,CAOA,aAAA2e,GAEC,OAAO3e,KAAKye,UAEb,CAEA,WAAA9S,CAAa5L,GAEZ,OAAOC,KAAKgW,aAAarK,YAAa5L,EAEvC,CAEA,QAAAuM,CAAUvM,GAET,MAAM2F,EAAS,GAETsQ,EAAehW,KAAKgW,aAEpBnC,EAASmC,EAAa4I,UAAW7e,GACjC0e,EAAaze,KAAKye,WAElBI,EAAgB,CAAE1Y,EAAM2Y,KAE7B,MAAMvX,EAAOuX,EAAUvX,KAGvB,IAAIgF,EAKJ,OAHeA,EAJU,YAAThF,EAIQ,IAAMpB,EAAKkG,MAAOtM,GAC5BoG,EAAKkG,MAAOtM,EAASwH,GAE5BgF,CAAM,EAId,GAAKxH,MAAMuB,QAASmY,GAEnB,IAAM,IAAIpa,EAAI,EAAGA,EAAIoa,EAAWza,OAAQK,IAEvCqB,EAAOI,KAAM+Y,EAAeJ,EAAYpa,GAAKwP,EAAQxP,UAMtD,IAAM,MAAMya,KAAajL,EAAS,CAEjC,MAAM1N,EAAOsY,EAAYK,EAAUpc,MAEnC,QAAc3B,IAAToF,EAMJ,MAAM,IAAIkN,MAAO,4BAA4ByL,EAAUpc,oCAJvDgD,EAAOI,KAAM+Y,EAAe1Y,EAAM2Y,GAQpC,CAMD,MAAO,GAFc9I,EAAa3J,MAAOtM,EAAS,gBAEvB2F,EAAOoL,KAAM,SAEzC,EAID,MAAM8E,GAAO,CAAEmJ,KAASrZ,KAEvBA,EAASA,EAAO1B,OAAS,GAAO0B,EAAQ,KAA8B,IAAvBA,EAAQ,GAAI7C,OAAoB0S,GAAW7P,GAAWqO,GAAarO,EAAQ,IAEnH6O,GAAY,IAAIiK,GAAkBjK,GAAYwK,GAAQrZ,KAI9DyN,EAAmB,OAAQyC,IAU3B,MAAMoJ,WAAqBtP,EAE1B,eAAWnI,GAEV,MAAO,cAER,CAUA,WAAAzH,CAAamf,EAAIC,EAAOC,KAAUzZ,GAIjC,GAFAgE,QAEKhE,EAAO1B,OAAS,EAAI,CAExB,IAAIob,EAAU,IAAIJ,GAAcC,EAAIC,EAAOC,GAE3C,IAAM,IAAI9a,EAAI,EAAGA,EAAIqB,EAAO1B,OAAS,EAAGK,IAEvC+a,EAAU,IAAIJ,GAAcC,EAAIG,EAAS1Z,EAAQrB,IAIlD6a,EAAQE,EACRD,EAAQzZ,EAAQA,EAAO1B,OAAS,EAEjC,CAOAhE,KAAKif,GAAKA,EAOVjf,KAAKkf,MAAQA,EAOblf,KAAKmf,MAAQA,CAEd,CAUA,WAAAxT,CAAa5L,EAASwM,GAErB,MAAM0S,EAAKjf,KAAKif,GAEVC,EAAQlf,KAAKkf,MACbC,EAAQnf,KAAKmf,MAEbE,EAAQH,EAAMvT,YAAa5L,GAC3Buf,OAAyB,IAAVH,EAAwBA,EAAMxT,YAAa5L,GAAY,KAE5E,GAAe,SAAVsf,GAA8B,SAAVC,EAExB,MAAO,OAED,GAAY,MAAPL,EAEX,OAAOI,EAED,GAAY,MAAPJ,GAAqB,MAAPA,GAAqB,MAAPA,GAAqB,MAAPA,GAAqB,OAAPA,GAAsB,OAAPA,EAElF,OAAOlf,EAAQwf,eAAgBF,GAEzB,GAAY,MAAPJ,GAAqB,OAAPA,GAAsB,OAAPA,GAAsB,OAAPA,GAAsB,OAAPA,EAEtE,MAAO,OAED,GAAY,MAAPA,GAAqB,MAAPA,GAAqB,OAAPA,GAAsB,OAAPA,EAAc,CAEpE,MAAMO,EAAajT,EAASxM,EAAQ0P,cAAelD,GAAWtH,KAAKoM,IAAKtR,EAAQ0P,cAAe4P,GAAStf,EAAQ0P,cAAe6P,IAE/H,OAAOE,EAAa,EAAI,OAAQA,IAAgB,MAEjD,CAEC,MAAe,UAAVH,GAAqBtf,EAAQ0f,SAAUH,GAEpCA,EAEIvf,EAAQ0f,SAAUJ,IAAWtf,EAAQ2f,SAAUJ,GAInDvf,EAAQ4f,oBAAqBN,GAEzBtf,EAAQ2f,SAAUL,IAAWtf,EAAQ0f,SAAUH,GAInDvf,EAAQ4f,oBAAqBL,GAEzBvf,EAAQ0P,cAAe6P,GAAUvf,EAAQ0P,cAAe4P,GAI5DC,EAIDD,CAIT,CAEA,QAAA/S,CAAUvM,EAASwM,GAElB,MAAM0S,EAAKjf,KAAKif,GAEVC,EAAQlf,KAAKkf,MACbC,EAAQnf,KAAKmf,MAEb5X,EAAOvH,KAAK2L,YAAa5L,EAASwM,GAExC,IAAI8S,EAAQ,KACRC,EAAQ,KAEE,SAAT/X,GAEJ8X,EAAQH,EAAMvT,YAAa5L,GAC3Buf,OAAyB,IAAVH,EAAwBA,EAAMxT,YAAa5L,GAAY,KAE1D,MAAPkf,GAAqB,MAAPA,GAAqB,OAAPA,GAAsB,OAAPA,GAAsB,OAAPA,EAEzDlf,EAAQ2f,SAAUL,GAEtBC,EAAQD,EAEGA,IAAUC,IAErBD,EAAQC,EAAQ,SAIC,OAAPL,GAAsB,OAAPA,GAE1BI,EAAQ9X,EACR+X,EAAQvf,EAAQ6f,oBAAqBN,EAAO,SAEjCvf,EAAQ0f,SAAUJ,IAAWtf,EAAQ2f,SAAUJ,GAI1DA,EAAQvf,EAAQ4f,oBAAqBN,GAMrCA,EAJWtf,EAAQ2f,SAAUL,IAAWtf,EAAQ0f,SAAUH,GAIlDvf,EAAQ4f,oBAAqBL,GAM7BA,EAAQ/X,GAMjB8X,EAAQC,EAAQ/X,EAIjB,MAAMsY,EAAIX,EAAM7S,MAAOtM,EAASsf,GAC1BS,OAAqB,IAAVX,EAAwBA,EAAM9S,MAAOtM,EAASuf,GAAU,KAEnES,EAAehgB,EAAQ0P,cAAelD,GACtCyT,EAAcjgB,EAAQkgB,oBAAqBhB,GAEjD,MAAgB,SAAX1S,EAEQ,MAAP0S,GAAcc,EAAe,EAE5BhgB,EAAQmgB,oBAELngB,EAAQ4N,OAAQ,GAAI5N,EAAQogB,UAAW,WAAY5T,OAAesT,MAAQC,MAAQvY,EAAMgF,GAIxFxM,EAAQ4N,OAAQ,KAAMkS,OAASC,MAAQvY,EAAMgF,GAInC,OAAP0S,GAAec,EAAe,EAEpChgB,EAAQmgB,oBAELngB,EAAQ4N,OAAQ,GAAI5N,EAAQogB,UAAW,gBAAiB5T,OAAesT,MAAQC,MAAQvY,EAAMgF,GAI7FxM,EAAQ4N,OAAQ,KAAMkS,QAAUC,MAAQvY,EAAMgF,GAIpC,MAAP0S,GAAcc,EAAe,EAEnChgB,EAAQmgB,oBAELngB,EAAQ4N,OAAQ,GAAI5N,EAAQogB,UAAW,cAAe5T,OAAesT,MAAQC,MAAQvY,EAAMgF,GAI3FxM,EAAQ4N,OAAQ,KAAMkS,OAASC,MAAQvY,EAAMgF,GAInC,OAAP0S,GAAec,EAAe,EAEpChgB,EAAQmgB,oBAELngB,EAAQ4N,OAAQ,GAAI5N,EAAQogB,UAAW,mBAAoB5T,OAAesT,MAAQC,MAAQvY,EAAMgF,GAIhGxM,EAAQ4N,OAAQ,KAAMkS,QAAUC,MAAQvY,EAAMgF,GAIpC,MAAP0S,GAAqB,MAAPA,EAElBlf,EAAQ4N,OAAQ,IAAIsR,IAAKY,KAAMR,EAAO9S,GAElCyT,EAEJjgB,EAAQ4N,OAAQ,GAAIqS,MAAkBH,MAAQC,MAAQvY,EAAMgF,GAI5DxM,EAAQ4N,OAAQ,KAAMkS,KAAOZ,KAAQa,MAAQvY,EAAMgF,GAItC,SAAV8S,EAENW,EAEGjgB,EAAQ4N,OAAQ,GAAIqS,MAAkBH,MAAQC,MAAQvY,EAAMgF,GAI5DxM,EAAQ4N,OAAQ,GAAIkS,KAAOZ,KAAQa,IAAMvY,EAAMgF,QARjD,CAcR,CAEA,SAAAwB,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKoe,GAAKjf,KAAKif,EAEhB,CAEA,WAAA3Q,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKif,GAAKpe,EAAKoe,EAEhB,EAaD,MAAM7K,GAAoBwE,GAAWoG,GAAc,KAW7CoB,GAAoBxH,GAAWoG,GAAc,KAW7CqB,GAAoBzH,GAAWoG,GAAc,KAW7CsB,GAAoB1H,GAAWoG,GAAc,KAU7CuB,GAAuB3H,GAAWoG,GAAc,KAUhDwB,GAAsB5H,GAAWoG,GAAc,MAU/CyB,GAAyB7H,GAAWoG,GAAc,MAUlD0B,GAAyB9H,GAAWoG,GAAc,KAUlD2B,GAA4B/H,GAAWoG,GAAc,KAUrD4B,GAA8BhI,GAAWoG,GAAc,MAUvD6B,GAAiCjI,GAAWoG,GAAc,MAU1D8B,GAAoBlI,GAAWoG,GAAc,MAU7C+B,GAAmBnI,GAAWoG,GAAc,MAU5CgC,GAAoBpI,GAAWoG,GAAc,KAU7CiC,GAAoBrI,GAAWoG,GAAc,MAU7CkC,GAAuBtI,GAAWoG,GAAc,KAUhDmC,GAAuBvI,GAAWoG,GAAc,KAUhDoC,GAAsBxI,GAAWoG,GAAc,KAU/CqC,GAAuBzI,GAAWoG,GAAc,KAUhDsC,GAA0B1I,GAAWoG,GAAc,MAUnDuC,GAA2B3I,GAAWoG,GAAc,MAE1D7L,EAAmB,MAAOiB,IAC1BjB,EAAmB,MAAOiN,IAC1BjN,EAAmB,MAAOkN,IAC1BlN,EAAmB,MAAOmN,IAC1BnN,EAAmB,SAAUoN,IAC7BpN,EAAmB,QAASqN,IAC5BrN,EAAmB,WAAYsN,IAC/BtN,EAAmB,WAAYuN,IAC/BvN,EAAmB,cAAewN,IAClCxN,EAAmB,gBAAiByN,IACpCzN,EAAmB,mBAAoB0N,IACvC1N,EAAmB,MAAO2N,IAC1B3N,EAAmB,KAAM4N,IACzB5N,EAAmB,MAAO6N,IAC1B7N,EAAmB,MAAO8N,IAC1B9N,EAAmB,SAAU+N,IAC7B/N,EAAmB,SAAUgO,IAC7BhO,EAAmB,QAASiO,IAC5BjO,EAAmB,SAAUkO,IAC7BlO,EAAmB,YAAamO,IAChCnO,EAAmB,aAAcoO,IAGjC,MAAMC,GAAY,IAAK9b,KAEtB+G,QAAQC,KAAM,iEACP6T,MAAW7a,IAInByN,EAAmB,YAAaqO,IAchC,MAAMC,WAAiB/R,EAEtB,eAAWnI,GAEV,MAAO,UAER,CAUA,WAAAzH,CAAa4hB,EAAQxC,EAAOC,EAAQ,KAAMwC,EAAQ,MAEjDjY,QAOA1J,KAAK0hB,OAASA,EAOd1hB,KAAKkf,MAAQA,EAQblf,KAAKmf,MAAQA,EAQbnf,KAAK2hB,MAAQA,CAEd,CAQA,YAAAlP,CAAc1S,GAEb,MAAM6hB,EAAQ5hB,KAAKkf,MAAMvT,YAAa5L,GAChC8hB,EAAQ7hB,KAAKmf,MAAQnf,KAAKmf,MAAMxT,YAAa5L,GAAY,KACzD+hB,EAAQ9hB,KAAK2hB,MAAQ3hB,KAAK2hB,MAAMhW,YAAa5L,GAAY,KAEzDgiB,EAAOhiB,EAAQ0f,SAAUmC,GAAU,EAAI7hB,EAAQ0P,cAAemS,GAC9DI,EAAOjiB,EAAQ0f,SAAUoC,GAAU,EAAI9hB,EAAQ0P,cAAeoS,GAC9DI,EAAOliB,EAAQ0f,SAAUqC,GAAU,EAAI/hB,EAAQ0P,cAAeqS,GAEpE,OAAKC,EAAOC,GAAQD,EAAOE,EAEnBL,EAEII,EAAOC,EAEXJ,EAEII,EAAOF,EAEXD,EAIDF,CAER,CAQA,WAAAjW,CAAa5L,GAEZ,MAAM2hB,EAAS1hB,KAAK0hB,OAEpB,OAAKA,IAAWD,GAASS,QAAUR,IAAWD,GAASU,UAAYT,IAAWD,GAASW,IAE/E,QAEIV,IAAWD,GAASY,MAExB,OAEIX,IAAWD,GAASa,IAExB,OAEIZ,IAAWD,GAASc,OAExBxiB,EAAQ6f,oBAAqB5f,KAAKkf,MAAMvT,YAAa5L,GAAW,QAE5D2hB,IAAWD,GAASe,IAExBxiB,KAAKkf,MAAMvT,YAAa5L,GAIxBC,KAAKyS,aAAc1S,EAI5B,CAEA,QAAAuM,CAAUvM,EAASwM,GAElB,IAAImV,EAAS1hB,KAAK0hB,OAElB,MAAMna,EAAOvH,KAAK2L,YAAa5L,GACzB0iB,EAAYziB,KAAKyS,aAAc1S,GAE/B8f,EAAI7f,KAAKkf,MACTY,EAAI9f,KAAKmf,MACT9W,EAAIrI,KAAK2hB,MAETe,EAAmB3iB,EAAQ+C,SAAS4f,iBAE1C,GAAKhB,IAAWD,GAASkB,oBAAsB,CAK9C,IAAIC,EAAK/C,EACLgD,EAAK/C,EAEJ/f,EAAQ0f,SAAUmD,EAAGjX,YAAa5L,IAEtC8iB,EAAKjJ,GAAMJ,GAAMqJ,GAAM,GAIvBD,EAAKhJ,GAAMJ,GAAMoJ,GAAM,GAIxB,MAAME,EAAUzC,GAAKuC,EAAIC,GAAKE,IAE9B,OAAOC,GAAWF,GAAUzW,MAAOtM,EAASwM,EAE7C,CAAO,GAAKmV,IAAWD,GAASwB,OAE/B,OAAOljB,EAAQ4N,OAAQ,OAASkS,EAAExT,MAAOtM,EAAS0iB,GAAc,KAAMlb,EAAMgF,GAEtE,GAAKmV,IAAWD,GAASyB,UAE/B,OAAO9C,GAAK,EAAKP,GAAIxT,MAAOtM,EAASwM,GAE/B,GAAKmV,IAAWD,GAAS0B,WAE/B,OAAO7C,GAAK,EAAKT,GAAIxT,MAAOtM,EAASwM,GAE/B,GAAKmV,IAAWD,GAAS2B,WAE/B,OAAOC,GAAKjD,GAAKP,EAAGC,IAAMzT,MAAOtM,EAASwM,GAEpC,CAEN,MAAM7G,EAAS,GAqDf,OAnDKgc,IAAWD,GAASY,OAASX,IAAWD,GAASe,IAErD9c,EAAOI,KACN+Z,EAAExT,MAAOtM,EAASwH,GAClBuY,EAAEzT,MAAOtM,EAASwH,IAGRmb,IAAqB,OAAyBhB,IAAWD,GAAS6B,KAE7E5d,EAAOI,KACN+Z,EAAExT,MAAOtM,EAA+D,IAAtDA,EAAQ0P,cAAeoQ,EAAElU,YAAa5L,IAAoB,QAAU0iB,GACtF3C,EAAEzT,MAAOtM,EAAS0iB,IAGNC,IAAqB,QAA2BhB,IAAWD,GAAS8B,KAAO7B,IAAWD,GAAS+B,MAAW9B,IAAWD,GAASe,IAE3I9c,EAAOI,KACN+Z,EAAExT,MAAOtM,EAAS0iB,GAClB3C,EAAEzT,MAAOtM,EAA+D,IAAtDA,EAAQ0P,cAAeqQ,EAAEnU,YAAa5L,IAAoB,QAAU0iB,IAG5Ef,IAAWD,GAASgC,QAE/B/d,EAAOI,KACN+Z,EAAExT,MAAOtM,EAAS0iB,GAClB3C,EAAEzT,MAAOtM,EAAS0iB,GAClBpa,EAAEgE,MAAOtM,EAAS,UAGR2hB,IAAWD,GAASiC,IAE/Bhe,EAAOI,KACN+Z,EAAExT,MAAOtM,EAAS0iB,GAClB3C,EAAEzT,MAAOtM,EAAS0iB,GAClBpa,EAAEgE,MAAOtM,EAA+D,IAAtDA,EAAQ0P,cAAepH,EAAEsD,YAAa5L,IAAoB,QAAU0iB,KAKlFC,IAAqB,OAA0BhB,IAAWD,GAASkC,MAAc,OAAN7D,IAE/E4B,EAAS,SAIVhc,EAAOI,KAAM+Z,EAAExT,MAAOtM,EAAS0iB,IACpB,OAAN3C,GAAapa,EAAOI,KAAMga,EAAEzT,MAAOtM,EAAS0iB,IACtC,OAANpa,GAAa3C,EAAOI,KAAMuC,EAAEgE,MAAOtM,EAAS0iB,KAI3C1iB,EAAQ4N,OAAQ,GAAI5N,EAAQogB,UAAWuB,EAAQna,OAAY7B,EAAOoL,KAAM,UAAYvJ,EAAMgF,EAElG,CAED,CAEA,SAAAwB,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAK6gB,OAAS1hB,KAAK0hB,MAEpB,CAEA,WAAApT,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAK0hB,OAAS7gB,EAAK6gB,MAEpB,EAMDD,GAASa,IAAM,MACfb,GAASmC,IAAM,MAEfnC,GAASoC,QAAU,UACnBpC,GAASqC,QAAU,UACnBrC,GAASsC,IAAM,MACftC,GAASuC,KAAO,OAChBvC,GAASwC,IAAM,MACfxC,GAASyC,KAAO,OAChBzC,GAAS0C,KAAO,OAChB1C,GAAS2C,aAAe,cACxB3C,GAAS4C,MAAQ,QACjB5C,GAAS6C,KAAO,OAChB7C,GAAS8C,UAAY,YACrB9C,GAAS+C,MAAQ,QACjB/C,GAASgD,IAAM,MACfhD,GAASiD,IAAM,MACfjD,GAASkD,IAAM,MACflD,GAASmD,KAAO,OAChBnD,GAASoD,KAAO,OAChBpD,GAASkC,KAAO,OAChBlC,GAASqD,IAAM,MACfrD,GAASsD,KAAO,OAChBtD,GAASS,OAAS,SAClBT,GAASwB,OAAS,SAClBxB,GAASyB,UAAY,WACrBzB,GAASuD,KAAO,OAChBvD,GAASwD,KAAO,OAChBxD,GAASyD,MAAQ,QACjBzD,GAAS0B,WAAa,aACtB1B,GAAS0D,MAAQ,QACjB1D,GAAS2D,OAAS,SAClB3D,GAAS4D,UAAY,YAIrB5D,GAAS6D,QAAU,UACnB7D,GAASc,OAAS,SAClBd,GAAS8B,IAAM,MACf9B,GAAS+B,IAAM,MACf/B,GAASe,IAAM,MACff,GAAS6B,KAAO,OAChB7B,GAAS8D,QAAU,UACnB9D,GAASU,SAAW,WACpBV,GAAS2B,WAAa,aACtB3B,GAASW,IAAM,MACfX,GAASY,MAAQ,QACjBZ,GAAS+D,IAAM,MACf/D,GAASkB,oBAAsB,qBAI/BlB,GAASiC,IAAM,MACfjC,GAASgE,MAAQ,QACjBhE,GAASgC,QAAU,UACnBhC,GAASiE,WAAa,aACtBjE,GAASkE,YAAc,cASvB,MAAMC,GAAwBlO,GAAO,MAc/BV,GAAmBU,GAAOzS,KAAK+R,IAgB/B6O,IAT2B5gB,KAAK+R,GASZ4B,GAAW6I,GAAUA,GAASa,MASlDwD,GAAoBlN,GAAW6I,GAAUA,GAASmC,KASlDmC,GAAwBnN,GAAW6I,GAAUA,GAASoC,SAStDmC,GAAwBpN,GAAW6I,GAAUA,GAASqC,SAStDmC,GAAoBrN,GAAW6I,GAAUA,GAASsC,KASlDmC,GAAqBtN,GAAW6I,GAAUA,GAASuC,MASnDmC,GAAoBvN,GAAW6I,GAAUA,GAASwC,KASlDmC,GAAqBxN,GAAW6I,GAAUA,GAASyC,MASnDmC,GAAqBzN,GAAW6I,GAAUA,GAAS0C,MASnDmC,GAA4B1N,GAAW6I,GAAUA,GAAS2C,cAS1DmC,GAAsB3N,GAAW6I,GAAUA,GAAS4C,OASpDmC,GAAqB5N,GAAW6I,GAAUA,GAAS6C,MASnDtB,GAA0BpK,GAAW6I,GAAUA,GAAS8C,WASxDkC,GAAsB7N,GAAW6I,GAAUA,GAAS+C,OASpDkC,GAAoB9N,GAAW6I,GAAUA,GAASgD,KASlDkC,GAAoB/N,GAAW6I,GAAUA,GAASiD,KASlDkC,GAAoBhO,GAAW6I,GAAUA,GAASkD,KASlDkC,GAAqBjO,GAAW6I,GAAUA,GAASmD,MASnDkC,GAAqBlO,GAAW6I,GAAUA,GAASoD,MASnDkC,GAAqBnO,GAAW6I,GAAUA,GAASkC,MASnDN,GAAoBzK,GAAW6I,GAAUA,GAASqD,KASlDkC,GAAqBpO,GAAW6I,GAAUA,GAASsD,MASnD/gB,GAAuB4U,GAAW6I,GAAUA,GAASS,QASrD+E,GAAuBrO,GAAW6I,GAAUA,GAASwB,QASrDiE,GAAyBtO,GAAW6I,GAAUA,GAASyB,WASvDiE,GAAqBvO,GAAW6I,GAAUA,GAASuD,MASnDoC,GAAqBxO,GAAW6I,GAAUA,GAASwD,MASnDoC,GAAsBzO,GAAW6I,GAAUA,GAASyD,OASpDoC,GAA2B1O,GAAW6I,GAAUA,GAAS0B,YASzDoE,GAAsB3O,GAAW6I,GAAUA,GAAS0D,OASpDqC,GAAuB5O,GAAW6I,GAAUA,GAAS2D,QASrDqC,GAA0B7O,GAAW6I,GAAUA,GAAS4D,WAsBxDhiB,IAV6Coe,GAAS6D,QAU/B1M,GAAW6I,GAAUA,GAASc,SAUrDmF,GAAsB9O,GAAW6I,GAAUA,GAAS8B,KAUpDoE,GAAsB/O,GAAW6I,GAAUA,GAAS+B,KAUpDoE,GAAoBhP,GAAW6I,GAAUA,GAASe,KAUlDqF,GAAqBjP,GAAW6I,GAAUA,GAAS6B,MAUnDwE,GAAwBlP,GAAW6I,GAAUA,GAAS8D,SAUtDwC,GAAyBnP,GAAW6I,GAAUA,GAASU,UAUvD6F,GAA2BpP,GAAW6I,GAAUA,GAAS2B,YAUzD6E,GAAoBrP,GAAW6I,GAAUA,GAASW,KAUlD8F,GAAsBtP,GAAW6I,GAAUA,GAASY,OAUpD8F,GAAoBvP,GAAW6I,GAAUA,GAAS+D,KASlD4C,GAAqBxP,GAAW6I,GAAUA,GAAS+D,IAAK,GASxD6C,GAAqBzP,GAAW6I,GAAUA,GAAS+D,IAAK,GASxD8C,GAAqB1P,GAAW6I,GAAUA,GAAS+D,IAAK,GAUxD+C,GAAmC3P,GAAW6I,GAAUA,GAASkB,qBASjE6F,GAAS3I,GAAOQ,GAAK2G,GAAMnH,GAAKsI,GAAK9E,GAAKxD,GAAK,EAAM,IASrD4I,GAAa5I,GAAOoI,GAAKpI,EAAGA,GAW5B6I,GAAoB9P,GAAW6I,GAAUA,GAASiC,KAWlDiF,GAAQ,CAAEzlB,EAAO0lB,EAAM,EAAGC,EAAO,IAAOtU,GAAY,IAAIkN,GAAUA,GAASgE,MAAOlR,GAAYrR,GAASqR,GAAYqU,GAAOrU,GAAYsU,KAStIC,GAAa5lB,GAAWylB,GAAOzlB,GAW/B6lB,GAAwBnQ,GAAW6I,GAAUA,GAASgC,SAWtDuF,GAA2BpQ,GAAW6I,GAAUA,GAASiE,YAWzDuD,GAA4BrQ,GAAW6I,GAAUA,GAASkE,aAS1DuD,GAAqBxQ,IAAI,EAAIyQ,MAElC,MACMC,EAAKnB,GAAKkB,EAAGE,GAAIjQ,GADb,QAAa,SACgBkQ,EAAK1B,GAAKwB,EAAIpS,IAErD,OAAOyP,GAAOC,GAAK4C,GAAKjJ,IAHW,YAGD,IAa7BkJ,GAAa,CAAEC,EAAGC,EAAIC,IAAQhB,GAAKe,EAAIC,EAAIF,GAW3CG,GAAoB,CAAEC,EAAGhB,EAAKC,IAAUG,GAAYJ,EAAKC,EAAMe,GAU/DC,GAAQ,CAAEC,EAAGF,KAElBnd,QAAQC,KAAM,yDACPqa,GAAM+C,EAAGF,IAWjBzW,EAAmB,MAAO0S,IAC1B1S,EAAmB,MAAO2S,IAC1B3S,EAAmB,SAAU9P,IAE7B8P,EAAmB,UAAW4S,IAC9B5S,EAAmB,UAAW6S,IAC9B7S,EAAmB,MAAO8S,IAC1B9S,EAAmB,OAAQ+S,IAC3B/S,EAAmB,MAAOgT,IAC1BhT,EAAmB,OAAQiT,IAC3BjT,EAAmB,OAAQkT,IAC3BlT,EAAmB,cAAemT,IAClCnT,EAAmB,QAASoT,IAC5BpT,EAAmB,OAAQqT,IAC3BrT,EAAmB,YAAa6P,IAChC7P,EAAmB,QAASsT,IAC5BtT,EAAmB,MAAOuT,IAC1BvT,EAAmB,MAAOwT,IAC1BxT,EAAmB,MAAOyT,IAC1BzT,EAAmB,OAAQ0T,IAC3B1T,EAAmB,OAAQ2T,IAC3B3T,EAAmB,OAAQ4T,IAC3B5T,EAAmB,MAAOkQ,IAC1BlQ,EAAmB,OAAQ6T,IAC3B7T,EAAmB,SAAUnP,IAC7BmP,EAAmB,WAAYsV,IAC/BtV,EAAmB,SAAU8T,IAC7B9T,EAAmB,WAAY+T,IAC/B/T,EAAmB,OAAQgU,IAC3BhU,EAAmB,OAAQiU,IAC3BjU,EAAmB,QAASkU,IAC5BlU,EAAmB,aAAcmU,IACjCnU,EAAmB,QAASoU,IAC5BpU,EAAmB,SAAUqU,IAC7BrU,EAAmB,QAAS0W,IAC5B1W,EAAmB,MAAOuU,IAC1BvU,EAAmB,MAAOwU,IAC1BxU,EAAmB,MAAOyU,IAC1BzU,EAAmB,OAAQ0U,IAC3B1U,EAAmB,UAAW2U,IAC9B3U,EAAmB,WAAY4U,IAC/B5U,EAAmB,MAAO8U,IAC1B9U,EAAmB,QAAS+U,IAC5B/U,EAAmB,MAAOgV,IAC1BhV,EAAmB,OAAQiV,IAC3BjV,EAAmB,OAAQkV,IAC3BlV,EAAmB,OAAQmV,IAC3BnV,EAAmB,qBAAsBoV,IACzCpV,EAAmB,MAAOoW,IAC1BpW,EAAmB,QAASwV,IAC5BxV,EAAmB,UAAW4V,IAC9B5V,EAAmB,aAAcwW,IACjCxW,EAAmB,cAAe8V,IAClC9V,EAAmB,aAAc6U,IACjC7U,EAAmB,WAAY2V,IAC/B3V,EAAmB,OAAQqV,IAC3BrV,EAAmB,YAAasU,IAChCtU,EAAmB,OAAQ+V,IAiB3B,MAAMa,WAAwBvgB,EAE7B,eAAWjC,GAEV,MAAO,iBAER,CASA,WAAAzH,CAAakqB,EAAUC,EAAQC,EAAW,MAEzCxgB,QAOA1J,KAAKgqB,SAAWA,EAOhBhqB,KAAKiqB,OAASA,EAQdjqB,KAAKkqB,SAAWA,CAEjB,CASA,WAAAve,CAAa5L,GAEZ,MAAM,OAAEkqB,EAAM,SAAEC,GAAanqB,EAAQ8L,kBAAmB7L,MAExD,QAAgBe,IAAXkpB,EAMJ,OAFAjqB,KAAKkM,MAAOnM,GAELC,KAAK2L,YAAa5L,GAI1B,MAAMoqB,EAASF,EAAOte,YAAa5L,GAEnC,GAAkB,OAAbmqB,EAAoB,CAExB,MAAME,EAAWF,EAASve,YAAa5L,GAEvC,GAAKA,EAAQ0P,cAAe2a,GAAarqB,EAAQ0P,cAAe0a,GAE/D,OAAOC,CAIT,CAEA,OAAOD,CAER,CAEA,KAAAje,CAAOnM,GAEN,MAAMiqB,EAAWhqB,KAAKgqB,SAASnb,QACzBob,EAASjqB,KAAKiqB,OAAOpb,QACrBqb,EAAWlqB,KAAKkqB,SAAWlqB,KAAKkqB,SAASrb,QAAU,KAInDwb,EAAmBtqB,EAAQsC,QAAQoL,UAEzC1N,EAAQuN,gBAAiB2c,GAASK,gBAAkBD,EAClC,OAAbH,IAAoBnqB,EAAQuN,gBAAiB4c,GAAWI,gBAAkBD,GAI/E,MAAMnd,EAAanN,EAAQ8L,kBAAmB7L,MAC9CkN,EAAW8c,SAAWA,EACtB9c,EAAW+c,OAASA,EAAO5nB,QAAS,CAAEoL,UAAWwc,IACjD/c,EAAWgd,SAAWA,EAAWA,EAAS7nB,QAAS,CAAEoL,UAAWyc,IAAe,IAEhF,CAEA,QAAA5d,CAAUvM,EAASwM,GAElB,MAAMhF,EAAOvH,KAAK2L,YAAa5L,GAEzBsN,EAAWtN,EAAQuN,gBAAiBtN,MAE1C,QAA+Be,IAA1BsM,EAASkd,aAEb,OAAOld,EAASkd,aAIjB,MAAM,SAAEP,EAAQ,OAAEC,EAAM,SAAEC,GAAanqB,EAAQ8L,kBAAmB7L,MAE5DwqB,EAAyB,SAAXje,EACdge,EAAeC,EAAc5nB,GAAU2E,GAAO8E,MAAOtM,GAAY,GAEvEsN,EAASkd,aAAeA,EAExB,MAAM/Y,EAAcwY,EAAS3d,MAAOtM,EAAS,QAE7CA,EAAQ0qB,YAAa,KAAM1qB,EAAQ2qB,WAAalZ,aAAyBmZ,aAEzE,IAAIC,EAAYX,EAAO5d,MAAOtM,EAASwH,GAkBvC,GAhBKqjB,IAIHA,EAFIJ,EAEQD,EAAe,MAAQK,EAAY,IAInC,UAAYA,EAAY,KAMtC7qB,EAAQ8qB,gBAAgBJ,YAAa1qB,EAAQ2qB,IAAM,KAAOE,EAAY,OAAS7qB,EAAQ2qB,IAAM,KAE3E,OAAbR,EAAoB,CAExBnqB,EAAQ0qB,YAAa,eAAgBE,aAErC,IAAIG,EAAcZ,EAAS7d,MAAOtM,EAASwH,GAEtCujB,IAIHA,EAFIN,EAEUD,EAAe,MAAQO,EAAc,IAIrC,UAAYA,EAAc,KAM1C/qB,EAAQ8qB,gBAAgBJ,YAAa1qB,EAAQ2qB,IAAM,KAAOI,EAAc,OAAS/qB,EAAQ2qB,IAAM,QAEhG,MAEC3qB,EAAQ0qB,YAAa,QAItB,OAAO1qB,EAAQ4N,OAAQ4c,EAAchjB,EAAMgF,EAE5C,EAaD,MAAMwe,GAAuBnS,GAAWmR,IAExC5W,EAAmB,SAAU4X,IAI7B,MAAMC,GAAO,IAAKtlB,KAEjB+G,QAAQC,KAAM,6DACPqe,MAAWrlB,IAInByN,EAAmB,OAAQ6X,IAc3B,MAAMC,WAAoBzhB,EAEzB,eAAWjC,GAEV,MAAO,aAER,CAQA,WAAAzH,CAAaqG,EAAMjD,EAAQ,CAAC,GAE3BwG,QASA1J,KAAKkrB,eAAgB,EAOrBlrB,KAAKmG,KAAOA,EAQZnG,KAAKkD,MAAQA,CAEd,CAOA,QAAAmI,GAEC,OAAOrL,KAAKmG,KAAKkF,UAElB,CAQA,WAAAM,CAAa5L,GAEZ,OAAOC,KAAKmG,KAAKwF,YAAa5L,EAE/B,CAEA,OAAAoM,CAASpM,GAERC,KAAKmG,KAAKkG,MAAOtM,EAElB,CAEA,KAAAmM,CAAOnM,GAEN,MAAMorB,EAAkBprB,EAAQqrB,aAEhCrrB,EAAQsrB,WAAY,IAAKtrB,EAAQsC,WAAYrC,KAAKkD,QAElD,MAAMiD,EAAOnG,KAAKmG,KAAKkG,MAAOtM,GAI9B,OAFAA,EAAQsrB,WAAYF,GAEbhlB,CAER,CAEA,QAAAmG,CAAUvM,EAASwM,GAElB,MAAM4e,EAAkBprB,EAAQqrB,aAEhCrrB,EAAQsrB,WAAY,IAAKtrB,EAAQsC,WAAYrC,KAAKkD,QAElD,MAAMqK,EAAUvN,KAAKmG,KAAKkG,MAAOtM,EAASwM,GAI1C,OAFAxM,EAAQsrB,WAAYF,GAEb5d,CAER,EAYD,MAAMlL,GAAwBuW,GAAWqS,IAUnC/P,GAAQ,CAAE/U,EAAMzD,IAAUL,GAAS8D,EAAM,CAAE+U,MAAOxY,IAExDyQ,EAAmB,UAAW9Q,IAC9B8Q,EAAmB,QAAS+H,IAc5B,MAAMoQ,WAAgB9hB,EAErB,eAAWjC,GAEV,MAAO,SAER,CAQA,WAAAzH,CAAaqG,EAAMzD,EAAO,MAEzBgH,QAOA1J,KAAKmG,KAAOA,EASZnG,KAAK0C,KAAOA,EAQZ1C,KAAKgK,QAAS,EASdhK,KAAKurB,WAAY,CAElB,CAEA,OAAAjgB,CAASvL,GAER,OAAOC,KAAK0C,MAAQgH,MAAM4B,QAASvL,EAEpC,CAEA,WAAA4L,CAAa5L,GAEZ,OAAOC,KAAKmG,KAAKwF,YAAa5L,EAE/B,CAEA,QAAAuM,CAAUvM,GAET,MAAM,KAAEoG,EAAI,KAAEzD,GAAS1C,KAEjBgQ,EAAUjQ,EAAQkQ,eAAgBjQ,KAAM0C,EAAM3C,EAAQ+P,cAAe9P,KAAK2L,YAAa5L,KAEvFgQ,EAAehQ,EAAQmQ,gBAAiBF,GAExCzC,EAAUpH,EAAKkG,MAAOtM,EAASiQ,EAAQzI,MAI7C,OAFAxH,EAAQoQ,gBAAiB,GAAGJ,OAAkBxC,IAAWvN,MAElD+P,CAER,EAYD,MAAMyb,GAA0B5S,GAAW0S,IAE3CnY,EAAmB,SAAS,IAAKzN,IAAY8lB,MAAc9lB,GAASwT,WAIpE,MAAMuS,GAAStlB,IAEdsG,QAAQC,KAAM,sDAEP8e,GAAWrlB,IAInBgN,EAAmB,OAAQsY,IAc3B,MAAMC,WAAoBliB,EAEzB,eAAWjC,GAEV,MAAO,aAER,CAQA,WAAAzH,CAAaqG,EAAMzD,EAAO,MAEzBgH,QAOA1J,KAAKmG,KAAOA,EASZnG,KAAK0C,KAAOA,EASZ1C,KAAK2rB,eAAgB,CAEtB,CAQA,QAAA5gB,GAEC,OAAO,CAER,CAEA,OAAAO,CAASvL,GAER,OAAOC,KAAK0C,MAAQgH,MAAM4B,QAASvL,EAEpC,CAEA,WAAA4L,CAAa5L,GAIZ,OAAOC,KAAKmG,KAAKwF,YAAa5L,EAE/B,CAQA,YAAA6rB,CAAc7rB,GAEb,MAAMmN,EAAanN,EAAQ8L,kBAAmB7L,MAE9C,IAAIkc,EAAUhP,EAAWgP,QAEzB,QAAiBnb,IAAZmb,EAAwB,CAE5B,MAAMxZ,EAAO1C,KAAK0C,KACZ6E,EAAOvH,KAAK2L,YAAa5L,GAE/BmN,EAAWgP,QAAUA,EAAUnc,EAAQqc,mBAAoBpc,KAAM0C,EAAM6E,GACvE2F,EAAW/G,KAAOnG,KAAKmG,IAExB,CAKA,OAFA+V,EAAQG,qBAAwBH,EAAQG,mBAA+C,aAAxBtc,EAAQ8b,aAEhEK,CAER,CAEA,KAAAhQ,CAAOnM,GAENC,KAAK4rB,aAAc7rB,EAEpB,CAEA,OAAAoM,CAASpM,GAIR,OAFAC,KAAK4rB,aAAc7rB,GAEZC,KAAKmG,KAAKgG,QAASpM,EAE3B,CAEA,QAAAuM,CAAUvM,GAET,MAAMmN,EAAanN,EAAQ8L,kBAAmB7L,MACxCkc,EAAUlc,KAAK4rB,aAAc7rB,GAE7B8rB,EAAwC,aAAxB9rB,EAAQ8b,cAA8D,IAAhC3O,EAAW4e,kBAA6B/rB,EAAQsC,QAAQ0pB,sBAEpH,QAAiChrB,IAA5BmM,EAAW6C,cAA8B8b,EAAgB,CAE7D,MAAMtkB,EAAOvH,KAAK2L,YAAa5L,GACzBgQ,EAAehQ,EAAQmQ,gBAAiBgM,EAAS3T,EAAgBC,QAGvEzI,EAAQisB,wBAAyBzjB,EAAgBC,OAAQxI,KAAKmG,KAAMoB,EAAMwI,GAE1E7C,EAAW6C,aAAeA,EAErB8b,EAGJ3e,EAAW4e,kBAAmB,OAEa/qB,IAAhCmM,EAAW4e,kBAAkC/rB,EAAQsC,QAAQ4pB,sBAExE/e,EAAW4e,kBAAmB,EAIhC,CAEA,OAAO/rB,EAAQmQ,gBAAiBgM,EAEjC,EAYD,MAAMA,GAAwBtD,GAAW8S,IASnCQ,GAAgB/lB,GAAU+V,GAAS/V,GAEzCgN,EAAmB,UAAW+I,IAC9B/I,EAAmB,cAAe+Y,IAWlC,MAAMC,GAAiCzT,IAAI,EAAIS,MAE9C,MAAM0G,EAAI1G,EAAMkH,IAAK,aAAejM,IAAK,aAAe+T,IAAK,KACvDrI,EAAI3G,EAAMkH,IAAK,aACfjL,EAAS+D,EAAMyH,cAAe,QAIpC,OAFkB8H,GAAK7I,EAAGC,EAAG1K,EAEb,IAEbuB,UAAW,CACdjU,KAAM,mBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,WAWnB6kB,GAAiC1T,IAAI,EAAIS,MAE9C,MAAM0G,EAAI1G,EAAMgP,IAAK,QAAU9H,IAAK,OAAQD,IAAK,MAC3CN,EAAI3G,EAAMkH,IAAK,OACfjL,EAAS+D,EAAMyH,cAAe,UAIpC,OAFkB8H,GAAK7I,EAAGC,EAAG1K,EAEb,IAEbuB,UAAW,CACdjU,KAAM,mBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,WAMnB8kB,GAAsB,oBACtBC,GAAqB,mBAQ3B,MAAMC,WAAuB7c,EAE5B,eAAWnI,GAEV,MAAO,gBAER,CASA,WAAAzH,CAAa0sB,EAAWnO,EAAQD,GAE/B1U,MAAO,QAOP1J,KAAKwsB,UAAYA,EAOjBxsB,KAAKqe,OAASA,EAOdre,KAAKoe,OAASA,CAEf,CAWA,iBAAAqO,CAAmB1sB,EAAS2sB,GAE3B,OAAKA,IAAeL,GAEZ,MAAgBM,kBAEZD,IAAeJ,GAEnBvsB,EAAQsC,QAAQuqB,kBAAoB7sB,EAAQ+C,SAAS8pB,iBAItDF,CAER,CAEA,KAAAxgB,CAAOnM,GAEN,MAAM,UAAEysB,GAAcxsB,KAEhBqe,EAASre,KAAKysB,kBAAmB1sB,EAASC,KAAKqe,QAC/CD,EAASpe,KAAKysB,kBAAmB1sB,EAASC,KAAKoe,QAErD,IAAItS,EAAa0gB,EAEjB,OAAiC,IAA5B,MAAgBK,SAAqBxO,IAAWD,GAAYC,GAAYD,GAMxE,MAAgB0O,YAAazO,KAAa,QAE9CvS,EAAa8N,GAAMuS,GAAkBrgB,EAAWihB,KAAOjhB,EAAW+T,IAI9D,MAAgBmN,aAAc3O,KAAa,MAAgB2O,aAAc5O,KAE7EtS,EAAa8N,GACZK,GAAM,MAAgBgT,WAAY,IAAI,MAAW5O,EAAQD,IAAWiC,IAAKvU,EAAWihB,KACpFjhB,EAAW+T,IAKR,MAAgBiN,YAAa1O,KAAa,QAE9CtS,EAAa8N,GAAMwS,GAAkBtgB,EAAWihB,KAAOjhB,EAAW+T,IAI5D/T,GAzBCA,CA2BT,EAWD,MAAMohB,GAAuB/mB,GAAUoO,GAAY,IAAIgY,GAAgBhY,GAAYpO,GAAQkmB,GAAqBC,KAS1Ga,GAAwBhnB,GAAUoO,GAAY,IAAIgY,GAAgBhY,GAAYpO,GAAQmmB,GAAoBD,KAU1Ge,GAAsB,CAAEjnB,EAAMumB,IAAgBnY,GAAY,IAAIgY,GAAgBhY,GAAYpO,GAAQkmB,GAAqBK,IAUvHW,GAAsB,CAAElnB,EAAMumB,IAAgBnY,GAAY,IAAIgY,GAAgBhY,GAAYpO,GAAQumB,EAAYL,KAapHlZ,EAAmB,qBAAsB+Z,IACzC/Z,EAAmB,sBAAuBga,IAE1Cha,EAAmB,sBAAuBia,IAC1Cja,EAAmB,sBAAuBka,IAa1C,IAAIC,GAAyB,cAAmCre,EAE/D,eAAW1H,GAEV,MAAO,sBAER,CAQA,WAAAzH,CAAaytB,EAAere,GAE3BxF,MAAO6jB,EAAere,GAStBlP,KAAKutB,cAAgBA,EASrBvtB,KAAKwtB,wBAAyB,CAE/B,CASA,WAAA7hB,GAEC,OAAO3L,KAAKutB,cAAcE,WAE3B,CAEA,QAAAnhB,CAAUvM,GAET,MAAMwN,EAAU7D,MAAM4C,SAAUvM,GAC1B2tB,EAAY1tB,KAAKutB,cAAc5hB,cAC/BgiB,EAAc3tB,KAAK2L,cAEzB,OAAO5L,EAAQ4N,OAAQJ,EAASmgB,EAAWC,EAE5C,GAYD,MAAMC,WAA0BpkB,EAE/B,eAAWjC,GAEV,MAAO,mBAER,CAUA,WAAAzH,CAAa8C,EAAU6qB,EAAantB,EAAS,KAAMoB,EAAQ,MAE1DgI,QAOA1J,KAAK4C,SAAWA,EAOhB5C,KAAKytB,YAAcA,EAQnBztB,KAAKM,OAASA,EAQdN,KAAK0B,MAAQA,EAQb1B,KAAKkN,WAAatK,EAAS4M,MAAO,KASlCxP,KAAK6tB,UAAYvtB,EAQjBN,KAAKmG,KAAO,KAQZnG,KAAKob,MAAQ,KAQbpb,KAAK2J,WAAajB,EAAeI,MAElC,CAQA,QAAAqS,CAAUC,GAIT,OAFApb,KAAKob,MAAQA,EAENpb,IAER,CASA,OAAAma,CAASjL,GAER,OAAOqF,GAAY,IAAI+Y,GAAwBttB,KAAMuU,GAAYrF,IAElE,CAQA,WAAA4e,CAAaL,GAEZ,MAAMtnB,EAAO2V,GAAS,KAAM2R,GAAc1nB,UAEtB,OAAf/F,KAAKob,OAETjV,EAAKgV,SAAUnb,KAAKob,OAIrBpb,KAAKmG,KAAOA,CAEb,CASA,WAAAwF,CAAa5L,GASZ,OAPmB,OAAdC,KAAKmG,OAETnG,KAAK6K,gBAAiB9K,GACtBC,KAAK+tB,eAIC/tB,KAAKmG,KAAKwF,YAAa5L,EAE/B,CAQA,qBAAAiuB,CAAuB1tB,EAASN,KAAK6tB,WAEpC,MAAM,WAAE3gB,GAAelN,KAEvB,IAAIkD,EAAQ5C,EAAQ4M,EAAY,IAEhC,IAAM,IAAI7I,EAAI,EAAGA,EAAI6I,EAAWlJ,OAAQK,IAEvCnB,EAAQA,EAAOgK,EAAY7I,IAI5B,OAAOnB,CAER,CASA,eAAA2H,CAAiBojB,GAIhB,OAFAjuB,KAAK6tB,UAA4B,OAAhB7tB,KAAKM,OAAkBN,KAAKM,OAAS2tB,EAAM3tB,OAErDN,KAAK6tB,SAEb,CAQA,KAAA3hB,GAIC,OAFAlM,KAAK+tB,cAEE/tB,KAAKmG,IAEb,CAOA,MAAAoE,GAECvK,KAAK+tB,aAEN,CAMA,WAAAA,GAEoB,OAAd/tB,KAAKmG,MAAgBnG,KAAK8tB,YAAa9tB,KAAKytB,aAEjD,MAAMvqB,EAAQlD,KAAKguB,wBAEdjpB,MAAMuB,QAASpD,GAEnBlD,KAAKmG,KAAKX,MAAQtC,EAIlBlD,KAAKmG,KAAKjD,MAAQA,CAIpB,EA4BD,MAAMgrB,WAA8BN,GAEnC,eAAWrmB,GAEV,MAAO,uBAER,CAUA,WAAAzH,CAAa8C,EAAU6f,EAAW3f,EAAW,MAE5C4G,MAAO9G,EAAU6f,EAAW3f,GAS5B9C,KAAK8C,SAAWA,EAEhB9C,KAAKmb,SAAUN,GAEhB,CASA,eAAAhQ,CAAiBojB,GAIhB,OAFAjuB,KAAK6tB,UAA8B,OAAlB7tB,KAAK8C,SAAoB9C,KAAK8C,SAAWmrB,EAAMnrB,SAEzD9C,KAAK6tB,SAEb,EAcD,MAAMM,GAAoB,CAAEzrB,EAAM6E,EAAMzE,EAAW,OAAUyR,GAAY,IAAI2Z,GAAuBxrB,EAAM6E,EAAMzE,IAShH,MAAMsrB,WAAwB1e,EAE7B,eAAWnI,GAEV,MAAO,iBAER,CASA,WAAAzH,CAAauuB,EAAaC,EAAeC,GAAqB/B,EAAY,MAEzE9iB,MAAO,QAOP1J,KAAKquB,YAAcA,EAQnBruB,KAAKsuB,aAAeA,EAQpBtuB,KAAKwsB,UAAYA,CAElB,CAQA,cAAAphB,GAEC,OAAO3F,EAAQzF,KAAKquB,YAErB,CAEA,KAAAniB,CAAOnM,GAEN,MAAMysB,EAAYxsB,KAAKwsB,WAAazsB,EAAQsC,QAAQ8W,MAC9CkV,EAAcruB,KAAKquB,YAEzB,GAAKA,IAAgB,MAAgB,OAAO7B,EAE5C,IAAI1gB,EAAa,KAEjB,MAAM0iB,EAAgBzuB,EAAQ+C,SAAS2rB,QAAQC,uBAAwBL,GAcvE,OAZuB,OAAlBG,EAEJ1iB,EAAa8N,GAAM4U,EAAehC,EAAUO,IAAK/sB,KAAKsuB,cAAgB9B,EAAU3M,IAIhFpT,QAAQkiB,MAAO,2DAA4DN,GAE3EviB,EAAa0gB,GAIP1gB,CAER,EAaD,MAAMuiB,GAAc,CAAEO,EAASC,EAAU1V,IAAW5E,GAAY,IAAI6Z,GAAiBQ,EAASra,GAAYsa,GAAYta,GAAY4E,KAO5HoV,GAAoCJ,GAAmB,sBAAuB,SAEpFhb,EAAmB,eAAe,CAAEgG,EAAOyV,EAASC,IAAcR,GAAaO,EAASC,EAAU1V,KA0BlG,MAAM2V,WAA4Bxc,EAEjC,eAAW/K,GAEV,MAAO,qBAER,CAUA,WAAAzH,CAAaoD,EAAO6rB,EAAa,KAAMC,EAAe,EAAGC,EAAe,GAEvEvlB,MAAOxG,EAAO6rB,GASd/uB,KAAKkvB,cAAe,EAQpBlvB,KAAK+uB,WAAaA,EAQlB/uB,KAAKgvB,aAAeA,EAQpBhvB,KAAKivB,aAAeA,EASpBjvB,KAAKmvB,MAAQ,MAQbnvB,KAAKovB,WAAY,EAQjBpvB,KAAK2C,UAAY,KAQjB3C,KAAKgK,QAAS,EAET9G,IAAqC,IAA5BA,EAAMmsB,oBAEnBrvB,KAAK2C,UAAYO,EACjBlD,KAAKmvB,MAAQjsB,EAAMisB,MACnBnvB,KAAKovB,UAAYlsB,EAAMosB,2BAIzB,CASA,OAAAhkB,CAASvL,GAER,GAA2B,IAAtBC,KAAKgvB,cAA4C,IAAtBhvB,KAAKivB,aAAqB,CAEzD,IAAIM,EAAaxvB,EAAQyvB,YAAYC,QAASzvB,KAAKkD,OAYnD,YAVoBnC,IAAfwuB,IAEJA,EAAa,CACZppB,KAAMnG,MAGPD,EAAQyvB,YAAYE,QAAS1vB,KAAKkD,MAAOqsB,IAInCA,EAAWppB,KAAK2D,IAExB,CAEA,OAAO9J,KAAK8J,IAEb,CASA,WAAA6B,CAAa5L,GAQZ,OANyB,OAApBC,KAAK+uB,aAET/uB,KAAK+uB,WAAahvB,EAAQ4vB,qBAAsB3vB,KAAK2C,YAI/C3C,KAAK+uB,UAEb,CASA,KAAA7iB,CAAOnM,GAEN,GAAwB,OAAnBC,KAAK2C,UAAqB,OAE/B,MAAM4E,EAAOvH,KAAK2L,YAAa5L,GACzByF,EAAQxF,KAAKkD,MACb0sB,EAAW7vB,EAAQ0P,cAAelI,GAClCsoB,EAAS7vB,KAAKgvB,cAAgBY,EAC9BE,EAAS9vB,KAAKivB,aAEd3mB,GAAuC,IAA9B9C,EAAMuqB,oBAA+BvqB,EAAQ,IAAI,MAAmBA,EAAOqqB,GACpFG,EAAkB,IAAI,MAA4B1nB,EAAQsnB,EAAUE,GAE1ExnB,EAAO2nB,SAAUjwB,KAAKmvB,OAEtBnvB,KAAK2C,UAAYqtB,EACjBhwB,KAAK2C,UAAU2sB,2BAA6BtvB,KAAKovB,SAElD,CAQA,QAAA9iB,CAAUvM,GAET,MAAM0J,EAAWzJ,KAAK2L,YAAa5L,GAE7BmwB,EAAgBnwB,EAAQowB,2BAA4BnwB,KAAMyJ,GAC1DsG,EAAehQ,EAAQmQ,gBAAiBggB,GAE9C,IAAI3jB,EAAS,KAEb,GAA6B,WAAxBxM,EAAQ8b,aAAoD,YAAxB9b,EAAQ8b,YAEhD7b,KAAK0C,KAAOqN,EAEZxD,EAASwD,MAEH,CAINxD,EAFoB2P,GAASlc,MAERqM,MAAOtM,EAAS0J,EAEtC,CAEA,OAAO8C,CAER,CAQA,YAAAkG,GAEC,MAAO,iBAER,CAQA,QAAAwd,CAAU/sB,GAUT,OARAlD,KAAKmvB,MAAQjsB,EAERlD,KAAK2C,YAAkD,IAArC3C,KAAK2C,UAAU0sB,oBAErCrvB,KAAK2C,UAAUwsB,MAAQjsB,GAIjBlD,IAER,CAQA,YAAAowB,CAAcltB,GAIb,OAFAlD,KAAKovB,UAAYlsB,EAEVlD,IAER,EAcD,MAAMgwB,GAAkB,CAAExqB,EAAO+B,EAAO,KAAMsoB,EAAS,EAAGC,EAAS,IAAOvb,GAAY,IAAIua,GAAqBtpB,EAAO+B,EAAMsoB,EAAQC,IAa9HO,GAAyB,CAAE7qB,EAAO+B,EAAO,KAAMsoB,EAAS,EAAGC,EAAS,IAAOE,GAAiBxqB,EAAO+B,EAAMsoB,EAAQC,GAASG,SAAU,OAYpIK,GAA2B,CAAE9qB,EAAO+B,EAAO,KAAMsoB,EAAS,EAAGC,EAAS,IAAOE,GAAiBxqB,EAAO+B,EAAMsoB,EAAQC,GAASM,cAAc,GAY1IG,GAAkC,CAAE/qB,EAAO+B,EAAO,KAAMsoB,EAAS,EAAGC,EAAS,IAAOO,GAAwB7qB,EAAO+B,EAAMsoB,EAAQC,GAASM,cAAc,GAE9Jjd,EAAmB,eAAiBqd,GAAgBR,GAAiBQ,EAAWttB,SAShF,MAAMutB,WAAoBjnB,EAEzB,eAAWjC,GAEV,MAAO,aAER,CASA,WAAAzH,CAAa4wB,EAAahvB,EAAOivB,EAAgB,CAAE,KAElDjnB,MAAO,QASP1J,KAAK4wB,eAAgB,EAOrB5wB,KAAK0wB,YAAcA,EAOnB1wB,KAAK0B,MAAQA,EAQb1B,KAAK2wB,cAAgBA,EAOrB3wB,KAAK6wB,cAAgB,EAOrB7wB,KAAKuB,QAAU,EAQfvB,KAAK0C,KAAO,GASZ1C,KAAK4J,iBAAmBlB,EAAeI,OAOvC9I,KAAK8wB,eAAiB,KAEtB9wB,KAAK+wB,qBAEN,CAKA,OAAA9lB,GAECjL,KAAKkL,cAAe,CAAE3D,KAAM,WAE7B,CAQA,KAAA2T,CAAOxY,GAIN,OAFA1C,KAAK0C,KAAOA,EAEL1C,IAER,CAKA,mBAAA+wB,GAEC,MAAM,MAAErvB,EAAK,cAAEivB,GAAkB3wB,KAEjC,IAAIgxB,EAAOL,EAAe,GAE1B,IAAM,IAAItsB,EAAI,EAAGA,EAAIssB,EAAc3sB,OAAQK,IAC1C2sB,GAAQL,EAAetsB,GAExBrE,KAAK6wB,cAAgB5rB,KAAKuhB,KAAM9kB,EAAQsvB,EAEzC,CAQA,MAAAC,CAAQ3mB,GAIP,OAFAtK,KAAK8wB,eAAiBxmB,EAEftK,IAER,CAOA,YAAAwM,EAAc,SAAE1J,IAEfA,EAASouB,QAASlxB,KAEnB,CAEA,QAAAsM,CAAUvM,GAET,MAAM,YAAE8b,GAAgB9b,EAExB,GAAqB,YAAhB8b,EAA4B,CAEhC,MAAMtO,EAAUvN,KAAK0wB,YAAYrkB,MAAOtM,EAAS,QAEhC,KAAZwN,GAEJxN,EAAQoQ,gBAAiB5C,EAASvN,KAIpC,CAED,EAaD,MAAMkxB,GAAU,CAAE/qB,EAAMzE,EAAOivB,IAAmBpc,GAAY,IAAIkc,GAAalc,GAAYpO,GAAQzE,EAAOivB,IAE1Gxd,EAAmB,UAAW+d,IAW9B,MAAMC,WAAkB3nB,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAQA,WAAAzH,CAAaqG,EAAMirB,GAAS,GAE3B1nB,QAOA1J,KAAKmG,KAAOA,EAQZnG,KAAKoxB,OAASA,EASdpxB,KAAKqxB,aAAc,CAEpB,CAEA,WAAA1lB,CAAa5L,GAEZ,MAAMuxB,EAAgBvxB,EAAQwxB,WACxB1iB,EAAQ9O,EAAQyxB,iBAAkBxxB,KAAMA,KAAKoxB,QAEnDrxB,EAAQ0xB,SAAU5iB,GAElB,MAAMpF,EAAWzJ,KAAKmG,KAAKwF,YAAa5L,GAIxC,OAFAA,EAAQ0xB,SAAUH,GAEX7nB,CAER,CAEA,KAAA4C,CAAOtM,KAAY2F,GAElB,MAAM4rB,EAAgBvxB,EAAQwxB,WACxB1iB,EAAQ9O,EAAQyxB,iBAAkBxxB,KAAMA,KAAKoxB,QAEnDrxB,EAAQ0xB,SAAU5iB,GAElB,MAAMhO,EAAOb,KAAKmG,KAAKkG,MAAOtM,KAAY2F,GAI1C,OAFA3F,EAAQ0xB,SAAUH,GAEXzwB,CAER,EAYD,MAAMgO,GAAQ,CAAE1I,EAAMirB,IAAY7c,GAAY,IAAI4c,GAAW5c,GAAYpO,GAAQirB,IAEjFje,EAAmB,QAAStE,IAe5B,MAAM6iB,WAAmBloB,EAExB,eAAWjC,GAEV,MAAO,YAER,CAQA,WAAAzH,CAAagM,EAAY6lB,GAExBjoB,QASA1J,KAAK4xB,cAAe,EAOpB5xB,KAAK8L,WAAaA,EAOlB9L,KAAK2xB,SAAWA,CAEjB,CAEA,WAAAhmB,CAAa5L,GAEZ,OAAOC,KAAK8L,WAAWH,YAAa5L,EAErC,CAEA,QAAAuM,CAAUvM,GAET,MAAMwN,EAAUvN,KAAK2xB,SAAStlB,MAAOtM,EAAS,QAQ9C,MANiB,KAAZwN,GAEJxN,EAAQoQ,gBAAiB5C,EAASvN,MAI5BA,KAAK8L,WAAWO,MAAOtM,EAE/B,EAYD,MAAM8xB,GAAuBjZ,GAAW8Y,IAExCve,EAAmB,SAAU0e,IAW7B,MAAMC,WAAkBtoB,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAWA,WAAAzH,CAAaqG,EAAM4rB,EAAWC,EAAYC,EAAava,GAAO,GAAKwa,EAAcxa,GAAO,IAEvFhO,QAOA1J,KAAKmG,KAAOA,EAOZnG,KAAK+xB,UAAYA,EAOjB/xB,KAAKgyB,WAAaA,EAQlBhyB,KAAKiyB,WAAaA,EAQlBjyB,KAAKkyB,YAAcA,EASnBlyB,KAAKmyB,SAAU,CAEhB,CAEA,KAAAjmB,GAEC,MAAM,KAAE/F,EAAI,UAAE4rB,EAAS,WAAEC,EAAU,WAAEC,EAAU,YAAEC,EAAW,QAAEC,GAAYnyB,KAE1E,IAAIwpB,EAAIrjB,EAAKia,IAAK2R,GAAYzR,IAAK0R,EAAW5R,IAAK2R,IAInD,OAFiB,IAAZI,IAAmB3I,EAAIA,EAAEb,SAEvBa,EAAEnJ,IAAK6R,EAAY9R,IAAK6R,IAAe7d,IAAK6d,EAEpD,EAeD,MAAMG,GAAsBxZ,GAAWkZ,GAAW,KAAM,KAAM,CAAEK,SAAS,IAanEE,GAA2BzZ,GAAWkZ,IAE5C3e,EAAmB,QAASif,IAC5Bjf,EAAmB,aAAckf,IAUjC,MAAMC,WAAuB9oB,EAE5B,eAAWjC,GAEV,MAAO,gBAER,CAQA,WAAAzH,CAAayN,EAAU,GAAI9D,EAAW,QAErCC,MAAOD,GAQPzJ,KAAKuN,QAAUA,CAEhB,CAEA,QAAAjB,CAAUvM,EAASwM,GAElB,MAAMhF,EAAOvH,KAAK2L,YAAa5L,GACzBwN,EAAUvN,KAAKuN,QAErB,GAAc,SAAThG,EAMJ,OAAOxH,EAAQ4N,OAAQ,KAAMJ,MAAchG,EAAMgF,GAJjDxM,EAAQoQ,gBAAiB5C,EAASvN,KAQpC,EAYD,MAAMuyB,GAA2B3Z,GAAW0Z,IAWtCE,GAAYC,IAAmBA,EAAc1H,GAAQ0H,EAAaF,GAAY,YAAgBA,GAAY,YAAcrZ,SAU9H/F,EAAmB,UAAWqf,IA2B9B,MAAME,WAAyBhjB,EAE9B,eAAWnI,GAEV,MAAO,kBAER,CASA,WAAAzH,CAAa0sB,EAAW6B,EAAazB,GAEpCljB,MAAO,QAOP1J,KAAKwsB,UAAYA,EAOjBxsB,KAAKquB,YAAcA,EAOnBruB,KAAK4sB,iBAAmBA,EASxB5sB,KAAK2yB,oBAAqB,CAE3B,CAEA,KAAAzmB,EAAO,QAAE7J,IAER,IAAIyJ,EAAa9L,KAAKwsB,WAAanqB,EAAQ8W,MAI3C,MAAMkV,GAAqC,OAArBruB,KAAKquB,YAAuBruB,KAAKquB,YAAchsB,EAAQgsB,cAAiB,MACxFzB,GAA+C,OAA1B5sB,KAAK4sB,iBAA4B5sB,KAAK4sB,iBAAmBvqB,EAAQuqB,mBAAsB,MAgBlH,OAdKyB,IAAgB,QAEpBviB,EAAaA,EAAWuiB,YAAaA,IAMjCzB,IAAqB,OAAgBA,IAAqB,MAAgBD,oBAE9E7gB,EAAaA,EAAWshB,oBAAqBR,IAIvC9gB,CAER,EAaD,MAAM8mB,GAAe,CAAEzZ,EAAOkV,EAAc,KAAMzB,EAAmB,OAAUrY,GAAY,IAAIme,GAAkBne,GAAY4E,GAASkV,EAAazB,IAEnJzZ,EAAmB,eAAgByf,IAmBnC,MAAMC,WAAsBrpB,EAE3B,eAAWjC,GAEV,MAAO,eAER,CAQA,WAAAzH,CAAagzB,EAAerpB,EAAW,MAEtCC,MAAOD,GAQPzJ,KAAKgK,QAAS,EAEdhK,KAAK+yB,eAAiBD,CAEvB,CAEA,OAAAxnB,CAASvL,GAER,OAAOC,KAAKgzB,iBAAkBjzB,EAE/B,CAEA,WAAA4L,CAAa5L,GAEZ,IAAI0J,EAAWzJ,KAAKyJ,SAEpB,GAAkB,OAAbA,EAAoB,CAExB,MAAMqpB,EAAgB9yB,KAAKgzB,iBAAkBjzB,GAE7C,GAAKA,EAAQkzB,qBAAsBH,GAAkB,CAEpD,MAAMnwB,EAAY5C,EAAQiB,SAASkyB,aAAcJ,GAEjDrpB,EAAW1J,EAAQ4vB,qBAAsBhtB,EAE1C,MAEC8G,EAAW,OAIb,CAEA,OAAOA,CAER,CAUA,gBAAA0pB,CAAkBL,GAIjB,OAFA9yB,KAAK+yB,eAAiBD,EAEf9yB,IAER,CAUA,gBAAAgzB,GAEC,OAAOhzB,KAAK+yB,cAEb,CAEA,QAAAzmB,CAAUvM,GAET,MAAM+yB,EAAgB9yB,KAAKgzB,iBAAkBjzB,GACvC0J,EAAWzJ,KAAK2L,YAAa5L,GAGnC,IAA2B,IAFDA,EAAQkzB,qBAAsBH,GAEtB,CAEjC,MAAMnwB,EAAY5C,EAAQiB,SAASkyB,aAAcJ,GAC3CM,EAAgBrzB,EAAQ4vB,qBAAsBhtB,GAE9CutB,EAAgBnwB,EAAQmzB,aAAcJ,EAAeM,GAE3D,GAA6B,WAAxBrzB,EAAQ8b,YAEZ,OAAO9b,EAAQ4N,OAAQuiB,EAAcxtB,KAAM0wB,EAAe3pB,GAM1D,OAFoByS,GAASlc,MAEVqM,MAAOtM,EAAS0J,EAIrC,CAIC,OAFAgD,QAAQC,KAAM,oCAAqComB,6BAE5C/yB,EAAQiT,cAAevJ,EAIhC,CAEA,SAAAsE,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKmJ,OAAShK,KAAKgK,OACnBnJ,EAAKkyB,eAAiB/yB,KAAK+yB,cAE5B,CAEA,WAAAzkB,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKgK,OAASnJ,EAAKmJ,OACnBhK,KAAK+yB,eAAiBlyB,EAAKkyB,cAE5B,EAYD,MAAMpwB,GAAY,CAAED,EAAM+G,IAAc8K,GAAY,IAAIse,GAAenwB,EAAM+G,IAWvE0f,GAAK,CAAE7nB,EAAQ,IAAOqB,GAAW,MAASrB,EAAQ,EAAIA,EAAQ,IAAM,QAW1E,MAAM+xB,WAAwB7pB,EAE7B,eAAWjC,GAEV,MAAO,iBAER,CAQA,WAAAzH,CAAawzB,EAAaC,EAAY,MAErC7pB,MAAO,SASP1J,KAAKwzB,mBAAoB,EAOzBxzB,KAAKszB,YAAcA,EAQnBtzB,KAAKuzB,UAAYA,CAElB,CAEA,QAAAjnB,CAAUvM,EAASwM,GAElB,MAAMknB,EAAkBzzB,KAAKszB,YAAYjnB,MAAOtM,EAAS,YACnD2zB,EAA2B,OAAnB1zB,KAAKuzB,UAAqB,IAAMvzB,KAAKuzB,UAAUlnB,MAAOtM,EAAS,OAE7E,OAAOA,EAAQ4N,OAAQ,GAAI5N,EAAQogB,UAAW,yBAA4BsT,MAAsBC,MAAY1zB,KAAK2L,YAAa5L,GAAWwM,EAE1I,EAYD,MAAMonB,GAA4B/a,GAAWya,IAc7C,MAAMO,WAAwB7Y,GAE7B,eAAWxT,GAEV,MAAO,iBAER,CAOA,WAAAzH,CAAawzB,GAEZ5pB,MAAO,GAQP1J,KAAK6zB,aAAeP,EASpBtzB,KAAK2J,WAAajB,EAAeE,KAElC,CAQA,eAAI0qB,GAEH,OAAOtzB,KAAK6zB,YAEb,CAQA,WAAIC,GAEH,OAAO9zB,KAAK6zB,aAAa3wB,KAE1B,CAEA,MAAAqH,GAEC,MAAMupB,EAAU9zB,KAAK8zB,QACfnlB,EAASmlB,EAAQnlB,OACjBolB,EAAUplB,GAAUA,EAAO3K,OAAS,EAAU2K,EAAQ,IAAOA,EAAQ,GAAIolB,OAAWplB,EAAQ,GAAQmlB,EAAQC,MAElH,GAAKA,QAAyBhzB,IAAhBgzB,EAAM5xB,MAAsB,CAEzC,MAAM,MAAEA,EAAK,OAAEC,GAAW2xB,EAE1B/zB,KAAKkD,MAAQ+B,KAAKmhB,KAAMnhB,KAAKoM,IAAKlP,EAAOC,GAE1C,CAED,EAWD,MAAM4xB,GAA4Bpb,GAAWgb,IAS7C,MAAMK,WAAoBlZ,GAEzB,eAAWxT,GAEV,MAAO,aAER,CAUA,WAAAzH,CAAaoD,EAAOgxB,EAAS,KAAMX,EAAY,KAAMY,EAAW,MAE/DzqB,MAAOxG,GASPlD,KAAKo0B,eAAgB,EAQrBp0B,KAAKk0B,OAASA,EAQdl0B,KAAKuzB,UAAYA,EAQjBvzB,KAAKm0B,SAAWA,EAQhBn0B,KAAKq0B,YAAc,KAQnBr0B,KAAKs0B,UAAY,KAQjBt0B,KAAKu0B,SAAW,KAQhBv0B,KAAKw0B,SAAU,EAUfx0B,KAAKy0B,cAAe,EAUpBz0B,KAAK2J,WAAajB,EAAeC,KAQjC3I,KAAKutB,cAAgB,KAQrBvtB,KAAK00B,OAASxxB,EAQdlD,KAAK20B,eAAiB,KAEtB30B,KAAK40B,gBAA4B,OAAXV,EAEvB,CAEA,SAAIhxB,CAAOA,GAELlD,KAAKutB,cAETvtB,KAAKutB,cAAcrqB,MAAQA,EAI3BlD,KAAK00B,OAASxxB,CAIhB,CAOA,SAAIA,GAEH,OAAOlD,KAAKutB,cAAgBvtB,KAAKutB,cAAcrqB,MAAQlD,KAAK00B,MAE7D,CAQA,cAAApZ,GAEC,OAAOtb,KAAKkD,MAAM4G,IAEnB,CAQA,WAAA6B,GAEC,OAAmC,IAA9B3L,KAAKkD,MAAM2xB,eAAiC,QAE5C70B,KAAKkD,MAAMqE,OAAS,MAEjB,QAEIvH,KAAKkD,MAAMqE,OAAS,MAExB,QAID,MAER,CAQA,YAAAkL,GAEC,MAAO,SAER,CAOA,YAAAqiB,GAEC,OAAO3L,GAAInpB,KAAKkD,MAAM6xB,QAEvB,CAQA,eAAAlqB,GAEC,OAAO7K,KAAKkD,KAEb,CAQA,gBAAA8xB,CAAkBd,GAIjB,OAF6B,OAAxBl0B,KAAK20B,iBAA0B30B,KAAK20B,eAAiB7Y,GAAS9b,KAAKkD,MAAM+xB,SAEvEj1B,KAAK20B,eAAetU,IAAK7G,GAAM0a,EAAQ,IAAM7K,EAErD,CAQA,eAAAuL,CAAiB1xB,GAKhB,OAHAlD,KAAKy0B,aAAevxB,EACpBlD,KAAK2J,WAAazG,EAAQwF,EAAeG,OAASH,EAAeC,KAE1D3I,IAER,CAUA,OAAAk1B,CAASn1B,EAASm0B,GAEjB,MAAMJ,EAAU9zB,KAAKkD,MAgBrB,OAdKnD,EAAQo1B,YAAiBrB,EAAQC,iBAAiBqB,cAAiC,IAAlBtB,EAAQuB,QAAsD,IAAlCvB,EAAQwB,wBAAmE,IAAjCxB,EAAQyB,uBAA4D,IAA3BzB,EAAQe,kBAI3LX,EAFIl0B,KAAKw0B,QAEAN,EAAOmB,QAIPnB,EAAOsB,KAAMhe,GAAKmc,GAAa3zB,KAAMA,KAAKuzB,WAAYzJ,GAAI1J,IAAK8T,EAAOpK,GAAI1J,IAAK,KAMnF8T,CAER,CAOA,KAAAhoB,CAAOnM,GAEN,MAAMmN,EAAanN,EAAQ8L,kBAAmB7L,MAC9CkN,EAAWqgB,cAAgBvtB,KAAKutB,cAIhC,MAAMuG,EAAU9zB,KAAKkD,MAErB,IAAO4wB,IAAiC,IAAtBA,EAAQ3wB,UAEzB,MAAM,IAAIkQ,MAAO,uFAMlB,IAAI6gB,EAASl0B,KAAKk0B,OAEA,OAAXA,IAAsD,IAAnCn0B,EAAQsC,QAAQozB,iBAA6B11B,EAAQsC,QAAQqzB,QAEtFxB,EAASn0B,EAAQsC,QAAQqzB,MAAO11B,OAI1Bk0B,IAASA,EAASl0B,KAAK80B,iBAEH,IAAtB90B,KAAKy0B,eAETP,EAASl0B,KAAKg1B,iBAAkBd,IAIjCA,EAASl0B,KAAKk1B,QAASn1B,EAASm0B,GAIhC,IAAIX,EAAYvzB,KAAKuzB,UAEF,OAAdA,GAAsBxzB,EAAQsC,QAAQszB,kBAE1CpC,EAAYxzB,EAAQsC,QAAQszB,gBAAiB31B,OAM9CkN,EAAWgnB,OAASA,EACpBhnB,EAAWqmB,UAAYA,EACvBrmB,EAAWinB,SAAWn0B,KAAKm0B,SAC3BjnB,EAAWmnB,YAAcr0B,KAAKq0B,YAC9BnnB,EAAWqnB,SAAWv0B,KAAKu0B,SAC3BrnB,EAAWonB,UAAYt0B,KAAKs0B,SAE7B,CASA,UAAAsB,CAAY71B,EAASm0B,GAEpB,OAAOA,EAAO7nB,MAAOtM,GAA0B,IAAjBC,KAAKw0B,QAAmB,OAAS,QAEhE,CAeA,eAAAqB,CAAiB91B,EAAS0zB,EAAiBqC,EAAWC,EAAcC,EAAaC,EAAcC,EAAgBC,GAE9G,MAAMrC,EAAU9zB,KAAKkD,MAErB,IAAIqK,EA4BJ,OAxBCA,EAFIwoB,EAEMh2B,EAAQq2B,qBAAsBtC,EAASL,EAAiBqC,EAAWC,EAAcE,GAEhFD,EAEDj2B,EAAQs2B,oBAAqBvC,EAASL,EAAiBqC,EAAWE,EAAaC,GAE9EE,EAEDp2B,EAAQu2B,oBAAqBxC,EAASL,EAAiBqC,EAAWK,EAAaF,GAE9EC,EAEDn2B,EAAQw2B,uBAAwBzC,EAASL,EAAiBqC,EAAWI,EAAgBD,IAEnE,IAAjBj2B,KAAKw0B,QAENz0B,EAAQy2B,oBAAqB1C,EAASL,EAAiBqC,EAAWG,GAIlEl2B,EAAQ02B,gBAAiB3C,EAASL,EAAiBqC,EAAWG,GAIlE1oB,CAER,CASA,QAAAjB,CAAUvM,EAASwM,GAElB,MAAMunB,EAAU9zB,KAAKkD,MAEfgK,EAAanN,EAAQ8L,kBAAmB7L,MACxCyzB,EAAkB/pB,MAAM4C,SAAUvM,EAAS,YAEjD,GAAgB,YAAXwM,EAEJ,OAAOknB,EAAkB,WAEnB,GAAK1zB,EAAQ22B,YAAanqB,GAEhC,OAAOknB,EAED,CAEN,MAAMpmB,EAAWtN,EAAQuN,gBAAiBtN,MAE1C,IAAI+P,EAAe1C,EAAS0C,aAE5B,QAAsBhP,IAAjBgP,EAA6B,CAEjC,MAAM,OAAEmkB,EAAM,UAAEX,EAAS,SAAEY,EAAQ,YAAEE,EAAW,UAAEC,EAAS,SAAEC,GAAarnB,EAEpE4oB,EAAY91B,KAAK41B,WAAY71B,EAASm0B,GACtC6B,EAAexC,EAAYA,EAAUlnB,MAAOtM,EAAS,SAAY,KACjEi2B,EAAc7B,EAAWA,EAAS9nB,MAAOtM,EAAS,SAAY,KAC9Dk2B,EAAe3B,EAAYA,EAAUjoB,MAAOtM,EAAS,OAAU,KAC/Dm2B,EAAiB7B,EAAcA,EAAYhoB,MAAOtM,EAAS,SAAY,KACvEo2B,EAAc5B,EAAW,CAAEA,EAAU,GAAIloB,MAAOtM,EAAS,QAAUw0B,EAAU,GAAIloB,MAAOtM,EAAS,SAAa,KAE9GiQ,EAAUjQ,EAAQkQ,eAAgBjQ,MAExC+P,EAAehQ,EAAQmQ,gBAAiBF,GAExC,MAAMzC,EAAUvN,KAAK61B,gBAAiB91B,EAAS0zB,EAAiBqC,EAAWC,EAAcC,EAAaC,EAAcC,EAAgBC,GAEpIp2B,EAAQoQ,gBAAiB,GAAGJ,OAAkBxC,IAAWvN,MAEzDqN,EAASE,QAAUA,EACnBF,EAAS0C,aAAeA,CAEzB,CAEA,IAAIxC,EAAUwC,EACd,MAAMtG,EAAWzJ,KAAK2L,YAAa5L,GAQnC,OANKA,EAAQ42B,yBAA0B7C,KAEtCvmB,EAAU8f,GAAqBkF,GAAYhlB,EAAS9D,GAAYqqB,EAAQpH,YAAaxgB,MAAOnM,GAAUsM,MAAOtM,EAAS0J,IAIhH1J,EAAQ4N,OAAQJ,EAAS9D,EAAU8C,EAE3C,CAED,CAQA,UAAAqqB,CAAY1zB,GAIX,OAFAlD,KAAKw0B,QAAUtxB,EAERlD,IAER,CAOA,UAAA62B,GAEC,OAAO72B,KAAKw0B,OAEb,CAIA,EAAArL,CAAI+K,GAIH,OAFAznB,QAAQC,KAAM,qEAEP1M,KAAK82B,OAAQ5C,EAErB,CAQA,MAAA4C,CAAQ5C,GAEP,MAAMZ,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYY,OAAS3f,GAAY2f,GACjCZ,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CAQA,IAAAyD,CAAMC,GAEL,MAAM1D,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYa,SAAW5f,GAAYyiB,GAAa3W,IAAK2T,GAAaV,IAClEA,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CAQA,KAAAI,CAAOH,GAEN,MAAMD,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYC,UAAYhf,GAAYgf,GACpCD,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CAQA,IAAAtC,CAAMuC,GAEL,OAAOI,GAAa3zB,KAAMuzB,EAE3B,CAQA,IAAA0D,CAAM9C,GAEL,MAAMb,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYa,SAAW5f,GAAY4f,GACnCb,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CAQA,OAAA4D,CAAS7C,GAER,MAAMf,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYe,YAAc9f,GAAY8f,GACtCf,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CASA,IAAA6D,CAAMC,EAAWC,GAEhB,MAAM/D,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYiB,SAAW,CAAEhgB,GAAY6iB,GAAa7iB,GAAY8iB,IAC9D/D,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CAQA,KAAAgE,CAAOhD,GAEN,MAAMhB,EAActzB,KAAK6B,QAIzB,OAHAyxB,EAAYgB,UAAY/f,GAAY+f,GACpChB,EAAY/F,cAAgBvtB,KAAK+F,UAE1BwO,GAAY+e,EAEpB,CAIA,SAAAvlB,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKqC,MAAQlD,KAAKkD,MAAMkD,OAAQvF,EAAKwN,MAAOvE,KAC5CjJ,EAAK2zB,QAAUx0B,KAAKw0B,QACpB3zB,EAAK4zB,aAAez0B,KAAKy0B,aACzB5zB,EAAK8I,WAAa3J,KAAK2J,UAExB,CAEA,WAAA2E,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKkD,MAAQrC,EAAKwN,KAAKK,SAAU7N,EAAKqC,OACtClD,KAAKw0B,QAAU3zB,EAAK2zB,QACpBx0B,KAAKy0B,aAAe5zB,EAAK4zB,aACzBz0B,KAAK2J,WAAa9I,EAAK8I,UAExB,CAKA,MAAAY,GAEC,MAAMupB,EAAU9zB,KAAKkD,MACfq0B,EAAgBv3B,KAAK20B,eAEJ,OAAlB4C,IAAyBA,EAAcr0B,MAAQ4wB,EAAQmB,SAE1B,IAA7BnB,EAAQ0D,kBAEZ1D,EAAQW,cAIV,CAOA,KAAA5yB,GAEC,MAAM41B,EAAU,IAAIz3B,KAAKF,YAAaE,KAAKkD,MAAOlD,KAAKk0B,OAAQl0B,KAAKuzB,UAAWvzB,KAAKm0B,UAGpF,OAFAsD,EAAQjD,QAAUx0B,KAAKw0B,QAEhBiD,CAER,EAcD,MAAM3D,GAAwBlb,GAAWqb,IAYnCyD,GAAc,IAAKhyB,IAAYouB,MAAYpuB,GAASkxB,YAAY,GAoBhEe,GAA2B7b,GAAS,SAAUZ,MAAO,cAAeC,SAAUN,IAAcnQ,gBAAgB,EAAIktB,YAAcA,EAAOC,OAOrIC,GAA0Bhc,GAAS,SAAUZ,MAAO,aAAcC,SAAUN,IAAcnQ,gBAAgB,EAAIktB,YAAcA,EAAOG,MAOnIC,GAAuClc,GAAS,QAASZ,MAAO,0BAA2BC,SAAUN,IAAcnQ,gBAAgB,EAAIktB,YAAcA,EAAOK,mBAc5JC,GAAiCpc,GAAS,QAASZ,MAAO,oBAAqBC,SAAUN,IAAcnQ,gBAAgB,EAAIktB,YAAcA,EAAOO,qBAqBhJC,GAA+Btc,GAAS,IAAI,OAAYZ,MAAO,kBAAmBC,SAAUN,IAAcnQ,gBAAgB,EAAIktB,UAAU9sB,IAAUA,EAAK5H,MAAMm1B,sBAAuBT,EAAOh2B,eAiBjM,MAAM02B,WAAqB9uB,EAE1B,eAAWjC,GAEV,MAAO,cAER,CAQA,WAAAzH,CAAaqV,EAAOojB,EAAW,MAE9B7uB,QAOA1J,KAAKmV,MAAQA,EAQbnV,KAAKu4B,SAAWA,EAQhBv4B,KAAK2J,WAAajB,EAAeI,OAQjC9I,KAAKw4B,aAAe,IAAIzd,GAAa,KAEtC,CAQA,WAAApP,GAEC,MAAMwJ,EAAQnV,KAAKmV,MAEnB,OAAKA,IAAUmjB,GAAaG,aAEpB,OAEItjB,IAAUmjB,GAAaI,UAAYvjB,IAAUmjB,GAAaK,eAAiBxjB,IAAUmjB,GAAaM,WAAazjB,IAAUmjB,GAAaO,MAE1I,YAFD,CAMR,CAOA,MAAAtuB,CAAQgR,GAEP,MAAMjb,EAASN,KAAKu4B,SACdO,EAAc94B,KAAKw4B,aACnBrjB,EAAQnV,KAAKmV,MAEnB,GAAKA,IAAUmjB,GAAaG,aAE3BK,EAAY51B,MAAQ5C,EAAOsB,iBAErB,GAAKuT,IAAUmjB,GAAaI,SAElCI,EAAY51B,MAAQ41B,EAAY51B,OAAS,IAAI,MAE7C41B,EAAY51B,MAAMm1B,sBAAuB/3B,EAAOsB,kBAE1C,GAAKuT,IAAUmjB,GAAaO,MAElCC,EAAY51B,MAAQ41B,EAAY51B,OAAS,IAAI,MAE7C41B,EAAY51B,MAAM61B,mBAAoBz4B,EAAOsB,kBAEvC,GAAKuT,IAAUmjB,GAAaM,UAElCE,EAAY51B,MAAQ41B,EAAY51B,OAAS,IAAI,MAE7C5C,EAAO04B,kBAAmBF,EAAY51B,YAEhC,GAAKiS,IAAUmjB,GAAaK,cAAgB,CAElD,MAAMf,EAASrc,EAAMqc,OAErBkB,EAAY51B,MAAQ41B,EAAY51B,OAAS,IAAI,MAC7C41B,EAAY51B,MAAMm1B,sBAAuB/3B,EAAOsB,aAEhDk3B,EAAY51B,MAAM+1B,aAAcrB,EAAOO,mBAExC,CAED,CASA,QAAA7rB,CAAUvM,GAET,MAAMoV,EAAQnV,KAAKmV,MAYnB,OAVKA,IAAUmjB,GAAaG,aAE3Bz4B,KAAKw4B,aAAa/uB,SAAW,OAElB0L,IAAUmjB,GAAaI,UAAYvjB,IAAUmjB,GAAaK,eAAiBxjB,IAAUmjB,GAAaM,WAAazjB,IAAUmjB,GAAaO,QAEjJ74B,KAAKw4B,aAAa/uB,SAAW,QAIvBzJ,KAAKw4B,aAAansB,MAAOtM,EAEjC,CAEA,SAAAgO,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAKsU,MAAQnV,KAAKmV,KAEnB,CAEA,WAAA7G,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAKmV,MAAQtU,EAAKsU,KAEnB,EAIDmjB,GAAaG,aAAe,cAC5BH,GAAaI,SAAW,WACxBJ,GAAaO,MAAQ,QACrBP,GAAaK,cAAgB,eAC7BL,GAAaM,UAAY,YASsCN,GAAaM,UASXN,GAAaG,aAT9E,MAkBMS,GAA+BtgB,GAAW0f,GAAcA,GAAaI,UAShBJ,GAAaO,MASNP,GAAaK,cAY/E,MAAMQ,WAAkBb,GAEvB,eAAW/wB,GAEV,MAAO,WAER,CAOA,WAAAzH,CAAaqV,GAEZzL,MAAOyL,EAER,CAQA,MAAA5K,CAAQgR,GAEPvb,KAAKu4B,SAAWhd,EAAMjb,OAEtBoJ,MAAMa,OAAQgR,EAEf,EASD,MAOM6d,GAAiCvgB,GAAesgB,GAAWA,GAAUV,cA4BrEY,GAAkCvd,GAAS,IAAI,OAAYnR,gBAAgB,EAAIrK,UAAUwK,IAAUA,EAAK5H,MAAMo2B,gBAAiBh5B,EAAOsB,eActIoB,GAAkC0V,IAAM3Y,GAEtCA,EAAQ+C,SAASC,MAAMC,iBAAmBu2B,KAE9CljB,MAJkC,GAIvBmjB,MAAO,mBAShBD,GAAuCrB,GAAiB7X,IAAK+Y,IAqD7DK,GAAiC92B,GAAW,WAAY,QAOxD+2B,GAA8BD,GAAiBvd,QAAS,iBAQxDyd,GAAiCF,GAAiBvd,QAAS,oBAO3D0d,GAA8BR,GAAiB/Y,IAAKqZ,IAAgB3W,IAAI7G,QAAS,mBAAoB7Z,QAAS,CAAE0pB,uBAAuB,IAOvI8N,GAAuCH,GAAcnR,mBAAoB6Q,IAAmBld,QAAS,4BAA6B8G,YAAYwW,MAAO,0BAA2Bn3B,QAAS,CAAE0pB,uBAAuB,IAOlN+N,GAA+BphB,IAAM3Y,GAEnCA,EAAQsC,QAAQ03B,qBAErB,QAAS1jB,MAJuB,GAIZ6F,QAAS,kBAAmB7Z,QAAS,CAAE0pB,uBAAuB,IAO/EiO,GAAsCF,GAAa7S,SAAS/K,QAAS,2BAA4B8G,YAAYwW,MAAO,yBAS1H,MAAMS,WAAwBzwB,EAE7B,eAAWjC,GAEV,MAAO,iBAER,CAKA,WAAAzH,GAEC4J,MAAO,QASP1J,KAAKk6B,mBAAoB,CAE1B,CAEA,QAAA5tB,CAAUvM,GAET,MAAM,SAAE+C,EAAQ,SAAE7B,GAAalB,EAE/B,OAAK+C,EAAS4f,mBAAqB,OAE7BzhB,EAASk5B,OAAS,MAEf,QAMFp6B,EAAQq6B,gBAEhB,EASD,MAAMC,GAA4BxhB,GAAeohB,IAQ3CK,GAA8B5iB,GAAO2iB,IAAcha,IAAK,GAAMD,IAAK,GASnEma,GAA+B53B,GAAW,SAAU,QAOpD63B,GAA8B9hB,IAAM3Y,IAEU,IAA9CA,EAAQiB,SAASy5B,aAAc,WAEnChuB,QAAQC,KAAM,oEAEP8M,GAAM,EAAG,EAAG,IAIb+gB,IAEL,QAASlkB,MAZsB,GAYXmjB,MAAO,eAOxBkB,GAA2BZ,GAAa3S,OAAOe,MAAO4R,GAAa1S,QAASpE,YAAYwW,MAAO,cAO/FmB,GAA6BjiB,IAAM3Y,IAExC,IAAIoG,EAYJ,OARCA,GAFqC,IAAjCpG,EAAQkB,SAAS25B,YAEdF,GAIAxe,GAAS2e,GAAuBL,IAAe,gBAAiBxX,YAIjE7c,CAAI,GAET,QAASkQ,MAhBqB,GAgBVmjB,MAAO,cAOxBsB,GAA4B5e,GAASye,GAAWpS,mBAAoB2P,IAAoB,iBAAkBlV,YAAYwW,MAAO,eAO7HuB,GAAwCriB,IAAM3Y,GAE5CA,EAAQsC,QAAQ24B,eAErB,QAAS3kB,MAJgC,GAIrBgK,IAAKia,IAAgBd,MAAO,yBAO7CyB,GAAuCF,GAAsBxS,mBAAoB2P,IAAmBsB,MAAO,0BAO3G0B,GAAiDxiB,IAAM3Y,GAErDA,EAAQsC,QAAQ84B,wBAErB,QAAS9kB,MAJyC,GAI9BgK,IAAKia,IAAgBd,MAAO,kCAU7C4B,GAAgC1iB,IAAI,EAAI2iB,EAAQpG,EAASmE,OAE9D,MAAMkC,EAAIrhB,GAAMgb,GAEVsG,EAAoBF,EAAO/a,IAAK9G,GAAM8hB,EAAG,GAAIrT,IAAKqT,EAAG,IAAOA,EAAG,GAAIrT,IAAKqT,EAAG,IAAOA,EAAG,GAAIrT,IAAKqT,EAAG,MAEvG,OAAOA,EAAEjb,IAAKkb,GAAoBxY,GAAG,IAYhC8X,GAAsCniB,IAAI,EAAI2iB,GAAUt7B,KAE7D,MAAMkD,EAAwBlD,EAAQ+C,SAASC,MAAME,sBAErD,GAA+B,OAA1BA,EAEJ,OAAOA,EAAsBslB,mBAAoB8S,GAMlD,MAAME,EAAoBlC,GAAkBhZ,IAAKgb,GAEjD,OAAOnD,GAAiB3P,mBAAoBgT,EAAmB,IAW1DC,GAAwC1f,GAAS,GAAIlR,aAAa,EAAI3J,cAAgBA,IAAWyJ,gBAAgB,EAAIzJ,cAAgBA,EAASw6B,kBAS9IC,GAA4B1B,GAAsB/S,SAASa,QAASiT,IAOpEY,GAA4B3B,GAAsB/S,SAAS8B,QAASgS,GAAuBS,IAO3FI,GAA8BF,GAAYnT,mBAAoB2P,IAAmBsB,MAAO,iBAOxFqC,GAA8BF,GAAYpT,mBAAoB2P,IAAmBsB,MAAO,iBAS9F,MAAMsC,WAAwB7H,GAE7B,eAAW1sB,GAEV,MAAO,iBAER,CAUA,WAAAzH,CAAaoD,EAAOgxB,EAAS,KAAMX,EAAY,KAAMY,EAAW,MAE/DzqB,MAAOxG,EAAOgxB,EAAQX,EAAWY,GASjCn0B,KAAK+7B,mBAAoB,CAE1B,CAQA,YAAAtpB,GAEC,MAAO,aAER,CAOA,YAAAqiB,GAEC,MAAMhB,EAAU9zB,KAAKkD,MAErB,OAAK4wB,EAAQlF,UAAY,MAEjBgN,GAEI9H,EAAQlF,UAAY,MAExBiN,IAIPpvB,QAAQkiB,MAAO,qDAAsDmF,EAAQlF,SAEtEpV,GAAM,EAAG,EAAG,GAIrB,CAQA,eAAAob,GAAsC,CAUtC,OAAAM,CAASn1B,EAASm0B,GAEjB,MAAMJ,EAAU9zB,KAAKkD,MAErB,OAAKnD,EAAQ+C,SAAS4f,mBAAqB,OAA4BoR,EAAQwB,sBAMvEpB,EAJA1a,GAAM0a,EAAOtK,EAAE3C,SAAUiN,EAAO8H,GAQzC,CASA,UAAApG,CAAY71B,EAASk8B,GAEpB,OAAOA,EAAO5vB,MAAOtM,EAAS,OAE/B,EAcD,MAAMm8B,GAA4BtjB,GAAWkjB,IAkB7C,MAAMK,WAAmBphB,GAExB,eAAWxT,GAEV,MAAO,YAER,CASA,WAAAzH,CAAaoD,EAAO6rB,EAAYqN,EAAc,GAE7C1yB,MAAOxG,EAAO6rB,GASd/uB,KAAKkvB,cAAe,EAOpBlvB,KAAK+uB,WAAaA,EAQlB/uB,KAAKo8B,YAAcA,CAEpB,CAQA,cAAA1wB,CAAgB3L,GAEf,OAAOC,KAAK2L,YAAa5L,EAE1B,CAQA,YAAA0S,GAEC,MAAO,QAER,EAaD,MAAMnK,GAAS,CAAEpF,EAAOqE,EAAM7F,IAAW6S,GAAY,IAAI4nB,GAAYj5B,EAAOqE,EAAM7F,IASlF,MAAM26B,WAAgCptB,EAErC,eAAW1H,GAEV,MAAO,yBAER,CAQA,WAAAzH,CAAaw8B,EAAkBptB,GAE9BxF,MAAO4yB,EAAkBptB,GASzBlP,KAAKu8B,0BAA2B,CAEjC,CAEA,QAAAjwB,CAAUvM,GAET,MAAMwN,EAAU7D,MAAM4C,SAAUvM,GAC1BwH,EAAOvH,KAAK2L,cACZ6wB,EAAax8B,KAAKmG,KAAKs2B,gBAE7B,OAAO18B,EAAQ4N,OAAQJ,EAASivB,EAAYj1B,EAE7C,EAqBD,MAAMm1B,WAAyBP,GAE9B,eAAW50B,GAEV,MAAO,kBAER,CAQA,WAAAzH,CAAaoD,EAAOyqB,EAAc,MAEjCjkB,MAAO,MASP1J,KAAKwF,MAAQtC,EAOblD,KAAK2tB,YAA8B,OAAhBA,EAAuB9mB,EAAc3D,EAAO,IAAQyqB,EAQvE3tB,KAAKw8B,WAAax8B,KAAKy8B,gBAQvBz8B,KAAK2J,WAAajB,EAAeG,OASjC7I,KAAK28B,mBAAoB,CAE1B,CASA,WAAAhxB,GAEC,OAAO3L,KAAKw8B,UAEb,CAQA,cAAA9wB,GAEC,OAAO1L,KAAK2tB,WAEb,CAOA,aAAA8O,GAEC,MAAM9O,EAAc3tB,KAAK2tB,YAEzB,IAAI6O,EAAa,OAoBjB,MAlBqB,SAAhB7O,EAEJ6O,EAAa,QAE4B,IAA9B,MAAMloB,KAAMqZ,GAEvB6O,EAAa,OAE0B,MAA5B7O,EAAYiP,OAAQ,GAE/BJ,EAAa,QAE0B,MAA5B7O,EAAYiP,OAAQ,KAE/BJ,EAAa,SAIPA,CAER,CAQA,MAAAjyB,GAEC,MAAM,MAAE/E,EAAK,MAAEtC,GAAUlD,KAEnB2tB,EAAc3tB,KAAK2tB,YAEzB,GAAqB,UAAhBA,GAA2C,QAAhBA,GAAyC,SAAhBA,EAExD,IAAM,IAAItpB,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAAO,CAIzCnB,EAFkB,EAAJmB,GAEGmB,EAAOnB,EAEzB,MAEM,GAAqB,UAAhBspB,EAEX,IAAM,IAAItpB,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAAO,CAEzC,MAAM/C,EAAY,EAAJ+C,EACRw4B,EAASr3B,EAAOnB,GAEtBnB,EAAO5B,GAAUu7B,EAAOC,EACxB55B,EAAO5B,EAAQ,GAAMu7B,EAAOE,EAC5B75B,EAAO5B,EAAQ,GAAMu7B,EAAO/c,GAAK,CAGlC,MAEM,GAAqB,SAAhB6N,EAEX,IAAM,IAAItpB,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAAO,CAEzC,MAAM/C,EAAY,EAAJ+C,EACR4wB,EAASzvB,EAAOnB,GAEtBnB,EAAO5B,GAAU2zB,EAAO+H,SAAU,GAClC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,EAEvC,MAEM,GAAqB,SAAhBrP,EAEX,IAAM,IAAItpB,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAAO,CAEzC,MAAM/C,EAAY,GAAJ+C,EACR4wB,EAASzvB,EAAOnB,GAEtBnB,EAAO5B,GAAU2zB,EAAO+H,SAAU,GAClC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GAEtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GAEtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,GAAM2zB,EAAO+H,SAAU,GACtC95B,EAAO5B,EAAQ,IAAO2zB,EAAO+H,SAAU,GAEvC95B,EAAO5B,EAAQ,IAAO,CAEvB,MAEM,GAAqB,SAAhBqsB,EAEX,IAAM,IAAItpB,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAAO,CAEzC,MAAM/C,EAAY,GAAJ+C,EACR4wB,EAASzvB,EAAOnB,GAEtB,IAAM,IAAIA,EAAI,EAAGA,EAAI4wB,EAAO+H,SAASh5B,OAAQK,IAE5CnB,EAAO5B,EAAQ+C,GAAM4wB,EAAO+H,SAAU34B,EAIxC,MAIA,IAAM,IAAIA,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAAO,CAEzC,MAAM/C,EAAY,EAAJ+C,EACRw4B,EAASr3B,EAAOnB,GAEtBnB,EAAO5B,GAAUu7B,EAAOjT,EACxB1mB,EAAO5B,EAAQ,GAAMu7B,EAAO/S,EAC5B5mB,EAAO5B,EAAQ,GAAMu7B,EAAOI,GAAK,EACjC/5B,EAAO5B,EAAQ,GAAMu7B,EAAOK,GAAK,CAElC,CAIF,CAQA,KAAAhxB,CAAOnM,GAEN,MAAMiE,EAAShE,KAAKwF,MAAMxB,OACpB2pB,EAAc3tB,KAAK2tB,YAEzB,IAAID,EAAYyP,aAEhB,MAAMX,EAAax8B,KAAKw8B,WAClBY,EAAsBr9B,EAAQ0P,cAAe+sB,GASnD,MAPiC,MAA5B7O,EAAYiP,OAAQ,KAAclP,EAAY2P,YAClB,MAA5B1P,EAAYiP,OAAQ,KAAclP,EAAY4P,aAEnDt9B,KAAKkD,MAAQ,IAAIwqB,EAAW1pB,EAASo5B,GACrCp9B,KAAKo8B,YAAcp4B,EACnBhE,KAAK+uB,WAAayN,EAEX9yB,MAAMwC,MAAOnM,EAErB,CASA,OAAAoa,CAASjL,GAER,OAAOqF,GAAY,IAAI8nB,GAAyBr8B,KAAMuU,GAAYrF,IAEnE,EAYD,MAAMquB,GAAe,CAAE13B,EAAQ4D,IAAc8K,GAAY,IAAImoB,GAAkB72B,EAAQ4D,IAsBvF,MAAM+zB,WAA6BvuB,EAElC,eAAW1H,GAEV,MAAO,sBAER,CAQA,WAAAzH,CAAaytB,EAAere,GAE3BxF,MAAO6jB,EAAere,GAStBlP,KAAKutB,cAAgBA,EASrBvtB,KAAKwtB,wBAAyB,CAE/B,CASA,WAAA7hB,GAEC,OAAO3L,KAAKutB,cAAcE,WAE3B,CAEA,QAAAnhB,CAAUvM,GAET,MAAMwN,EAAU7D,MAAM4C,SAAUvM,GAC1B2tB,EAAY1tB,KAAKutB,cAAc5hB,cAC/BgiB,EAAc3tB,KAAK2L,cAEzB,OAAO5L,EAAQ4N,OAAQJ,EAASmgB,EAAWC,EAE5C,EAYD,MAAM8P,WAAsBj0B,EAE3B,eAAWjC,GAEV,MAAO,eAER,CAUA,WAAAzH,CAAa8C,EAAU6qB,EAAantB,EAAS,KAAMoB,EAAQ,MAE1DgI,QAOA1J,KAAK4C,SAAWA,EAOhB5C,KAAKytB,YAAcA,EAQnBztB,KAAKM,OAASA,EAQdN,KAAK0B,MAAQA,EAQb1B,KAAKkN,WAAatK,EAAS4M,MAAO,KASlCxP,KAAK6tB,UAAYvtB,EAQjBN,KAAKmG,KAAO,KAQZnG,KAAKob,MAAQ,KAQbpb,KAAK0C,KAAO,KAQZ1C,KAAK2J,WAAajB,EAAeI,MAElC,CASA,OAAAqR,CAASjL,GAER,OAAOqF,GAAY,IAAIipB,GAAsBx9B,KAAMuU,GAAYrF,IAEhE,CAQA,QAAAiM,CAAUC,GAIT,OAFApb,KAAKob,MAAQA,EAENpb,IAER,CAQA,KAAAkb,CAAOxY,GAIN,OAFA1C,KAAK0C,KAAOA,EAEL1C,IAER,CAQA,WAAA8tB,CAAaL,GAEZ,IAAItnB,EAAO,KAIVA,EAFmB,OAAfnG,KAAK0B,MAEF4G,GAAQ,KAAMmlB,EAAaztB,KAAK0B,OAE5BqD,MAAMuB,QAAStG,KAAKguB,yBAExBuP,GAAc,KAAM9P,GAEA,YAAhBA,EAEJqG,GAAS,MAEW,gBAAhBrG,EAEJyO,GAAa,MAIbpgB,GAAS,KAAM2R,GAIH,OAAfztB,KAAKob,OAETjV,EAAKgV,SAAUnb,KAAKob,OAIF,OAAdpb,KAAK0C,MAAgByD,EAAK+U,MAAOlb,KAAK0C,MAE3C1C,KAAKmG,KAAOA,EAAKJ,SAElB,CASA,WAAA4F,CAAa5L,GASZ,OAPmB,OAAdC,KAAKmG,OAETnG,KAAK6K,gBAAiB9K,GACtBC,KAAK+tB,eAIC/tB,KAAKmG,KAAKwF,YAAa5L,EAE/B,CAQA,qBAAAiuB,CAAuB1tB,EAASN,KAAK6tB,WAEpC,MAAM,WAAE3gB,GAAelN,KAEvB,IAAIkD,EAAQ5C,EAAQ4M,EAAY,IAEhC,IAAM,IAAI7I,EAAI,EAAGA,EAAI6I,EAAWlJ,OAAQK,IAEvCnB,EAAQA,EAAOgK,EAAY7I,IAI5B,OAAOnB,CAER,CASA,eAAA2H,CAAiBojB,GAIhB,OAFAjuB,KAAK6tB,UAA4B,OAAhB7tB,KAAKM,OAAkBN,KAAKM,OAAS2tB,EAAM3tB,OAErDN,KAAK6tB,SAEb,CAQA,KAAA3hB,GAIC,OAFAlM,KAAK+tB,cAEE/tB,KAAKmG,IAEb,CAOA,MAAAoE,GAECvK,KAAK+tB,aAEN,CAMA,WAAAA,GAEoB,OAAd/tB,KAAKmG,MAAgBnG,KAAK8tB,YAAa9tB,KAAKytB,aAEjD,MAAMvqB,EAAQlD,KAAKguB,wBAEdjpB,MAAMuB,QAASpD,GAEnBlD,KAAKmG,KAAKX,MAAQtC,EAIlBlD,KAAKmG,KAAKjD,MAAQA,CAIpB,EAaD,MAAM2qB,GAAY,CAAEnrB,EAAM6E,EAAMjH,IAAYiU,GAAY,IAAIkpB,GAAe/6B,EAAM6E,EAAMjH,IAajFo9B,GAAkB,CAAEh7B,EAAM6E,EAAM7F,EAAOpB,IAAYiU,GAAY,IAAIkpB,GAAe/6B,EAAM6E,EAAMjH,EAAQoB,IAe5G,MAAMi8B,WAA8BF,GAEnC,eAAWl2B,GAEV,MAAO,uBAER,CAUA,WAAAzH,CAAa8C,EAAU6f,EAAWxhB,EAAW,MAE5CyI,MAAO9G,EAAU6f,EAAWxhB,GAS5BjB,KAAKiB,SAAWA,EAShBjB,KAAK49B,yBAA0B,CAEhC,CASA,eAAA/yB,CAAiBojB,GAIhB,OAFAjuB,KAAK6tB,UAA8B,OAAlB7tB,KAAKiB,SAAoBjB,KAAKiB,SAAWgtB,EAAMhtB,SAEzDjB,KAAK6tB,SAEb,EAcD,MAAMgQ,GAAoB,CAAEn7B,EAAM6E,EAAMtG,EAAW,OAAUsT,GAAY,IAAIopB,GAAuBj7B,EAAM6E,EAAMtG,IAS1G68B,GAAgCplB,IAAM3Y,KAES,IAA/CA,EAAQiB,SAASy5B,aAAc,YAEnC16B,EAAQiB,SAAS+8B,kBAIXp7B,GAAW,UAAW,UARQ+V,GAiBhCslB,GAA6BF,GAAgB/a,IAAIyW,MAAO,gBAOxDyE,GAA4Bj7B,GAAgBqd,IAAKzG,GAAMokB,GAAc,IAAMjb,IAAI7G,QAAS,iBAAkB8G,YAAYwW,MAAO,eAyB7H0E,GAAiBC,GAAwBA,EAAmB9d,IAAKyd,GAAgBZ,GAAIna,IAqBrFqb,GAA8BliB,GAASgiB,GAAcvD,GAAWzS,MAAO+V,KAAiB,mBAAoBjb,YAAYwW,MAAO,iBA8B/H6E,GAA8BpkB,GAAMgkB,GAAaG,GAAezD,IAyBhE2D,GAA0C,MAI/C,IAAIC,EAAalhB,GAAY6K,MAAO8R,IAIpC,OAHAuE,EAAaA,EAAWrW,MAAO7K,IAAc2F,YAC7Cub,EAAa7V,GAAK6V,EAAYxD,GAAuB5d,GAAWkD,IAAK5D,GAAUyK,YAAaA,WAAWkB,OAAOA,QAASpF,YAEhHub,CAGN,EAX8C,GAkB1CC,GAAkC9lB,IAAM7E,IAE7C,MAAM,QAAE4qB,EAAO,UAAEC,EAAS,KAAEC,EAAI,GAAExV,GAAOtV,EAEnC+qB,EAAKH,EAAQtX,OACb0X,EAAKJ,EAAQrX,OACb0X,EAAM3V,EAAGhC,OACT4X,EAAM5V,EAAG/B,OAET4X,EAAIN,EAEJO,EAASJ,EAAG3W,MAAO8W,GACnBE,EAASF,EAAE9W,MAAO0W,GAElBO,EAAIF,EAAO5e,IAAKye,EAAIlV,GAAIxV,IAAK8qB,EAAO7e,IAAK0e,EAAInV,IAC7CwV,EAAIH,EAAO5e,IAAKye,EAAIhV,GAAI1V,IAAK8qB,EAAO7e,IAAK0e,EAAIjV,IAE7CuV,EAAMF,EAAElX,IAAKkX,GAAI9tB,IAAK+tB,EAAEnX,IAAKmX,IAC7BE,EAAQhF,GAAcja,IAAKgf,EAAI/Y,eAErC,OAAOlS,GAAK+qB,EAAE9e,IAAKse,EAAK/U,EAAG0V,GAASF,EAAE/e,IAAKse,EAAK7U,EAAGwV,GAASN,EAAE3e,IAAKse,EAAK1B,IAAMja,WAAW,IAa1F,MAAMuc,WAAsB7vB,EAE3B,eAAWnI,GAEV,MAAO,eAER,CAQA,WAAAzH,CAAaqG,EAAMq5B,EAAY,MAE9B91B,MAAO,QAOP1J,KAAKmG,KAAOA,EAQZnG,KAAKw/B,UAAYA,EAQjBx/B,KAAKy/B,cAAgB,KAEtB,CAEA,KAAAvzB,CAAOnM,GAEN,MAAM,cAAE0/B,EAAa,UAAED,GAAcx/B,KAErC,IAAI0/B,EAAY1/B,KAAKmG,KAAKka,IAAK,GAAMD,IAAK,GAEvB,OAAdof,IAEJE,EAAYlmB,GAAMkmB,EAAUrW,GAAGhJ,IAAKmf,GAAaE,EAAUzC,IAI5D,IAAInxB,EAAa,KAEjB,GAAK2zB,IAAkB,MAEtB3zB,EAAa+uB,GAAuB6E,QAE9B,GAAKD,IAAkB,MAAwB,CAMpD3zB,GAFgB,IAFD/L,EAAQkzB,qBAAsB,WAIhCoL,GAAche,IAAKqf,GAAY1c,YAI/Bwb,GAAmB,CAC/BC,QAAS3E,GACT4E,UAAW/D,GACXgE,KAAMe,EACNvW,GAAIA,MAKP,CAEA,OAAOrd,CAER,EAYD,MAAM4zB,GAA0B9mB,GAAW2mB,IAOrCI,GAAYjnB,IAAI,EAAI4a,cAAasM,gBAGtC,MAAMC,EAAkBv1B,GAAcgpB,EAAYzkB,QAAQxM,QAAS,CAAEqzB,MAASoK,GAAax1B,EAAUw1B,EAAQ5L,QAAU/K,MAAQsM,gBAAgB,IAEzIsK,EAAMroB,GAAOmoB,GAAiB3L,GAAYA,KAEhD,OAAO9a,GACN1B,GAAOmoB,GAAiB3L,GAAYA,EAAO9f,IAAK8f,EAAO/M,WAAa/G,IAAK2f,GACzEroB,GAAOmoB,GAAiB3L,GAAYA,EAAO9f,IAAK8f,EAAO9M,WAAahH,IAAK2f,IACxE1f,IAAKuf,EAAW,IAMbI,GAAmBtnB,IAAM7E,IAE9B,MAAM,SAAEosB,EAAQ,UAAEvB,EAAS,MAAEwB,GAAUrsB,EAGjCssB,EAAUF,EAAS9Y,OAAOnE,YAE1Bod,EAAK1B,EAEL2B,EAHUJ,EAAS7Y,OAAOpE,YAGbkF,MAAOkY,GACpBE,EAAKF,EAAGlY,MAAOiY,GAEfI,EAAOJ,EAAQlY,IAAKoY,GAAKhgB,IAAKia,IAE9BkG,EAAQD,EAAKvZ,OAAO3G,IAAK6f,EAAMtW,EAAEvJ,IAAKggB,GAAKjsB,IAAK8rB,EAAMpW,EAAEzJ,IAAKigB,KAEnE,OAAOC,EAAKld,MAAMhD,IAAKqe,GAAYte,IAAKogB,GAAQxd,WAAW,IAa5D,MAAMyd,WAAoB/wB,EAEzB,eAAWnI,GAEV,MAAO,aAER,CAQA,WAAAzH,CAAawzB,EAAakM,EAAY,MAErC91B,MAAO,QAOP1J,KAAKszB,YAAcA,EAQnBtzB,KAAKw/B,UAAYA,CAElB,CAEA,KAAAtzB,GAEC,MAAM0zB,EAA+B,OAAnB5/B,KAAKw/B,UAAqBx/B,KAAKw/B,UAAY,EACvDU,EAAQP,GAAW,CAAErM,YAAatzB,KAAKszB,YAAasM,cAE1D,OAAOI,GAAkB,CACxBC,SAAUnG,GACV4E,UAAW/D,GACXuF,SAGF,EAYD,MAAMQ,GAAwB9nB,GAAW6nB,IAInCE,GAAiB,IAAIj6B,IAU3B,MAAMk6B,WAAqBp3B,EAE1B,eAAWjC,GAEV,MAAO,cAER,CAOA,WAAAzH,CAAaqV,GAEZzL,QAOA1J,KAAKmV,MAAQA,CAEd,CASA,QAAAoc,CAAU3uB,EAAU2E,GAEnB,IAAIpB,EAAOw6B,GAAe7/B,IAAK8B,GAU/B,YARc7B,IAAToF,IAEJA,EAAO03B,GAAmBj7B,EAAU2E,GAEpCo5B,GAAen+B,IAAKI,EAAUuD,IAIxBA,CAER,CAQA,QAAA06B,CAAUj+B,GAET,OAAO5C,KAAKuxB,SAAU3uB,EAAU,QAEjC,CAQA,QAAAk+B,CAAUl+B,GAET,OAAO5C,KAAKuxB,SAAU3uB,EAAU,QAEjC,CAQA,UAAAm+B,CAAYn+B,GAEX,OAAO5C,KAAKuxB,SAAuB,QAAb3uB,EAAqB,MAAQA,EAAW,MAAO,UAEtE,CASA,KAAAsJ,CAAOnM,GAEN,MAAMkB,EAAWlB,EAAQsC,QAAQpB,SAC3BkU,EAAQnV,KAAKmV,MAEnB,IAAIhP,EAAO,KAEX,GAAKgP,IAAUyrB,GAAaI,MAAQ,CAEnC,MAAMxU,OAA+BzrB,IAAnBE,EAASkY,MAAsBnZ,KAAK8gC,SAAU3rB,GAAUqE,KAIzErT,EAFIlF,EAASqW,MAAkC,IAA3BrW,EAASqW,IAAInU,UAE1BqpB,EAAUnM,IAAKrgB,KAAK+gC,WAAY,QAIhCvU,CAIT,MAAO,GAAKrX,IAAUyrB,GAAaK,QAAU,CAE5C,MAAMC,EAAclhC,KAAK6gC,SAAU1rB,GAIlChP,EAFIlF,EAASkgC,WAA4C,IAAhClgC,EAASkgC,SAASh+B,UAEpC+9B,EAAY7gB,IAAKrgB,KAAK+gC,WAAY,UAIlCG,CAIT,MAAO,GAAK/rB,IAAUyrB,GAAaQ,kBAIjCj7B,EAFIlF,EAASogC,cAAkD,IAAnCpgC,EAASogC,YAAYl+B,UAE1CnD,KAAK+gC,WAAY,YAAajE,EAI9BplB,GAAO,QAIT,GAAKvC,IAAUyrB,GAAaU,mBAAqB,CAEvD,MAAMC,EAAwBvhC,KAAK6gC,SAAU1rB,GAI5ChP,EAFIlF,EAASugC,uBAAoE,IAA5CvgC,EAASugC,qBAAqBr+B,UAE5Do+B,EAAsBlhB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ0K,GAIpD0hB,CAIT,MAAO,GAAKpsB,IAAUyrB,GAAaa,eAAiB,CAEnD,MAAMC,EAAoB1hC,KAAK8gC,SAAU3rB,GAIxChP,EAFIlF,EAAS0gC,mBAA4D,IAAxC1gC,EAAS0gC,iBAAiBx+B,UAEpDu+B,EAAkBrhB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ4X,KAIhD2U,CAIT,MAAO,GAAKvsB,IAAUyrB,GAAagB,UAAY,CAE9C,MAAMC,EAAgB7hC,KAAK6gC,SAAU1rB,GAIpChP,EAFIlF,EAAS6gC,eAAoD,IAApC7gC,EAAS6gC,aAAa3+B,UAE5C0+B,EAAcxhB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ4nB,GAI5C8E,CAIT,MAAO,GAAK1sB,IAAUyrB,GAAamB,UAAY,CAE9C,MAAMC,EAAgBhiC,KAAK6gC,SAAU1rB,GAIpChP,EAFIlF,EAASghC,eAAoD,IAApChhC,EAASghC,aAAa9+B,UAE5C6+B,EAAc3hB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ2K,GAI5CkiB,CAIT,MAAO,GAAK7sB,IAAUyrB,GAAasB,SAAW,CAE7C,MAAMC,EAAwBniC,KAAK6gC,SAAU,qBACvCuB,EAAepiC,KAAK8gC,SAAU3rB,GAAQkL,IAAK8hB,GAIhDh8B,EAFIlF,EAASohC,cAAkD,IAAnCphC,EAASohC,YAAYl/B,UAE1Ci/B,EAAa/hB,IAAKrgB,KAAK+gC,WAAY5rB,IAInCitB,CAIT,MAAO,GAAKjtB,IAAUyrB,GAAa0B,OAE7BrhC,EAASy+B,WAEbv5B,EAAOu5B,GAAW1/B,KAAK+gC,WAAY,UAAY/gC,KAAKuxB,SAAU,cAAe,SAC7EprB,EAAKs5B,cAAgBx+B,EAASw+B,eAI9Bt5B,EAFWlF,EAASy/B,QAEbA,GAAS1gC,KAAK+gC,WAAY,QAASjE,EAAG98B,KAAK6gC,SAAU,cAIrDlG,QAIF,GAAKxlB,IAAUyrB,GAAa2B,UAAY,CAE9C,MAAMC,EAAgBxiC,KAAK6gC,SAAU1rB,GAIpChP,EAFIlF,EAASwhC,eAAoD,IAApCxhC,EAASwhC,aAAat/B,UAE5Cq/B,EAAcniB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ2nB,GAI5C0F,CAIT,MAAO,GAAKrtB,IAAUyrB,GAAa8B,oBAAsB,CAExD,MAAMC,EAAyB3iC,KAAK6gC,SAAU1rB,GAI7ChP,EAFIlF,EAAS2hC,wBAAsE,IAA7C3hC,EAAS2hC,sBAAsBz/B,UAE9Dw/B,EAAuBtiB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ2nB,GAIrD6F,CAIT,MAAO,GAAKxtB,IAAUyrB,GAAaiC,iBAIjC18B,EAFIlF,EAAS6hC,mBAENpD,GAAW1/B,KAAK+gC,WAAY5rB,GAASnV,KAAKuxB,SAAUpc,EAAQ,QAAS,SAIrEwlB,QAIF,GAAKxlB,IAAUyrB,GAAamC,MAAQ,CAE1C,MAAMC,EAAYhjC,KAAK8gC,SAAU,cAAezgB,IAAKrgB,KAAK6gC,SAAU,UAInE16B,EAFIlF,EAASgiC,gBAAsD,IAArChiC,EAASgiC,cAAc9/B,UAE9C6/B,EAAU3iB,IAAKrgB,KAAK+gC,WAAY,cAAehU,KAI/CiW,CAIT,MAAO,GAAK7tB,IAAUyrB,GAAasC,gBAAkB,CAEpD,MAAMC,EAAqBnjC,KAAK6gC,SAAU1rB,GAIzChP,EAFIlF,EAASmiC,oBAA8D,IAAzCniC,EAASmiC,kBAAkBjgC,UAEtDggC,EAAmB9iB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ0K,GAIjDsjB,EAIRh9B,EAAOA,EAAKwiB,MAAO,IAAM,EAE1B,MAAO,GAAKxT,IAAUyrB,GAAayC,WAElC,GAAKpiC,EAASqiC,gBAAsD,IAArCriC,EAASqiC,cAAcngC,UAAqB,CAE1E,MAAMogC,EAAkBvjC,KAAK+gC,WAAY5rB,GAGzChP,EAFsB6T,GAAMwpB,GAAyB5Z,EAAG4Z,GAAyB1Z,EAAG0Z,GAAyB1Z,EAAE7C,SAAUuc,GAAyB5Z,GAE7HvJ,IAAKkjB,EAAgBE,GAAGpjB,IAAK,GAAMD,IAAKhH,GAAM,IAAQ4J,YAAY3C,IAAKkjB,EAAgBzjB,GAE7G,MAEC3Z,EAAOq9B,QAIF,GAAKruB,IAAUyrB,GAAa8C,sBAAwB,CAE1D,MAAMC,EAA8B9V,GAAW,IAAK,QAAS5sB,EAAS2iC,2BAEtE,GAAK3iC,EAAS4iC,wBAA0B,CAEvC,MAAMC,EAA8BjW,GAAW,IAAK,QAAS5sB,EAAS2iC,2BAEtEz9B,EAAOw9B,EAA4BvjB,IAAK0jB,GAA8BzjB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ4nB,GAAI3oB,IAAK0vB,EAE9G,MAEC39B,EAAOw9B,CAIT,MAAO,GAAKxuB,IAAUyrB,GAAamD,aAAe,CAEjD,MAAMC,EAAmBhkC,KAAK6gC,SAAU1rB,GAIvChP,EAFIlF,EAASgjC,gBAEND,EAAiB3jB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ2nB,GAI/CkH,CAIT,MAAO,GAAK7uB,IAAUyrB,GAAasD,UAAY,CAE9C,MAAMC,EAAgBnkC,KAAK6gC,SAAU1rB,GAIpChP,EAFIlF,EAASmjC,aAEND,EAAc9jB,IAAKrgB,KAAK+gC,WAAY5rB,GAAQ4nB,GAI5CoH,CAIT,MAAO,GAAKhvB,IAAUyrB,GAAayD,IAElCl+B,EAAOnG,KAAK6gC,SAAU1rB,QAEhB,GAAKA,IAAUyrB,GAAa0D,UAElCn+B,EAAOnG,KAAK+gC,WAAY5rB,GAAQ4X,IAAI1M,IAAKrgB,KAAK6gC,SAAU,2BAElD,GAAK1rB,IAAUyrB,GAAa2D,GAElCp+B,EAAOnG,KAAK+gC,WAAY5rB,GAAQ2nB,EAAE1c,IAAK,GAAMC,IAAKrgB,KAAK6gC,SAAU,mBAAqBzsB,IAAK,OAErF,CAEN,MAAMowB,EAAaxkC,KAAK2L,YAAa5L,GAErCoG,EAAOnG,KAAKuxB,SAAUpc,EAAOqvB,EAE9B,CAEA,OAAOr+B,CAER,EAIDy6B,GAAa6D,WAAa,YAC1B7D,GAAaI,MAAQ,QACrBJ,GAAaK,QAAU,UACvBL,GAAa8D,UAAY,YACzB9D,GAAa+D,SAAW,WACxB/D,GAAaQ,kBAAoB,mBACjCR,GAAaU,mBAAqB,oBAClCV,GAAaa,eAAiB,gBAC9Bb,GAAagE,aAAe,eAC5BhE,GAAagB,UAAY,YACzBhB,GAAamB,UAAY,YACzBnB,GAAa0B,OAAS,SACtB1B,GAAa2B,UAAY,YACzB3B,GAAa8B,oBAAsB,qBACnC9B,GAAaiC,iBAAmB,kBAChCjC,GAAasB,SAAW,WACxBtB,GAAaiE,SAAW,WACxBjE,GAAamC,MAAQ,QACrBnC,GAAasC,gBAAkB,iBAC/BtC,GAAayC,WAAa,aAC1BzC,GAAakE,YAAc,cAC3BlE,GAAamE,gBAAkB,iBAC/BnE,GAAa8C,sBAAwB,uBACrC9C,GAAayD,IAAM,MACnBzD,GAAamD,aAAe,eAC5BnD,GAAasD,UAAY,YACzBtD,GAAaoE,qBAAuB,sBACpCpE,GAAaqE,kBAAoB,mBACjCrE,GAAasE,WAAa,QAC1BtE,GAAauE,eAAiB,WAC9BvE,GAAawE,cAAgB,UAC7BxE,GAAayE,WAAa,YAC1BzE,GAAa0E,iBAAmB,aAChC1E,GAAa2E,YAAc,aAC3B3E,GAAa4E,WAAa,aAC1B5E,GAAa0D,UAAY,QACzB1D,GAAa2D,GAAK,KAOlB,MAAMkB,GAAkC5sB,GAAe+nB,GAAcA,GAAa6D,YAQ5EiB,GAA8B7sB,GAAe+nB,GAAcA,GAAaI,OAOxE2E,GAAkC9sB,GAAe+nB,GAAcA,GAAa8D,WAQ5EkB,GAAiC/sB,GAAe+nB,GAAcA,GAAasB,UAQ3E2D,GAAgChtB,GAAe+nB,GAAcA,GAAaK,SAO1E6E,GAAiCjtB,GAAe+nB,GAAcA,GAAa+D,UAQ3EoB,GAA0CltB,GAAe+nB,GAAcA,GAAaU,oBAQpF0E,GAAsCntB,GAAe+nB,GAAcA,GAAaa,gBAQhFwE,GAAyCptB,GAAe+nB,GAAcA,GAAaQ,mBAOnF8E,GAAqCrtB,GAAe+nB,GAAcA,GAAagE,cAQ/EuB,GAAkCttB,GAAe+nB,GAAcA,GAAagB,WAQ5EwE,GAAkCvtB,GAAe+nB,GAAcA,GAAamB,WAQ5EsE,GAA+BxtB,GAAe+nB,GAAcA,GAAa0B,QAASjgC,QAAS,CAAEqzB,MAAO,OAQpG4Q,GAAkCztB,GAAe+nB,GAAcA,GAAa2B,WAQ5EgE,GAA2C1tB,GAAe+nB,GAAcA,GAAa8B,qBAQrF8D,GAAwC3tB,GAAe+nB,GAAcA,GAAaiC,kBAAmBxgC,QAAS,CAAEqzB,MAAO,OAOvH+Q,GAAiC5tB,GAAe+nB,GAAcA,GAAaiE,UAQ3E6B,GAA8B7tB,GAAe+nB,GAAcA,GAAamC,OAQxE4D,GAAuC9tB,GAAe+nB,GAAcA,GAAasC,iBAOjF0D,GAAmC/tB,GAAe+nB,GAAcA,GAAayC,YAO7EwD,GAAoChuB,GAAe+nB,GAAcA,GAAakE,aAO9EgC,GAAuCjuB,GAAe+nB,GAAcA,GAAamE,iBAOjFgC,GAA6CluB,GAAe+nB,GAAcA,GAAa8C,uBAQvFsD,GAAqCnuB,GAAe+nB,GAAcA,GAAamD,cAQ/EkD,GAAkCpuB,GAAe+nB,GAAcA,GAAasD,WAO5EgD,GAA4BruB,GAAe+nB,GAAcA,GAAayD,KAOtE8C,GAA4CtuB,GAAe+nB,GAAcA,GAAaoE,sBAOtFoC,GAAyCvuB,GAAe+nB,GAAcA,GAAaqE,mBAOnFoC,GAAkCxuB,GAAe+nB,GAAcA,GAAasE,YAO5EoC,GAAqCzuB,GAAe+nB,GAAcA,GAAauE,gBAO/EoC,GAAoC1uB,GAAe+nB,GAAcA,GAAawE,eAc9EoC,IAP+D5G,GAAayE,WAOrCxsB,GAAe+nB,GAAcA,GAAa0E,mBAcjFmC,IAPgE7G,GAAa2E,YAO1C1sB,GAAe+nB,GAAcA,GAAa4E,aAQ7EkC,GAAiC7uB,GAAe+nB,GAAcA,GAAa0D,WAQ3EqD,GAA2B9uB,GAAe+nB,GAAcA,GAAa2D,IAOrEf,GAAyC1nB,GAAS,IAAI,OAAYlR,aAAa,SAAW2Q,GAE/F,OAAOA,EAAMta,QAEd,IAAIyJ,gBAAgB,UAAW,SAAEzJ,IAEhCjB,KAAKkD,MAAMV,IAAKvB,EAASkc,WAAalY,KAAK0hB,IAAK1lB,EAAS2mC,oBAAsB3mC,EAASkc,WAAalY,KAAKyhB,IAAKzlB,EAAS2mC,oBAEzH,IASMC,GAAsCnvB,IAAM3Y,GAE1CA,EAAQsC,QAAQylC,4BAErB,QAASzxB,MAJ8B,GAInB6F,QAAS,yBAiBhC,MAAM6rB,WAAkBv+B,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAOA,WAAAzH,CAAaqV,GAEZzL,MAAO,QAOP1J,KAAKmV,MAAQA,EASbnV,KAAKgoC,aAAc,CAEpB,CAEA,QAAA17B,CAAUvM,GAET,MAAM0J,EAAWzJ,KAAK2L,YAAa5L,GAC7BoV,EAAQnV,KAAKmV,MAEnB,IAAIpF,EAgCAxD,EA9BJ,GAAK4I,IAAU4yB,GAAUv/B,OAExBuH,EAAehQ,EAAQkoC,sBAEjB,GAAK9yB,IAAU4yB,GAAUG,SAE/Bn4B,EAAehQ,EAAQooC,wBAEjB,GAAKhzB,IAAU4yB,GAAUK,KAE/Br4B,EAAehQ,EAAQsoC,oBAEjB,GAAKlzB,IAAU4yB,GAAUO,iBAE/Bv4B,EAAehQ,EAAQwoC,+BAEjB,GAAKpzB,IAAU4yB,GAAUS,oBAE/Bz4B,EAAehQ,EAAQ0oC,iCAEjB,IAAKtzB,IAAU4yB,GAAUW,SAM/B,MAAM,IAAIr1B,MAAO,mCAAqC8B,GAJtDpF,EAAehQ,EAAQ4oC,kBAMxB,CAIA,GAA6B,WAAxB5oC,EAAQ8b,aAAoD,YAAxB9b,EAAQ8b,YAEhDtP,EAASwD,MAEH,CAINxD,EAFoB2P,GAASlc,MAERqM,MAAOtM,EAAS0J,EAEtC,CAEA,OAAO8C,CAER,EAIDw7B,GAAUv/B,OAAS,SACnBu/B,GAAUG,SAAW,WACrBH,GAAUW,SAAW,WACrBX,GAAUO,iBAAmB,kBAC7BP,GAAUS,oBAAsB,qBAChCT,GAAUK,KAAO,OAOjB,MAAMQ,GAA4B/vB,GAAekvB,GAAWA,GAAUv/B,QAOhEqgC,GAA8BhwB,GAAekvB,GAAWA,GAAUG,UA4BlEY,IArBwDf,GAAUW,SAOAX,GAAUS,oBAObT,GAAUO,iBAO/CzvB,GAAekvB,GAAWA,GAAUK,OAYpE,MAAMW,WAAqBv/B,EAE1B,eAAWjC,GAEV,MAAO,cAER,CASA,WAAAzH,CAAa4B,EAAOsnC,EAAgBC,GAEnCv/B,MAAO,QAOP1J,KAAK0B,MAAQA,EAOb1B,KAAKgpC,eAAiBA,EAOtBhpC,KAAKipC,cAAgBA,EAOrBjpC,KAAKkpC,mBAAqB,KAO1BlpC,KAAKmpC,kBAAoB,KASzBnpC,KAAK2J,WAAajB,EAAeE,MAOjC5I,KAAKsI,OAAS,KAOdtI,KAAKopC,YAAc,IAEpB,CASA,KAAAl9B,CAAOnM,GAEN,MAAM,MAAE2B,EAAK,eAAEsnC,EAAc,cAAEC,GAAkBjpC,KAEjD,IAAI,mBAAEkpC,EAAkB,kBAAEC,GAAsBnpC,KAEhD,GAA4B,OAAvBkpC,EAA8B,CAIlC,GAAKxnC,GAAS,IAEbwnC,EAAqB5gC,GAAQ0gC,EAAexjC,MAAO,OAAQP,KAAKoM,IAAK3P,EAAO,IAAMyY,QAAS0uB,QAErF,CAEN,MAAMvgC,EAAS,IAAI,MAA4B0gC,EAAexjC,MAAO,GAAI,GAEzExF,KAAKsI,OAASA,EAEd,MAAM+gC,EAAWL,EAAe7Z,QAAU,MAAmBoB,GAAkCD,GAEzFgZ,EAAkB,CAEvBD,EAAU/gC,EAAQ,OAAQ,GAAI,GAC9B+gC,EAAU/gC,EAAQ,OAAQ,GAAI,GAC9B+gC,EAAU/gC,EAAQ,OAAQ,GAAI,GAC9B+gC,EAAU/gC,EAAQ,OAAQ,GAAI,KAG/B4gC,EAAqBhvB,MAASovB,EAE/B,CAEAtpC,KAAKkpC,mBAAqBA,CAE3B,CAEA,GAAKD,GAAuC,OAAtBE,EAA6B,CAElD,MAAM7gC,EAAS,IAAI,MAA0B2gC,EAAczjC,MAAO,GAE5D6jC,EAAWJ,EAAc9Z,QAAU,MAAmBoB,GAAkCD,GAE9FtwB,KAAKopC,YAAc9gC,EAEnB6gC,EAAoB3vB,GAAM6vB,EAAU/gC,EAAQ,OAAQ,EAAG,IAEvDtI,KAAKmpC,kBAAoBA,CAE1B,CAIA,MAAMI,EAAmBL,EAAmB7oB,IAAKqZ,IAAgB3W,IAKjE,GAJA2W,GAAcvlB,OAAQo1B,GAIjBxpC,EAAQkzB,qBAAsB,UAAa,CAE/C,MAAMuW,EAAiBpO,GAAiBZ,GAAa0O,GAIrD1O,GAAYrmB,OAAQq1B,EAErB,CAIgC,OAA3BxpC,KAAKmpC,mBAET7sB,GAAiB,OAAQ,kBAAmBnI,OAAQnU,KAAKmpC,kBAI3D,CAOA,MAAA5+B,GAEMvK,KAAKgpC,eAAe7Z,QAAU,OAAoC,OAAhBnvB,KAAKsI,QAAmBtI,KAAKgpC,eAAeznC,UAAYvB,KAAKsI,OAAO/G,UAE1HvB,KAAKsI,OAAO/G,QAAUvB,KAAKgpC,eAAeznC,SAItCvB,KAAKipC,eAAiBjpC,KAAKipC,cAAc9Z,QAAU,OAAyC,OAArBnvB,KAAKopC,aAAwBppC,KAAKipC,cAAc1nC,UAAYvB,KAAKopC,YAAY7nC,UAExJvB,KAAKopC,YAAY7nC,QAAUvB,KAAKipC,cAAc1nC,QAIhD,EAuBD,MAAMkoC,WAA0BV,GAE/B,eAAWxhC,GAEV,MAAO,mBAER,CAOA,WAAAzH,CAAa4pC,GAEZ,MAAM,MAAEhoC,EAAK,eAAEsnC,EAAc,cAAEC,GAAkBS,EAEjDhgC,MAAOhI,EAAOsnC,EAAgBC,GAO9BjpC,KAAK0pC,cAAgBA,CAEtB,EAWD,MAAMA,GAA8B9wB,GAAW6wB,IAW/C,MAAME,WAAkBngC,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAOA,WAAAzH,CAAa8pC,GAEZlgC,MAAO,QAOP1J,KAAK4pC,UAAYA,EAQjB5pC,KAAK6pC,eAAiB,IAEvB,CASA,KAAA39B,CAAOnM,GAEuB,OAAxBC,KAAK6pC,iBAEuB,OAA3B9pC,EAAQsoC,eAEZroC,KAAK6pC,eAAiBhB,GAItB7oC,KAAK6pC,eAAiBf,IAMxB,MAAMgB,EAAmBpxB,IAAI,EAAItV,MAEhC,MAAM4tB,EAAO2C,GAAa+D,GAAa13B,KAAK4pC,UAAUG,kBAAoB,GACpEngB,EAAIpS,GAAKpU,GAAKmd,OAAQ/I,GAAKwZ,IAC3BlH,EAAItS,GAAKpU,GAAKkd,IAAK9I,GAAKwZ,IAC9B,OAAO0G,GAAa13B,KAAK4pC,UAAUG,iBAAkB1wB,GAAOuQ,EAAGE,IAAMF,CAAC,IAEnEjT,UAAW,CACdjU,KAAM,mBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,KAAM6E,KAAM,UAIhByiC,EAAaF,EAAkBtyB,GAAKxX,KAAK6pC,iBAEzCI,EAAkBjqC,KAAK4pC,UAAUM,iBAEjClZ,EAAO2C,GAAa+D,GAAauS,GAAmB,GACpDE,EAAIzyB,GAAOsyB,GAAa3pB,IAAK,GAAI+pB,QAAQ5Q,QAEzC5P,EAAIugB,EAAE5pB,OAAQyQ,GACdlH,EAAIqgB,EAAE7pB,IAAK9I,GAAKwZ,IAChBqZ,EAAiBnwB,GACtBwd,GAAauS,EAAiB5wB,GAAOuQ,EAAGE,IACxC4N,GAAauS,EAAiB5wB,GAAOuQ,EAAExV,IAAK,GAAK0V,IACjD4N,GAAauS,EAAiB5wB,GAAOuQ,EAAExV,IAAK,GAAK0V,IACjD4N,GAAauS,EAAiB5wB,GAAOuQ,EAAExV,IAAK,GAAK0V,KAI5CwgB,EAAgBtqC,KAAK4pC,UAAUW,eAErC,GAAuB,OAAlBD,EAAyB,CAE7B,MAAME,EAAmB9xB,IAAI,EAAItV,MAEhC,MAAM4tB,EAAO2C,GAAa+D,GAAa4S,GAAiB,GAAI1gB,EACtDugB,EAAI/mC,EACJwmB,EAAIugB,EAAE5pB,OAAQyQ,GACdlH,EAAIqgB,EAAE7pB,IAAK0Q,GACjB,OAAO0G,GAAa4S,EAAejxB,GAAOuQ,EAAGE,IAAMiD,GAAG,IAEnDpW,UAAW,CACdjU,KAAM,mBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,KAAM6E,KAAM,UAIhB4R,EAAQqxB,EAAkBR,GAEhC1tB,GAAiB,OAAQ,eAAgBnI,OAAQgF,EAElD,CAEA,MAAMsxB,EAAKxwB,GAAMowB,GAEjB3Q,GAAcvlB,OAAQk2B,EAAehqB,IAAKqZ,KAE1C,MAAM6B,EAAoBf,GAAYla,IAAK9G,GAAMixB,EAAI,GAAIxiB,IAAKwiB,EAAI,IAAOA,EAAI,GAAIxiB,IAAKwiB,EAAI,IAAOA,EAAI,GAAIxiB,IAAKwiB,EAAI,MAE5GC,EAAiBD,EAAGpqB,IAAKkb,GAAoBxY,IAEnDyX,GAAYrmB,OAAQu2B,GAEf3qC,EAAQkzB,qBAAsB,YAElC+K,GAAa2M,UAAWF,EAI1B,EAWD,MAAMG,GAAsBhyB,GAAW+wB,IAIjCkB,GAAW,IAAI3qC,QAQrB,MAAM4qC,WAAqBthC,EAE1B,eAAWjC,GAEV,MAAO,cAER,CAQA,WAAAzH,CAAairC,EAAaC,GAAe,GA0CxC,IAAIC,EAAgBC,EAAuBC,EAxC3CzhC,MAAO,QAOP1J,KAAK+qC,YAAcA,EAQnB/qC,KAAKgrC,aAAeA,EAOpBhrC,KAAK2J,WAAajB,EAAeI,OASjC9I,KAAKorC,cAAgBzoC,GAAW,YAAa,SAO7C3C,KAAKqrC,eAAiB1oC,GAAW,aAAc,QAI1CqoC,GAEJC,EAAiBpd,GAAW,aAAc,QAC1Cqd,EAAwBrd,GAAW,oBAAqB,QACxDsd,EAAmBzN,GAAiB,wBAAyB,OAAQqN,EAAYO,SAASC,MAAMvnC,UAIhGinC,EAAiBnvB,GAASivB,EAAYS,WAAY,QAClDN,EAAwBpvB,GAASivB,EAAYU,kBAAmB,QAChEN,EAAmB7iC,GAAQyiC,EAAYO,SAASI,aAAc,OAAQX,EAAYO,SAASC,MAAMvnC,SASlGhE,KAAKirC,eAAiBA,EAOtBjrC,KAAKkrC,sBAAwBA,EAO7BlrC,KAAKmrC,iBAAmBA,EASxBnrC,KAAK2rC,yBAA2B,IAEjC,CASA,kBAAAC,CAAoBF,EAAe1rC,KAAKmrC,iBAAkBU,EAAWnS,IAEpE,MAAM,cAAE0R,EAAa,eAAEC,EAAc,eAAEJ,EAAc,sBAAEC,GAA0BlrC,KAE3E8rC,EAAWJ,EAAavxB,QAASixB,EAAcxhB,GAC/CmiB,EAAWL,EAAavxB,QAASixB,EAActhB,GAC/CkiB,EAAWN,EAAavxB,QAASixB,EAAcnO,GAC/CgP,EAAWP,EAAavxB,QAASixB,EAAclO,GAI/CgP,EAAajB,EAAe5qB,IAAKwrB,GAEjCM,EAAU/3B,GACf03B,EAASzrB,IAAKgrB,EAAezhB,GAAIvJ,IAAK6rB,GACtCH,EAAS1rB,IAAKgrB,EAAevhB,GAAIzJ,IAAK6rB,GACtCF,EAAS3rB,IAAKgrB,EAAepO,GAAI5c,IAAK6rB,GACtCD,EAAS5rB,IAAKgrB,EAAenO,GAAI7c,IAAK6rB,IAGvC,OAAOhB,EAAsB7qB,IAAK8rB,GAAUppB,GAE7C,CASA,gBAAAqpB,CAAkBV,EAAe1rC,KAAKmrC,iBAAkB9P,EAASb,IAEhE,MAAM,cAAE4Q,EAAa,eAAEC,EAAc,eAAEJ,EAAc,sBAAEC,GAA0BlrC,KAE3E8rC,EAAWJ,EAAavxB,QAASixB,EAAcxhB,GAC/CmiB,EAAWL,EAAavxB,QAASixB,EAActhB,GAC/CkiB,EAAWN,EAAavxB,QAASixB,EAAcnO,GAC/CgP,EAAWP,EAAavxB,QAASixB,EAAclO,GAIrD,IAAImP,EAAaj4B,GAChBi3B,EAAezhB,EAAEvJ,IAAKyrB,GACtBT,EAAevhB,EAAEzJ,IAAK0rB,GACtBV,EAAepO,EAAE5c,IAAK2rB,GACtBX,EAAenO,EAAE7c,IAAK4rB,IAKvB,OAFAI,EAAanB,EAAsB7qB,IAAKgsB,GAAahsB,IAAK4qB,GAEnDoB,EAAW9jB,mBAAoB8S,GAAStY,GAEhD,CAQA,0BAAAupB,CAA4BvsC,GAE3B,MAAMgrC,EAAchrC,EAAQO,OAU5B,OARuC,OAAlCN,KAAK2rC,2BAETZ,EAAYO,SAASiB,qBAAuB,IAAIpP,aAAc4N,EAAYO,SAASI,cAEnF1rC,KAAK2rC,yBAA2BjO,GAAiB,gCAAiC,OAAQqN,EAAYO,SAASC,MAAMvnC,SAI/GhE,KAAK4rC,mBAAoB5rC,KAAK2rC,yBAA0BhS,GAEhE,CAQA,yBAAA6S,CAA2BzsC,GAE1B,MAAM0sC,EAAM1sC,EAAQ+C,SAAS4pC,SAE7B,OAASD,GAAOA,EAAI9rC,IAAK,cAAsE,IAApD+G,EAAmB3H,EAAQO,QAASqsC,WAEhF,CAOA,KAAAzgC,CAAOnM,GAEDC,KAAKwsC,0BAA2BzsC,IAEpC45B,GAAiBxlB,OAAQnU,KAAKssC,2BAA4BvsC,IAI3D,MAAM6sC,EAAe5sC,KAAK4rC,qBAK1B,GAFAlS,GAAcvlB,OAAQy4B,GAEjB7sC,EAAQkzB,qBAAsB,UAAa,CAE/C,MAAM4Z,EAAa7sC,KAAKosC,mBAExB5R,GAAYrmB,OAAQ04B,GAEf9sC,EAAQkzB,qBAAsB,YAElC+K,GAAa7pB,OAAQ04B,EAIvB,CAED,CASA,QAAAvgC,CAAUvM,EAASwM,GAElB,GAAgB,SAAXA,EAEJ,OAAOmtB,GAAcrtB,MAAOtM,EAASwM,EAIvC,CAOA,MAAAhC,CAAQgR,GAEP,MACM+vB,GADStrC,KAAKgrC,aAAezvB,EAAMjb,OAASN,KAAK+qC,aAC/BO,SAEnBT,GAAS/pC,IAAKwqC,KAAe/vB,EAAMuxB,UAExCjC,GAASroC,IAAK8oC,EAAU/vB,EAAMuxB,SAES,OAAlC9sC,KAAK2rC,0BAAoCL,EAASiB,qBAAqB/pC,IAAK8oC,EAASI,cAE1FJ,EAAS/gC,SAEV,EAWD,MASMwiC,GAAsBhC,GAAiBx2B,GAAY,IAAIu2B,GAAcC,GAAa,IA8BxF,MAAMiC,WAAiBxjC,EAEtB,eAAWjC,GAEV,MAAO,UAER,CAOA,WAAAzH,CAAa4F,EAAS,IAErBgE,QAEA1J,KAAK0F,OAASA,CAEf,CASA,UAAAunC,CAAY3rC,GAEX,OAAOyG,OAAOC,aAAc,IAAI5C,WAAY,GAAM9D,EAEnD,CAQA,aAAA4rC,CAAentC,GAEd,MAAMmN,EAAanN,EAAQ8L,kBAAmB7L,MAE9C,QAA8Be,IAAzBmM,EAAWigC,UAA0B,OAAOjgC,EAIjD,MAAM2G,EAAS,CAAC,EAEhB,IAAM,IAAIxP,EAAI,EAAG+oC,EAAIptC,KAAK0F,OAAO1B,OAAS,EAAGK,EAAI+oC,EAAG/oC,IAAO,CAE1D,MAAM4T,EAAQjY,KAAK0F,OAAQrB,GAErB3B,GAA0B,IAAjBuV,EAAMpV,QAAmBoV,EAAMvV,MAAU1C,KAAKitC,WAAY5oC,GACnEkD,GAA0B,IAAjB0Q,EAAMpV,QAAmBoV,EAAM1Q,MAAU,MAExDsM,EAAQnR,GAAS6vB,GAAY7vB,EAAM6E,EAEpC,CAEA,MAAMiP,EAAQzW,EAAQwW,WAOtB,OALArJ,EAAWmgC,YAAcrtC,KAAK0F,OAAQ1F,KAAK0F,OAAO1B,OAAS,GAAK6P,EAAQ2C,EAAOzW,GAC/EmN,EAAWigC,UAAY32B,EAEvBzW,EAAQ0W,cAEDvJ,CAER,CAQA,WAAAvB,CAAa5L,GAEZ,MAAM,YAAEstC,GAAgBrtC,KAAKktC,cAAentC,GAE5C,OAAOstC,EAAcA,EAAY1hC,YAAa5L,GAAY,MAE3D,CAEA,KAAAmM,CAAOnM,GAINC,KAAKktC,cAAentC,EAErB,CAEA,QAAAuM,CAAUvM,GAET,MAAMmN,EAAalN,KAAKktC,cAAentC,GAEjC2F,EAAS1F,KAAK0F,OACdynC,EAAYjgC,EAAWigC,UAE7B,IAAM,IAAI9oC,EAAI,EAAG+oC,EAAI1nC,EAAO1B,OAAS,EAAGK,EAAI+oC,EAAG/oC,IAAO,CAErD,MAAM4T,EAAQvS,EAAQrB,GAEtB,IAAI5C,EAAQ,KAAM6rC,EAAM,KAAM5qC,EAAO,KAAM6E,EAAO,KAAMgmC,EAAY,KAAMhjC,EAAS,KAE9E0N,EAAMpV,QAEV0E,EAAO,MACP7E,EAAO1C,KAAKitC,WAAY5oC,GACxB5C,EAAQ,IACR6rC,EAAMr1B,EAAM5L,MAAOtM,EAASwH,GAC5BgmC,EAAY,MAIZhmC,EAAO0Q,EAAM1Q,MAAQ,MACrB7E,EAAOuV,EAAMvV,MAAQ1C,KAAKitC,WAAY5oC,GACtC5C,EAAQwW,EAAMxW,MACd6rC,EAAMr1B,EAAMq1B,IACZC,EAAYt1B,EAAMs1B,UAClBhjC,EAAS0N,EAAM1N,OAEO,iBAAV9I,EAAqBA,EAAQ1B,EAAQiT,cAAezL,EAAM9F,GAC5DA,GAASA,EAAMoB,SAASpB,EAAQA,EAAM4K,MAAOtM,EAASwH,IAE5C,iBAAR+lC,EAAmBA,EAAMvtC,EAAQiT,cAAezL,EAAM+lC,GACxDA,GAAOA,EAAIzqC,SAASyqC,EAAMA,EAAIjhC,MAAOtM,EAASwH,SAEzCxG,IAAVU,QAA+BV,IAARusC,GAE3B7rC,GAAgB,OAChB6rC,EAAM,IACNC,EAAY,WAEOxsC,IAARusC,QAA+BvsC,IAAVU,IAEhCA,EAAQ,IACR8rC,EAAY,UAIMxsC,IAAdwsC,IAIHA,EAFIp/B,OAAQ1M,GAAU0M,OAAQm/B,GAElB,KAIA,MAQf,MAAME,EAAgB,CAAE/rC,QAAO6rC,MAAKC,aAI9BE,EAAeD,EAAc/rC,MAC7BisC,EAAaF,EAAcF,IAEjC,IAAIK,EAAqB,GACrBC,EAAqB,GACrBC,EAAgB,GAEbtjC,IAI4BA,EAFpB,QAAThD,GAA2B,SAATA,EAEjBgmC,EAAUp3B,SAAU,KAAiB,KAC5B,KAITo3B,EAAUp3B,SAAU,KAAiB,QAC5B,SAMhBw3B,GAAsB5tC,EAAQ+tC,OAAQvmC,EAAM7E,GAAS,MAAQ+qC,EAE7DG,GAAsBlrC,EAAO,IAAM6qC,EAAY,IAAMG,EACrDG,GAAiBnrC,EAAO,IAAM6H,EAE9B,MAAMwjC,EAAa,SAAUJ,MAAyBC,MAAyBC,MAE/E9tC,EAAQ0qB,aAAqB,IAANpmB,EAAU,KAAO,IAAOtE,EAAQ2qB,IAAMqjB,EAAa,UAAWpjB,YAEtF,CAEA,MAAMqjB,EAAeb,EAAU9gC,MAAOtM,EAAS,QAEzCkuC,EAAiB/gC,EAAWmgC,YAAcngC,EAAWmgC,YAAYhhC,MAAOtM,GAAY,GAE1FA,EAAQ8qB,gBAAgBJ,YAAa,KAAO1qB,EAAQ2qB,IAAMsjB,GAE1D,IAAM,IAAI3pC,EAAI,EAAG+oC,EAAIptC,KAAK0F,OAAO1B,OAAS,EAAGK,EAAI+oC,EAAG/oC,IAEnDtE,EAAQ0qB,aAAqB,IAANpmB,EAAU,GAAKtE,EAAQ2qB,KAAQ,SAAUG,gBAMjE,OAFA9qB,EAAQ4qB,aAEDsjB,CAER,EAWD,MAAMC,GAAO,IAAKxoC,IAAY6O,GAAY,IAAIy4B,GAAUz3B,GAAW7P,EAAQ,SAAYwT,SAgBjFi1B,GAAQ,IAAM5b,GAAY,SAAUrZ,SAapCk1B,GAA+B,IAAIluC,QACnCmuC,GAA2B,IAAI,MAE/BC,GAAyB51B,IAAI,EAAI61B,YAAWC,YAAW3e,SAAQ1tB,QAAOm1B,QAAOxH,aAElF,MAAM2e,EAAaj3B,GAAKoxB,IAAcvoB,IAAKwP,GAASzb,IAAK0b,GAEnDhG,EAAI2kB,EAAWnuB,IAAKne,GACpBynB,EAAI6kB,EAAWruB,IAAK0J,EAAEzJ,IAAKle,IAIjC,OAFqBu1B,GAAa6W,EAAWl1B,GAAOuQ,EAAGE,IAAMwN,MAAOA,GAEhDjX,IAAKmuB,EAAW,IAwIrC,MAAME,WAAkBllC,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAOA,WAAAzH,CAAa6uC,GAEZjlC,MAAO,QAOP1J,KAAK2uC,KAAOA,EAOZ3uC,KAAK4uC,mBAAqB9yB,GAAS,GAOnC9b,KAAK2J,WAAajB,EAAeI,MAElC,CAOA,KAAAoD,CAAOnM,GAEN,MAAM,SAAEiB,GAAajB,EAEf8uC,OAAyD9tC,IAAtCC,EAAS8tC,gBAAgBjD,SAC5CkD,EAAkB/tC,EAASy5B,aAAc,gBAAkD15B,IAApCC,EAAS8tC,gBAAgBzT,OAEhF2T,EAAiBhuC,EAAS8tC,gBAAgBjD,UAAY7qC,EAAS8tC,gBAAgBzT,QAAUr6B,EAAS8tC,gBAAgB31B,MAClH81B,OAAyCluC,IAAnBiuC,EAAiCA,EAAehrC,OAAS,GAI7E8vB,QAASya,EAAS,OAAE1e,EAAM,KAAEmB,GA7LtC,SAAmBhwB,GAElB,MAAM6tC,OAAyD9tC,IAAtCC,EAAS8tC,gBAAgBjD,SAC5CkD,OAAsDhuC,IAApCC,EAAS8tC,gBAAgBzT,OAC3C6T,OAAoDnuC,IAAnCC,EAAS8tC,gBAAgB31B,MAK1C61B,EAAiBhuC,EAAS8tC,gBAAgBjD,UAAY7qC,EAAS8tC,gBAAgBzT,QAAUr6B,EAAS8tC,gBAAgB31B,MAClH81B,OAAyCluC,IAAnBiuC,EAAiCA,EAAehrC,OAAS,EAErF,IAAImrC,EAAQf,GAAettC,IAAKE,GAEhC,QAAeD,IAAVouC,GAAuBA,EAAMztC,QAAUutC,EAAoB,MAEhDluC,IAAVouC,GAAsBA,EAAMrb,QAAQ7oB,UAEzC,MAAMmkC,EAAepuC,EAAS8tC,gBAAgBjD,UAAY,GACpDwD,EAAeruC,EAAS8tC,gBAAgBzT,QAAU,GAClDiU,EAActuC,EAAS8tC,gBAAgB31B,OAAS,GAEtD,IAAIo2B,EAAkB,GAEI,IAArBV,IAA4BU,EAAkB,IAC1B,IAApBR,IAA2BQ,EAAkB,IAC1B,IAAnBL,IAA0BK,EAAkB,GAEjD,IAAIptC,EAAQnB,EAASG,WAAW0qC,SAASnqC,MAAQ6tC,EAC7CntC,EAAS,EAEb,MAAMotC,EAAiB,KAElBrtC,EAAQqtC,IAEZptC,EAAS6C,KAAKuhB,KAAMrkB,EAAQqtC,GAC5BrtC,EAAQqtC,GAIT,MAAMlnC,EAAS,IAAI60B,aAAch7B,EAAQC,EAAS,EAAI6sC,GAEhDQ,EAAgB,IAAI,MAAkBnnC,EAAQnG,EAAOC,EAAQ6sC,GACnEQ,EAAcloC,KAAO,MACrBkoC,EAAcrlC,aAAc,EAI5B,MAAMslC,EAAqC,EAAlBH,EAEzB,IAAM,IAAIlrC,EAAI,EAAGA,EAAI4qC,EAAmB5qC,IAAO,CAE9C,MAAMsrC,EAAcP,EAAc/qC,GAC5BurC,EAAcP,EAAchrC,GAC5BwrC,EAAaP,EAAajrC,GAE1ByrB,EAAS3tB,EAAQC,EAAS,EAAIiC,EAEpC,IAAM,IAAI8lC,EAAI,EAAGA,EAAIwF,EAAYjuC,MAAOyoC,IAAO,CAE9C,MAAMta,EAASsa,EAAIuF,GAEO,IAArBb,IAEJR,GAAWyB,oBAAqBH,EAAaxF,GAE7C7hC,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWzkB,EAC3CthB,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWvkB,EAC3CxhB,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWpR,EAC3C30B,EAAQwnB,EAASD,EAAS,GAAM,IAIR,IAApBkf,IAEJV,GAAWyB,oBAAqBF,EAAazF,GAE7C7hC,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWzkB,EAC3CthB,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWvkB,EAC3CxhB,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWpR,EAC3C30B,EAAQwnB,EAASD,EAAS,GAAM,IAIT,IAAnBqf,IAEJb,GAAWyB,oBAAqBD,EAAY1F,GAE5C7hC,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWzkB,EAC3CthB,EAAQwnB,EAASD,EAAS,GAAMwe,GAAWvkB,EAC3CxhB,EAAQwnB,EAASD,EAAS,IAAOwe,GAAWpR,EAC5C30B,EAAQwnB,EAASD,EAAS,IAAiC,IAAxBggB,EAAWjgB,SAAmBye,GAAWnR,EAAI,EAIlF,CAED,CAWA,SAAS6S,IAERN,EAAcxkC,UAEdmjC,GAAe4B,OAAQhvC,GAEvBA,EAASivC,oBAAqB,UAAWF,EAE1C,CAjBAZ,EAAQ,CACPztC,MAAOutC,EACPnb,QAAS2b,EACT5f,OAAQ0f,EACRve,KAAM,IAAI,MAAS7uB,EAAOC,IAG3BgsC,GAAe5rC,IAAKxB,EAAUmuC,GAY9BnuC,EAASkvC,iBAAkB,UAAWH,EAEvC,CAEA,OAAOZ,CAER,CAiE+CgB,CAAUnvC,IAE7B,IAArB6tC,GAA4BnV,GAAciR,UAAW3qC,KAAK4uC,qBACtC,IAApBG,GAA2BvU,GAAYmQ,UAAW3qC,KAAK4uC,oBAE5D,MAAMzsC,EAAQqV,GAAKwZ,EAAK7uB,OAExB+rC,GAAMe,GAAmB,EAAI5qC,QAE5B,MAAMmqC,EAAY92B,GAAO,GAAI8hB,QAExBx5B,KAAK2uC,KAAKjtC,MAAQ,GAAkC,OAA3B1B,KAAK2uC,KAAKyB,mBAAoDrvC,IAA3Bf,KAAK2uC,KAAKyB,aAE1E5B,EAAUr6B,OAAQujB,GAAa13B,KAAK2uC,KAAKyB,aAAc/2B,GAAO7B,GAAKnT,GAAI+P,IAAK,GAAKoD,GAAKqxB,MAAoB/L,GAI1G0R,EAAUr6B,OAAQ0Z,GAAW,wBAAyB,SAAU1T,QAAS9V,GAAIm1B,UAIpD,IAArBqV,GAEJnV,GAAc2W,UAAW/B,GAAU,CAClCC,YACAC,YACA3e,SACA1tB,QACAm1B,MAAOjzB,EACPyrB,OAAQtY,GAAK,OAKU,IAApBu3B,GAEJvU,GAAY6V,UAAW/B,GAAU,CAChCC,YACAC,YACA3e,SACA1tB,QACAm1B,MAAOjzB,EACPyrB,OAAQtY,GAAK,KAGf,GAIF,CAOA,MAAAjN,GAEC,MAAMqkC,EAAqB5uC,KAAK4uC,mBAE3B5uC,KAAK2uC,KAAK3tC,SAASsvC,qBAEvB1B,EAAmB1rC,MAAQ,EAI3B0rC,EAAmB1rC,MAAQ,EAAIlD,KAAK2uC,KAAK5sC,sBAAsBsO,QAAQ,CAAEwP,EAAGC,IAAOD,EAAIC,GAAG,EAI5F,EAWD,MAAMywB,GAA+B33B,GAAW81B,IAOhD,MAAM8B,WAAqBhnC,EAE1B,eAAWjC,GAEV,MAAO,cAER,CAKA,WAAAzH,GAEC4J,MAAO,QASP1J,KAAKywC,gBAAiB,CAEvB,EAWD,MAAMC,WAAeF,GAEpB,eAAWjpC,GAEV,MAAO,QAER,CAOA,WAAAzH,CAAa6wC,EAAS,MAErBjnC,QAQA1J,KAAK2wC,OAASA,CAEf,CAEA,KAAAzkC,CAAOnM,GAENA,EAAQsC,QAAQuuC,iBAAiBjG,UAAW3qC,KAAK2wC,OAElD,EAWD,MAAME,WAA4B5lB,GAEjC,eAAW1jB,GAEV,MAAO,qBAER,CAUA,WAAAzH,CAAaqG,EAAM2qC,EAAgB,KAAMC,EAAe,KAAMC,EAAoB,MAEjFtnC,MAAOvD,GAQPnG,KAAK8wC,cAAgBA,EAQrB9wC,KAAK+wC,aAAeA,EAQpB/wC,KAAKgxC,kBAAoBA,EAEzBhxC,KAAK00B,OAAS,IAEf,CAeA,UAAAtJ,GAEC,MAAM,aAAE2lB,EAAY,kBAAEC,GAAsBhxC,KAOtCixC,EAAiB,CACtBC,cANqB13B,KAAOggB,MAAO,iBAOnC2X,eANiB33B,KAAOggB,MAAO,kBAO/B4X,gBANkB53B,KAAOggB,MAAO,mBAOhC6X,iBANmB73B,KAAOggB,MAAO,qBAmBlC,MAVgB,CACf8X,SAAU93B,KAAOggB,MAAO,YACxB+X,WAAY/3B,KAAOggB,MAAO,cAC1BgY,cAAeh4B,KAAOggB,MAAO,iBAC7BoX,iBAAkBl5B,GAAO,GAAI8hB,MAAO,oBACpCyX,iBACAQ,SAAUV,EACVW,cAAeV,EAKjB,CAEA,KAAA9kC,CAAOnM,GAKN,OAHAC,KAAKkD,MAAQlD,KAAK00B,SAAY10B,KAAK00B,OAAS10B,KAAKorB,cACjDprB,KAAKkD,MAAM4tC,cAAgB9wC,KAAK8wC,eAAiB/wC,EAAQsC,QAAQyuC,cAE1DpnC,MAAMwC,MAAOnM,EAErB,EAID,MAAM4xC,GAAgC/4B,GAAWi4B,IASjD,MAAMe,WAAuBpB,GAE5B,eAAWjpC,GAEV,MAAO,gBAER,CAOA,WAAAzH,CAAaqG,GAEZuD,QAOA1J,KAAKmG,KAAOA,CAEb,CAEA,KAAA+F,CAAOnM,GAENA,EAAQsC,QAAQkvC,WAAWlB,UAAWrwC,KAAKmG,KAE5C,EAMD,IAAI0rC,GAAeC,GASnB,MAAMC,WAAmBvoC,EAExB,eAAWjC,GAEV,MAAO,YAER,CAOA,WAAAzH,CAAaqV,GAEZzL,QAYA1J,KAAKmV,MAAQA,EASbnV,KAAKgyC,gBAAiB,CAEvB,CAOA,WAAArmC,GAEC,OAAK3L,KAAKmV,QAAU48B,GAAWE,SAAkB,OACrC,MAEb,CAOA,aAAA1mC,GAEC,IAAI5B,EAAajB,EAAeC,KAUhC,OARK3I,KAAKmV,QAAU48B,GAAWG,MAAQlyC,KAAKmV,QAAU48B,GAAWE,WAEhEtoC,EAAajB,EAAeG,QAI7B7I,KAAK2J,WAAaA,EAEXA,CAER,CAQA,MAAAY,EAAQ,SAAEzH,IAET,MAAMqvC,EAAervC,EAASsvC,kBAEzBpyC,KAAKmV,QAAU48B,GAAWE,SAER,OAAjBE,EAEJL,GAAYvuC,KAAM4uC,EAAaE,WAI/BvvC,EAASwvC,YAAaR,IAEtBA,GAAYS,eAAgBzvC,EAAS0vC,kBAMhB,OAAjBL,GAEJN,GAAc1vC,MAAQgwC,EAAahwC,MACnC0vC,GAAczvC,OAAS+vC,EAAa/vC,QAIpCU,EAAS2vC,qBAAsBZ,GAMlC,CAEA,KAAA3lC,GAEC,MAAMiJ,EAAQnV,KAAKmV,MAEnB,IAAI5I,EAAS,KAgBb,OAZCA,EAFI4I,IAAU48B,GAAWG,KAEhBp2B,GAAS+1B,KAAmBA,GAAgB,IAAI,QAE9C18B,IAAU48B,GAAWE,SAEvBn2B,GAASg2B,KAAiBA,GAAc,IAAI,QAI5C14B,GAAMs5B,GAAiBpyB,IAAKqyB,KAI/BpmC,CAER,CAEA,QAAAD,CAAUvM,GAET,GAAKC,KAAKmV,QAAU48B,GAAWa,WAAa,CAE3C,IAAIC,EAAQ9yC,EAAQ+yC,eAEpB,GAAK/yC,EAAQo1B,UAAY,CAIxB,MAAMnE,EAAOjxB,EAAQ8L,kBAAmB8mC,IAAa7mC,WAAWO,MAAOtM,GAEvE8yC,EAAQ,GAAI9yC,EAAQ8Q,QAAS,YAAegiC,QAAc7hB,SAAc6hB,OAEzE,CAEA,OAAOA,CAER,CAEA,OAAOnpC,MAAM4C,SAAUvM,EAExB,EAIDgyC,GAAWa,WAAa,aACxBb,GAAWE,SAAW,WACtBF,GAAWG,KAAO,OAClBH,GAAWgB,GAAK,KAShB,MAAMC,GAAyBn6B,GAAek5B,GAAYA,GAAWgB,IAO/DJ,GAA2B95B,GAAek5B,GAAYA,GAAWG,MAOjEQ,GAAiC75B,GAAek5B,GAAYA,GAAWa,YASvEP,GAAyBx5B,GAAek5B,GAAYA,GAAWE,UAmD/DgB,IA5CeZ,GAASa,GAOiCb,GAAShpB,GAqC1C,IAAI,OAWlC,MAAM8pB,WAA4Blf,GAEjC,eAAW1sB,GAEV,MAAO,qBAER,CASA,WAAAzH,CAAao0B,EAAS8e,GAAUzf,EAAY,KAAM6f,EAAqB,MAE1C,OAAvBA,KAEJA,EAAqB,IAAI,OACNC,UAAY,OAIhC3pC,MAAO0pC,EAAoBlf,EAAQX,GAQnCvzB,KAAKszC,iBAAkB,EASvBtzC,KAAKuzC,qBAAsB,EAS3BvzC,KAAK4J,iBAAmBlB,EAAeE,KAExC,CAEA,YAAA4D,CAAc+O,GAEb,MAAMzY,EAAWyY,EAAMzY,SACvBA,EAAS2vC,qBAAsBQ,IAI/B,MAAMG,EAAqBpzC,KAAKkD,MAE3BkwC,EAAmBrf,MAAM5xB,QAAU8wC,GAAQ9wC,OAASixC,EAAmBrf,MAAM3xB,SAAW6wC,GAAQ7wC,SAEpGgxC,EAAmBrf,MAAM5xB,MAAQ8wC,GAAQ9wC,MACzCixC,EAAmBrf,MAAM3xB,OAAS6wC,GAAQ7wC,OAC1CgxC,EAAmBhpC,aAAc,GAMlC,MAAMopC,EAAyBJ,EAAmBE,gBAClDF,EAAmBE,gBAAkBtzC,KAAKszC,gBAE1CxwC,EAAS2wC,yBAA0BL,GAEnCA,EAAmBE,gBAAkBE,CAEtC,CAEA,KAAA3xC,GAEC,MAAM6xC,EAAsB,IAAI1zC,KAAKF,YAAaE,KAAKk0B,OAAQl0B,KAAKuzB,UAAWvzB,KAAKkD,OAGpF,OAFAwwC,EAAoBJ,gBAAkBtzC,KAAKszC,gBAEpCI,CAER,EAaD,MAWMC,GAAmC/6B,GAAWu6B,GAAqB,KAAM,KAAM,CAAEG,iBAAiB,IAIxG,IAAIM,GAAoB,KASxB,MAAMC,WAAiCV,GAEtC,eAAW5rC,GAEV,MAAO,0BAER,CAQA,WAAAzH,CAAao0B,EAAS8e,GAAUzf,EAAY,MAEhB,OAAtBqgB,KAEJA,GAAoB,IAAI,OAIzBlqC,MAAOwqB,EAAQX,EAAWqgB,GAE3B,EAYD,MAAME,GAAqCl7B,GAAWi7B,IAWtD,MAAME,WAA0BvqC,EAE/B,eAAWjC,GAEV,MAAO,mBAER,CAQA,WAAAzH,CAAaqV,EAAO6+B,EAAY,MAE/BtqC,MAAO,SAYP1J,KAAKmV,MAAQA,EASbnV,KAAKg0C,UAAYA,EASjBh0C,KAAKi0C,qBAAsB,CAE5B,CAEA,QAAA3nC,CAAUvM,GAET,MAAM,MAAEoV,GAAUnV,KAElB,OAAKmV,IAAU4+B,GAAkBG,WAEzBn0C,EAAQo0C,eAITzqC,MAAM4C,SAAUvM,EAExB,CAEA,KAAAmM,EAAO,OAAE0rB,IAER,MAAM,MAAEziB,GAAUnV,KACZkD,EAAQlD,KAAKg0C,UAEnB,IAAI7tC,EAAO,KAEX,GAAKgP,IAAU4+B,GAAkBG,WAEjB,OAAVhxC,IAEHiD,EAAOiuC,KAAYjgC,OAAQjR,SAIvB,GAAKiS,IAAU4+B,GAAkBM,MAItCluC,EAFIyxB,EAAO0c,oBAEJC,GAAyBza,GAAamD,EAAGtF,GAAYG,IAIrD0c,GAA0B1a,GAAamD,EAAGtF,GAAYG,SAIxD,GAAK3iB,IAAU4+B,GAAkBU,aAEvC,GAAe,OAAVvxC,EAEJ,GAAK00B,EAAO0c,oBAAsB,CAEjC,MAAMI,EAAQC,GAAyBzxC,EAAOy0B,GAAYG,IAE1D3xB,EAAOquC,GAA0BE,EAAO/c,GAAYG,GAErD,MAEC3xB,EAAOjD,OAMRiD,EAAOquC,GAA0B1a,GAAamD,EAAGtF,GAAYG,IAM/D,OAAO3xB,CAER,EAID4tC,GAAkBG,WAAa,YAC/BH,GAAkBM,MAAQ,QAC1BN,GAAkBU,aAAe,cAajC,MAAMD,GAA2B,CAAEE,EAAO7c,EAAME,IAAS2c,EAAMtgC,IAAKyjB,GAAOvX,IAAKuX,EAAKzX,IAAK2X,IAwBpFwc,GAA0B,CAAEG,EAAO7c,EAAME,IAASF,EAAKzjB,IAAKsgC,GAAQr0B,IAAK0X,GAAMzX,IAAKyX,EAAI3X,IAAKyX,GAAOxX,IAAKq0B,IAWzGC,GAA0B,CAAErd,EAAOO,EAAME,IAASF,EAAKxX,IAAK0X,GAAMzX,IAAKyX,EAAI3X,IAAKyX,GAAOxX,IAAKiX,GAAQlX,IAAK2X,IAWzG6c,GAA0B,CAAEF,EAAO7c,EAAME,KA4B9CF,EAAOA,EAAKxmB,IAAK,MAAOmoB,QACxB,MAAMqb,EAAYzuB,GAAMsuB,EAAMztB,SAAS3G,IAAKuX,IACtCid,EAAc1uB,GAAM2R,EAAIzX,IAAKuX,IACnC,OAAOgd,EAAUv0B,IAAKw0B,EAAa,EA8B9BV,GAA0Bx7B,GAAWm7B,GAAmBA,GAAkBG,YAO1E5c,GAAsBze,GAAek7B,GAAmBA,GAAkBM,OAS1EU,GAA4Bn8B,GAAWm7B,GAAmBA,GAAkBU,cAO3BX,KAEvDxc,GAAMnjB,OAAWjR,GAAWkxC,GAAWlxC,GA4DvC,MAAM8xC,GAAUp8B,GAlDhB,cAA0BpP,EAOzB,WAAA1J,CAAa4C,GAEZgH,MAAO,SAOP1J,KAAK0C,KAAOA,EASZ1C,KAAKi1C,eAAgB,CAEtB,CAQA,QAAA3oC,GAEC,OAAOtM,KAAK0C,IAEb,IAuBD,MAAMwyC,WAAqB1rC,EAE1B,eAAWjC,GAEV,MAAO,cAER,CAQA,WAAAzH,CAAaqV,EAAQ+/B,GAAaC,SAEjCzrC,QAQA1J,KAAKmV,MAAQA,CAEd,CAQA,KAAAjJ,CAAOnM,GAEN2J,MAAMwC,MAAOnM,GAEb,MAAMq1C,EAAkBr1C,EAAQq1C,iBAC1B,mBAAEC,EAAkB,YAAEC,GAAgBF,EAI5C,OAFAp1C,KAAKu1C,iBAAmBx1C,EAAQkB,SAASs0C,iBAEpCv1C,KAAKmV,QAAU+/B,GAAaM,kBAEzBx1C,KAAKy1C,qBAAsBJ,EAAoBC,GAE3Ct1C,KAAKmV,QAAU+/B,GAAaQ,SAEhC11C,KAAK21C,sBAAuBL,EAAav1C,GAIzCC,KAAK41C,aAAcP,EAAoBC,EAIhD,CASA,oBAAAG,CAAsBJ,EAAoBC,GAEzC,OAAO58B,IAAI,KAEV,MAAMm9B,EAAkBn+B,KAAQ8hB,MAAO,mBACjCsc,EAAmBp+B,KAAQ8hB,MAAO,sBAElCuc,EAAcr+B,GAAO,GAAI8hB,MAAO,eAEhCwc,EAAiBV,EAAYtxC,OAEnC,IAA+B,IAA1BhE,KAAKu1C,kBAA8BS,EAAiB,EAAI,CAE5D,MAAMC,EAAiB1Y,GAAc+X,GAErCpH,GAAM8H,GAAgB,EAAI3xC,QAEzB,MAAM6xC,EAAQD,EAAe97B,QAAS9V,GAEtCwxC,EAAgB1hC,OAAQ2lB,GAAa7R,IAAKiuB,EAAMnzB,KAAMkE,SAAS7S,IAAK8hC,EAAMhZ,IAC1E4Y,EAAiB3hC,OAAQ0hC,EAAgBruB,SAASlH,IAAK,IAEvDy1B,EAAYpL,UAAW3hB,GAAY8sB,EAAiB7uB,SAAU6uB,EAAkBD,GAAmB,GAIrG,CAEA,MAAMM,EAAwBd,EAAmBrxC,OAEjD,GAAKmyC,EAAwB,EAAI,CAEhC,MAAMF,EAAiB1Y,GAAc8X,GAC/Be,EAA0B1+B,GAAO,GAAI8hB,MAAO,2BAElD0U,GAAMiI,GAAuB,EAAI9xC,QAEhC,MAAM6xC,EAAQD,EAAe97B,QAAS9V,GAEtCwxC,EAAgB1hC,OAAQ2lB,GAAa7R,IAAKiuB,EAAMnzB,KAAMkE,SAAS7S,IAAK8hC,EAAMhZ,IAC1E4Y,EAAiB3hC,OAAQ0hC,EAAgBruB,SAASlH,IAAK,IAEvD81B,EAAwBzL,UAAW3hB,GAAY8sB,EAAiB7uB,SAAU6uB,EAAkBD,GAAkB3uB,WAAY,IAI3H6uB,EAAYpL,UAAWyL,EAAwBlvB,WAEhD,CAEA3K,GAAasD,EAAE8qB,UAAWoL,GAE1Bx5B,GAAasD,EAAEW,MAAO,GAAM61B,SAAS,GAlD/B39B,EAsDR,CASA,YAAAk9B,CAAcP,EAAoBC,GAEjC,OAAO58B,IAAI,KAEV,MAAMs9B,EAAiBV,EAAYtxC,OAEnC,IAA+B,IAA1BhE,KAAKu1C,kBAA8BS,EAAiB,EAAI,CAE5D,MAAMC,EAAiB1Y,GAAc+X,GAErCpH,GAAM8H,GAAgB,EAAI3xC,QAEzB,MAAM6xC,EAAQD,EAAe97B,QAAS9V,GACtCy1B,GAAa7R,IAAKiuB,EAAMnzB,KAAMpC,YAAau1B,EAAMhZ,GAAImZ,SAAS,GAIhE,CAEA,MAAMF,EAAwBd,EAAmBrxC,OAEjD,GAAKmyC,EAAwB,EAAI,CAEhC,MAAMF,EAAiB1Y,GAAc8X,GAC/BiB,EAAUp/B,IAAM,GAAOsiB,MAAO,WAEpC0U,GAAMiI,GAAuB,EAAI9xC,QAEhC,MAAM6xC,EAAQD,EAAe97B,QAAS9V,GACtCiyC,EAAQniC,OAAQ2lB,GAAa7R,IAAKiuB,EAAMnzB,KAAMpC,YAAau1B,EAAMhZ,GAAIpc,IAAKw1B,GAAW,IAItFA,EAAQD,SAET,IAjCM39B,EAqCR,CASA,qBAAAi9B,CAAuBL,EAAav1C,GAEnC,MAAMi2C,EAAiBV,EAAYtxC,OAInC,OAFAjE,EAAQw2C,uBAAwBP,GAEzBt9B,IAAI,KAEV,MAAMu9B,EAAiB1Y,GAAc+X,GAC/BkB,EAAoBxB,GAASj1C,EAAQ02C,mBAE3CvI,GAAM8H,GAAgB,EAAI3xC,QAEzB,MAAM6xC,EAAQD,EAAe97B,QAAS9V,GAEhC0jB,EAAW+R,GAAa7R,IAAKiuB,EAAMnzB,KAAM3C,IAAK81B,EAAMhZ,GAAIjW,SAC9DuvB,EAAkBr8B,QAAS9V,GAAI8P,OAAQ4T,EAAU,GAE/C,GAZGrP,EAgBR,EAIDw8B,GAAaM,kBAAoB,kBACjCN,GAAaC,QAAU,UACvBD,GAAaQ,SAAW,WAQxB,MAsBMgB,GAAuBh+B,IAAI,EAAIxV,KAE7BujB,GAAOpG,GAAK,IAAOqG,GAAKrG,GAAK,GAAMnd,EAAM0mB,GAAIxV,IAAKiM,GAAK,GAAKnd,EAAM4mB,MAAUzJ,IAAKjM,GAAK,GAAKiP,GAAKqD,GAAKrG,GAAK,GAAMnd,EAAM4mB,GAAI1V,IAAKlR,EAAM0mB,UAIvI+sB,GAAuBj+B,IAAI,EAAIxV,KAE7BwzC,GAAQt9B,GAAMs9B,GAAQxzC,EAAMmmB,IAAMnmB,EAAM+5B,MAI1C2Z,GAAsCl+B,IAAI,EAAImzB,MAGnD,MAAMgL,EAAWlvB,GAChB3jB,GAAQmjB,GAAM0kB,EAAS9oB,MACvB/e,GAAQojB,GAAMykB,EAAS9oB,OAGlB+zB,EAAWp/B,GAAO,GAAI4I,IAAK5I,GAtBT,KAsBmC2I,IAAKw2B,IAAard,MAAO,YAG9Eud,EAAY39B,GACjB8M,GAAMK,GAAOH,GAAM0wB,KACnB5wB,GAAMM,GAAMJ,GAAM0wB,MAIbE,EAAQ59B,GACbu9B,GAAQpwB,GAAOwwB,EAAUntB,EAAEvJ,IAAKwrB,EAAS9oB,OACzC4zB,GAAQpwB,GAAOwwB,EAAUjtB,EAAEzJ,IAAKwrB,EAAS9oB,QAIpCk0B,EAAaxwB,GAAOL,GAAM0wB,IAG1BltB,EAAIxV,GAAKiM,GAAK42B,EAAW/vB,WAAY8vB,EAAMptB,GAAKvJ,GAAK42B,EAAYD,EAAMltB,IAGvEjK,EAAI6H,GAAOuvB,EAAYA,EAAW/vB,YAClCgwB,EAAQ19B,GACboQ,EAAEvJ,IAAKuJ,GAAItJ,IAAKD,GAAK,EAAKR,GAAIQ,IAAKD,GAAK,EAAKP,KAC7C+J,EAAExJ,IAAKC,GAAK,GAAKR,IAAMS,IAAKF,GAAK,EAAKP,IACtCO,GAAK,EAAKA,GAAK,EAAKwJ,GAAIvJ,IAAKD,GAAK,EAAKwJ,IAAMtJ,IAAKD,GAAK,EAAKR,GAAIQ,IAAKD,GAAK,EAAKP,OAG1Es3B,EAAYvtB,EAAElJ,SAAUb,EAAEqH,YAAa6D,OAAQnB,EAAElJ,SAAUb,GAAIkL,OAAQmsB,EAAMttB,EAAGstB,EAAMptB,GAAKotB,EAAMja,GAGvG,OAAOtU,GAAOwuB,EAAW,KAAQ,EAAK,IAEnCxgC,UAAW,CACdjU,KAAM,wBACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,WAAY6E,KAAM,WAS5B,MAAM6vC,WAAqB,MAE1B,eAAW7vC,GAEV,MAAO,cAER,CAOA,QAAIA,GAEH,OAAOvH,KAAKF,YAAYyH,IAEzB,CAEA,QAAIA,CAAMmtB,GAAiB,CAK3B,WAAA50B,GAEC4J,QASA1J,KAAKq3C,gBAAiB,EAQtBr3C,KAAKs3C,KAAM,EAQXt3C,KAAKu3C,QAAS,EAUdv3C,KAAKu1C,kBAAmB,EAkBxBv1C,KAAKw3C,WAAa,KAelBx3C,KAAKy3C,QAAU,KAcfz3C,KAAK2wC,OAAS,KAqBd3wC,KAAKwsB,UAAY,KAajBxsB,KAAK03C,WAAa,KAalB13C,KAAKkhC,YAAc,KAqBnBlhC,KAAK+wC,aAAe,KAQpB/wC,KAAKgxC,kBAAoB,KAazBhxC,KAAK23C,cAAgB,KAiBrB33C,KAAK43C,aAAe,KAgBpB53C,KAAK63C,aAAe,KAQpB73C,KAAKs0B,UAAY,KAUjBt0B,KAAK83C,mBAAqB,KAiB1B93C,KAAK+3C,mBAAqB,KAwB1B/3C,KAAKg4C,eAAiB,KAUtBh4C,KAAK8L,WAAa,KAWlB9L,KAAKi4C,QAAU,KAUfj4C,KAAKk4C,aAAe,KAUpBl4C,KAAKm4C,WAAa,IAEnB,CAQA,qBAAAC,GAEC,OAAOp4C,KAAKuH,KAAO5B,EAAe3F,KAEnC,CAOA,KAAAqM,CAAOtM,GAENC,KAAKkM,MAAOnM,EAEb,CAQA,aAAAs4C,CAAet4C,GAEd,OAAO,IAAIF,EAAsBE,EAElC,CAOA,KAAAmM,CAAOnM,GAENA,EAAQsC,QAAQ24B,YAAc,IAAMh7B,KAAKg7B,YAAaj7B,GACtDA,EAAQsC,QAAQ03B,kBAAoB,IAAM/5B,KAAK+5B,kBAAmBh6B,GAClEA,EAAQsC,QAAQylC,yBAA2B,IAAM9nC,KAAK8nC,yBAA0B/nC,GAEhF,MAAM+C,EAAW/C,EAAQ+C,SACnBqvC,EAAervC,EAASsvC,kBAI9BryC,EAAQwW,WAER,MAAM4hC,EAAan4C,KAAKm4C,YAAcn4C,KAAKs4C,YAAav4C,GAkBxD,IAAIw4C,EAhBJx4C,EAAQyW,MAAM1K,WAAaqsC,EAE3Bn4C,KAAK21C,sBAAuB51C,GAED,OAAtBC,KAAK63C,eAET93C,EAAQyW,MAAM1K,WAAa/L,EAAQyW,MAAM1K,WAAW+lB,OAAQ7xB,KAAK63C,eAIlE93C,EAAQy4C,QAAS,SAAUz4C,EAAQ0W,eAInC1W,EAAQwW,WAIR,MAAMkiC,EAAez4C,KAAK04C,cAAe34C,GAkBzC,IAhByB,IAApBC,KAAK24C,aAA0C,IAAnB34C,KAAK44C,YAIf,OAAjBzG,GAE8B,IAA7BA,EAAa0G,aAAuB74C,KAAK84C,WAAY/4C,IAIlC,IAAnB+C,EAASw0B,OAAiBt3B,KAAK84C,WAAY/4C,IAMvB,OAAtBC,KAAKk4C,aAAwB,CAEjCl4C,KAAK+4C,kBAAmBh5C,GACxBC,KAAKg5C,cAAej5C,GAEpB,MAAMk5C,EAAoBj5C,KAAKk5C,cAAen5C,GAExB,OAAjB04C,GAAwB14C,EAAQyW,MAAMpC,IAAKqkC,GAIhD,MAAMU,EAAcv/B,GAAMq/B,EAAmB18B,GAAasD,GAAIxO,IAAK,GAcnE,GAZAknC,EAAav4C,KAAKsW,YAAavW,EAASo5C,GAIxC5sC,GAAO4H,OAAQokC,GAIU,OAApBv4C,KAAK8L,aAAsBysC,EAAav4C,KAAK8L,YAI5B,OAAjBqmC,EAAwB,CAE5B,MAAM1F,EAAM3pC,EAAS4pC,SACf0M,EAAcp5C,KAAKi4C,QAEZ,OAARxL,GAEJ8L,EAAa9L,EAEQ,OAAhB2M,IAEJb,EAAa9L,EAAI4M,MAAOD,KAIE,OAAhBA,IAEXb,EAAaa,EAIf,CAED,KAAO,CAEN,IAAIlB,EAAel4C,KAAKk4C,cAEiB,IAApCA,EAAaoB,qBAEjBpB,EAAet+B,GAAMs+B,IAItBK,EAAav4C,KAAKsW,YAAavW,EAASm4C,EAEzC,CAEAn4C,EAAQyW,MAAM1K,WAAaysC,EAE3Bx4C,EAAQy4C,QAAS,WAAYz4C,EAAQ0W,eAIrC1W,EAAQw5C,QAAUv5C,KAAKq4C,cAAet4C,EAEvC,CAQA,aAAA24C,CAAe34C,GAEd,GAAiC,OAA5BA,EAAQq1C,gBAA2B,OAAO,KAE/C,MAAM,YAAEE,EAAW,mBAAED,GAAuBt1C,EAAQq1C,gBAEpD,IAAIroC,EAAS,KAEb,GAAKuoC,EAAYtxC,OAAS,GAAKqxC,EAAmBrxC,OAAS,EAAI,CAE9D,MAAMw1C,EAAUz5C,EAAQ+C,SAAS02C,QAE5Bx5C,KAAKy5C,iBAAmBD,EAAU,EAGtCzsC,EAtlBwBwH,GAAY,IAAI2gC,GAAcA,GAAaM,oBA0lBnEz1C,EAAQyW,MAAMpC,IAlmBKG,GAAY,IAAI2gC,IAsmBrC,CAEA,OAAOnoC,CAER,CAOA,qBAAA4oC,CAAuB51C,GAItB,GAFAC,KAAKu1C,kBAAmB,EAES,OAA5Bx1C,EAAQq1C,gBAA2B,OAExC,MAAMsE,EAAiB35C,EAAQq1C,gBAAgBE,YAAYtxC,OAItD01C,EAAiB,GAAKA,GAAkB,GAAK35C,EAAQme,YAAa,kBAEtEne,EAAQyW,MAAMpC,IA7mBcG,GAAY,IAAI2gC,GAAcA,GAAaQ,YA+mBvE11C,KAAKu1C,kBAAmB,EAM1B,CAOA,UAAAuD,CAAY/4C,GAEX,MAAM,SAAE+C,EAAQ,OAAE80B,GAAW73B,EAI7B,IAAIu0B,EAAYt0B,KAAKs0B,UAErB,GAAmB,OAAdA,EAAqB,CAEzB,MAAMmY,EAAM3pC,EAAS4pC,SAEhBD,GAAOA,EAAI9rC,IAAK,SAEpB2zB,EAAYmY,EAAI3rC,IAAK,UAE0B,IAApCgC,EAAS62C,yBAInBrlB,EAFIsD,EAAO0c,oBAECM,GAAyB9a,GAAamD,EAAGtF,GAAYG,IAIrD0c,GAA0B1a,GAAamD,EAAGtF,GAAYG,IAMrE,CAEmB,OAAdxD,GAEJgD,GAAMnjB,OAAQmgB,GAAYpb,QAI5B,CASA,iBAAA6gB,GAEC,OAAO/2B,GAAgBqd,IAAKqZ,IAAgB3W,GAE7C,CAQA,wBAAA+kB,GAEC,OAAO9P,GAAuB3X,IAAKyZ,GAEpC,CAQA,WAAAwe,CAAav4C,GAQZ,OANAA,EAAQwW,WAERvW,KAAK45C,cAAe75C,GAEpBA,EAAQsC,QAAQw3C,OAAS95C,EAAQ0W,cAE1BoxB,EAER,CAQA,aAAA+R,CAAe75C,GAEd,MAAM,OAAEO,EAAM,SAAEU,GAAajB,EAc7B,IAZKiB,EAAS8tC,gBAAgBjD,UAAY7qC,EAAS8tC,gBAAgBzT,QAAUr6B,EAAS8tC,gBAAgB31B,QAErGo3B,GAAgBjwC,GAAS4Y,UAII,IAAzB5Y,EAAOC,eAEXwsC,GAAmBzsC,GAAS4Y,SAIxBlZ,KAAK85C,gBAAkB,CAE3B,MAAMA,EAAkBjc,GAAmB,kBAAmB,WACxDkc,EAAoBlc,GAAmB,oBAAqB,SAC5Dmc,EAAmBnc,GAAmB,mBAAoB,SAEhEnE,GAAc2W,UAAW7V,GAAYxX,YAAY3C,IAAOy5B,EAAgBlwB,EAAEvJ,IAAK05B,GAAoB3lC,IAAK4lC,IAEzG,CAoBA,OAlBK15C,EAAO25C,eAEXrP,GAAOtqC,GAAS4Y,SAIV5Y,EAAO45C,iBAAmB55C,EAAO0oC,iBAAuE,IAArD1oC,EAAO0oC,eAAe1Z,4BAE/Eoa,GAAeppC,GAAS4Y,SAIE,OAAtBlZ,KAAK43C,cAETle,GAAcvlB,OAAQnU,KAAK43C,aAAav1C,QAAS,CAAE4pB,qBAAqB,KAIlEyN,EAER,CAQA,iBAAAqf,EAAmB,OAAEz4C,EAAM,SAAEU,IAE5B,IAAIwrB,EAAYxsB,KAAKwsB,UAAY5S,GAAM5Z,KAAKwsB,WAAckZ,GAY1D,IAR2B,IAAtB1lC,KAAKm6C,cAAyBn5C,EAASy5B,aAAc,WAEzDjO,EAAY5S,GAAM4S,EAAUzJ,IAAI1C,IAAK1d,GAAW,QAAS,SAAY6pB,EAAU3M,IAM3Evf,EAAO2oC,cAAgB,CAI3Bzc,EAFsBlQ,GAAiB,OAAQ,kBAErB+D,IAAKmM,EAEhC,CAEA,GAAKlsB,EAAO25C,eAAiB35C,EAAOiqC,eAAiB,CAIpD/d,EAFmBlQ,GAAiB,OAAQ,eAErB+D,IAAKmM,EAE7B,CAKAjQ,GAAapI,OAAQqY,GAIrB,MAAM0U,EAAclhC,KAAKkhC,YAAcxpB,GAAO1X,KAAKkhC,aAAgB2E,GAKnE,GAJAtpB,GAAasD,EAAE1L,OAAQoI,GAAasD,EAAEQ,IAAK6gB,IAIf,OAAvBlhC,KAAK23C,eAA0B33C,KAAKo6C,UAAY,EAAI,CAExD,MAAMzC,EAAuC,OAAvB33C,KAAK23C,cAAyBjgC,GAAO1X,KAAK23C,eAAkBlS,GAElFlpB,GAAasD,EAAEe,cAAe+2B,GAAgBtB,SAE/C,EAIwB,IAAnBr2C,KAAKq6C,WAET99B,GAAasD,EAAEa,SAAUk2B,GAAuBld,KAAkB2c,WAIzC,IAArBr2C,KAAKs6C,aAAyBt6C,KAAKu6C,WAAa,QAA2C,IAAzBv6C,KAAKy5C,iBAE3El9B,GAAasD,EAAE1L,OAAQ,EAIzB,CASA,aAAA6kC,GAIA,CAOA,kBAAAwB,GAEC,OAAyB,IAAhBx6C,KAAKu3C,OAAoB/9B,GAAM,GAAM+C,GAAawQ,GAE5D,CAOA,WAAAiO,GAEC,OAAOh7B,KAAK03C,WAAal+B,GAAMxZ,KAAK03C,YAAerR,EAEpD,CAQA,gBAAAoU,GAEC,IAAIt0C,EAAO,KAYX,OAVKnG,KAAKy3C,QAETtxC,EAAOnG,KAAKy3C,QAEDz3C,KAAK06C,SAEhBv0C,EAAOnG,KAAK06C,OAAOC,cAAgB9c,GAAmB,SAAU,eAAkBA,GAAmB,SAAU,YAIzG13B,CAER,CAQA,aAAAy0C,CAAe76C,GAEd,IAAIoG,EAAO,KAQX,OANKpG,EAAQkB,SAAS45C,WAErB10C,EAAO,IAAIyrC,GAAgBlK,KAIrBvhC,CAER,CAQA,WAAA20C,CAAa/6C,GAEZ,MAAMg7C,EAAqB,GAIrBtD,EAAUz3C,KAAKy6C,iBAAkB16C,GAElC03C,GAAWA,EAAQhH,gBAEvBsK,EAAmBj1C,KAAM2xC,GAI1B,MAAMuD,EAAeh7C,KAAK46C,cAAe76C,GAQzC,GANKi7C,GAAgBA,EAAavK,gBAEjCsK,EAAmBj1C,KAAMk1C,GAIL,OAAhBh7C,KAAK2wC,QAAmB5wC,EAAQkB,SAASg6C,MAAQ,CAErD,MAAMtK,EAAyB,OAAhB3wC,KAAK2wC,OAAkB3wC,KAAK2wC,OAAShJ,GAEpDoT,EAAmBj1C,KAAM,IAAI4qC,GAAQC,GAEtC,CAEA,IAAIuK,EAAUl7C,KAAKw3C,YAAcz3C,EAAQy3C,WAQzC,OANKuD,EAAmB/2C,OAAS,IAEhCk3C,EAAUn7C,EAAQ+C,SAASq4C,SAASC,WAAY,IAAKF,EAAQG,eAAgBN,KAIvEG,CAER,CAUA,kBAAAI,GAIA,CAQA,aAAApC,CAAen5C,GAEd,MAAM,SAAEkB,GAAalB,GACf,aAAEgxC,EAAY,kBAAEC,EAAiB,aAAE5O,GAAiBpiC,KAMpDw3C,GAFyB,IAAhBx3C,KAAKu3C,QAAuC,OAApBv3C,KAAKw3C,WAEhBx3C,KAAK86C,YAAa/6C,GAAY,KAE1D,IAAIk5C,EAAoBj5C,KAAKw6C,mBAAoBz6C,GAEjD,GAAKy3C,GAAcA,EAAWnsC,WAAWkwC,UAAY,CAEpD,MAAMzK,EAAgB9wC,KAAKs7C,mBAAoBv7C,GAE/Ck5C,EAAoBtH,GAAiB6F,EAAY1G,EAAeC,EAAcC,EAE/E,MAA6B,OAAjBD,IAEXkI,EAAoBz/B,GAA4B,OAAtBw3B,EAA6BtoB,GAAKuwB,EAAmBlI,EAAcC,GAAsBD,IAcpH,OARO3O,IAAwC,IAAxBA,EAAav/B,QAAuB5B,EAASub,WAA0C,IAA9Bvb,EAASub,SAASpV,WAEjGoV,GAASrI,OAAQqF,GAAM4oB,GAA8BwD,KAErDqT,EAAoBA,EAAkB7kC,IAAKoI,KAIrCy8B,CAER,CASA,WAAA3iC,CAAavW,EAAS+L,GAIrB,IAAkB,IAAb9L,KAAKs3C,IAAe,CAExB,MAAMkE,EAAUz7C,EAAQy7C,QAEnBA,IAEJjvC,GAAO4H,OAAQrI,GAEfA,EAAa8N,GAAM4hC,GAIrB,CAEA,OAAO1vC,CAER,CASA,gBAAA2vC,CAAkBx6C,GAKjB,IAAM,MAAM2B,KAAY3B,EAAW,CAElC,MAAMiC,EAAQjC,EAAU2B,QAEE7B,IAArBf,KAAM4C,KAEV5C,KAAM4C,GAAaM,EAEdA,GAASA,EAAMrB,QAAQ7B,KAAM4C,GAAaM,EAAMrB,SAIvD,CAEA,MAAM65C,EAAc73C,OAAO83C,0BAA2B16C,EAASnB,YAAY87C,WAE3E,IAAM,MAAM9sC,KAAO4sC,OAE0D36C,IAAvE8C,OAAOg4C,yBAA0B77C,KAAKF,YAAY87C,UAAW9sC,SAClC/N,IAA3B26C,EAAa5sC,GAAMhO,KAEvB+C,OAAOsG,eAAgBnK,KAAKF,YAAY87C,UAAW9sC,EAAK4sC,EAAa5sC,GAMxE,CAQA,MAAA1I,CAAQiI,GAEP,MAAMI,OAAoB1N,IAATsN,GAAsC,iBAATA,EAEzCI,IAEJJ,EAAO,CACNK,SAAU,CAAC,EACXC,OAAQ,CAAC,EACT5L,MAAO,CAAC,IAKV,MAAMlC,EAAO,MAAS+6C,UAAUx1C,OAAOwP,KAAM5V,KAAMqO,GAC7CJ,EAAehI,EAAiBjG,MAEtCa,EAAKqN,WAAa,CAAC,EAEnB,IAAM,MAAM,SAAEtL,EAAQ,UAAEoD,KAAeiI,EAEtCpN,EAAKqN,WAAYtL,GAAaoD,EAAUI,OAAQiI,GAAOvE,KAMxD,SAAS8E,EAAkBC,GAE1B,MAAMhJ,EAAS,GAEf,IAAM,MAAMiJ,KAAOD,EAAQ,CAE1B,MAAMhO,EAAOgO,EAAOC,UACbjO,EAAKkO,SACZlJ,EAAOC,KAAMjF,EAEd,CAEA,OAAOgF,CAER,CAEA,GAAK4I,EAAS,CAEb,MAAMC,EAAWE,EAAkBP,EAAKK,UAClCC,EAASC,EAAkBP,EAAKM,QAChC5L,EAAQ6L,EAAkBP,EAAKtL,OAEhC2L,EAAS1K,OAAS,IAAInD,EAAK6N,SAAWA,GACtCC,EAAO3K,OAAS,IAAInD,EAAK8N,OAASA,GAClC5L,EAAMiB,OAAS,IAAInD,EAAKkC,MAAQA,EAEtC,CAEA,OAAOlC,CAER,CAQA,IAAA0C,CAAM8a,GA0BL,OAxBAre,KAAKw3C,WAAan5B,EAAOm5B,WACzBx3C,KAAKy3C,QAAUp5B,EAAOo5B,QAEtBz3C,KAAKwsB,UAAYnO,EAAOmO,UACxBxsB,KAAK03C,WAAar5B,EAAOq5B,WACzB13C,KAAKkhC,YAAc7iB,EAAO6iB,YAC1BlhC,KAAK+wC,aAAe1yB,EAAO0yB,aAC3B/wC,KAAKgxC,kBAAoB3yB,EAAO2yB,kBAChChxC,KAAK23C,cAAgBt5B,EAAOs5B,cAE5B33C,KAAK43C,aAAev5B,EAAOu5B,aAC3B53C,KAAK63C,aAAex5B,EAAOw5B,aAE3B73C,KAAKs0B,UAAYjW,EAAOiW,UACxBt0B,KAAK83C,mBAAqBz5B,EAAOy5B,mBACjC93C,KAAK+3C,mBAAqB15B,EAAO05B,mBACjC/3C,KAAKg4C,eAAiB35B,EAAO25B,eAE7Bh4C,KAAK8L,WAAauS,EAAOvS,WACzB9L,KAAKi4C,QAAU55B,EAAO45B,QAEtBj4C,KAAKk4C,aAAe75B,EAAO65B,aAC3Bl4C,KAAKm4C,WAAa95B,EAAO85B,WAElBzuC,MAAMnG,KAAM8a,EAEpB,EAuMD,MAAMy9B,GAAiC,IAAI,MAO3C,MAAMC,WAA8B3E,GAEnC,eAAW7vC,GAEV,MAAO,uBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAKg8C,yBAA0B,EAE/Bh8C,KAAKy7C,iBAAkBK,IAEvB97C,KAAKi8C,UAAWx9B,EAEjB,EAID,MAAMy9B,GAAiC,IAAI,MAO3C,MAAMC,WAA+B/E,GAEpC,eAAW7vC,GAEV,MAAO,wBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAKo8C,0BAA2B,EAEhCp8C,KAAKy7C,iBAAkBS,IAQvBl8C,KAAKq8C,WAAa,EAalBr8C,KAAKs8C,WAAa,KAalBt8C,KAAKu8C,cAAgB,KAarBv8C,KAAKw8C,aAAe,KAapBx8C,KAAKy8C,YAAc,KAEnBz8C,KAAKi8C,UAAWx9B,EAEjB,CAOA,aAAAu6B,GAEC,MAAMsD,EAAat8C,KAAKs8C,WAAa5kC,GAAO1X,KAAKs8C,YAAe9U,GAC1D+U,EAAgBv8C,KAAKu8C,cAAgB7kC,GAAO1X,KAAKu8C,eAAkBlV,GACnEmV,EAAex8C,KAAKw8C,aAAe9kC,GAAO1X,KAAKw8C,cAAiBlV,GAChEmV,EAAcz8C,KAAKy8C,YAAc/kC,GAAO1X,KAAKy8C,aAAgBlV,GAEnE9pB,GAAStJ,OAAQqoC,GACjB9+B,GAAQvJ,OAAQsoC,GAEhB,MAAMC,EAAgBxgC,GAASvZ,GAAW,gBAAiB0d,IAAKk8B,KACpCD,EAAaI,EAActoC,IAAKkoC,GAAeI,GAEvD90B,IAAKnK,GAASrJ,IAAKsJ,KAAYiD,YAAalD,IAAW44B,SAE5E,EAylBD,MAAMsG,GAAqBx2C,GAAUoO,GAAYpO,GAAOka,IAAK,IAAMjM,IAAK,IAWlEwoC,GAAiC,IAAI,MAO3C,MAAMC,WAA+BzF,GAEpC,eAAW7vC,GAEV,MAAO,wBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK88C,0BAA2B,EAEhC98C,KAAKy7C,iBAAkBmB,IAEvB58C,KAAKi8C,UAAWx9B,EAEjB,CAMA,iBAAAs6B,GAEC,MAAM7X,EAAclhC,KAAKkhC,YAAcxpB,GAAO1X,KAAKkhC,aAAgB2E,GAEnEtpB,GAAapI,OAAQyF,GAAM+iC,GAAkB5hB,IAAyBmG,GAEvE,EAiBD,MAAM6b,WAAuBrtC,EAE5B,eAAWnI,GAEV,MAAO,gBAER,CAOA,WAAAzH,CAAak9C,EAAUnjB,IAEtBnwB,MAAO,QAOP1J,KAAKg9C,QAAUA,CAEhB,CAEA,KAAA9wC,GAEC,MAAM+wC,EAAMj9C,KAAKg9C,QAEXE,EAAID,EAAIhgB,EAAElW,KAAMk2B,EAAIrzB,GAAIvJ,IAAK,GAAgB,EAAVpb,KAAK+R,KAAW5C,IAAK,IACxDiE,EAAI4kC,EAAInzB,EAAEnB,OAAS,EAAK,GAAM9B,OAAOxG,IAAK,EAAIpb,KAAK+R,IAAK5C,IAAK,IAEnE,OAAOgF,GAAM8jC,EAAG7kC,EAEjB,EAWD,MAAM8kC,GAA2BvkC,GAAWmkC,IAU5C,MAAMK,WAAyB,MAE9B,WAAAt9C,CAAakxB,EAAO,EAAGqsB,EAAU,CAAC,GAEjC3zC,MAAOsnB,EAAMqsB,GAEbr9C,KAAKs9C,oBAAqB,CAE3B,CASA,0BAAAC,CAA4Bz6C,EAAU06C,GAErC,MAAMC,EAAmBD,EAAUnK,UAC7BG,EAAyBgK,EAAUlK,gBAEzCkK,EAAUlK,iBAAkB,EAE5BtzC,KAAK8zB,QAAQvsB,KAAOi2C,EAAUj2C,KAC9BvH,KAAK8zB,QAAQpH,WAAa8wB,EAAU9wB,WAEpC1sB,KAAK8zB,QAAQwf,gBAAkBkK,EAAUlK,gBACzCtzC,KAAK8zB,QAAQuf,UAAYmK,EAAUnK,UACnCrzC,KAAK8zB,QAAQ4pB,UAAYF,EAAUE,UAEnC,MAAM18C,EAAW,IAAI,MAAa,EAAG,EAAG,GAElCkzB,EAASipB,GAAYtjB,IAErB54B,EAAW,IAAIm2C,GACrBn2C,EAASurB,UAAYsH,GAAS0pB,EAAWtpB,EAAQ,GACjDjzB,EAASk5B,KAAO,MAChBl5B,EAASs5C,SAAW,MAEpB,MAAM5L,EAAO,IAAI,MAAM3tC,EAAUC,GAE3B08C,EAAQ,IAAI,MAClBA,EAAMvpC,IAAKu6B,GAGN6O,EAAUnK,YAAc,QAA2BmK,EAAUnK,UAAY,OAE9E,MAAMzb,EAAS,IAAI,MAAY,EAAG,GAAI53B,MAEhC49C,EAAa96C,EAAS4pC,SAa5B,OAZA5pC,EAAS+6C,OAAQ,MAEjBjmB,EAAOrtB,OAAQzH,EAAU66C,GAEzB76C,EAAS+6C,OAAQD,GAEjBJ,EAAUnK,UAAYoK,EACtBD,EAAUhK,uBAAyBA,EAEnC7E,EAAK3tC,SAASiK,UACd0jC,EAAK1tC,SAASgK,UAEPjL,IAER,EAMD,MAAM89C,GAAW,IAAI59C,QAQrB,MAAM69C,WAAoBruC,EAEzB,eAAWnI,GAEV,MAAO,aAER,CAOA,WAAAzH,CAAa23C,GAEZ/tC,MAAO,QAOP1J,KAAKy3C,QAAUA,EASfz3C,KAAKg+C,aAAe,KAQpBh+C,KAAKi+C,iBAAmB/hB,KAExB,MAAMgiB,EAAiB,IAAI,MAC3BA,EAAe5oB,uBAAwB,EAUvCt1B,KAAKm+C,gBAAkBD,EASvBl+C,KAAK4J,iBAAmBlB,EAAeG,MAExC,CAEA,YAAA2D,CAAc+O,GAEb,MAAM,SAAEzY,EAAQ,SAAE7B,GAAasa,EAEzBk8B,EAAUz3C,KAAKy3C,QAErB,GAAKA,EAAQrjB,eAAiBqjB,EAAQ7Z,wBAA0B,CAE/D,MAAM9J,EAAY2jB,EAAsB,cAAIA,EAAQv0C,MAAQjC,EAAUw2C,EAAQ70C,UAE9E,GAAKkxB,GAAWA,EAAQ3wB,UAAY,CAEnC,MAAMyrB,EAAUkF,EAAQlF,QAExB,GAAKA,IAAY,OAAoCA,IAAY,MAAmC,CAInG,GAAKkvB,GAASn9C,IAAKmzB,GAAY,CAE9B,MAAMsqB,EAAUN,GAASh9C,IAAKgzB,GAE9BuqB,GAAmBD,EAAStqB,EAAQlF,SACpC5uB,KAAKg+C,aAAeI,CAErB,KAAO,CAIN,MAAMrqB,EAAQD,EAAQC,MAEtB,GA0DN,SAAsCA,GAErC,OAAKA,SAEEA,EAAM3xB,OAAS,CAEvB,CAhEWk8C,CAA6BvqB,GAAU,CAE3C,MAAMoe,EAAe,IAAIiL,GAAkBrpB,EAAM3xB,QACjD+vC,EAAaoL,2BAA4Bz6C,EAAUgxB,GAEnDuqB,GAAmBlM,EAAare,QAASA,EAAQlF,SACjD5uB,KAAKg+C,aAAe7L,EAAare,QAEjCgqB,GAASt7C,IAAKsxB,EAASqe,EAAare,SAEpCA,EAAQoc,iBAAkB,UAAWqO,GAEtC,MAICv+C,KAAKg+C,aAAeh+C,KAAKm+C,eAI3B,CAIAn+C,KAAKi+C,iBAAiB/6C,MAAQlD,KAAKg+C,YAEpC,MAICh+C,KAAKi+C,iBAAmBj+C,KAAKy3C,OAI/B,CAED,CAED,CAEA,KAAAvrC,CAAOnM,GAIN,OAFAC,KAAKwM,aAAczM,GAEZC,KAAKi+C,gBAEb,EA4BD,SAASM,GAAkBC,GAE1B,MAAM1qB,EAAU0qB,EAAMpgC,OAEtB0V,EAAQmc,oBAAqB,UAAWsO,IAExC,MAAMpM,EAAe2L,GAASh9C,IAAKgzB,QAEb/yB,IAAjBoxC,IAEJ2L,GAAS9N,OAAQlc,GAEjBqe,EAAalnC,UAIf,CAUA,SAASozC,GAAmBvqB,EAASlF,GAE/BA,IAAY,MAEhBkF,EAAQlF,QAAU,MAEPA,IAAY,QAEvBkF,EAAQlF,QAAU,MAIpB,CASA,MAAM6vB,GAA4B7lC,GAAWmlC,IAU7C,MAAMW,WAA6BlO,GAElC,eAAWjpC,GAEV,MAAO,sBAER,CAOA,WAAAzH,CAAa23C,EAAU,MAEtB/tC,QAQA1J,KAAKy3C,QAAUA,CAEhB,CAEA,KAAAvrC,CAAOnM,GAINA,EAAQsC,QAAQs8C,YAAcF,GAAaz+C,KAAKy3C,QAEjD,EAWD,MAAMmH,WAA0BpO,GAE/B,eAAWjpC,GAEV,MAAO,mBAER,CAOA,WAAAzH,CAAak7C,EAAe,MAE3BtxC,QAOA1J,KAAKg7C,aAAeA,CAErB,CAEA,KAAA9uC,CAAOnM,GAIN,MAAM8+C,EAAgBnnC,GAAO,EAAIzS,KAAK+R,IAEtCjX,EAAQsC,QAAQy8C,mBAAqB9+C,KAAKg7C,aAAa36B,IAAKw+B,EAE7D,EAUD,MAAME,GAWL,KAAAt9C,GAAqC,CAWrC,MAAAu9C,GAAsC,CAWtC,MAAAC,GAAsC,CAWtC,cAAAC,GAA6C,CAU7C,QAAAC,GAAwC,CAYxC,gBAAAvO,GAAgD,EAWjD,MAAMwO,WAA2BL,GAKhC,WAAAj/C,GAEC4J,OAED,CASA,QAAAy1C,CAAU98C,EAASmU,EAAOzW,GAEzB,MAAM6wC,EAAmBvuC,EAAQuuC,iBAC3BK,EAAiB5uC,EAAQ4uC,eACzB6N,EAAqB/+C,EAAQsC,QAAQy8C,mBAE3C7N,EAAeG,gBAAgBj9B,OAAQyF,GAAM,IAIxCklC,EAEJ7N,EAAeG,gBAAgBf,UAAWyO,GAI1C7N,EAAeG,gBAAgBf,UAAWz2B,GAAM,EAAK,EAAK,EAAK,IAMhEq3B,EAAeG,gBAAgBzG,UAAWiG,GAE1CK,EAAeG,gBAAgBzG,UAAWpuB,GAAawQ,IAExD,CASA,MAAAiyB,CAAQ38C,EAASmU,EAAOzW,GAEvB,MAAMkB,EAAWlB,EAAQkB,SACnBo+C,EAAgBh9C,EAAQg9C,cACxB5H,EAAU13C,EAAQsC,QAAQs8C,YAEhC,GAAKlH,EAEJ,OAASx2C,EAASq+C,SAEjB,KAAK,MACJD,EAActyB,IAAI5Y,OAAQuU,GAAK22B,EAActyB,IAAKsyB,EAActyB,IAAI1M,IAAKo3B,EAAQ1qB,KAAOkZ,GAAyB5lB,IAAK6lB,MACtH,MAED,KAAK,MACJmZ,EAActyB,IAAI5Y,OAAQuU,GAAK22B,EAActyB,IAAK0qB,EAAQ1qB,IAAKkZ,GAAyB5lB,IAAK6lB,MAC7F,MAED,KAAK,MACJmZ,EAActyB,IAAIsjB,UAAWoH,EAAQ1qB,IAAI1M,IAAK4lB,GAAyB5lB,IAAK6lB,MAC5E,MAED,QACCz5B,QAAQC,KAAM,wDAAyDzL,EAASq+C,SAOpF,EAID,MAAMC,GAAiC,IAAI,MAO3C,MAAMC,WAA8BpI,GAEnC,eAAW7vC,GAEV,MAAO,uBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAKy/C,yBAA0B,EAU/Bz/C,KAAKu3C,QAAS,EAEdv3C,KAAKy7C,iBAAkB8D,IAEvBv/C,KAAKi8C,UAAWx9B,EAEjB,CAQA,WAAAuc,GAEC,OAAOL,EAER,CASA,gBAAA8f,CAAkB16C,GAEjB,MAAM03C,EAAU/tC,MAAM+wC,iBAAkB16C,GAExC,OAAO03C,EAAU,IAAIiH,GAAsBjH,GAAY,IAExD,CASA,aAAAmD,CAAe76C,GAEd,IAAIoG,EAAO,KAQX,OANKpG,EAAQkB,SAAS45C,WAErB10C,EAAO,IAAIy4C,GAAmBlX,KAIxBvhC,CAER,CAQA,kBAAAq0C,GAEC,OAAOj+B,GAAawQ,GAErB,CAOA,kBAAAuuB,GAEC,OAAO,IAAI8D,EAEZ,EAID,MAAMM,GAA0BhnC,IAAI,EAAIinC,KAAIC,MAAKC,YAOhD,MAAMC,EAAUD,EAAMx/B,KAAO,SAAUD,IAAK,SAAUC,IAAKw/B,GAAQ35B,OAEnE,OAAOy5B,EAAGt/B,IAAKy/B,EAAQ54B,YAAa9S,IAAKwrC,EAAIv/B,IAAKy/B,GAAW,IAIxDC,GAA6BrnC,IAAM7E,GAEjCA,EAAO0I,aAAa8D,IAAK,EAAIpb,KAAK+R,MAMpCgpC,GAA6BtnC,IAAI,EAAIunC,WAEnCziC,GAAU6C,IAAK3I,GAAO,KAAQtD,IAAK,GAAMiM,IAAK3I,GAAO,EAAIzS,KAAK+R,KAAOqJ,IAAK4/B,EAAM93B,IAAK3K,OAIvF0iC,GAAgCxnC,IAAI,EAAIynC,qBAE7C,MAAMC,EAAUD,EAAe/rC,IAAK4lB,IAAwBhX,YAEtDi9B,EAAQllB,GAAsB9S,IAAKm4B,GAAUz3B,QAC7Ck3B,EAAQ7lB,GAAsB/R,IAAKm4B,GAAUz3B,QAE7C03B,EAAIX,GAAW,CAAEC,GAAIriC,GAAesiC,IAAK,EAAKC,UAC9CS,EAhB6B5oC,GAAO,KAiBpC6oC,EAAIP,GAAc,CAAEC,UAE1B,OAAOI,EAAEhgC,IAAKigC,GAAIjgC,IAAKkgC,EAAG,IAS3B,MAAMC,WAA2BpB,GAOhC,WAAAt/C,CAAa2gD,GAAW,GAEvB/2C,QAUA1J,KAAKygD,SAAWA,CAEjB,CAUA,MAAAxB,EAAQ,eAAEkB,EAAc,WAAEO,EAAU,eAAEzP,IAErC,MACMM,EADQxW,GAAsB9S,IAAKk4B,GAAiBx3B,QACjCtI,IAAKqgC,GAE9BzP,EAAeC,cAAcb,UAAWkB,EAAWlxB,IAAK0/B,GAAc,CAAExjC,aAAcA,GAAawQ,SAE5E,IAAlB/sB,KAAKygD,UAETxP,EAAeE,eAAed,UAAWkB,EAAWlxB,IAAK6/B,GAAiB,CAAEC,oBAAqB9/B,IAAK4lB,IAIxG,CASA,QAAAkZ,EAAU,iBAAEvO,EAAgB,WAAEW,EAAU,eAAEN,IAEzCA,EAAeG,gBAAgBf,UAAWkB,EAAWlxB,IAAK0/B,GAAc,CAAExjC,oBAE1E00B,EAAeG,gBAAgBzG,UAAWiG,EAE3C,EAID,MAAM+P,GAAiC,IAAI,MAO3C,MAAMC,WAAgCxJ,GAErC,eAAW7vC,GAEV,MAAO,yBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK6gD,2BAA4B,EAQjC7gD,KAAKu3C,QAAS,EAEdv3C,KAAKy7C,iBAAkBkF,IAEvB3gD,KAAKi8C,UAAWx9B,EAEjB,CASA,gBAAAg8B,CAAkB16C,GAEjB,MAAM03C,EAAU/tC,MAAM+wC,iBAAkB16C,GAExC,OAAO03C,EAAU,IAAIiH,GAAsBjH,GAAY,IAExD,CAOA,kBAAA6D,GAEC,OAAO,IAAIkF,IAAoB,EAEhC,EAID,MAAMM,GAAiC,IAAI,MAO3C,MAAMC,WAA8B3J,GAEnC,eAAW7vC,GAEV,MAAO,uBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAKghD,yBAA0B,EAQ/BhhD,KAAKu3C,QAAS,EAadv3C,KAAKihD,cAAgB,KAarBjhD,KAAKkhD,aAAe,KAEpBlhD,KAAKy7C,iBAAkBqF,IAEvB9gD,KAAKi8C,UAAWx9B,EAEjB,CASA,gBAAAg8B,CAAkB16C,GAEjB,MAAM03C,EAAU/tC,MAAM+wC,iBAAkB16C,GAExC,OAAO03C,EAAU,IAAIiH,GAAsBjH,GAAY,IAExD,CAOA,kBAAA6D,GAEC,OAAO,IAAIkF,EAEZ,CAOA,aAAAxH,GAIC,MAAMiI,GAAkBjhD,KAAKihD,cAAgBvpC,GAAO1X,KAAKihD,eAAkBtb,IAAoBt0B,IAAK,MAEpGmM,GAAUrJ,OAAQ8sC,GAIlB,MAAMC,EAAelhD,KAAKkhD,cAAgBpb,GAE1CxoB,GAAcnJ,OAAQ+sC,EAEvB,CAEA,IAAA39C,CAAM8a,GAKL,OAHAre,KAAKihD,cAAgB5iC,EAAO4iC,cAC5BjhD,KAAKkhD,aAAe7iC,EAAO6iC,aAEpBx3C,MAAMnG,KAAM8a,EAEpB,EAID,MAAM8iC,GAAqCzoC,IAAM3Y,IAEhD,IAAmD,IAA9CA,EAAQiB,SAASy5B,aAAc,UAEnC,OAAO/iB,GAAO,GAIf,MAAM0pC,EAAMzmB,GAAWxT,OAAO9D,MAAMhS,IAAKspB,GAAWvT,OAAO/D,OAG3D,OAF0B+9B,EAAIx3B,EAAEvY,IAAK+vC,EAAIt3B,GAAIzY,IAAK+vC,EAAInkB,EAE9B,IAInBokB,GAA6B3oC,IAAM7E,IAExC,MAAM,UAAE4I,GAAc5I,EAEhBytC,EAAoBH,KAE1B,IAAII,EAAkB9kC,EAAUpL,IAAK,OAIrC,OAHAkwC,EAAkBA,EAAgBntC,IAAKktC,GACvCC,EAAkBA,EAAgBC,IAAK,GAEhCD,CAAe,IAMjBE,GAAsC/oC,IAAI,EAAIs+B,QAAO0K,QAAOC,YAEjE,MAAMC,EAAK5K,EAAM5uB,OAEXy5B,EAAKH,EAAMrhC,IAAKuhC,EAAGxtC,IAAKwtC,EAAG16B,WAAW7G,IAAKshC,EAAMv5B,SAAW/B,QAC5Dy7B,EAAKH,EAAMthC,IAAKuhC,EAAGxtC,IAAKwtC,EAAG16B,WAAW7G,IAAKqhC,EAAMt5B,SAAW/B,QAElE,OAAO/F,GAAK,GAAKuhC,EAAGztC,IAAK0tC,GAAKzwC,IAAKuU,IAAW,IAE3CjP,UAAW,CACdjU,KAAM,wBACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,SACvB,CAAE7E,KAAM,QAAS6E,KAAM,SACvB,CAAE7E,KAAM,QAAS6E,KAAM,YAMnBw6C,GAAkDrpC,IAAI,EAAIwE,SAAQ8kC,SAAQC,QAAOC,QAAOC,QAAOC,QAAOT,QAAOD,YAElH,MAAMG,EAAKH,EAAMrhC,IAAK7G,GAAM0D,EAAOmD,IAAK4hC,GAASD,EAAO3hC,IAAK6hC,GAASP,GAAQ39C,UACxE89C,EAAKH,EAAMthC,IAAK7G,GAAM0D,EAAOmD,IAAK8hC,GAASH,EAAO3hC,IAAK+hC,GAASV,GAAQ19C,UAG9E,OAFUsc,GAAK,GAAKuhC,EAAGztC,IAAK0tC,IAEnBh5B,UAAU,IAEhBnS,UAAW,CACdjU,KAAM,oCACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,SAAU6E,KAAM,QAAS86C,UAAW,MAC5C,CAAE3/C,KAAM,SAAU6E,KAAM,QAAS86C,UAAW,MAC5C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,SAOvCC,GAAsB5pC,IAAI,EAAIs+B,QAAOiJ,YAE1C,MAAM2B,EAAK5K,EAAM5uB,OAEXm6B,EAAQtC,EAAM73B,OAAO/H,IAAKuhC,EAAG16B,YAAaA,WAEhD,OAAO06B,EAAGthC,IAAKiiC,EAAMn6B,QAAS/H,IAAK,EAAIpb,KAAK+R,GAAI,IAE7CL,UAAW,CACdjU,KAAM,QACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,SACvB,CAAE7E,KAAM,QAAS6E,KAAM,YAInBs3C,GAA8BnnC,GAAO,EAAIzS,KAAK+R,IAI9CwrC,GAAkC9pC,IAAI,EAAIwE,SAAQ8kC,SAAQ/B,QAAOwC,QAAOC,YAE7E,MAAMd,EAAK1kC,EAAOmD,IAAK2hC,GACjB3pC,EAAImB,GAAMwoC,EAAO3hC,IAAKoiC,GAASvlC,EAAOmD,IAAKqiC,GAASd,EAAGvhC,IAAK4/B,IAC5D0C,EAAKtqC,EAAE4P,IAAK5P,GACZuqC,EAAKhB,EAAGthC,IAAKqiC,GAEnB,OAAO9D,GAAcx+B,IAAKuhC,EAAGvhC,IAAKuiC,EAAGx6B,QAAU,IAE5CzR,UAAW,CACdjU,KAAM,oBACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,SAAU6E,KAAM,QAAS86C,UAAW,MAC5C,CAAE3/C,KAAM,SAAU6E,KAAM,QAAS86C,UAAW,MAC5C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,MAC3C,CAAE3/C,KAAM,QAAS6E,KAAM,QAAS86C,UAAW,SAKvCQ,GAAyBnqC,IAAM7E,IAEpC,MAAM,eAAEssC,EAAc,GAAER,EAAE,IAAEC,EAAG,UAAEnjC,EAAS,EAAEqmC,EAAC,gBAAEC,EAAe,eAAEC,GAAmBnvC,EAE7E8mB,EAAa9mB,EAAO8mB,YAAcI,GAElCic,EAAQv6B,EAAU2L,OAElBg4B,EAAUD,EAAe/rC,IAAK4lB,IAAwBhX,YAEtD0+B,EAAQ/mB,EAAW1S,IAAKk4B,GAAiBx3B,QACzCg5B,EAAQhnB,EAAW1S,IAAK+R,IAAwBrR,QAChDs3B,EAAQtlB,EAAW1S,IAAKm4B,GAAUz3B,QAClCk3B,EAAQ7lB,GAAsB/R,IAAKm4B,GAAUz3B,QAEnD,IACIs6B,EAAG1C,EADHF,EAAIX,GAAW,CAAEC,KAAIC,MAAKC,UAS9B,GANKznC,GAAS2qC,KAEb1C,EAAItjC,GAAY2L,IAAK23B,EAAGyC,IAIpB1qC,GAAS4qC,GAAmB,CAEhC,MAAMb,EAAQ/kC,GAAY6K,IAAKk4B,GACzB8B,EAAQ7kC,GAAY6K,IAAK+R,IACzByoB,EAAQrlC,GAAY6K,IAAKm4B,GACzBgC,EAAQ/kC,GAAY4K,IAAKk4B,GACzB+B,EAAQ7kC,GAAY4K,IAAK+R,IACzB0oB,EAAQrlC,GAAY4K,IAAKm4B,GAE/B6C,EAAIlB,GAAmC,CAAE7kC,UAAQ8kC,OAAQhL,EAAOiL,QAAOC,QAAOC,QAAOC,QAAOT,QAAOD,UACnGnB,EAAIiC,GAAmB,CAAEtlC,UAAQ8kC,OAAQhL,EAAOiJ,QAAOwC,QAAOC,SAE/D,MAECO,EAAIxB,GAAuB,CAAEzK,QAAO0K,QAAOC,UAC3CpB,EAAI+B,GAAO,CAAEtL,QAAOiJ,UAIrB,OAAOI,EAAEhgC,IAAK4iC,GAAI5iC,IAAKkgC,EAAG,IAQrB2C,GAA0BxqC,IAAI,EAAI+D,YAAWklC,YAElD,MAAMwB,EAAKvpC,IAAQ,GAAK,OAAU,KAAO,MAEnCwpC,EAAKxpC,GAAM,EAAG,MAAQ,MAAQ,KAE9BkjB,EAAIrgB,EAAU4D,IAAK8iC,GAAK/uC,IAAKgvC,GAE7BC,EAAOvmB,EAAElT,EAAEvJ,IAAKyc,EAAElT,GAAI43B,IAAKG,EAAMthC,KAAO,MAAO6F,QAAS7F,IAAKyc,EAAElT,GAAIxV,IAAK0oB,EAAEhT,GAIhF,OAFY1Q,IAAQ,KAAM,MAAOiH,IAAKgjC,GAAOjvC,IAAK0oB,EAAEoW,GAE1C,IAEPv8B,UAAW,CACdjU,KAAM,YACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,YAAa6E,KAAM,SAC3B,CAAE7E,KAAM,QAAS6E,KAAM,WAInB+7C,GAAgC5qC,IAAM7E,IAE3C,MAAM,MAAE8tC,EAAK,cAAErkC,EAAa,YAAEC,EAAW,UAAEd,GAAc5I,EAEnD0vC,EAAML,GAAW,CAAEvB,QAAOllC,cAChC,OAAOa,EAAc+C,IAAKkjC,EAAI35B,GAAIxV,IAAKmJ,EAAY8C,IAAKkjC,EAAIz5B,GAAK,IAI5D05B,GAA8B9qC,IAAI,EAAIoqC,IAAGlD,MAAKC,YAEnD,MAAMj2B,EAAIi2B,EAAM34B,WAAW4B,WACrB26B,EAAK75B,EAAEvJ,IAAKuJ,GACZ85B,EAAK95B,EAAEvJ,IAAKojC,EAAIA,GAAK96B,MAAO,EAAG,OAErC,OAAOm6B,EAAE1iC,IAAK5G,GAAMomC,GAAMv/B,IAAKqjC,IAAOpjC,IAAKojC,EAAGx8B,WAAY,IAEvDvQ,UAAW,CACdjU,KAAM,gBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,MAAO6E,KAAM,SACrB,CAAE7E,KAAM,QAAS6E,KAAM,YAKnBo8C,GAA0BjrC,IAAI,EAAI+D,YAAWwjC,YAElD,MAAMjJ,EAAQv6B,EAAU2L,OAGlBw7B,EAAWlsC,GAAO,GAAM4I,IAAK02B,GAE7B6M,EADQ5D,EAAM73B,OACAlB,WAAW7V,IAAK,UAEpC,OAAOqG,GAAO,GAAMtD,IAAKwvC,GAAWvjC,IAAKwjC,EAAM17B,IAAKy7B,EAASvjC,IAAK,MAAUC,IAAK,EAAMrb,KAAK+R,GAAI,IAE7FL,UAAW,CACdjU,KAAM,YACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,YAAa6E,KAAM,SAC3B,CAAE7E,KAAM,QAAS6E,KAAM,YAKnBu8C,GAA0BprC,IAAI,EAAIipC,QAAOD,WAGvChqC,GAAO,GAAM4I,IAAK5I,GAAO,GAAM2I,IAAKqhC,EAAMttC,IAAKutC,GAAQvhC,IAAKshC,EAAMrhC,IAAKshC,QAE3EhrC,UAAW,CACdjU,KAAM,YACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,SACvB,CAAE7E,KAAM,QAAS6E,KAAM,YAInBw8C,GAA2BrrC,IAAI,EAAIynC,qBAExC,MAAMC,EAAUD,EAAe/rC,IAAK4lB,IAAwBhX,YAEtD0+B,EAAQ3mB,GAAsB9S,IAAKk4B,GAAiBx3B,QACpDg5B,EAAQ5mB,GAAsB9S,IAAK+R,IAAwBrR,QAC3Ds3B,EAAQllB,GAAsB9S,IAAKm4B,GAAUz3B,QAE7C43B,EAAIoD,GAAW,CAAElnC,UAAWK,GAAgBmjC,UAC5CgD,EAAIa,GAAW,CAAEnC,QAAOD,UAE9B,OAAO7kC,GAAMwD,IAAKkgC,GAAIlgC,IAAK4iC,EAAG,IAUzBe,GAAuBtrC,IAAI,EAAIsmB,IAAGikB,IAAGxmC,gBAE1C,MAIMklC,EAAQ3iB,EAAE/W,IAAKg7B,GAAIn6B,WAGnBK,EAAK/P,GAAMqD,EAAWklC,EAAMz6B,WAAWb,QAI7C,OAFA8C,EAAGhV,OAAQgV,EAAG9I,IARI,SAQajM,IAPd,WASV+U,CAAE,IAENxS,UAAW,CACdjU,KAAM,SACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,YAAa6E,KAAM,YAIvB08C,GAA4CvrC,IAAI,EAAIoqC,QAKzD,MAAM1V,EAAI0V,EAAE9+C,SAEZ,OAAO2jB,GAAOylB,EAAE/sB,IAAK+sB,GAAIh5B,IAAK0uC,EAAE7lB,GAAI3c,IAAK8sB,EAAEh5B,IAAK,IAAS,EAAG,IAEzDuC,UAAW,CACdjU,KAAM,8BACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,IAAK6E,KAAM,WAIf28C,GAAyCxrC,IAAI,EAAIyrC,KAAIxB,SAE1D,MAAM/4B,EAAIu6B,EAAGl8B,IAAK06B,GACZ74B,EAAIF,EAAEvG,MAAMmW,QAGZ3Z,EAAIiK,EAAEzJ,IAAK,UAAYjM,IAAK,UAAYiM,IAAKyJ,GAAI1V,IAAK,UAAYolB,QAClE1Z,EAAIgK,EAAE1V,IAAK,WAAYiM,IAAKyJ,GAAI1V,IAAK,UAAYolB,QACjDnhB,EAAIwH,EAAES,IAAKR,GAEXskC,EAAiBx6B,EAAEjJ,YAAa,GAAMoK,OAAQ1S,EAAGsP,GAAOiC,EAAEvJ,IAAKuJ,GAAI1C,WAAY,MAAOZ,cAAcjG,IAAK,IAAMD,IAAK/H,IAE1H,OAAO8rC,EAAGj8B,MAAOy6B,GAAKtiC,IAAK+jC,EAAgB,IAExCztC,UAAW,CACdjU,KAAM,2BACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,KAAM6E,KAAM,QACpB,CAAE7E,KAAM,KAAM6E,KAAM,WAIhB88C,GAA6B3rC,IAAI,EAAIsmB,IAAGikB,IAAGqB,IAAGC,OAAMC,KAAIC,KAAIC,KAAIC,SAIrE,MAAMR,EAAKM,EAAGrkC,IAAKokC,GAAKhrB,QAClBmpB,EAAKgC,EAAGvkC,IAAKokC,GAAKhrB,QAElBorB,EAAcT,EAAGj8B,MAAOy6B,GACxB51C,EAASyM,KAAOggB,QA8BtB,OA5BAvgB,GAAI2rC,EAAY38B,IAAKq8B,EAAElkC,IAAKokC,IAAO3jC,iBAAkB,IAAO,KAG3D,MAAMgkC,EAAK5B,EAAE7iC,IAAK4e,EAAE3e,IAAK4iC,EAAEh7B,IAAK+W,KAAQhc,YAClC8hC,EAAK9lB,EAAE9W,MAAO28B,GAAK59B,SAGnB89B,EAAMR,EAAKlkC,IAAKpG,GAAM4qC,EAAIC,EAAI9lB,GAAIvX,aAAc+R,QAIhDwrB,EAAUD,EAAI1kC,IAAKmkC,EAAGpkC,IAAKkkC,IAAMthC,YAAYwW,QAC7CyrB,EAAUF,EAAI1kC,IAAKokC,EAAGrkC,IAAKkkC,IAAMthC,YAAYwW,QAC7C0rB,EAAUH,EAAI1kC,IAAKqkC,EAAGtkC,IAAKkkC,IAAMthC,YAAYwW,QAC7C2rB,EAAUJ,EAAI1kC,IAAKskC,EAAGvkC,IAAKkkC,IAAMthC,YAAYwW,QAG7C4rB,EAAmB5rC,GAAM,GAAIggB,QACnC4rB,EAAiB/U,UAAW6T,GAA0B,CAAEC,GAAIa,EAASrC,GAAIsC,KACzEG,EAAiB/U,UAAW6T,GAA0B,CAAEC,GAAIc,EAAStC,GAAIuC,KACzEE,EAAiB/U,UAAW6T,GAA0B,CAAEC,GAAIe,EAASvC,GAAIwC,KACzEC,EAAiB/U,UAAW6T,GAA0B,CAAEC,GAAIgB,EAASxC,GAAIqC,KAGzEj4C,EAAOoH,OAAQqF,GAAMyqC,GAA6B,CAAEnB,EAAGsC,KAAwB,IAIzEr4C,CAAM,IAEV4J,UAAW,CACdjU,KAAM,eACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,OAAQ6E,KAAM,QACtB,CAAE7E,KAAM,KAAM6E,KAAM,QACpB,CAAE7E,KAAM,KAAM6E,KAAM,QACpB,CAAE7E,KAAM,KAAM6E,KAAM,QACpB,CAAE7E,KAAM,KAAM6E,KAAM,WAShB89C,GAAK,EAAM,EAEXC,GAAOzlC,GAAOQ,GAAKglC,GAAIhlC,GAAKR,EAAGQ,GAAKR,EAAGA,EAAEoH,SAAS7S,IAAK,IAAQgM,IAAK,IAAQhM,IAAK,IAEjFmxC,GAAO1lC,GAAOQ,GAAKglC,GAAIhlC,GAAKR,EAAGQ,GAAKR,EAAGQ,GAAK,EAAKR,GAAIO,IAAK,KAAUhM,IAAK,IAEzEwuC,GAAO/iC,GAAOQ,GAAKglC,GAAIhlC,GAAKR,EAAGQ,GAAKR,EAAGQ,IAAO,EAAKR,GAAIzL,IAAK,IAAQA,IAAK,IAAQA,IAAK,IAEtFoxC,GAAO3lC,GAAOQ,GAAKglC,GAAIl9B,GAAKtI,EAAG,IAE/B4lC,GAAO5lC,GAAOylC,GAAIzlC,GAAIzL,IAAKmxC,GAAI1lC,IAE/B6lC,GAAO7lC,GAAO+iC,GAAI/iC,GAAIzL,IAAKoxC,GAAI3lC,IAG/B8lC,GAAO9lC,GAAOzL,IAAO,EAAKmxC,GAAI1lC,GAAIS,IAAKglC,GAAIzlC,GAAIzL,IAAKmxC,GAAI1lC,MAExDhb,GAAOgb,GAAOzL,GAAK,EAAKoxC,GAAI3lC,GAAIS,IAAKsiC,GAAI/iC,GAAIzL,IAAKoxC,GAAI3lC,MAEtD+lC,GAAU,CAAEtyB,EAAauyB,EAAWC,KAEzC,MAAM38B,EAAKmK,EAAYY,OACjB6xB,EAAW1lC,GAAK8I,EAAI08B,EAAU3S,IAAK9+B,IAAK,IAExC4xC,EAAMz/B,GAAOw/B,GACbE,EAAMx/B,GAAOs/B,GAEbG,EAAMT,GAAIQ,EAAIr8B,GACdu8B,EAAMT,GAAIO,EAAIr8B,GACdw8B,EAAMT,GAAIM,EAAIr8B,GACdy8B,EAAMxhD,GAAIohD,EAAIr8B,GACd08B,EAAMX,GAAIM,EAAIn8B,GACdy8B,EAAM1hD,GAAIohD,EAAIn8B,GAEd06B,EAAKprC,GAAM4sC,EAAIp8B,EAAExV,IAAKgyC,GAAOJ,EAAIl8B,EAAE1V,IAAKkyC,IAAQlmC,IAAK,IAAMC,IAAKwlC,EAAUx8B,IAC1Eo7B,EAAKrrC,GAAM4sC,EAAIp8B,EAAExV,IAAKiyC,GAAOL,EAAIl8B,EAAE1V,IAAKkyC,IAAQlmC,IAAK,IAAMC,IAAKwlC,EAAUx8B,IAC1Eq7B,EAAKtrC,GAAM4sC,EAAIp8B,EAAExV,IAAKgyC,GAAOJ,EAAIl8B,EAAE1V,IAAKmyC,IAAQnmC,IAAK,IAAMC,IAAKwlC,EAAUx8B,IAC1Es7B,EAAKvrC,GAAM4sC,EAAIp8B,EAAExV,IAAKiyC,GAAOL,EAAIl8B,EAAE1V,IAAKmyC,IAAQnmC,IAAK,IAAMC,IAAKwlC,EAAUx8B,IAE1ExJ,EAAI4lC,GAAIQ,EAAIn8B,GAAIzJ,IAAKjM,GAAK8xC,EAAI7lC,IAAKiT,EAAYwD,OAAQ0tB,GAAK9wB,MAAOoyB,IAASK,EAAI9lC,IAAKiT,EAAYwD,OAAQ2tB,GAAK/wB,MAAOoyB,MACrHhmC,EAAI4lC,GAAIO,EAAIn8B,GAAIzJ,IAAKjM,GAAK8xC,EAAI7lC,IAAKiT,EAAYwD,OAAQ4tB,GAAKhxB,MAAOoyB,IAASK,EAAI9lC,IAAKiT,EAAYwD,OAAQ6tB,GAAKjxB,MAAOoyB,MAE3H,OAAOjmC,EAAEzL,IAAK0L,EAAG,EAYZ0mC,GAA+B9tC,IAAI,EAAI4a,EAAamzB,EAAU/uC,GAAO,OAE1E,MAAMgvC,EAAWttC,GAAMka,EAAYtC,KAAMxZ,GAAKivC,KACxCE,EAAWvtC,GAAMka,EAAYtC,KAAMxZ,GAAKivC,EAAQryC,IAAK,MACrDwyC,EAActmC,GAAK,EAAKomC,GACxBG,EAAcvmC,GAAK,EAAKqmC,GACxBG,EAAUlB,GAAStyB,EAAa1Z,GAAMgtC,EAAaF,GAAYngC,GAAOkgC,IACtEM,EAAUnB,GAAStyB,EAAa1Z,GAAMitC,EAAaF,GAAYngC,GAAMigC,IAE3E,OAAOhgC,GAAOggC,GAAU/9B,IAAKo+B,EAASC,EAAS,IAQ1CC,GAAyCtuC,IAAI,EAAIuuC,EAAG5uC,EAAGuF,EAAWD,EAAKupC,MAG5E,MAAMC,EAAmB3tC,GAAMuP,GAAS1Q,EAAE4O,SAAUjE,GAAWikC,GAAK3mC,GAAK,EAAK3C,KAGxEypC,EAAa5tC,GAClBxV,GAAQkjD,EAAa,GAAInkC,KACzB/e,GAAQkjD,EAAa,GAAInkC,KACzB/e,GAAQkjD,EAAa,GAAInkC,MAI1B,OAAOC,GAAWmkC,GAAmB9mC,IAAKzC,EAAUyC,IAAK+mC,GAAc,IAEpEzwC,UAAW,CACdjU,KAAM,2BACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,IAAK6E,KAAM,QACnB,CAAE7E,KAAM,YAAa6E,KAAM,SAC3B,CAAE7E,KAAM,MAAO6E,KAAM,SACrB,CAAE7E,KAAM,cAAe6E,KAAM,WAIzB8/C,GAAoC3uC,IAAI,EAAI+D,EAAWkB,KAIrDlB,EAAU4D,IAAKsI,GAAOhL,EAAI0C,IAAK,GAAMD,IAAK,GAAO,EAAK,MAE1DzJ,UAAW,CACdjU,KAAM,sBACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,YAAa6E,KAAM,SAC3B,CAAE7E,KAAM,MAAO6E,KAAM,YAIjB+/C,GAAwC3T,KACxC4T,GAAyC5T,KAEzC6T,GAAsC9uC,IAAI,EAAI+uC,EAAWhrC,EAAWkB,IAAS1c,eAElF,MAEMymD,GAFWzmD,EAASk5B,OAAS,MAAWmtB,GAA0BC,IAEpCzwB,OAAQ2wB,GAGtC3B,EAAM1/B,GAAMusB,GAAW/oB,GAAIvJ,IAAKgnC,GAAqB5qC,EAAWkB,IAEtE,OAAO6oC,GAAgBkB,EAAoB5B,EAAK,IAI3C6B,GAAkCjvC,IAAI,EAAIkvC,EAAsB9pC,EAAkBD,MAEvF5E,GAAI4E,EAAoB4C,SAAU,IAAK,KAGtC,MAAMonC,EAAyB1hC,GAAKrI,GAAmBmJ,SAAS3G,IAAKzC,GAGrE,OAFsBoI,GAAK4hC,EAAuB5gC,SAAS5G,IAAKunC,GAE5C,IAKdpuC,GAAM,MAEV7C,UAAW,CACdjU,KAAM,oBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,uBAAwB6E,KAAM,SACtC,CAAE7E,KAAM,mBAAoB6E,KAAM,QAClC,CAAE7E,KAAM,sBAAuB6E,KAAM,YAIjCugD,GAAuCpvC,IAAI,EAAIuuC,EAAG5uC,EAAGoE,EAAWF,EAAce,EAAeC,EAAasuB,EAAUqb,EAAaa,EAAYC,EAAYrqC,EAAKC,EAAWE,EAAkBD,EAAqBE,MAErN,IAAIkqC,EAAkBC,EAEtB,GAAKnqC,EAAa,CAEjBkqC,EAAmBruC,KAAO4f,QAC1B0uB,EAAgB1uC,KAAOggB,QAEvB,MAAM2uB,EAAaxqC,EAAIyC,IAAK,GAAMC,IAAKtC,EAAWsC,IAAK,OACjD+nC,EAAO5uC,GAAMmE,EAAIyC,IAAK+nC,GAAcxqC,EAAKA,EAAIvJ,IAAK+zC,IAExDja,GAAM,CAAEzsC,MAAO,EAAG6rC,IAAK,IAAK,EAAIjpC,QAE/B,MAAMsZ,EAAMyqC,EAAKjuC,QAAS9V,GAEpBgkD,EAAkBrB,GAA0BC,EAAG5uC,EAAGuF,EAAWD,EAAKupC,GAClEoB,EAAmBzc,EAASz3B,IAAKi0C,GAGjCE,EAASP,EAAW3nC,IAAK0nC,EAAW1nC,IAAKzG,GAAM0uC,EAAkB,KACjEE,EAAmBpvC,GAAMmvC,EAAOl/B,GAAG/I,IAAKioC,EAAOrrB,IAAM1D,QAC3DgvB,EAAiBnY,UAAW,GAC5BmY,EAAiBC,UAAW,GAC5BD,EAAiBr0C,OAAQiF,GAAMovC,EAAiB5+B,EAAG4+B,EAAiB1+B,EAAE5C,aAGtE,MAAMwgC,EAAqBF,GAAuBgB,EAAkB/rC,EAAWkB,GAE/EsqC,EAAiB9tC,QAAS9V,GAAI8P,OAAQuzC,EAAmBvtC,QAAS9V,IAClE4jD,EAAiBpoC,EAAEwwB,UAAWqX,EAAmB7nC,GAEjDqoC,EAAc/tC,QAAS9V,GAAI8P,OAAQoI,EAAapC,QAAS9V,GAAIgc,IAAKsnC,GAAmB3jD,GAAQqkD,GAAmBvqC,EAAkBD,GAAsB1D,QAAS9V,IAAO,IAIzK4jD,EAAiBpoC,EAAE4oC,UAAW,EAE/B,KAAO,CAEN,MAAMJ,EAAkBrB,GAA0BC,EAAG5uC,EAAGuF,EAAWD,EAAKupC,GAClEoB,EAAmBzc,EAASz3B,IAAKi0C,GAGjCE,EAASP,EAAW3nC,IAAK0nC,EAAW1nC,IAAKzG,GAAM0uC,EAAkB,KACjEE,EAAmBpvC,GAAMmvC,EAAOl/B,GAAG/I,IAAKioC,EAAOrrB,IAAM1D,QAC3DgvB,EAAiBnY,UAAW,GAC5BmY,EAAiBC,UAAW,GAC5BD,EAAiBr0C,OAAQiF,GAAMovC,EAAiB5+B,EAAG4+B,EAAiB1+B,EAAE5C,aAGtE+gC,EAAmBT,GAAuBgB,EAAkB/rC,EAAWkB,GACvEuqC,EAAgB3rC,EAAa8D,IAAKsnC,GAAmB3jD,GAAQqkD,GAAmBvqC,EAAkBD,GAEnG,CAEA,MAAM6qC,EAAkBR,EAAcn7B,IAAI1M,IAAK4nC,EAAiBl7B,KAC1D40B,EAAQsF,EAAEh/B,IAAK5P,GAAIsQ,QAGnB03B,EAAI7mC,GAAM8pC,GAAiB,CAChC3B,QACArkC,gBACAC,cACAd,eAKKksC,EAAsBT,EAAcprB,EAAE1oB,IAAK8zC,EAAcnrB,EAAGmrB,EAAcpoC,GAAIQ,IAAK,GAEzF,OAAO1G,GAAMymC,EAAEn5B,WAAW7G,IAAKqoC,GAAmBT,EAAiBpoC,EAAEqH,WAAW7G,IAAKsoC,GAAsBzhC,WAAY,IASlH0hC,GAA8B3uC,GACnC,WAAa,QAAW,UACtB,UAAW,WAAa,UACxB,SAAW,QAAW,WAanB4uC,GAAgB,CAAEC,EAAgBC,IAEhCD,EAAe1oC,IAAK2oC,GAAczoC,IAAKwoC,EAAe10C,IAAK20C,IAAgB3gC,OAyB7E4gC,GAAgCtwC,IAAI,EAAIuwC,aAAYC,OAAMC,YAAWC,oBAAmBC,aAG7F,MAAMrsC,EAAiB0L,GAAKugC,EAAYC,EAAMlgC,GAAY,EAAK,IAAMogC,IAK/DE,EAHcL,EAAW3oC,IAAKtD,GAAiBoL,OAAO/H,IAAK8oC,EAAU/gC,OAAOlB,YAGlDA,WAEhCjO,GAAIqwC,EAAY5oC,SAAU,IAAK,IAEvBlH,GAAM,KAId,MAAM+vC,EAAYD,EAAYjjC,OAGxBmjC,EAAKX,GAAe7rC,EAAgBisC,GACpCQ,EAAM/J,GAAW,CAAEC,GAAI6J,EAAI5J,IAAK,EAAKC,MAAOsJ,IAE5CO,EAAOD,EAAIviC,WACXyiC,EAAQ3sC,EAAe0D,SAAUuoC,GAAal+B,OAAQ9lB,KAAK+R,GAAI,GAC/D4yC,EAAQlyC,GAAOzS,KAAK+R,IAAKoJ,IAAKupC,GAG9BE,EA9De,CAAEC,IAEvB,MAAMC,EAASD,EAASzjC,OACxB,OAAO7M,GAAM,GAAMpF,IAAK21C,GAASzpC,IAAK9G,GAAM,GAAM4G,IAAK2pC,GAAU,EA2DjDC,CAAeX,EAAO1gC,MAAO,EAAK,QAC5C0X,EAAKwoB,GAAegB,EAAS7sC,EAAeitC,UAC5CC,EAAMxK,GAAW,CAAEC,GAAItf,EAAIuf,IAAK,EAAKC,MAAO0J,IAC5CY,EAAQ3wC,GACbqwC,EAAQjgC,EAAElJ,SAAU1D,GAAiB+N,OAAQ9lB,KAAK+R,GAAI,GACtD6yC,EAAQ//B,EAAEpJ,SAAU1D,GAAiB+N,OAAQ9lB,KAAK+R,GAAI,GACtD6yC,EAAQ5sB,EAAEvc,SAAU1D,GAAiB+N,OAAQ9lB,KAAK+R,GAAI,IAIjDozC,EAAMptC,EAAeqD,IAAK+oC,EAAmBG,EAAW,GACxDc,EAAM7wC,GAAMowC,GAAQx1C,IAAK+1C,GAGzBG,EAAOb,EAAIppC,IAAK6pC,GAAMvhC,MAAO,KAAM,OACnC4hC,EAAOD,EAAKjkC,OACZmkC,EAAKd,EAAKthC,OAAO/H,IAAK6pC,GAAM5pC,IAAK9G,GAAM,GAAM4G,IAAKkqC,IAIlDG,EADKhB,EAAIr1C,IAAKo2C,GACPhxB,QAGPkxB,EAAKF,EAAGpqC,IAAKspC,GAAOlwB,QAW1B,OATA0U,GAAM,CAAEzsC,MAAO,EAAG6rC,IAAK,EAAGC,UAAW,KAAM7qC,KAAM,MAAO,EAAI44B,QAE3DovB,EAAG/f,UAAW4f,GACd,MAAMI,EAzEgB,EAAEP,EAAKt2C,KAE9B,MAAM82C,EAAQR,EAAI/pC,IAAK,EAAMpb,KAAK+R,GAAK,MACjChS,EAAMwU,GAAM,UAAY,UAAY,WACpCqxC,EAAMrxC,GAAM,OAAY,QAAY,SACpCsxC,EAAMtxC,GAAM,QAAY,QAAY,SAEpCoQ,EAAIlS,GAAO,SAAazS,KAAKohB,KAAM,EAAMphB,KAAK+R,GAAK,UAAeqJ,IAAKuqC,EAAMvqC,IAAK,SAAajM,IAAKN,EAAM8V,GAAIjD,OAAQtG,IAAKuqC,EAAMxiC,OAAO/H,KAAO,SAAa4F,OAElK,IAAIlD,EAAM/d,EAAIqb,IAAKyqC,EAAIzqC,IAAK,EAAMpb,KAAK+R,IAAKqP,QAAShG,IAAKwqC,EAAIxqC,IAAKuqC,GAAQx2C,IAAKN,GAAQ6S,OAAQtG,IAAKuqC,EAAMxiC,OAAOnB,SAAS5G,IAAKyqC,GAAM7kC,OAKtI,OAJAlD,EAAMvJ,GAAMuJ,EAAI6G,EAAExV,IAAKwV,GAAK7G,EAAI+G,EAAG/G,EAAIka,GAAI3c,IAAK,WAEpCsoC,GAAcvoC,IAAK0C,EAErB,EA2DEgoC,CAAiBrzC,GAAO4jB,GAAIjb,IAAK+pC,GAAO1yC,GAAO4jB,GAAIjb,IAAKgqC,IAAQhqC,IAAK,GAChFoqC,EAAEpa,UAAWqa,EAAGrqC,IAAKsqC,GAAM,IAKrBF,EAAEp5C,IAAKmI,GAAM,GAAO,IAExB7C,UAAW,CACdjU,KAAM,kBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,aAAc6E,KAAM,SAC5B,CAAE7E,KAAM,OAAQ6E,KAAM,SACtB,CAAE7E,KAAM,YAAa6E,KAAM,SAC3B,CAAE7E,KAAM,oBAAqB6E,KAAM,SACnC,CAAE7E,KAAM,SAAU6E,KAAM,WAWpByjD,GAA6BtyC,IAAI,EAAI2iB,SAAQ4vB,UAASxuC,gBAE3D,MAAMklC,EAAQtmB,EAAOpT,IAAKgjC,GAAUniC,WAE9BoiC,EAAKzuC,EAAU2L,OAEfvI,EAAIkL,GACTtO,EAAUiE,SAAU,KACpBhJ,IAAS,OAAQ2I,IAAK6qC,GAAK92C,IAAKsD,GAAO,OAAQ2I,IAAK5D,IAAc2D,IAAK,MACvE1I,IAAS,MAAO2I,IAAK6qC,GAAK92C,IAAKsD,GAAO,MAAO2I,IAAK5D,IAAc2D,IAAK,OAGhEN,EAAIiL,GACTtO,EAAUiE,SAAU,KACpBhJ,GAAO,IAAO2I,IAAK6qC,GAAK9qC,IAAK1I,GAAO,MAAO2I,IAAK5D,IAAcrI,IAAK,MACnEsD,GAAO,MAAO2I,IAAK6qC,GAAK9qC,IAAK1I,GAAO,MAAO2I,IAAK5D,IAAcrI,IAAK,MAKpE,OAFW2W,GAAQtO,EAAUiE,SAAU,KAAQ,EAAKhJ,GAAO,IAAM2I,IAAK5D,GAAY2D,IAAK,OAAUhM,IAAKyL,EAAEQ,IAAKshC,GAAQvtC,IAAK0L,GAAImG,OAEpH5F,IAAK,EAAMpb,KAAK+R,IAAK8R,UAAU,IAIpCqiC,GAAc3xC,GAAM,KACpB4xC,GAAe1zC,GAAO,GAQ5B,MAAM2zC,WAA8BtM,GAYnC,WAAAj/C,CAAa6c,GAAY,EAAOE,GAAQ,EAAOE,GAAc,EAAOI,GAAa,EAAOjb,GAAe,EAAO6b,GAAa,GAE1HrU,QAQA1J,KAAK2c,UAAYA,EAQjB3c,KAAK6c,MAAQA,EAQb7c,KAAK+c,YAAcA,EAQnB/c,KAAKmd,WAAaA,EAQlBnd,KAAKkC,aAAeA,EAQpBlC,KAAK+d,WAAaA,EAQlB/d,KAAKsrD,kBAAoB,KAQzBtrD,KAAKurD,wBAA0B,KAQ/BvrD,KAAKwrD,0BAA4B,KAQjCxrD,KAAKyrD,oBAAsB,KAQ3BzrD,KAAK0rD,sBAAwB,KAQ7B1rD,KAAK2rD,mBAAqB,KAQ1B3rD,KAAK4rD,cAAgB,IAEtB,CAQA,KAAAnqD,CAAOY,GAiBN,IAfwB,IAAnBrC,KAAK2c,YAET3c,KAAKsrD,kBAAoB9xC,KAAOggB,MAAO,qBACvCx5B,KAAKurD,wBAA0B/xC,KAAOggB,MAAO,2BAC7Cx5B,KAAKwrD,0BAA4BhyC,KAAOggB,MAAO,+BAI5B,IAAfx5B,KAAK6c,QAET7c,KAAKyrD,oBAAsBjyC,KAAOggB,MAAO,uBACzCx5B,KAAK0rD,sBAAwBlyC,KAAOggB,MAAO,2BAIlB,IAArBx5B,KAAK+c,YAAuB,CAEhC,MAAM8uC,EAAS9wB,GAAsB9S,IAAK+R,IAAwBrR,QAElE3oB,KAAK2rD,mBAAqB3C,GAAiB,CAC1CC,WAAYvxC,GAAO,GACnBwxC,KAAMlsC,GACNmsC,UAAW0C,EACXzC,kBAAmBnsC,GACnBosC,OAAQ/rC,KAGTtd,KAAK4rD,cAAgBpI,GAAe,CAAEV,EAAG9iD,KAAK2rD,mBAAoB/L,IAAK,EAAKC,MAAOgM,GAEpF,CAEA,IAA2B,IAAtB7rD,KAAKkC,aAAwB,CAEjC,MAAM2pC,EAAWjS,GACXvhB,EAAI+f,GAAehY,IAAKwZ,IAAgB5W,YACxCikC,EAAIhsB,GAEV54B,EAAQovC,SAAWqW,GAClBb,EACA5uC,EACAoE,GACAF,GACAe,GACAC,GACAsuB,EACAzS,GACAlB,GACAF,GACAra,GACAC,GACAE,GACAD,GACA7d,KAAK+d,WAAaA,GAAa,MAGhC1b,EAAQqvC,cAAgBxvC,GAExBqa,GAAasD,EAAE8qB,UAAWjiB,GAAK,EAAGrmB,EAAQovC,SAAS5xB,EAAG3d,IAEvD,CAED,CAMA,sBAAA4pD,CAAwBC,EAAeC,EAAczuC,GAEpD,MAAMokC,EAAQ5mB,GAAsB9S,IAAK+R,IAAwBrR,QAE3D46B,EAAML,GAAW,CAAEzmC,aAAWklC,UAI9BsK,GAFKjsD,KAAK4rD,cAAgB7uC,GAAY2L,IAAKpL,GAAetd,KAAK4rD,eAAkBtuC,IAErE+C,IAAKkjC,EAAI35B,GAAIxV,IAAKmJ,EAAY8C,IAAKkjC,EAAIz5B,IAGnDoiC,EADM3I,EAAI35B,EAAExV,IAAKmvC,EAAIz5B,GACX5C,WAEVilC,EAAO7uC,GAAclJ,IAAKkJ,GAAc4J,WAAW7G,IAAK,UACxD+rC,EAAMH,EAAO5rC,IAAK8rC,GAAO7rC,IAAK4rC,EAAI7rC,IAAK8rC,GAAOjlC,YAEpD6kC,EAAc1b,UAAW4b,GACzBD,EAAa3b,UAAW+b,EAAI/rC,IAAK6rC,GAElC,CASA,MAAAjN,EAAQ,eAAEkB,EAAc,WAAEO,EAAU,eAAEzP,IAErC,MACMM,EADQxW,GAAsB9S,IAAKk4B,GAAiBx3B,QACjCtI,IAAKqgC,GAQ9B,IANoB,IAAf1gD,KAAK6c,OAET7c,KAAKyrD,oBAAoBpb,UAAWkB,EAAWlxB,IAAK0jC,GAAY,CAAE5D,sBAI3C,IAAnBngD,KAAK2c,UAAqB,CAE9B,MACM0vC,EADUnxB,GAA+BjT,IAAKk4B,GAAiBx3B,QACxCtI,IAAKqgC,GAElC1gD,KAAKurD,wBAAwBlb,UAAWgc,EAAahsC,IAAKwiC,GAAU,CAAE1C,iBAAgBR,GAAIwL,GAAavL,IAAKwL,GAAc3uC,UAAWG,GAAoB+d,WAAYO,MAEtK,CAEA+V,EAAeC,cAAcb,UAAWkB,EAAWlxB,IAAK0/B,GAAc,CAAExjC,aAAcA,GAAawQ,QAEnGkkB,EAAeE,eAAed,UAAWkB,EAAWlxB,IAAKwiC,GAAU,CAAE1C,iBAAgBR,GAAIriC,GAAesiC,IAAK,EAAGnjC,aAAWM,YAAa/c,KAAK+c,YAAa+lC,EAAG9iD,KAAK2rD,mBAAoB5I,gBAAiB/iD,KAAK+c,YAAaimC,eAAgBhjD,KAAKmd,cAE/O,CAUA,cAAA+hC,EAAgB,WAAEwB,EAAU,cAAE4L,EAAa,UAAEC,EAAS,WAAEC,EAAU,eAAEvb,EAAc,MAAEwb,EAAK,MAAEC,IAE1F,MAAMlI,EAAK8H,EAAcl4C,IAAKm4C,GAAYnsC,IAAKosC,GACzC/H,EAAK6H,EAAclsC,IAAKmsC,GAAYnsC,IAAKosC,GACzC9H,EAAK4H,EAAclsC,IAAKmsC,GAAYn4C,IAAKo4C,GACzC7H,EAAK2H,EAAcl4C,IAAKm4C,GAAYn4C,IAAKo4C,GAEzCxtB,EAAIjE,GACJkoB,EAAIjpB,GACJsqB,EAAIxqB,GAAaN,QAEjBrQ,EAAK66B,GAAQ,CAAEhlB,IAAGikB,IAAGxmC,eAErBkwC,EAAKF,EAAM31B,OAAQ3N,GAAKqQ,QACxBozB,EAAKF,EAAM51B,OAAQ3N,GAAKqQ,QAExB+qB,EAAOtqC,GACZT,GAAMmzC,EAAG/iC,EAAG,EAAG+iC,EAAG7iC,GAClBtQ,GAAM,EAAG,EAAG,GACZA,GAAMmzC,EAAG1vB,EAAG,EAAG0vB,EAAGzvB,IACjB1D,QAIIsmB,EAAUxiC,GAAc+C,IAAKusC,EAAGhjC,GAAIxV,IAAKkJ,GAAc4J,WAAW7G,IAAKusC,EAAG9iC,IAAM0P,QAEtFyX,EAAeE,eAAed,UAAWqQ,EAAWrgC,IAAKy/B,GAAUz/B,IAAKgkC,GAAc,CAAErlB,IAAGikB,IAAGqB,IAAGC,OAAMC,KAAIC,KAAIC,KAAIC,SAEnH1T,EAAeC,cAAcb,UAAWqQ,EAAWrgC,IAAK9D,IAAe8D,IAAKgkC,GAAc,CAAErlB,IAAGikB,IAAGqB,IAAGC,KAAMtqC,GAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAKuqC,KAAIC,KAAIC,KAAIC,QAE3J,CASA,QAAAxF,CAAU98C,EAASmU,EAAOzW,GAEzBC,KAAKoxC,gBAAiB/uC,EAASmU,EAAOzW,GACtCC,KAAKqxC,iBAAkBhvC,EAASmU,EAAOzW,GACvCC,KAAK4wC,iBAAkBvuC,EAASmU,EAAOzW,EAExC,CASA,eAAAqxC,EAAiB,WAAEG,EAAU,eAAEN,IAE9BA,EAAeG,gBAAgBf,UAAWkB,EAAWlxB,IAAK0/B,GAAc,CAAExjC,mBAE3E,CASA,gBAAA80B,EAAkB,SAAEC,EAAQ,cAAEE,EAAa,eAAEP,IAe5C,IAboB,IAAfjxC,KAAK6c,OAET7c,KAAK0rD,sBAAsBrb,UAAWmB,EAAcnxB,IACnDxD,GACAmuC,GAAc,CACb3vB,OAAQN,GACRkwB,QAASjxB,GACTvd,UAAWK,QAMU,IAAnB9c,KAAK2c,UAAqB,CAE9B,MAAMkwC,EAAU3xB,GAA+BjT,IAAK+R,IAAwBrR,QAEtEmkC,EAAexJ,GAAiB,CACrC3B,MAAOkL,EACPvvC,cAAe6tC,GACf5tC,YAAa6tC,GACb3uC,UAAWG,KAGZ5c,KAAKwrD,0BAA0Bnb,UAAWrwC,KAAKsrD,kBAAkBjrC,IAAKysC,GAEvE,CAIA,MAAMC,EAAmBvzC,KAAOggB,MAAO,oBACjCwzB,EAAkBxzC,KAAOggB,MAAO,mBAChCyzB,EAA2Bzb,EAAcnxB,IAAK,EAAIpb,KAAK+R,IAE7DhX,KAAK8rD,uBAAwBiB,EAAkBC,EAAiBzvC,IAEhE,MAAM2vC,EAAkBH,EAAiB34C,IAAK44C,GAExCG,EAAU5wC,GAAa8D,IAAK6sC,EAAgBpwB,EAAEzrB,IAAK67C,EAAgBnwB,GAAI1rB,IAAK67C,EAAgBptC,GAAIoH,YAEtG+pB,EAAeI,iBAAiBhB,UAAWiB,EAASjxB,IAAK0sC,IACzD9b,EAAeI,iBAAiBhB,UAAW2c,EAAgB3sC,IAAK4sC,IAEhEhc,EAAeG,gBAAgBf,UAAW8c,EAAQ9sC,IAAK4sC,GAExD,CASA,gBAAArc,EAAkB,iBAAEA,EAAgB,eAAEK,IAErC,MAEMmc,EAFQryB,GAAsB9S,IAAK+R,IAAwBrR,QAE9CvU,IAAKw8B,GAClByc,EAAQ5wC,GAAU4D,KAAO,IAAO6G,WAAWD,SAASf,OAEpDyqB,EAASC,EAAiBxwB,IAAKgtC,EAAKjlC,IAAKklC,GAAQnmC,YAAayB,SAE5C,IAAnB3oB,KAAK2c,WAET3c,KAAKwrD,0BAA0B7gB,UAAWiG,IAIvB,IAAf5wC,KAAK6c,OAET7c,KAAK0rD,sBAAsB/gB,UAAWiG,GAIvCK,EAAeG,gBAAgBzG,UAAWiG,GAC1CK,EAAeI,iBAAiB1G,UAAWgG,EAE5C,CASA,MAAAqO,CAAQ38C,GAEP,MAAM,cAAEg9C,GAAkBh9C,EAE1B,IAAwB,IAAnBrC,KAAK2c,UAAqB,CAE9B,MAAMkwC,EAAU3xB,GAA+BjT,IAAK+R,IAAwBrR,QAEtE2kC,EAAM5N,GAAW,CACtBG,MAAOgN,EACPlN,GAAIwL,GACJvL,IAAKwL,KAGAmC,EAAiBlO,EAAch/B,IAAK1D,GAAU0D,IAAKitC,GAAMpmC,YAAa9S,IAAKpU,KAAKurD,wBAAwBn3C,IAAKpU,KAAKwrD,2BAA4BnrC,IAAK1D,KAEzJ0iC,EAAclrC,OAAQo5C,EAEvB,CAEA,IAAoB,IAAfvtD,KAAK6c,MAAiB,CAE1B,MAAM2wC,EAAkB3wC,GAAMigB,EAAEzrB,IAAKwL,GAAMkgB,GAAI1rB,IAAKwL,GAAMiD,GAAIO,IAAK,MAAQ6G,WACrEumC,EAAapO,EAAch/B,IAAKmtC,GAAkBp5C,IAAKpU,KAAKyrD,oBAAqBzrD,KAAK0rD,uBAE5FrM,EAAclrC,OAAQs5C,EAEvB,CAED,EAMD,MAAMC,GAA0Bh2C,GAAO,GACjCi2C,GAA0Bj2C,IAAS,GACnCk2C,GAA0Bl2C,GAAO,IACjCm2C,GAA0Bn2C,IAAS,GACnCo2C,GAA0Bp2C,GAAO,IACjCq2C,GAA0Br2C,GAAO,GACjCs2C,GAA0Bt2C,GAAO,MACjCu2C,GAA0Bv2C,GAAO,GACjCw2C,GAA0Bx2C,GAAO,KACjCy2C,GAA0Bz2C,GAAO,GAEjC02C,GAAmC12C,GAAO,GAC1C22C,GAAmC32C,GAAO,IAM1C42C,GAAwB51C,IAAI,EAAI61C,MAErC,MAAMC,EAAeh1C,GAAM6J,GAAKkrC,IAAc/0B,QACxCi1B,EAAO/2C,IAAS,GAAM8hB,QA4B5B,OA1BAvgB,GAAIu1C,EAAa5kC,EAAEjJ,YAAa6tC,EAAavxB,IAAK,KAEjDhkB,GAAIu1C,EAAa5kC,EAAEjJ,YAAa6tC,EAAa1kC,IAAK,KAEjD2kC,EAAKt6C,OAAQ4W,GAAQwjC,EAAU3kC,EAAEjJ,YAAa,GAAO,EAAK,GAAO,IAE9D+tC,MAAM,KAETD,EAAKt6C,OAAQ4W,GAAQwjC,EAAUzkC,EAAEnJ,YAAa,GAAO,EAAK,GAAO,GAE/D,IAEA+tC,MAAM,KAETz1C,GAAIu1C,EAAavxB,EAAEtc,YAAa6tC,EAAa1kC,IAAK,KAEjD2kC,EAAKt6C,OAAQ4W,GAAQwjC,EAAUtxB,EAAEtc,YAAa,GAAO,EAAK,GAAO,IAE9D+tC,MAAM,KAETD,EAAKt6C,OAAQ4W,GAAQwjC,EAAUzkC,EAAEnJ,YAAa,GAAO,EAAK,GAAO,GAE/D,IAIG8tC,CAAI,IAER93C,UAAW,CACdjU,KAAM,UACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,YAAa6E,KAAM,WAKvBmuB,GAAsBhd,IAAI,EAAI61C,EAAWE,MAE9C,MAAMtlC,EAAK/P,KAAOogB,QA4BlB,OA1BAvgB,GAAIw1C,EAAKjuC,MAAO,IAAO,KAEtB2I,EAAGhV,OAAQiF,GAAMm1C,EAAUtxB,EAAGsxB,EAAUzkC,GAAIxJ,IAAK+C,GAAKkrC,EAAU3kC,IAAO,IAEpE+kC,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B2I,EAAGhV,OAAQiF,GAAMm1C,EAAU3kC,EAAE3C,SAAUsnC,EAAUtxB,EAAEhW,UAAW3G,IAAK+C,GAAKkrC,EAAUzkC,IAAO,IAEtF6kC,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B2I,EAAGhV,OAAQiF,GAAMm1C,EAAU3kC,EAAE3C,SAAUsnC,EAAUzkC,GAAIxJ,IAAK+C,GAAKkrC,EAAUtxB,IAAO,IAE7E0xB,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B2I,EAAGhV,OAAQiF,GAAMm1C,EAAUtxB,EAAEhW,SAAUsnC,EAAUzkC,GAAIxJ,IAAK+C,GAAKkrC,EAAU3kC,IAAO,IAE7E+kC,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B2I,EAAGhV,OAAQiF,GAAMm1C,EAAU3kC,EAAE3C,SAAUsnC,EAAUtxB,GAAI3c,IAAK+C,GAAKkrC,EAAUzkC,IAAO,IAE7E4kC,MAAM,KAETvlC,EAAGhV,OAAQiF,GAAMm1C,EAAU3kC,EAAG2kC,EAAUzkC,GAAIxJ,IAAK+C,GAAKkrC,EAAUtxB,IAAO,IAIjE5c,GAAK,GAAK8I,EAAG/U,IAAK,GAAO,IAE7BuC,UAAW,CACdjU,KAAM,QACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,YAAa6E,KAAM,QAC3B,CAAE7E,KAAM,OAAQ6E,KAAM,YAIlBqnD,GAA+Bl2C,IAAI,EAAI+D,MAE5C,MAAMoyC,EAAMn3C,GAAO,GAAM8hB,QAwBzB,OAtBAvgB,GAAIwD,EAAUoE,iBAAkB+sC,KAAa,KAE5CiB,EAAI16C,OAAQu5C,GAAUttC,IAAK3D,GAAY4D,IAAKwtC,GAAUztC,IAAKutC,KAAcrtC,IAAKotC,GAAUttC,IAAKwtC,KAAcx5C,IAAKu5C,IAAa,IAE1HgB,OAAQlyC,EAAUoE,iBAAkBitC,KAAa,KAEpDe,EAAI16C,OAAQy5C,GAAUxtC,IAAK3D,GAAY4D,IAAK0tC,GAAU3tC,IAAKytC,KAAcvtC,IAAKstC,GAAUxtC,IAAK0tC,KAAc15C,IAAKy5C,IAAa,IAE1Hc,OAAQlyC,EAAUoE,iBAAkBmtC,KAAa,KAEpDa,EAAI16C,OAAQ25C,GAAU1tC,IAAK3D,GAAY4D,IAAK4tC,GAAU7tC,IAAK2tC,KAAcztC,IAAKwtC,GAAU1tC,IAAK4tC,KAAc55C,IAAK25C,IAAa,IAE1HY,OAAQlyC,EAAUoE,iBAAkBqtC,KAAa,KAEpDW,EAAI16C,OAAQ65C,GAAU5tC,IAAK3D,GAAY4D,IAAK8tC,GAAU/tC,IAAK6tC,KAAc3tC,IAAK0tC,GAAU5tC,IAAK8tC,KAAc95C,IAAK65C,IAAa,IAE1HS,MAAM,KAETG,EAAI16C,OAAQuD,IAAS,GAAM2I,IAAK+F,GAAM/F,GAAK,KAAM5D,KAAiB,IAI5DoyC,CAAG,IAEPl4C,UAAW,CACdjU,KAAM,iBACN6E,KAAM,QACNsM,OAAQ,CACP,CAAEnR,KAAM,YAAa6E,KAAM,YAKvBunD,GAA6Bp2C,IAAI,EAAIq2C,EAAcN,MAExD,MAAMtlC,EAAK4lC,EAAav1B,QACxBrQ,EAAGhV,OAAQkM,GAAK,EAAK8I,GAAK/I,IAAK,IAC/B,MAAMmuC,EAAY/0C,GAAM2P,EAAI,GAAMqQ,QA+BlC,OA7BAvgB,GAAIw1C,EAAKjuC,MAAO,IAAO,KAEtB+tC,EAAUp6C,OAAQo6C,EAAUS,IAAK,IAE9BL,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B+tC,EAAUp6C,OAAQo6C,EAAUU,KAC5BV,EAAUW,GAAGvkB,WAAa,EAAK,IAE5BgkB,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B+tC,EAAU3kC,EAAE+gB,WAAa,EAAK,IAE3BgkB,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B+tC,EAAUp6C,OAAQo6C,EAAUS,KAC5BT,EAAUW,GAAGvkB,WAAa,EAAK,IAE5BgkB,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B+tC,EAAUp6C,OAAQo6C,EAAUU,KAC5BV,EAAUllC,GAAGshB,WAAa,EAAK,IAE5BgkB,OAAQF,EAAKjuC,MAAO,IAAO,KAE9B+tC,EAAUtxB,EAAE0N,WAAa,EAAK,IAIxB4jB,CAAS,IAEb53C,UAAW,CACdjU,KAAM,eACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,KAAM6E,KAAM,QACpB,CAAE7E,KAAM,OAAQ6E,KAAM,YAMlB4nD,GAA8Bz2C,IAAI,EAAIgiC,EAAQ0U,EAAqBC,EAAqBC,EAAoBC,EAAqBC,MAEtI,MAAM/yC,EAAY/E,GAAO23C,GACnBI,EAAYj2C,GAAM41C,GAElBP,EAAMlmC,GAAOimC,GAAgBnyC,GAAakxC,GAAW6B,GACrDE,EAAOjpC,GAAOooC,GACdc,EAASppC,GAAOsoC,GAChBe,EAASp2C,GAAMq2C,GAAgBnV,EAAQ+U,EAAWE,EAAQL,EAAoBC,EAAqBC,IAAmBh2B,QAU5H,OARAvgB,GAAIy2C,EAAKjvC,SAAU,IAAO,KAEzB,MAAMqvC,EAASt2C,GAAMq2C,GAAgBnV,EAAQ+U,EAAWE,EAAOv7C,IAAK,GAAOk7C,EAAoBC,EAAqBC,IAAmBh2B,QAEvIo2B,EAAOz7C,OAAQuU,GAAKknC,EAAQE,EAAQJ,GAAQ,IAItCE,CAAM,IAIRC,GAA+Bn3C,IAAI,EAAIgiC,EAAQqV,EAAqBC,EAAkBV,EAAoBC,EAAqBC,MAEpI,MAAMG,EAASj4C,GAAOs4C,GAAmBx2B,QACnC+0B,EAAY/0C,GAAMu2C,GAClBtB,EAAO/2C,GAAO42C,GAASC,IAAc/0B,QACrCy2B,EAAYv4C,GAAOiQ,GAAOymC,GAAmBhuC,IAAKuvC,GAAU,IAAQn2B,QAC1Em2B,EAAOx7C,OAAQwT,GAAOgoC,EAAQvB,KAC9B,MAAM8B,EAAWx4C,GAAOwO,GAAMypC,IAAWn2B,QACnCrQ,EAAK/P,GAAMsc,GAAO64B,EAAWE,GAAOpuC,IAAK6vC,EAAS9vC,IAAK,IAAQhM,IAAK,IAAQolB,QAelF,OAbAvgB,GAAIw1C,EAAK9tC,YAAa,IAAO,KAE5BwI,EAAGW,EAAEumB,UAAW6f,GAChBzB,EAAK0B,UAAW,EAAK,IAItBhnC,EAAGS,EAAEymB,UAAWoe,EAAKpuC,IAAK6vC,IAC1B/mC,EAAGS,EAAEymB,UAAW4f,EAAU5vC,IAAKA,GAAK,EAAKguC,MACzCllC,EAAGW,EAAEumB,UAAWhwB,GAAK,EAAK6F,GAAMspC,GAAiBpvC,IAAK8vC,KACtD/mC,EAAGS,EAAE+gB,UAAW2kB,GAChBnmC,EAAGW,EAAE6gB,UAAW4kB,GAET7U,EAAO5jB,OAAQ3N,GAAKgO,KAAM/d,KAAQA,KAAQ,IAI5Cg3C,GAA0B13C,IAAI,EAAIgiC,SAAQiV,SAAQU,kBAAiBC,QAAOC,OAAMjB,qBAAoBC,sBAAqBC,qBAE9H,MAAMgB,EAAW7pC,GAAK2pC,GAGhBG,EAAkBJ,EAAgBhwC,IAAKmwC,GAC3Cp8C,IAAKm8C,EAAKroC,MAAOmoC,GAAkBhwC,IAAKqG,GAAK4pC,KAC7Cl8C,IAAKm8C,EAAKlwC,IAAKkwC,EAAKtoC,IAAKooC,GAAkBhwC,IAAKmwC,EAAStpC,cAE3D,OAAO2oC,GAAgBnV,EAAQ+V,EAAiBd,EAAQL,EAAoBC,EAAqBC,EAAgB,IAI5Gz4B,GAAqBre,IAAI,EAAIuuC,IAAGyJ,cAAaC,WAAUN,kBAAiBO,UAASpX,UAASqX,SAAQlB,SAAQjV,SAAQ4U,qBAAoBC,sBAAqBC,qBAEhK,MAAMe,EAAO/2C,GAAMuR,GAAQ2lC,EAAaC,EAAUzoC,GAAOyoC,EAAUN,KAAsB72B,QAEzFvgB,GAAI4M,GAAK0qC,EAAKltD,OAAQmW,GAAM,MAAW,KAEtC+2C,EAAKp8C,OAAQqF,GAAM62C,EAAgBpzB,EAAG,EAAKozB,EAAgBzmC,EAAE3C,UAAY,IAI1EspC,EAAKp8C,OAAQ6O,GAAWutC,IAExB,MAAMO,EAAet3C,KAAOggB,QAiB5B,OAhBAs3B,EAAazgB,UAAWugB,EAAQz2C,QAAS3C,GAAK,IAAM6I,IAAK+vC,GAAW,CAAEE,MAAO,EAAKC,OAAMF,kBAAiBV,SAAQjV,SAAQ4U,qBAAoBC,sBAAqBC,qBAElKthB,GAAM,CAAEzsC,MAAO+V,GAAK,GAAK81B,IAAK2Z,IAAK,EAAI5iD,QAEtC4U,GAAI5U,EAAEwc,iBAAkB24B,IAAW,KAElCrL,IAAO,IAIR,MAAMmiB,EAAQ54C,GAAOm5C,EAAOxwC,IAAK3I,GAAOrT,KAAQm1B,QAChDs3B,EAAazgB,UAAWugB,EAAQz2C,QAAS9V,GAAIgc,IAAK+vC,GAAW,CAAEE,MAAOA,EAAMjwC,KAAO,GAAOkwC,OAAMF,kBAAiBV,SAAQjV,SAAQ4U,qBAAoBC,sBAAqBC,qBAC1KsB,EAAazgB,UAAWugB,EAAQz2C,QAAS9V,GAAIgc,IAAK+vC,GAAW,CAAEE,QAAOC,OAAMF,kBAAiBV,SAAQjV,SAAQ4U,qBAAoBC,sBAAqBC,oBAAsB,IAItK51C,GAAMk3C,EAAc,EAAG,IAM/B,IAAIC,GAAa,KAEjB,MAAMC,GAAS,IAAI9wD,QA4BnB,SAAS+wD,GAAsBn9B,GAE9B,IAAIo9B,EAAeF,GAAOlwD,IAAKgzB,GAI/B,SAFsC/yB,IAAjBmwD,EAA6BA,EAAaC,cAAiB,KAE1Dr9B,EAAQq9B,aAAe,CAE5C,MAAMp9B,EAAQD,EAAQC,MAEtB,GAAKD,EAAQ6mB,cAAgB,CAE5B,IAkRH,SAAyB5mB,GAExB,GAAKA,QAAwC,OAAO,EAEpD,IAAIryB,EAAQ,EACZ,MAAMsC,EAAS,EAEf,IAAM,IAAIK,EAAI,EAAGA,EAAIL,EAAQK,SAERtD,IAAfgzB,EAAO1vB,IAAoB3C,IAIjC,OAAOA,IAAUsC,CAGlB,CAlSQotD,CAAgBr9B,GAMpB,OAAO,KAJPm9B,EAAeH,GAAWM,YAAav9B,EAASo9B,EASlD,KAAO,CAEN,IA8RH,SAAoCn9B,GAEnC,OAAKA,SAEEA,EAAM3xB,OAAS,CAEvB,CApSQkvD,CAA2Bv9B,GAM/B,OAAO,KAJPm9B,EAAeH,GAAWQ,oBAAqBz9B,EAASo9B,EAQ1D,CAEAA,EAAaC,aAAer9B,EAAQq9B,aAEpCH,GAAOxuD,IAAKsxB,EAASo9B,EAEtB,CAEA,OAAOA,EAAap9B,OAErB,CAaA,MAAM09B,WAAkB9hD,EAEvB,eAAWnI,GAEV,MAAO,WAER,CASA,WAAAzH,CAAaoD,EAAOgxB,EAAS,KAAMX,EAAY,MAE9C7pB,MAAO,QAQP1J,KAAK00B,OAASxxB,EASdlD,KAAKyxD,OAAS,KAOdzxD,KAAKk0B,OAASA,EAOdl0B,KAAKuzB,UAAYA,EASjBvzB,KAAK+wD,WAAa,KAElB,MAAM7S,EAAiB,IAAI,MAC3BA,EAAe5oB,uBAAwB,EAQvCt1B,KAAK0xD,SAAW59B,GAASoqB,GAQzBl+C,KAAK2xD,OAAS71C,GAAS,GAQvB9b,KAAK4xD,QAAU91C,GAAS,GAQxB9b,KAAK6xD,QAAU/1C,GAAS,GAQxB9b,KAAK4J,iBAAmBlB,EAAeG,MAExC,CAEA,SAAI3F,CAAOA,GAEVlD,KAAK00B,OAASxxB,EACdlD,KAAKyxD,OAAS,IAEf,CAOA,SAAIvuD,GAEH,OAAOlD,KAAK00B,MAEb,CAOA,iBAAAo9B,CAAmBh+B,GAElB,MAAMi+B,EA9MR,SAA8BC,GAE7B,MAAMC,EAAShtD,KAAKmhB,KAAM4rC,GAAgB,EAEpCE,EAAc,EAAMF,EAI1B,MAAO,CAAEG,WAFU,GAAQ,EAAIltD,KAAKoM,IAAKpM,KAAKkjB,IAAK,EAAG8pC,GAAU,MAE3CC,cAAaD,SAEnC,CAoMqBG,CAAqBt+B,EAAQC,MAAM3xB,QAEtDpC,KAAK0xD,SAASxuD,MAAQ4wB,EACtB9zB,KAAK2xD,OAAOzuD,MAAQ6uD,EAAWI,WAC/BnyD,KAAK4xD,QAAQ1uD,MAAQ6uD,EAAWG,YAChClyD,KAAK6xD,QAAQ3uD,MAAQ6uD,EAAWE,MAEjC,CAEA,YAAAzlD,GAEC,IAAI6lD,EAAQryD,KAAKyxD,OAEjB,MAAMN,EAAekB,EAAQA,EAAMlB,cAAiB,EAC9Cr9B,EAAU9zB,KAAK00B,OAEhBy8B,IAAiBr9B,EAAQq9B,eAI5BkB,GAF+B,IAA3Bv+B,EAAQw+B,eAEJx+B,EAIAm9B,GAAsBn9B,GAIhB,OAAVu+B,IAEJryD,KAAKyxD,OAASY,EAEdryD,KAAK8xD,kBAAmBO,IAM3B,CAEA,KAAAnmD,CAAOnM,GAEc,OAAfgxD,KAEJA,GAAahxD,EAAQwyD,wBAMtBvyD,KAAKwM,aAAczM,GAInB,IAAIm0B,EAASl0B,KAAKk0B,OAEF,OAAXA,GAAmBn0B,EAAQsC,QAAQqzB,QAEvCxB,EAASn0B,EAAQsC,QAAQqzB,MAAO11B,OAMjC,MAAM8zB,EAAU9zB,KAAKkD,MAEhBnD,EAAQ+C,SAAS4f,mBAAqB,QAAoD,IAA3BoR,EAAQw+B,iBAA6D,IAAlCx+B,EAAQwB,wBAE9GpB,EAAS1a,GAAM0a,EAAOtK,EAAE3C,SAAUiN,EAAO8H,KAI1C9H,EAAS1a,GAAM0a,EAAOtK,EAAGsK,EAAOpK,EAAE7C,SAAUiN,EAAO+I,GAInD,IAAI1J,EAAYvzB,KAAKuzB,UAUrB,OARmB,OAAdA,GAAsBxzB,EAAQsC,QAAQszB,kBAE1CpC,EAAYxzB,EAAQsC,QAAQszB,gBAAiB31B,OAMvCmvD,GAAenvD,KAAK0xD,SAAUx9B,EAAQX,EAAWvzB,KAAK2xD,OAAQ3xD,KAAK4xD,QAAS5xD,KAAK6xD,QAEzF,EAqDD,MAAMW,GAA6B55C,GAAW44C,IAExCiB,GAAgB,IAAIvyD,QAS1B,MAAMwyD,WAAwBliB,GAE7B,eAAWjpC,GAEV,MAAO,iBAER,CAOA,WAAAzH,CAAa23C,EAAU,MAEtB/tC,QAQA1J,KAAKy3C,QAAUA,CAEhB,CAEA,KAAAvrC,CAAOnM,GAEN,MAAM,SAAEkB,GAAalB,EAErB,IAAI03C,EAAUz3C,KAAKy3C,QAEnB,GAAKA,EAAQrjB,eAAiBqjB,EAAQ7Z,wBAA0B,CAE/D,MAAM16B,EAAUu0C,EAAsB,cAAIA,EAAQv0C,MAAQjC,EAAUw2C,EAAQ70C,UAE5E,IAAI+vD,EAAeF,GAAc3xD,IAAKoC,QAEhBnC,IAAjB4xD,IAEJA,EAAeH,GAActvD,GAE7BuvD,GAAcjwD,IAAKU,EAAOyvD,IAI3Blb,EAAUkb,CAEX,CAIA,MACMC,EADS3xD,EAASy5C,OACG7sB,GAAW,kBAAmB,QAAS9tB,EAAQkB,UAAa4sB,GAAW,uBAAwB,QAAS9tB,EAAQ49C,OAGrIkV,GAD2C,IAA3B5xD,EAAS6xD,eAA0B7xD,EAASkc,WAAa,EACpCmhB,GAA4BvD,GAEjEuW,EAAWmG,EAAQp1C,QAAS0wD,GAAuBt2C,GAAWo2C,IAAuBxyC,IAAKuyC,GAC1FrhB,EAAakG,EAAQp1C,QAAS2wD,GAAyB/3B,KAA2B5a,IAAKpb,KAAK+R,IAAKqJ,IAAKuyC,GAEtGK,EAAkBpkD,GAAOyiC,GACzB4hB,EAAoBrkD,GAAO0iC,GAIjCxxC,EAAQsC,QAAQivC,SAASjB,UAAW4iB,GAEpClzD,EAAQsC,QAAQmvC,cAAcnB,UAAW6iB,GAIzC,MAAM5H,EAAoBvrD,EAAQsC,QAAQyuC,cAAcwa,kBAExD,GAAKA,EAAoB,CAExB,MAAM6H,EAA2B1b,EAAQp1C,QAAS0wD,GAAuBn2C,GAAoBse,KAAmC7a,IAAKuyC,GAC/HQ,EAA2BvkD,GAAOskD,GAExC7H,EAAkBjb,UAAW+iB,EAE9B,CAED,EAID,MAAML,GAAwB,CAAElxB,EAAewxB,KAE9C,IAAIC,EAAa,KAEjB,MAAO,CACN59B,MAAO,KAEc,OAAf49B,IAEJA,EAAat5B,GAAsB/S,SAASa,QAASurC,GAGrDC,EAAazxB,EAAcxhB,IAAKwhB,GAAgBnZ,IAAK4qC,EAAYD,GAAiBrwC,YAElFswC,EAAaA,EAAW/qC,mBAAoB2P,KAItCo7B,GAGR39B,gBAAiB,IAETkM,EAGR,EAIImxB,GAA4BO,IAE1B,CACN79B,MAAO,IAEC69B,EAGR59B,gBAAiB,IAETje,GAAO,KAOX87C,GAAiC,IAAI,MAO3C,MAAMC,WAAiCrc,GAEtC,eAAW7vC,GAEV,MAAO,0BAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK0zD,4BAA6B,EAQlC1zD,KAAKu3C,QAAS,EAadv3C,KAAKoiC,aAAe,KAapBpiC,KAAKgiC,cAAgB,KAarBhiC,KAAK6hC,cAAgB,KAErB7hC,KAAKy7C,iBAAkB+X,IAEvBxzD,KAAKi8C,UAAWx9B,EAEjB,CAUA,gBAAAg8B,CAAkB16C,GAEjB,IAAI03C,EAAU/tC,MAAM+wC,iBAAkB16C,GAQtC,OANiB,OAAZ03C,GAAoB13C,EAAQ4zD,kBAEhClc,EAAU13C,EAAQ4zD,iBAIZlc,EAAU,IAAIib,GAAiBjb,GAAY,IAEnD,CAOA,kBAAA6D,GAEC,OAAO,IAAI+P,EAEZ,CAKA,aAAAuI,GAEC,MAAMlyB,EAAoBhZ,GAAKlP,GAAM,KAAQ+C,GAAawQ,IAAKrQ,IAE/DY,GAAcnJ,OAAQutB,GACtBnkB,GAAYpJ,OAAQ,EAErB,CAOA,aAAA6kC,GAIC,MAAMhX,EAAgBhiC,KAAKgiC,cAAgBtqB,GAAO1X,KAAKgiC,eAAkBoE,GAEzE1pB,GAAUvI,OAAQ6tB,GAIlB,IAAIH,EAAgB7hC,KAAK6hC,cAAgBnqB,GAAO1X,KAAK6hC,eAAkBsE,GACvEtE,EAAgBwf,GAAc,CAAE5kC,UAAWolB,IAE3CplB,GAAUtI,OAAQ0tB,GAIlB7hC,KAAK4zD,gBAILr3C,GAAapI,OAAQyF,GAAM2C,GAAawQ,IAAI1M,IAAK2hB,EAAc9a,YAAc3K,GAAasD,GAE3F,CAEA,IAAAtc,CAAM8a,GAOL,OALAre,KAAKoiC,aAAe/jB,EAAO+jB,aAE3BpiC,KAAKgiC,cAAgB3jB,EAAO2jB,cAC5BhiC,KAAK6hC,cAAgBxjB,EAAOwjB,cAErBn4B,MAAMnG,KAAM8a,EAEpB,EAID,MAAMw1C,GAAiC,IAAI,MAO3C,MAAMC,WAAiCL,GAEtC,eAAWlsD,GAEV,MAAO,0BAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK+zD,4BAA6B,EAalC/zD,KAAKwiC,cAAgB,KAarBxiC,KAAK2iC,uBAAyB,KAa9B3iC,KAAKg0D,oBAAsB,KAa3Bh0D,KAAKgjC,UAAY,KAajBhjC,KAAKmjC,mBAAqB,KAa1BnjC,KAAKi0D,gBAAkB,KAavBj0D,KAAKk0D,mBAAqB,KAa1Bl0D,KAAKm0D,yBAA2B,KAahCn0D,KAAKuhC,sBAAwB,KAa7BvhC,KAAK0hC,kBAAoB,KAazB1hC,KAAKo0D,QAAU,KAafp0D,KAAKgkC,iBAAmB,KAaxBhkC,KAAKmkC,cAAgB,KAarBnkC,KAAKq0D,wBAA0B,KAa/Br0D,KAAKs0D,qBAAuB,KAa5Bt0D,KAAKu0D,eAAiB,KAatBv0D,KAAKw0D,eAAiB,KAEtBx0D,KAAKy7C,iBAAkBoY,IAEvB7zD,KAAKi8C,UAAWx9B,EAEjB,CAQA,gBAAIg2C,GAEH,OAAOz0D,KAAK2c,UAAY,GAA4B,OAAvB3c,KAAKwiC,aAEnC,CAQA,kBAAIkyB,GAEH,OAAO10D,KAAK+c,YAAc,GAA8B,OAAzB/c,KAAKi0D,eAErC,CAQA,YAAIU,GAEH,OAAO30D,KAAK6c,MAAQ,GAAwB,OAAnB7c,KAAKgjC,SAE/B,CAQA,iBAAI8vB,GAEH,OAAO9yD,KAAKmd,WAAa,GAA6B,OAAxBnd,KAAKw0D,cAEpC,CAQA,mBAAII,GAEH,OAAO50D,KAAKkC,aAAe,GAA+B,OAA1BlC,KAAKgkC,gBAEtC,CAQA,iBAAI6wB,GAEH,OAAO70D,KAAK+d,WAAa,GAA6B,OAAxB/d,KAAKu0D,cAEpC,CAKA,aAAAX,GAEC,MAAMQ,EAAUp0D,KAAKo0D,QAAU18C,GAAO1X,KAAKo0D,SAAYltB,GAEvDvpB,GAAIxJ,OAAQigD,GACZ92C,GAAcnJ,OAAQuU,GAAKhB,GAAOU,GAAMzK,GAAIyC,IAAK,GAAME,IAAK3C,GAAIvJ,IAAK,KAAUiM,IAAK2lB,IAAyBxsB,GAAM,IAAQ6G,IAAK0lB,IAA6BxpB,GAAawQ,IAAKrQ,KAC/Ka,GAAYpJ,OAAQuU,GAAKqd,GAA2B,EAAKrpB,IAE1D,CAOA,kBAAA4+B,GAEC,OAAO,IAAI+P,GAAuBrrD,KAAKy0D,aAAcz0D,KAAK20D,SAAU30D,KAAK00D,eAAgB10D,KAAK8yD,cAAe9yD,KAAK40D,gBAAiB50D,KAAK60D,cAEzI,CAOA,aAAA7b,CAAej5C,GAMd,GAJA2J,MAAMsvC,cAAej5C,GAIhBC,KAAKy0D,aAAe,CAExB,MAAMjyB,EAAgBxiC,KAAKwiC,cAAgB9qB,GAAO1X,KAAKwiC,eAAkB8D,GACnE3D,EAAyB3iC,KAAK2iC,uBAAyBjrB,GAAO1X,KAAK2iC,wBAA2B4D,GAEpG5pB,GAAUxI,OAAQquB,GAClB5lB,GAAmBzI,OAAQktC,GAAc,CAAE5kC,UAAWkmB,IAEvD,CAIA,GAAK3iC,KAAK20D,SAAW,CAEpB,MAAM3xB,EAAYhjC,KAAKgjC,UAAYxpB,GAAMxZ,KAAKgjC,WAAc0D,GACtDvD,EAAqBnjC,KAAKmjC,mBAAqBzrB,GAAO1X,KAAKmjC,oBAAuBwD,GAExF9pB,GAAM1I,OAAQ6uB,GACdlmB,GAAe3I,OAAQgvB,EAExB,CAIA,GAAKnjC,KAAK00D,eAAiB,CAE1B,MAAMT,EAAkBj0D,KAAKi0D,gBAAkBv8C,GAAO1X,KAAKi0D,iBAAoBptB,GACzEqtB,EAAqBl0D,KAAKk0D,mBAAqBx8C,GAAO1X,KAAKk0D,oBAAuBptB,GAClFqtB,EAA2Bn0D,KAAKm0D,yBAA2Bz8C,GAAO1X,KAAKm0D,0BAA6BptB,GAE1GhqB,GAAY5I,OAAQ8/C,GACpBj3C,GAAe7I,OAAQ+/C,GACvBj3C,GAAqB9I,OAAQggD,EAE9B,CAIA,GAAKn0D,KAAK8yD,cAAgB,CAEzB,MAAMgC,GAAgB90D,KAAKw0D,eAAiBp7C,GAAMpZ,KAAKw0D,gBAAmB5tB,IAAqBpN,QAE/Frc,GAAWhJ,OAAQ2gD,EAAY9wD,UAE/BiV,GAAIkE,GAAWqD,MAAO,IAAO,KAE5Bs0C,EAAY3gD,OAAQiF,GAAM,EAAK,GAAO,IAEnCs1C,MAAM,KAEToG,EAAYrM,UAAWrvC,GAAM+D,KAC7BA,GAAWhJ,OAAQgJ,GAAW2L,WAAY,IAK3C5L,GAAO/I,OAAQgJ,GAAWiL,OAAOM,IAAKjM,GAAU2L,OAAQ,IAExDhL,GAAYjJ,OAAQkqB,GAAe,GAAIhe,IAAKy0C,EAAYlrC,GAAIxV,IAAKiqB,GAAe,GAAIhe,IAAKy0C,EAAYhrC,KACrGzM,GAAYlJ,OAAQkqB,GAAe,GAAIhe,IAAKy0C,EAAYlrC,GAAIxJ,IAAKie,GAAe,GAAIhe,IAAKy0C,EAAYhrC,IAEtG,CAIA,GAAK9pB,KAAK40D,gBAAkB,CAE3B,MAAM5wB,EAAmBhkC,KAAKgkC,iBAAmBtsB,GAAO1X,KAAKgkC,kBAAqBgD,GAC5E7C,EAAgBnkC,KAAKmkC,cAAgBzsB,GAAO1X,KAAKmkC,eAAkB8C,GACnEotB,EAA0Br0D,KAAKq0D,wBAA0B38C,GAAO1X,KAAKq0D,yBAA4BltB,GACjGmtB,EAAuBt0D,KAAKs0D,qBAAuB96C,GAAMxZ,KAAKs0D,sBAAyBltB,GAO7F,GALAllC,GAAaiS,OAAQ6vB,GACrBpmB,GAAUzJ,OAAQgwB,GAClBtmB,GAAoB1J,OAAQkgD,GAC5Bv2C,GAAiB3J,OAAQmgD,GAEpBt0D,KAAK60D,cAAgB,CAEzB,MAAMN,EAAiBv0D,KAAKu0D,eAAiB78C,GAAO1X,KAAKu0D,gBAAmB9sB,GAE5E1pB,GAAW5J,OAAQogD,EAEpB,CAED,CAED,CAOA,oBAAAp5B,GAEC,OAAOn7B,KAAKg0D,oBAAsBx6C,GAAMxZ,KAAKg0D,qBAAwBxtB,EAEtE,CAEA,KAAAt6B,CAAOnM,GAENA,EAAQsC,QAAQ84B,qBAAuB,IAAMn7B,KAAKm7B,qBAAsBp7B,GAExE2J,MAAMwC,MAAOnM,EAEd,CAEA,IAAAwD,CAAM8a,GAwBL,OAtBAre,KAAKwiC,cAAgBnkB,EAAOmkB,cAC5BxiC,KAAK2iC,uBAAyBtkB,EAAOskB,uBACrC3iC,KAAKg0D,oBAAsB31C,EAAO21C,oBAElCh0D,KAAKgjC,UAAY3kB,EAAO2kB,UACxBhjC,KAAKmjC,mBAAqB9kB,EAAO8kB,mBAEjCnjC,KAAKi0D,gBAAkB51C,EAAO41C,gBAC9Bj0D,KAAKk0D,mBAAqB71C,EAAO61C,mBACjCl0D,KAAKm0D,yBAA2B91C,EAAO81C,yBAEvCn0D,KAAKuhC,sBAAwBljB,EAAOkjB,sBACpCvhC,KAAK0hC,kBAAoBrjB,EAAOqjB,kBAEhC1hC,KAAKgkC,iBAAmB3lB,EAAO2lB,iBAC/BhkC,KAAKmkC,cAAgB9lB,EAAO8lB,cAC5BnkC,KAAKq0D,wBAA0Bh2C,EAAOg2C,wBACtCr0D,KAAKs0D,qBAAuBj2C,EAAOi2C,qBACnCt0D,KAAKu0D,eAAiBl2C,EAAOk2C,eAE7Bv0D,KAAKw0D,eAAiBn2C,EAAOm2C,eAEtB9qD,MAAMnG,KAAM8a,EAEpB,EA+KD,MAAM02C,GAAsCr8C,IAAI,EAAI2iB,SAAQ8kB,iBAAgBpgD,cAG3E,MAAM2hD,EAAQrmB,EAAOpT,IAAKk4B,GACpBtN,EAAQz5B,GAAMsoC,EAAMrhC,IAAK,IAAMjM,IAAK,IAAO,GAEjD,GAAKrU,EAAQkB,SAAS+zD,YAAc,CAEnC,MAAMA,EAAcn3B,GAAmB,cAAe,WAAYx7B,QAAS,CAAEqzB,MAAO,IAAMmd,IAE1F,OAAOr5B,GAAMw7C,EAAYl4B,EAE1B,CAAO,CAEN,MAAMm4B,EAAKpiB,EAAMrrB,SAASnH,IAAK,IAE/B,OAAOqI,GAAKlP,GAAM,IAAOA,GAAM,GAAOwP,GAAYtR,GAAO,IAAM0I,IAAK60C,EAAGrrC,GAAKlS,GAAO,IAAMtD,IAAK6gD,EAAGrrC,GAAKipB,EAAMjpB,GAE7G,KASD,MAAMsrC,WAA0BnW,GAU/B,MAAAE,EAAQ,eAAEkB,EAAc,WAAEO,EAAU,eAAEzP,GAAkBz6B,EAAOzW,GAE9D,MAAMwxC,EAAawjB,GAAuB,CAAE15B,OAAQd,GAAgB4lB,iBAAgBpgD,YAAYsgB,IAAKqgC,GAErGzP,EAAeC,cAAcb,UAAWkB,EAAWlxB,IAAK0/B,GAAc,CAAExjC,aAAcA,GAAawQ,OAEpG,CASA,QAAAoyB,EAAU,iBAAEvO,EAAgB,WAAEW,EAAU,eAAEN,IAEzCA,EAAeG,gBAAgBf,UAAWkB,EAAWlxB,IAAK0/B,GAAc,CAAExjC,oBAE1E00B,EAAeG,gBAAgBzG,UAAWiG,EAE3C,EAID,MAAMukB,GAAiC,IAAI,KAO3C,MAAMC,WAA6Bhe,GAElC,eAAW7vC,GAEV,MAAO,sBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAKq1D,wBAAyB,EAQ9Br1D,KAAKu3C,QAAS,EAEdv3C,KAAKy7C,iBAAkB0Z,IAEvBn1D,KAAKi8C,UAAWx9B,EAEjB,CAOA,kBAAA68B,GAEC,OAAO,IAAI4Z,EAEZ,EAYD,MAAMI,WAAqB5lD,EAE1B,eAAWnI,GAEV,MAAO,cAER,CAKA,WAAAzH,GAEC4J,MAAO,OAER,CAEA,KAAAwC,GAEC,MAAM0d,EAAIpQ,GAAMwgB,GAAsBiD,EAAG,EAAGjD,GAAsBpQ,EAAE3C,UAAWjE,YACzE8G,EAAIkQ,GAAsB9R,MAAO0B,GAEvC,OAAOxQ,GAAMwQ,EAAE3B,IAAK8S,IAAyBjR,EAAE7B,IAAK8S,KAA0B1a,IAAK,MAAQjM,IAAK,GAEjG,EAUD,MAAMmhD,GAAyB18C,GAAey8C,IAExCE,GAAiC,IAAI,MAO3C,MAAMC,WAA+Bre,GAEpC,eAAW7vC,GAEV,MAAO,wBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK01D,0BAA2B,EAEhC11D,KAAKy7C,iBAAkB+Z,IAEvBx1D,KAAKi8C,UAAWx9B,EAEjB,CAOA,aAAAu6B,CAAej5C,GAEd,MAAMopB,EAAKosC,GAEX,IAAII,EAIHA,EAFI51D,EAAQkB,SAAS20D,OAEP/3B,GAAmB,SAAU,WAAYx7B,QAAS,CAAEqzB,MAAO,IAAMvM,IAIjE3P,GAAMkP,GAAK,GAAK,GAAKS,EAAGW,IAIvCvN,GAAawQ,IAAI4d,UAAWgrB,EAAY5oC,IAEzC,EAID,MAAM8oC,GAAiC,IAAI,MAY3C,MAAMC,WAA2B1e,GAEhC,eAAW7vC,GAEV,MAAO,oBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK+1D,sBAAuB,EAE5B/1D,KAAKy7C,iBAAkBoa,IAEvB71D,KAAKi8C,UAAWx9B,EAEjB,EAWD,MAAMu3C,WAAmBtmD,EAExB,eAAWnI,GAEV,MAAO,YAER,CASA,WAAAzH,CAAa83C,EAAcqe,GAE1BvsD,QAOA1J,KAAK43C,aAAeA,EAQpB53C,KAAKi2D,aAAeA,CAErB,CAQA,WAAAtqD,CAAa5L,GAEZ,OAAOC,KAAK43C,aAAajsC,YAAa5L,EAEvC,CAEA,KAAAmM,CAAOnM,GAEN,MAAM,aAAEk2D,EAAY,aAAEre,GAAiB53C,KAIvC,GAAkB,SAFDA,KAAK2L,YAAa5L,GAER,CAE1B,MAAMm2D,EAAWD,EAAatvC,MACxBwvC,EAAWF,EAAavvC,MAO9B,OALuB1M,GACtBk8C,EAAUC,EACVA,EAASlvC,SAAUivC,GAGE71C,IAAKu3B,EAE5B,CAAO,CAEN,MAAMwe,EAAWH,EACXI,EAAkBn8C,GAAMN,GAAM,EAAK,EAAK,EAAK,GAAOA,GAAM,EAAK+M,GAAKyvC,EAASxsC,GAAKlD,GAAK0vC,EAASxsC,GAAI3C,SAAU,GAAOrN,GAAM,EAAK8M,GAAK0vC,EAASxsC,GAAKjD,GAAKyvC,EAASxsC,GAAK,GAAOhQ,GAAM,EAAK,EAAK,EAAK,IAClM08C,EAAkBp8C,GAAMN,GAAM+M,GAAKyvC,EAAStsC,GAAK,EAAKpD,GAAK0vC,EAAStsC,GAAK,GAAOlQ,GAAM,EAAK,EAAK,EAAK,GAAOA,GAAM8M,GAAK0vC,EAAStsC,GAAI7C,SAAU,EAAKN,GAAKyvC,EAAStsC,GAAK,GAAOlQ,GAAM,EAAK,EAAK,EAAK,IAClM28C,EAAkBr8C,GAAMN,GAAM+M,GAAKyvC,EAASn5B,GAAKvW,GAAK0vC,EAASn5B,GAAIhW,SAAU,EAAK,GAAOrN,GAAM8M,GAAK0vC,EAASn5B,GAAKtW,GAAKyvC,EAASn5B,GAAK,EAAK,GAAOrjB,GAAM,EAAK,EAAK,EAAK,GAAOA,GAAM,EAAK,EAAK,EAAK,IAExM,OAAOy8C,EAAgBh2C,IAAKi2C,GAAkBj2C,IAAKk2C,GAAkBl2C,IAAKzG,GAAMg+B,EAAc,IAAQ70B,GAEvG,CAED,EAaD,MAAMyzC,GAAuB59C,GAAWo9C,IAElCS,GAAiC,IAAI,MAO3C,MAAMC,WAA2Btf,GAEhC,eAAW7vC,GAEV,MAAO,oBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAK22D,sBAAuB,EAE5B32D,KAAK42D,qBAAsB,EAmB3B52D,KAAK43C,aAAe,KAapB53C,KAAKi2D,aAAe,KAUpBj2D,KAAKw/B,UAAY,KAEjBx/B,KAAKy7C,iBAAkBgb,IAEvBz2D,KAAKi8C,UAAWx9B,EAEjB,CASA,iBAAAsb,CAAmBh6B,GAElB,MAAM,OAAEO,EAAM,OAAEs3B,GAAW73B,EAErB82D,EAAkB72D,KAAK62D,iBAEvB,aAAEjf,EAAY,aAAEqe,EAAY,UAAEz2B,GAAcx/B,KAE5C82D,EAAa9zD,GAAgBqd,IAAK7G,GAAMo+B,GAAgB,IAE9D,IAAItY,EAAQlmB,GAAMggB,GAAkB,GAAIrW,IAAI/e,SAAUo1B,GAAkB,GAAIrW,IAAI/e,UAQhF,GANmB,OAAdw7B,IAEJF,EAAQA,EAAMjf,IAAKmf,KAIK,IAApBq3B,EAEJ,GAAKj/B,EAAO0c,oBAEXhV,EAAQA,EAAMjf,IAAKy2C,EAAW75B,EAAEhW,cAE1B,CAEN,MAAM8vC,EAAar/C,GAAO,GAAM4I,IAAK0X,GAAuB7d,QAAS,GAAIA,QAAS,IAClFmlB,EAAQA,EAAMjf,IAAK02C,EAAW12C,IAAK,GAEpC,CAID,IAAI22C,EAAkBv9B,GAAiBpQ,GAEvC,GAAK/oB,EAAOwB,SAAsC,IAA5BxB,EAAOwB,OAAOiF,UAAqB,CAExD,MAAMjF,EAxxcW,EAAEY,EAAM6E,EAAMjH,IAAYiU,GAAY,IAAIqZ,GAAmBlrB,EAAM6E,EAAMjH,IAwxc3E22D,CAAa,SAAU,OAAQ32D,GAE9C02D,EAAkBA,EAAgB52C,IAAKte,EAAOse,IAAK,IAEpD,CAEA42C,EAAkBA,EAAgB32C,IAAKif,GAEvC,MAAM82B,EAAW1+C,GAAOu+C,GAAgBxvB,IAElCywB,EAAkBV,GAAQQ,EAAiBZ,GAEjD,OAAOx8C,GAAMk9C,EAAWztC,GAAGjV,IAAK8iD,GAAmBJ,EAAW5jB,GAE/D,CAEA,IAAA3vC,CAAM8a,GAML,OAJAre,KAAK43C,aAAev5B,EAAOu5B,aAC3B53C,KAAKi2D,aAAe53C,EAAO43C,aAC3Bj2D,KAAKw/B,UAAYnhB,EAAOmhB,UAEjB91B,MAAMnG,KAAM8a,EAEpB,CAQA,mBAAIw4C,GAEH,OAAO72D,KAAK42D,mBAEb,CAEA,mBAAIC,CAAiB3zD,GAEflD,KAAK42D,sBAAwB1zD,IAEjClD,KAAK42D,oBAAsB1zD,EAC3BlD,KAAKoK,aAAc,EAIrB,EASD,MAAM+sD,WAAwBpY,GAK7B,WAAAj/C,GAEC4J,QAOA1J,KAAKo3D,WAAa1/C,GAAO,GAAI8hB,MAAO,aAErC,CAOA,MAAAylB,EAAQ,WAAEoY,IAETr3D,KAAKo3D,WAAWzsB,UAAW0sB,EAE5B,CAOA,MAAArY,CAAQ38C,GAEPka,GAAasD,EAAE8qB,UAAW3qC,KAAKo3D,WAAWlwC,YAE1C7kB,EAAQg9C,cAActyB,IAAI5Y,OAAQoI,GAAawQ,IAEhD,EAID,MAAMuqC,GAA+B,IAAI,KAOzC,MAAMC,WAA2BngB,GAEhC,eAAW7vC,GAEV,MAAO,oBAER,CAOA,WAAAzH,CAAa2e,GAEZ/U,QASA1J,KAAKw3D,sBAAuB,EAS5Bx3D,KAAKu3C,QAAS,EAEdv3C,KAAKy7C,iBAAkB6b,IAEvBt3D,KAAKi8C,UAAWx9B,EAEjB,CAOA,kBAAA68B,GAEC,OAAO,IAAI6b,EAEZ,EAMcz+C,IAAI,EAAIob,UAAS3K,SAE/B,MAAMsuC,EAAU,KAEVC,EAAMl+C,KAAOggB,QAsCnB,OApCAvgB,GAAIkQ,EAAGS,EAAElJ,SAAU+2C,IAAW,KAE7BC,EAAIvjD,OAAQqF,GAAM,EAAG,EAAG,GAAK,IAE1Bm1C,OAAQxlC,EAAGW,EAAEpJ,SAAU+2C,IAAW,KAErCC,EAAIvjD,OAAQqF,GAAM,EAAG,EAAG,GAAK,IAE1Bm1C,OAAQxlC,EAAG8T,EAAEvc,SAAU+2C,IAAW,KAErCC,EAAIvjD,OAAQqF,GAAM,EAAG,EAAG,GAAK,IAE1Bm1C,OAAQxlC,EAAGS,EAAEjJ,YAAa,QAAe,KAE5C+2C,EAAIvjD,OAAQqF,IAAQ,EAAG,EAAG,GAAK,IAE5Bm1C,OAAQxlC,EAAGW,EAAEnJ,YAAa,QAAe,KAE5C+2C,EAAIvjD,OAAQqF,GAAM,GAAK,EAAG,GAAK,IAE5Bm1C,OAAQxlC,EAAG8T,EAAEtc,YAAa,QAAe,KAE5C+2C,EAAIvjD,OAAQqF,GAAM,EAAG,GAAK,GAAK,IAE5Bk1C,MAAM,KAET,MAAM7mC,EAAO,IAEP+B,EAAIkK,EAAQgD,OAAQ3N,EAAG/U,IAAKoF,IAAM,IAAQ,EAAK,KAAUsjB,EAAE1c,IAAK0T,EAAQgD,OAAQ3N,EAAG/U,IAAKoF,GAAMqO,EAAM,EAAK,KAAUiV,GACnHhT,EAAIgK,EAAQgD,OAAQ3N,EAAG/U,IAAKoF,GAAM,GAAK,IAAQ,KAAUsjB,EAAE1c,IAAK0T,EAAQgD,OAAQ3N,EAAG/U,IAAKoF,GAAM,EAAKqO,EAAM,KAAUiV,GACnHG,EAAInJ,EAAQgD,OAAQ3N,EAAG/U,IAAKoF,GAAM,EAAK,GAAK,OAAasjB,EAAE1c,IAAK0T,EAAQgD,OAAQ3N,EAAG/U,IAAKoF,GAAM,EAAK,EAAKqO,KAAWiV,GAEzH46B,EAAIvjD,OAAQqF,GAAMoQ,EAAGE,EAAGmT,GAAK,IAIvBy6B,EAAI10C,WAAW,IA0TvB,MAAM20C,GAQL,WAAA73D,CAAaiD,EAAO60D,GAOnB53D,KAAK+C,MAAQA,EAOb/C,KAAK43D,KAAOA,EAQZ53D,KAAK63D,SAAW/sD,KAQhB9K,KAAK83D,eAAiB,KAStB93D,KAAK+3D,WAAa,IAEnB,CAKA,KAAAt2D,GAEC,MAAM8I,EAAS,CAAEytD,EAAMz8C,KAEtBvb,KAAK+3D,WAAa/3D,KAAK63D,SAASI,sBAAuB1tD,IAE1B,IAAxBvK,KAAK43D,KAAKM,WAAqBl4D,KAAK43D,KAAKO,QAE9Cn4D,KAAK+C,MAAMwB,UAAUgG,SAErBvK,KAAK43D,KAAKr8C,MAAQvb,KAAK+C,MAAMwB,UAAUuoC,QAEV,OAAxB9sC,KAAK83D,gBAA0B93D,KAAK83D,eAAgBE,EAAMz8C,EAAO,EAIvEhR,GAED,CAKA,IAAA6tD,GAECp4D,KAAK63D,SAASQ,qBAAsBr4D,KAAK+3D,YAEzC/3D,KAAK+3D,WAAa,IAEnB,CAOA,gBAAAO,CAAkBhuD,GAEjBtK,KAAK83D,eAAiBxtD,CAEvB,CAOA,UAAA+gB,CAAYhpB,GAEXrC,KAAK63D,SAAWx1D,CAEjB,CAKA,OAAA4I,GAECjL,KAAKo4D,MAEN,EAYD,MAAMG,GAKL,WAAAz4D,GAOCE,KAAKw4D,QAAU,IAAIt4D,OAEpB,CAQA,GAAAY,CAAKgD,GAEJ,IAAIwT,EAAMtX,KAAKw4D,QAEf,IAAM,IAAIn0D,EAAI,EAAGA,EAAIP,EAAKE,OAAQK,IAIjC,GAFAiT,EAAMA,EAAIxW,IAAKgD,EAAMO,SAERtD,IAARuW,EAAoB,OAI1B,OAAOA,EAAIxW,IAAKgD,EAAMA,EAAKE,OAAS,GAErC,CASA,GAAAxB,CAAKsB,EAAMZ,GAEV,IAAIoU,EAAMtX,KAAKw4D,QAEf,IAAM,IAAIn0D,EAAI,EAAGA,EAAIP,EAAKE,OAAQK,IAAO,CAExC,MAAMyK,EAAMhL,EAAMO,IAEM,IAAnBiT,EAAI3W,IAAKmO,IAAkBwI,EAAI9U,IAAKsM,EAAK,IAAI5O,SAElDoX,EAAMA,EAAIxW,IAAKgO,EAEhB,CAIA,OAFAwI,EAAI9U,IAAKsB,EAAMA,EAAKE,OAAS,GAAKd,GAE3BlD,IAER,CAQA,OAAQ8D,GAEP,IAAIwT,EAAMtX,KAAKw4D,QAEf,IAAM,IAAIn0D,EAAI,EAAGA,EAAIP,EAAKE,OAAQK,IAIjC,GAFAiT,EAAMA,EAAIxW,IAAKgD,EAAMO,SAERtD,IAARuW,EAAoB,OAAO,EAIjC,OAAOA,EAAI04B,OAAQlsC,EAAMA,EAAKE,OAAS,GAExC,EAID,IAAIy0D,GAAQ,EAsDZ,MAAMC,GAgBL,WAAA54D,CAAaiD,EAAO41D,EAAY71D,EAAUxC,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYohB,EAAexjB,GAErGp1C,KAAKoD,GAAKq1D,KAQVz4D,KAAK64D,OAAS91D,EAQd/C,KAAK84D,YAAcH,EAOnB34D,KAAK8C,SAAWA,EAOhB9C,KAAKM,OAASA,EAOdN,KAAKiB,SAAWA,EAOhBjB,KAAK29C,MAAQA,EAOb39C,KAAK43B,OAASA,EAOd53B,KAAKw3C,WAAaA,EAOlBx3C,KAAKqC,QAAUu2D,EAOf54D,KAAKgB,SAAWV,EAAOU,SAOvBhB,KAAKuB,QAAUN,EAASM,QAQxBvB,KAAKwB,UAAY,KAUjBxB,KAAKmB,WAAa,KASlBnB,KAAK+4D,SAAW,KAShB/4D,KAAKg5D,cAAgB,KAQrBh5D,KAAKi5D,WAAa,KASlBj5D,KAAKiC,OAAS,KAOdjC,KAAKo1C,gBAAkBA,EAOvBp1C,KAAKk5D,wBAA8C,OAApB9jB,EAA2BA,EAAgB+jB,SAAW,GAOrFn5D,KAAKo5D,qBAAuBp5D,KAAKq5D,qBAOjCr5D,KAAKs5D,gBAAkBt5D,KAAKkG,cAS5BlG,KAAKu5D,kBAAoB,KASzBv5D,KAAKw5D,UAAY,KASjBx5D,KAAKy5D,SAAW,KAQhBz5D,KAAK05D,UAAY,KASjB15D,KAAK25D,gBAAiB,EAQtB35D,KAAK45D,kBAAoB,KAExB55D,KAAKiL,SAAS,EAIfjL,KAAKiB,SAASivC,iBAAkB,UAAWlwC,KAAK45D,kBAEjD,CAOA,cAAAC,CAAgBx3D,GAEfrC,KAAKo1C,gBAAkB/yC,CAExB,CAQA,uBAAIy3D,GAEH,OAA8B,OAAzB95D,KAAKo1C,iBAA4Bp1C,KAAKo1C,gBAAgB+jB,WAAan5D,KAAKk5D,0BAE7El5D,KAAKk5D,wBAA0Bl5D,KAAKo1C,gBAAgB+jB,UAE7C,EAER,CAQA,0BAAIY,GAEH,OAA0C,IAAnC/5D,KAAKiB,SAASs0C,iBAA4Bv1C,KAAKo1C,gBAAgB4kB,mBAAqB,CAE5F,CAOA,mBAAAC,GAEC,OAAOj6D,KAAKu5D,oBAAuBv5D,KAAKu5D,kBAAoBv5D,KAAK64D,OAAOqB,aAAcl6D,MAEvF,CAOA,UAAAm6D,GAEC,OAAOn6D,KAAKy5D,WAAcz5D,KAAKy5D,SAAWz5D,KAAKi6D,sBAAsB1gB,QAEtE,CAOA,WAAA6gB,GAEC,OAAOp6D,KAAKw5D,YAAex5D,KAAKw5D,UAAYx5D,KAAKi6D,sBAAsBI,iBAExE,CAOA,QAAAC,GAEC,OAAOt6D,KAAK84D,YAAYwB,SAAUt6D,KAEnC,CAOA,WAAAu6D,GAEC,OAAOv6D,KAAK84D,YAAYyB,YAAav6D,KAEtC,CAOA,aAAAw6D,GAEC,MAAO,CAAEx6D,KAAKM,OAAQN,KAAKiB,SAAUjB,KAAKqC,QAASrC,KAAKw3C,WAEzD,CAQA,WAAAijB,CAAaz5D,GAEZhB,KAAKgB,SAAWA,EAChBhB,KAAKmB,WAAa,IAEnB,CAQA,aAAAu5D,GAEC,GAAyB,OAApB16D,KAAKmB,WAAsB,OAAOnB,KAAKmB,WAE5C,MAAMw5D,EAAiB36D,KAAKi6D,sBAAsBU,eAC5C35D,EAAWhB,KAAKgB,SAEhBG,EAAa,GACb63D,EAAgB,IAAI4B,IAE1B,IAAM,MAAM1qC,KAAiByqC,EAAiB,CAE7C,MAAMh4D,EAAYutB,EAAc/pB,MAAQ+pB,EAAc/pB,KAAKxD,UAAYutB,EAAc/pB,KAAKxD,UAAY3B,EAASkyB,aAAchD,EAAcxtB,MAE3I,QAAmB3B,IAAd4B,EAA0B,SAE/BxB,EAAW2E,KAAMnD,GAEjB,MAAMqtB,EAAkBrtB,EAAUk4D,6BAA+Bl4D,EAAU9B,KAAO8B,EAClFq2D,EAAc5kD,IAAK4b,EAEpB,CAKA,OAHAhwB,KAAKmB,WAAaA,EAClBnB,KAAKg5D,cAAgBj0D,MAAMoD,KAAM6wD,EAAcnzD,UAExC1E,CAER,CAOA,gBAAA25D,GAIC,OAF4B,OAAvB96D,KAAKg5D,eAAyBh5D,KAAK06D,gBAEjC16D,KAAKg5D,aAEb,CAOA,iBAAA+B,GAEC,MAAM,OAAEz6D,EAAM,SAAEW,EAAQ,SAAED,EAAQ,MAAEoa,EAAK,UAAE5Z,GAAcxB,KAEnDi5D,EAAaj5D,KAAKi5D,aAAgBj5D,KAAKi5D,WAAa,CACzD+B,YAAa,EACbC,YAAa,EACbC,cAAe,EACfC,cAAe,IAGV75D,EAAQtB,KAAKs6D,WACbc,EAAuB,OAAV95D,EACb45D,EAAgBl6D,EAASq6D,0BAA4Br6D,EAASk6D,cAAkB56D,EAAOoB,MAAQ,EAAIpB,EAAOoB,MAAQ,EAExH,GAAuB,IAAlBw5D,EAAsB,OAAO,KAIlC,GAFAjC,EAAWiC,cAAgBA,GAEG,IAAzB56D,EAAO25C,cAAyB,OAAOgf,EAE5C,IAAIqC,EAAc,GAEU,IAAvBr6D,EAASs6D,WAAwBj7D,EAAOk7D,UAAcl7D,EAAOm7D,gBAAoBn7D,EAAOo7D,QAAYp7D,EAAOq7D,aAE/GL,EAAc,GAIf,IAAIL,EAAcz5D,EAAUC,MAAQ65D,EAChCM,GAAep6D,EAAUC,MAAQD,EAAUE,OAAU45D,EAE1C,OAAVlgD,IAEJ6/C,EAAch2D,KAAKoM,IAAK4pD,EAAa7/C,EAAM3Z,MAAQ65D,GACnDM,EAAa32D,KAAKu8C,IAAKoa,GAAcxgD,EAAM3Z,MAAQ2Z,EAAM1Z,OAAU45D,IAIpE,MAAMzvB,EAAW7qC,EAASG,WAAW0qC,SACrC,IAAIgwB,EAAYC,IAEXV,EAEJS,EAAYv6D,EAAMI,MAEPmqC,UAEXgwB,EAAYhwB,EAASnqC,OAItBu5D,EAAch2D,KAAKoM,IAAK4pD,EAAa,GACrCW,EAAa32D,KAAKu8C,IAAKoa,EAAYC,GAEnC,MAAMn6D,EAAQk6D,EAAaX,EAE3B,OAAKv5D,EAAQ,GAAKA,IAAUo6D,IAAkB,MAE9C7C,EAAW+B,YAAct5D,EACzBu3D,EAAWgC,YAAcA,EAElBhC,EAER,CASA,mBAAA8C,GAEC,MAAM,SAAE/6D,GAAahB,KAErB,IAAIm5D,EAAW,GAEf,IAAM,MAAMz2D,KAAQmB,OAAOC,KAAM9C,EAASG,YAAauS,OAAS,CAE/D,MAAM/Q,EAAY3B,EAASG,WAAYuB,GAEvCy2D,GAAYz2D,EAAO,IAEdC,EAAU9B,OAAOs4D,GAAYx2D,EAAU9B,KAAKgvB,OAAS,KACrDltB,EAAUmtB,SAASqpC,GAAYx2D,EAAUmtB,OAAS,KAClDntB,EAAUitB,WAAWupC,GAAYx2D,EAAUitB,SAAW,KACtDjtB,EAAUq5D,aAAa7C,GAAY,KAEzC,CAQA,OANKn4D,EAASM,QAEb63D,GAAY,UAINA,CAER,CASA,mBAAA8C,GAEC,MAAM,OAAE37D,EAAM,SAAEW,GAAajB,KAE7B,IAAIm5D,EAAWl4D,EAASm3C,wBAExB,IAAM,MAAMx1C,KAnkBd,SAAkB6V,GAEjB,MAAM3U,EAAOD,OAAOC,KAAM2U,GAE1B,IAAIyjD,EAAQr4D,OAAOs4D,eAAgB1jD,GAEnC,KAAQyjD,GAAQ,CAEf,MAAMxgB,EAAc73C,OAAO83C,0BAA2BugB,GAEtD,IAAM,MAAMptD,KAAO4sC,EAElB,QAA4B36C,IAAvB26C,EAAa5sC,GAAsB,CAEvC,MAAMstD,EAAa1gB,EAAa5sC,GAE3BstD,GAAwC,mBAAnBA,EAAWt7D,KAEpCgD,EAAKgC,KAAMgJ,EAIb,CAIDotD,EAAQr4D,OAAOs4D,eAAgBD,EAEhC,CAEA,OAAOp4D,CAER,CAmiB0Bu4D,CAASp7D,GAAa,CAE7C,GAAK,8DAA8DqT,KAAM1R,GAAa,SAEtF,MAAMM,EAAQjC,EAAU2B,GAExB,IAAI05D,EAEJ,GAAe,OAAVp5D,EAAiB,CAIrB,MAAMqE,SAAcrE,EAEN,WAATqE,EAEJ+0D,EAAqB,IAAVp5D,EAAc,IAAM,IAEX,WAATqE,GAEX+0D,EAAW,IAENp5D,EAAMC,YAEVm5D,GAAYp5D,EAAM0rB,SAInB0tC,GAAY,KAIZA,EAAWv0D,OAAQ7E,EAIrB,MAECo5D,EAAWv0D,OAAQ7E,GAIpBi2D,GAAiCmD,EAAW,GAE7C,CA4CA,OA1CAnD,GAAYn5D,KAAKk5D,wBAA0B,IAEtC54D,EAAOU,WAEXm4D,GAAYn5D,KAAK+7D,uBAIbz7D,EAAOgrC,WAEX6tB,GAAY74D,EAAOgrC,SAASC,MAAMvnC,OAAS,KAIvC1D,EAAOyB,wBAEXo3D,GAAY74D,EAAOyB,sBAAsBiC,OAAS,KAI9C1D,EAAO25C,gBAEXkf,GAAY74D,EAAO4pC,iBAAiBpgC,KAAO,IAEZ,OAA1BxJ,EAAOiqC,iBAEX4uB,GAAY74D,EAAOiqC,eAAezgC,KAAO,MAMtCxJ,EAAOoB,MAAQ,IAInBy3D,GAAY74D,EAAOwJ,KAAO,KAI3BqvD,GAAY74D,EAAOi8D,cAAgB,IAE5Bl3D,EAAY8zD,EAEpB,CAQA,uBAAIqD,GAEH,OAAOx8D,KAAKgB,SAASoC,KAAOpD,KAAKM,OAAOU,SAASoC,EAElD,CAmBA,eAAIgH,GAEH,OAA4CpK,KAAKo5D,uBAAyBp5D,KAAKq5D,sBAAwBr5D,KAAK85D,mBAE7G,CAOA,kBAAAT,GAIC,IAAIF,EAAWn5D,KAAK64D,OAAO3yD,YAAalG,KAAK29C,MAAO39C,KAAKw3C,YAQzD,OANKx3C,KAAKM,OAAOi8D,gBAEhBpD,GAAY,GAINA,CAER,CAOA,WAAAjzD,GAEC,OAAOlG,KAAKi8D,sBAAwBj8D,KAAKq5D,oBAE1C,CAKA,OAAApuD,GAECjL,KAAKiB,SAASgvC,oBAAqB,UAAWjwC,KAAK45D,mBAEnD55D,KAAK05D,WAEN,EAID,MAAM+C,GAAc,GAOpB,MAAMC,GAYL,WAAA58D,CAAagD,EAAUC,EAAO41D,EAAYgE,EAAWC,EAAUhF,GAO9D53D,KAAK8C,SAAWA,EAOhB9C,KAAK+C,MAAQA,EAOb/C,KAAK24D,WAAaA,EAOlB34D,KAAK28D,UAAYA,EAOjB38D,KAAK48D,SAAWA,EAOhB58D,KAAK43D,KAAOA,EAQZ53D,KAAK68D,UAAY,CAAC,CAEnB,CAeA,GAAA/7D,CAAKR,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYohB,EAAexjB,EAAiB0nB,GAEjF,MAAMC,EAAW/8D,KAAKg9D,YAAaF,GAGnCL,GAAa,GAAMn8D,EACnBm8D,GAAa,GAAMx7D,EACnBw7D,GAAa,GAAM7D,EACnB6D,GAAa,GAAMjlB,EAEnB,IAAI92C,EAAeq8D,EAASj8D,IAAK27D,IAoCjC,YAlCsB17D,IAAjBL,GAEJA,EAAeV,KAAKi9D,mBAAoBj9D,KAAK+C,MAAO/C,KAAK24D,WAAY34D,KAAK8C,SAAUxC,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYohB,EAAexjB,EAAiB0nB,GAEjKC,EAASv6D,IAAKi6D,GAAa/7D,KAI3BA,EAAam5D,eAAgBzkB,GAExB10C,EAAa87D,qBAEjB97D,EAAa+5D,YAAan6D,EAAOU,WAI7BN,EAAaa,UAAYN,EAASM,SAAWb,EAAa0J,eAEzD1J,EAAa44D,kBAAoB54D,EAAawF,eAElDxF,EAAauK,UAEbvK,EAAeV,KAAKc,IAAKR,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYohB,EAAexjB,EAAiB0nB,IAItGp8D,EAAaa,QAAUN,EAASM,UAQ5Bb,CAER,CAQA,WAAAs8D,CAAaF,EAAS,WAErB,OAAO98D,KAAK68D,UAAWC,KAAc98D,KAAK68D,UAAWC,GAAW,IAAIvE,GAErE,CAKA,OAAAttD,GAECjL,KAAK68D,UAAY,CAAC,CAEnB,CAkBA,kBAAAI,CAAoBl6D,EAAO41D,EAAY71D,EAAUxC,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYohB,EAAexjB,EAAiB0nB,GAE7H,MAAMC,EAAW/8D,KAAKg9D,YAAaF,GAE7Bp8D,EAAe,IAAIg4D,GAAc31D,EAAO41D,EAAY71D,EAAUxC,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYohB,EAAexjB,GAYhI,OAVA10C,EAAag5D,UAAY,KAExB15D,KAAK28D,UAAU3sB,OAAQtvC,GACvBV,KAAK48D,SAAS5sB,OAAQtvC,GACtBV,KAAK+C,MAAMitC,OAAQtvC,GAEnBq8D,EAAS/sB,OAAQtvC,EAAa85D,gBAAiB,EAIzC95D,CAER,EAWD,MAAMw8D,GAKL,WAAAp9D,GAQCE,KAAKa,KAAO,IAAIX,OAEjB,CAQA,GAAAY,CAAKR,GAEJ,IAAIgX,EAAMtX,KAAKa,KAAKC,IAAKR,GASzB,YAPaS,IAARuW,IAEJA,EAAM,CAAC,EACPtX,KAAKa,KAAK2B,IAAKlC,EAAQgX,IAIjBA,CAER,CAQA,OAAQhX,GAEP,IAAIgX,EAAM,KAUV,OARKtX,KAAKa,KAAKF,IAAKL,KAEnBgX,EAAMtX,KAAKa,KAAKC,IAAKR,GAErBN,KAAKa,KAAKmvC,OAAQ1vC,IAIZgX,CAER,CAQA,GAAA3W,CAAKL,GAEJ,OAAON,KAAKa,KAAKF,IAAKL,EAEvB,CAKA,OAAA2K,GAECjL,KAAKa,KAAO,IAAIX,OAEjB,EAID,MAAMi9D,GACG,EADHA,GAEE,EAFFA,GAGI,EAHJA,GAIK,EAKLC,GAAkB,GAaxB,MAAMC,WAAmBH,GAOxB,WAAAp9D,CAAaw9D,GAEZ5zD,QAOA1J,KAAKs9D,QAAUA,CAEhB,CAQA,OAAQ36D,GAEP,MAAM46D,EAAgB7zD,MAAMsmC,OAAQrtC,GAQpC,YANuB5B,IAAlBw8D,GAEJv9D,KAAKs9D,QAAQE,iBAAkB76D,GAIzB46D,CAER,CASA,MAAAhzD,CAAQ5H,EAAW4E,GAElB,MAAM1G,EAAOb,KAAKc,IAAK6B,GAEvB,QAAsB5B,IAAjBF,EAAKU,QAEJgG,IAAS41D,GAEbn9D,KAAKs9D,QAAQG,gBAAiB96D,GAEnB4E,IAAS41D,GAEpBn9D,KAAKs9D,QAAQI,qBAAsB/6D,GAExB4E,IAAS41D,GAEpBn9D,KAAKs9D,QAAQK,uBAAwBh7D,GAE1B4E,IAAS41D,IAEpBn9D,KAAKs9D,QAAQM,+BAAgCj7D,GAI9C9B,EAAKU,QAAUvB,KAAK69D,oBAAqBl7D,GAAYpB,YAE/C,CAEN,MAAMyuB,EAAkBhwB,KAAK69D,oBAAqBl7D,IAE7C9B,EAAKU,QAAUyuB,EAAgBzuB,SAAWyuB,EAAgBb,QAAU,SAExEnvB,KAAKs9D,QAAQQ,gBAAiBn7D,GAE9B9B,EAAKU,QAAUyuB,EAAgBzuB,QAIjC,CAED,CASA,mBAAAs8D,CAAqBl7D,GAIpB,OAFKA,EAAUk4D,+BAA+Bl4D,EAAYA,EAAU9B,MAE7D8B,CAER,EAkCD,SAASo7D,GAAqB/8D,GAE7B,OAA4B,OAAnBA,EAASM,MAAmBN,EAASM,MAAMC,QAAUP,EAASG,WAAW0qC,SAAStqC,OAE5F,CAUA,SAASy8D,GAAmBh9D,GAE3B,MAAMi9D,EAAU,GAEVC,EAAgBl9D,EAASM,MACzB68D,EAAmBn9D,EAASG,WAAW0qC,SAE7C,GAAuB,OAAlBqyB,EAAyB,CAE7B,MAAM14D,EAAQ04D,EAAc14D,MAE5B,IAAM,IAAInB,EAAI,EAAG+oC,EAAI5nC,EAAMxB,OAAQK,EAAI+oC,EAAG/oC,GAAK,EAAI,CAElD,MAAMwb,EAAIra,EAAOnB,EAAI,GACfyb,EAAIta,EAAOnB,EAAI,GACfgE,EAAI7C,EAAOnB,EAAI,GAErB45D,EAAQn4D,KAAM+Z,EAAGC,EAAGA,EAAGzX,EAAGA,EAAGwX,EAE9B,CAED,KAAO,CAIN,IAAM,IAAIxb,EAAI,EAAG+oC,EAFH+wB,EAAiB34D,MAEFxB,OAAS,EAAM,EAAGK,EAAI+oC,EAAG/oC,GAAK,EAAI,CAE9D,MAAMwb,EAAIxb,EAAI,EACRyb,EAAIzb,EAAI,EACRgE,EAAIhE,EAAI,EAEd45D,EAAQn4D,KAAM+Z,EAAGC,EAAGA,EAAGzX,EAAGA,EAAGwX,EAE9B,CAED,CAEA,MAAMld,EAAY,IAzEnB,SAA2B6C,GAI1B,IAAM,IAAInB,EAAImB,EAAMxB,OAAS,EAAGK,GAAK,IAAMA,EAE1C,GAAKmB,EAAOnB,IAAO,MAAQ,OAAO,EAInC,OAAO,CAER,CA6DyB+5D,CAAkBH,GAAY,MAAwB,OAAyBA,EAAS,GAGhH,OAFAt7D,EAAUpB,QAAUw8D,GAAqB/8D,GAElC2B,CAER,CAQA,MAAM07D,WAAmBnB,GAQxB,WAAAp9D,CAAaqB,EAAYy2D,GAExBluD,QAOA1J,KAAKmB,WAAaA,EAOlBnB,KAAK43D,KAAOA,EAOZ53D,KAAKs+D,WAAa,IAAIp+D,QAQtBF,KAAKu+D,cAAgB,IAAIr+D,OAE1B,CAQA,GAAAS,CAAKD,GAEJ,MAAMM,EAAWN,EAAaM,SAE9B,OAAO0I,MAAM/I,IAAKK,KAAmD,IAArChB,KAAKc,IAAKE,GAAWmM,WAEtD,CAOA,eAAAqxD,CAAiB99D,IAEkB,IAA7BV,KAAKW,IAAKD,IAA2BV,KAAKy+D,aAAc/9D,GAE7DV,KAAK0+D,iBAAkBh+D,EAExB,CAOA,YAAA+9D,CAAc/9D,GAEb,MAAMM,EAAWN,EAAaM,SACThB,KAAKc,IAAKE,GAElBmM,aAAc,EAE3BnN,KAAK43D,KAAK+G,OAAOhG,aAEjB,MAAMe,EAAY,KAEjB15D,KAAK43D,KAAK+G,OAAOhG,aAEjB,MAAMr3D,EAAQN,EAASM,MACjBs9D,EAAqBl+D,EAAag6D,gBAEzB,OAAVp5D,GAEJtB,KAAKmB,WAAW6uC,OAAQ1uC,GAIzB,IAAM,MAAMu9D,KAAqBD,EAEhC5+D,KAAKmB,WAAW6uC,OAAQ6uB,GAIzB,MAAMC,EAAqB9+D,KAAKs+D,WAAWx9D,IAAKE,QAEpBD,IAAvB+9D,GAEJ9+D,KAAKmB,WAAW6uC,OAAQ8uB,GAIzB99D,EAASivC,oBAAqB,UAAWypB,EAAW,EAIrD14D,EAASkvC,iBAAkB,UAAWwpB,EAEvC,CAOA,gBAAAgF,CAAkBh+D,GAIjB,MAAMS,EAAaT,EAAag6D,gBAEhC,IAAM,MAAM/3D,KAAaxB,EAEnBwB,EAAUo8D,0BAA4Bp8D,EAAUq8D,kCAEpDh/D,KAAK89D,gBAAiBn7D,EAAWw6D,IAIjCn9D,KAAK89D,gBAAiBn7D,EAAWw6D,IAQnC,MAAM77D,EAAQtB,KAAKs6D,SAAU55D,GAEd,OAAVY,GAEJtB,KAAK89D,gBAAiBx8D,EAAO67D,IAM9B,MAAMhe,EAAWz+C,EAAaM,SAASm+C,SAErB,OAAbA,GAEJn/C,KAAK89D,gBAAiB3e,EAAUge,GAIlC,CAQA,eAAAW,CAAiBn7D,EAAW4E,GAE3B,MAAM03D,EAASj/D,KAAK43D,KAAKsH,OAAOC,MAEzBx8D,EAAUk4D,kCAY6B95D,IAAxCf,KAAKu+D,cAAcz9D,IAAK6B,IAE5B3C,KAAKmB,WAAWoJ,OAAQ5H,EAAW4E,GAEnCvH,KAAKu+D,cAAc/7D,IAAKG,EAAWs8D,IAExBj/D,KAAKu+D,cAAcz9D,IAAK6B,EAAU9B,QAAWo+D,IAExDj/D,KAAKmB,WAAWoJ,OAAQ5H,EAAW4E,GAEnCvH,KAAKu+D,cAAc/7D,IAAKG,EAAU9B,KAAMo+D,GAExCj/D,KAAKu+D,cAAc/7D,IAAKG,EAAWs8D,IAtB/Bj/D,KAAKu+D,cAAcz9D,IAAK6B,KAAgBs8D,IAE5Cj/D,KAAKmB,WAAWoJ,OAAQ5H,EAAW4E,GAEnCvH,KAAKu+D,cAAc/7D,IAAKG,EAAWs8D,GAwBtC,CAQA,WAAA1E,CAAa75D,GAEZ,OAAOA,EAAaM,SAASm+C,QAE9B,CASA,QAAAmb,CAAU55D,GAET,MAAM,SAAEM,EAAQ,SAAEC,GAAaP,EAE/B,IAAIY,EAAQN,EAASM,MAErB,IAA4B,IAAvBL,EAASs6D,UAAqB,CAElC,MAAM+C,EAAat+D,KAAKs+D,WAExB,IAAIQ,EAAqBR,EAAWx9D,IAAKE,QAEbD,IAAvB+9D,GAEJA,EAAqBd,GAAmBh9D,GAExCs9D,EAAW97D,IAAKxB,EAAU89D,IAEfA,EAAmBv9D,UAAYw8D,GAAqB/8D,KAE/DhB,KAAKmB,WAAW6uC,OAAQ8uB,GAExBA,EAAqBd,GAAmBh9D,GAExCs9D,EAAW97D,IAAKxB,EAAU89D,IAI3Bx9D,EAAQw9D,CAET,CAEA,OAAOx9D,CAER,EASD,MAAM89D,GAKL,WAAAt/D,GAWCE,KAAKk4D,WAAY,EAUjBl4D,KAAKub,MAAQ,EAUbvb,KAAKm/D,MAAQ,EAiBbn/D,KAAKk/D,OAAS,CACbC,MAAO,EACPE,WAAY,EACZC,UAAW,EACXC,UAAW,EACXC,OAAQ,EACRC,MAAO,EACPC,UAAW,EACXC,mBAAoB,EACpBC,eAAgB,GAcjB5/D,KAAKkxB,QAAU,CACdiuC,MAAO,EACPE,WAAY,EACZK,UAAW,EACXC,mBAAoB,EACpBC,eAAgB,GAWjB5/D,KAAK2+D,OAAS,CACbhG,WAAY,EACZjqD,SAAU,EAGZ,CASA,MAAAnE,CAAQjK,EAAQoB,EAAOw5D,GAEtBl7D,KAAKk/D,OAAOI,YAEPh/D,EAAOu/D,QAAUv/D,EAAOw/D,SAE5B9/D,KAAKk/D,OAAOK,WAAarE,GAAkBx5D,EAAQ,GAExCpB,EAAOk7D,SAElBx7D,KAAKk/D,OAAOM,QAAUtE,EAAgBx5D,EAE3BpB,EAAOm7D,eAElBz7D,KAAKk/D,OAAOO,OAASvE,GAAkBx5D,EAAQ,GAEpCpB,EAAOo7D,OAElB17D,KAAKk/D,OAAOO,OAASvE,GAAkBx5D,EAAQ,GAI/C+K,QAAQkiB,MAAO,yCAIjB,CAQA,eAAAoxC,CAAiBx4D,EAAMywD,GAEe,IAAhCh4D,KAAMuH,GAAOq4D,iBAEjB5/D,KAAMuH,GAAOm4D,UAAY,GAK1B1/D,KAAMuH,GAAOm4D,WAAa1H,EAE1Bh4D,KAAMuH,GAAOq4D,iBAGR5/D,KAAMuH,GAAOq4D,gBAAkB5/D,KAAMuH,GAAOo4D,qBAEhD3/D,KAAMuH,GAAOq4D,eAAiB,EAKhC,CAKA,KAAAzH,GAEC,MAAM6H,EAA2BhgE,KAAKk/D,OAAOG,WAC7Cr/D,KAAKk/D,OAAOS,mBAAqBK,EAEjC,MAAMC,EAA4BjgE,KAAKkxB,QAAQmuC,WAC/Cr/D,KAAKkxB,QAAQyuC,mBAAqBM,EAGlCjgE,KAAKk/D,OAAOI,UAAY,EACxBt/D,KAAKk/D,OAAOG,WAAa,EACzBr/D,KAAKkxB,QAAQmuC,WAAa,EAE1Br/D,KAAKk/D,OAAOK,UAAY,EACxBv/D,KAAKk/D,OAAOM,OAAS,EACrBx/D,KAAKk/D,OAAOO,MAAQ,CAGrB,CAKA,OAAAx0D,GAECjL,KAAKm4D,QAELn4D,KAAKm/D,MAAQ,EAEbn/D,KAAKk/D,OAAOC,MAAQ,EACpBn/D,KAAKkxB,QAAQiuC,MAAQ,EAErBn/D,KAAKk/D,OAAOQ,UAAY,EACxB1/D,KAAKkxB,QAAQwuC,UAAY,EACzB1/D,KAAK2+D,OAAOhG,WAAa,EACzB34D,KAAK2+D,OAAOjwD,SAAW,CAExB,EAUD,MAAMwxD,GAOL,WAAApgE,CAAaq5D,GAOZn5D,KAAKm5D,SAAWA,EAQhBn5D,KAAKmgE,UAAY,CAElB,EAUD,MAAMC,WAAuBF,GAS5B,WAAApgE,CAAaq5D,EAAUkH,EAAeC,GAErC52D,MAAOyvD,GAOPn5D,KAAKqgE,cAAgBA,EAOrBrgE,KAAKsgE,gBAAkBA,CAExB,EAUD,MAAMC,WAAwBL,GAQ7B,WAAApgE,CAAaq5D,EAAUqH,GAEtB92D,MAAOyvD,GAOPn5D,KAAKwgE,eAAiBA,EAStBxgE,KAAKygE,mBAAoB,CAE1B,EAID,IAAIC,GAAQ,EASZ,MAAMC,GAWL,WAAA7gE,CAAa8gE,EAAMC,EAAOn+D,EAAMo+D,EAAa,KAAM3/D,EAAa,MAO/DnB,KAAKoD,GAAKs9D,KAOV1gE,KAAK4gE,KAAOA,EAOZ5gE,KAAK6gE,MAAQA,EAQb7gE,KAAK0C,KAAOA,EAOZ1C,KAAK8gE,WAAaA,EAOlB9gE,KAAKmB,WAAaA,EAQlBnB,KAAKmgE,UAAY,CAElB,EAUD,MAAMY,WAAkB7D,GAQvB,WAAAp9D,CAAaw9D,EAASv6D,GAErB2G,QAOA1J,KAAKs9D,QAAUA,EAOft9D,KAAK+C,MAAQA,EAUb/C,KAAK48D,SAAW,KAQhB58D,KAAKghE,OAAS,IAAIt6D,IASlB1G,KAAKihE,SAAW,CACfpnB,OAAQ,IAAInzC,IACZw6D,SAAU,IAAIx6D,IACdwqB,QAAS,IAAIxqB,IAGf,CASA,aAAAy6D,CAAezwC,EAAaksC,GAE3B,MAAM,QAAEU,GAAYt9D,KAEda,EAAOb,KAAKc,IAAK4vB,GAEvB,GAAK1wB,KAAKohE,oBAAqB1wC,GAAgB,CAE9C,MAAM2wC,EAAmBxgE,EAAKk4D,SAEzBsI,IAEJA,EAAiBlB,YACjBkB,EAAiBb,eAAeL,aAMjC,MAAMmB,EAAmBthE,KAAK+C,MAAMo+D,cAAezwC,GAInD,IAAI6wC,EAAevhE,KAAKihE,SAAS/vC,QAAQpwB,IAAKwgE,EAAiBE,oBAEzCzgE,IAAjBwgE,IAECF,GAAkE,IAA9CA,EAAiBb,eAAeL,WAAkBngE,KAAKyhE,gBAAiBJ,EAAiBb,gBAElHe,EAAe,IAAIZ,GAAmBW,EAAiBE,cAAe,UAAW9wC,EAAYhuB,KAAM4+D,EAAiBR,WAAYQ,EAAiB3G,gBACjJ36D,KAAKihE,SAAS/vC,QAAQ1uB,IAAK8+D,EAAiBE,cAAeD,GAE3DjE,EAAQoE,cAAeH,IAMxB,MAAMpI,EAAWn5D,KAAK2hE,oBAAqBjxC,EAAa6wC,GAExD,IAAIxI,EAAW/4D,KAAKghE,OAAOlgE,IAAKq4D,QAEdp4D,IAAbg4D,IAECsI,GAAmD,IAA/BA,EAAiBlB,WAAkBngE,KAAK4hE,iBAAkBP,GAEnFtI,EAAW/4D,KAAK6hE,oBAAqBnxC,EAAa6wC,EAAcpI,EAAUyD,IAM3E7D,EAASoH,YACToB,EAAapB,YAIbt/D,EAAKU,QAAUmvB,EAAYnvB,QAC3BV,EAAKk4D,SAAWA,CAEjB,CAEA,OAAOl4D,EAAKk4D,QAEb,CASA,YAAAmB,CAAcx5D,EAAcohE,EAAW,MAEtC,MAAM,QAAExE,GAAYt9D,KAEda,EAAOb,KAAKc,IAAKJ,GAEvB,GAAKV,KAAK+hE,mBAAoBrhE,GAAiB,CAE9C,MAAM2gE,EAAmBxgE,EAAKk4D,SAEzBsI,IAEJA,EAAiBlB,YACjBkB,EAAiBhB,cAAcF,YAC/BkB,EAAiBf,gBAAgBH,aAMlC,MAAMmB,EAAmB5gE,EAAau5D,sBAEhCv3D,EAAOhC,EAAaO,SAAWP,EAAaO,SAASyB,KAAO,GAIlE,IAAIs/D,EAAchiE,KAAKihE,SAASpnB,OAAO/4C,IAAKwgE,EAAiBW,mBAExClhE,IAAhBihE,IAECX,GAAiE,IAA7CA,EAAiBhB,cAAcF,WAAkBngE,KAAKyhE,gBAAiBJ,EAAiBhB,eAEjH2B,EAAc,IAAIrB,GAAmBW,EAAiBW,aAAc,SAAUv/D,GAC9E1C,KAAKihE,SAASpnB,OAAOr3C,IAAK8+D,EAAiBW,aAAcD,GAEzD1E,EAAQoE,cAAeM,IAIxB,IAAIE,EAAgBliE,KAAKihE,SAASC,SAASpgE,IAAKwgE,EAAiBa,qBAE1CphE,IAAlBmhE,IAECb,GAAmE,IAA/CA,EAAiBf,gBAAgBH,WAAkBngE,KAAKyhE,gBAAiBJ,EAAiBf,iBAEnH4B,EAAgB,IAAIvB,GAAmBW,EAAiBa,eAAgB,WAAYz/D,GACpF1C,KAAKihE,SAASC,SAAS1+D,IAAK8+D,EAAiBa,eAAgBD,GAE7D5E,EAAQoE,cAAeQ,IAMxB,MAAM/I,EAAWn5D,KAAKoiE,mBAAoB1hE,EAAcshE,EAAaE,GAErE,IAAInJ,EAAW/4D,KAAKghE,OAAOlgE,IAAKq4D,QAEdp4D,IAAbg4D,GAECsI,GAAmD,IAA/BA,EAAiBlB,WAAkBngE,KAAK4hE,iBAAkBP,GAEnFtI,EAAW/4D,KAAKqiE,mBAAoB3hE,EAAcshE,EAAaE,EAAe/I,EAAU2I,IAIxFphE,EAAaq4D,SAAWA,EAMzBA,EAASoH,YACT6B,EAAY7B,YACZ+B,EAAc/B,YAIdt/D,EAAKk4D,SAAWA,CAEjB,CAEA,OAAOl4D,EAAKk4D,QAEb,CAQA,OAAQz4D,GAEP,MAAMy4D,EAAW/4D,KAAKc,IAAKR,GAASy4D,SA8BpC,OA5BKA,IAIJA,EAASoH,YAEmB,IAAvBpH,EAASoH,WAAkBngE,KAAK4hE,iBAAkB7I,GAIlDA,EAAS0H,mBAEb1H,EAASyH,eAAeL,YAEmB,IAAtCpH,EAASyH,eAAeL,WAAkBngE,KAAKyhE,gBAAiB1I,EAASyH,kBAI9EzH,EAASuH,gBAAgBH,YACzBpH,EAASsH,cAAcF,YAEmB,IAArCpH,EAASsH,cAAcF,WAAkBngE,KAAKyhE,gBAAiB1I,EAASsH,eACjC,IAAvCtH,EAASuH,gBAAgBH,WAAkBngE,KAAKyhE,gBAAiB1I,EAASuH,mBAM1E52D,MAAMsmC,OAAQ1vC,EAEtB,CAKA,OAAA2K,GAECvB,MAAMuB,UAENjL,KAAKghE,OAAS,IAAIt6D,IAClB1G,KAAKihE,SAAW,CACfpnB,OAAQ,IAAInzC,IACZw6D,SAAU,IAAIx6D,IACdwqB,QAAS,IAAIxqB,IAGf,CAOA,eAAA83D,CAAiB99D,GAEhBV,KAAKk6D,aAAcx5D,EAEpB,CAYA,mBAAAmhE,CAAqBnxC,EAAa6wC,EAAcpI,EAAUyD,GAIzDzD,EAAWA,GAAYn5D,KAAK2hE,oBAAqBjxC,EAAa6wC,GAE9D,IAAIxI,EAAW/4D,KAAKghE,OAAOlgE,IAAKq4D,GAYhC,YAVkBp4D,IAAbg4D,IAEJA,EAAW,IAAIwH,GAAiBpH,EAAUoI,GAE1CvhE,KAAKghE,OAAOx+D,IAAK22D,EAAUJ,GAE3B/4D,KAAKs9D,QAAQgF,sBAAuBvJ,EAAU6D,IAIxC7D,CAER,CAaA,kBAAAsJ,CAAoB3hE,EAAcshE,EAAaE,EAAe/I,EAAU2I,GAIvE3I,EAAWA,GAAYn5D,KAAKoiE,mBAAoB1hE,EAAcshE,EAAaE,GAE3E,IAAInJ,EAAW/4D,KAAKghE,OAAOlgE,IAAKq4D,GAkBhC,YAhBkBp4D,IAAbg4D,IAEJA,EAAW,IAAIqH,GAAgBjH,EAAU6I,EAAaE,GAEtDliE,KAAKghE,OAAOx+D,IAAK22D,EAAUJ,GAE3Br4D,EAAaq4D,SAAWA,EAMxB/4D,KAAKs9D,QAAQiF,qBAAsB7hE,EAAcohE,IAI3C/I,CAER,CAUA,mBAAA4I,CAAqBjxC,EAAa6wC,GAEjC,OAAO7wC,EAAYttB,GAAK,IAAMm+D,EAAan+D,EAE5C,CAWA,kBAAAg/D,CAAoB1hE,EAAcshE,EAAaE,GAE9C,OAAOF,EAAY5+D,GAAK,IAAM8+D,EAAc9+D,GAAK,IAAMpD,KAAKs9D,QAAQkF,kBAAmB9hE,EAExF,CAQA,gBAAAkhE,CAAkB7I,GAEjB/4D,KAAKghE,OAAOhxB,OAAQ+oB,EAASI,SAE9B,CAQA,eAAAsI,CAAiBgB,GAEhB,MAAM7B,EAAO6B,EAAQ7B,KACfC,EAAQ4B,EAAQ5B,MAEtB7gE,KAAKihE,SAAUJ,GAAQ7wB,OAAQ4wB,EAEhC,CASA,mBAAAQ,CAAqB1wC,GAEpB,MAAM7vB,EAAOb,KAAKc,IAAK4vB,GAEvB,YAAyB3vB,IAAlBF,EAAKk4D,UAA0Bl4D,EAAKU,UAAYmvB,EAAYnvB,OAEpE,CASA,kBAAAwgE,CAAoBrhE,GAInB,YAAyBK,IAFZf,KAAKc,IAAKJ,GAEXq4D,UAA0B/4D,KAAKs9D,QAAQoF,kBAAmBhiE,EAEvE,EAUD,MAAMiiE,WAAiBzF,GAYtB,WAAAp9D,CAAaw9D,EAASv6D,EAAO2L,EAAUvN,EAAYw7D,EAAW/E,GAE7DluD,QAOA1J,KAAKs9D,QAAUA,EAOft9D,KAAK0O,SAAWA,EAOhB1O,KAAK28D,UAAYA,EAOjB38D,KAAKmB,WAAaA,EAOlBnB,KAAK+C,MAAQA,EAOb/C,KAAK43D,KAAOA,EAEZ53D,KAAK28D,UAAUC,SAAW58D,IAE3B,CAQA,YAAAk6D,CAAcx5D,GAEb,MAAMk8D,EAAWl8D,EAAa05D,cAE9B,IAAM,MAAMwI,KAAahG,EAAW,CAEnC,MAAMiG,EAAY7iE,KAAKc,IAAK8hE,QAEC7hE,IAAxB8hE,EAAUD,YAId5iE,KAAK8iE,MAAOF,GAEZ5iE,KAAKs9D,QAAQjD,eAAgBuI,EAAWhG,EAAU,GAElDiG,EAAUD,UAAYA,EAIxB,CAEA,OAAOhG,CAER,CAQA,aAAAuE,CAAezwC,GAEd,MAAMksC,EAAW58D,KAAK+C,MAAMo+D,cAAezwC,GAAcksC,SAEzD,IAAM,MAAMgG,KAAahG,EAAW,CAEnC,MAAMiG,EAAY7iE,KAAKc,IAAK8hE,QAEC7hE,IAAxB8hE,EAAUD,YAEd5iE,KAAK8iE,MAAOF,GAEZ5iE,KAAKs9D,QAAQjD,eAAgBuI,EAAWhG,EAAU,GAElDiG,EAAUD,UAAYA,EAIxB,CAEA,OAAOhG,CAER,CAOA,gBAAAmG,CAAkBryC,GAEjB1wB,KAAKgjE,gBAAiBhjE,KAAKmhE,cAAezwC,GAE3C,CAOA,eAAA8tC,CAAiB99D,GAEhBV,KAAKgjE,gBAAiBhjE,KAAKk6D,aAAcx5D,GAE1C,CAOA,eAAAsiE,CAAiBpG,GAEhB,IAAM,MAAMgG,KAAahG,EAExB58D,KAAKijE,QAASL,EAAWhG,EAI3B,CAOA,KAAAkG,CAAOF,GAEN,IAAM,MAAMM,KAAWN,EAAUhG,SAEhC,GAAKsG,EAAQC,iBAEZnjE,KAAK0O,SAAS00D,cAAeF,EAAQpvC,cAE/B,GAAKovC,EAAQG,gBAAkB,CAErC,MAAM1gE,EAAYugE,EAAQvgE,UACpBywB,EAAgBzwB,EAAU2gE,iCAAmCnG,GAAyBA,GAE5Fn9D,KAAKmB,WAAWoJ,OAAQ5H,EAAWywB,EAEpC,CAIF,CAQA,OAAA6vC,CAASL,EAAWhG,GAEnB,MAAM,QAAEU,GAAYt9D,KAEpB,IAAIujE,GAAsB,EACtBC,GAAgB,EAChBC,EAAa,EACbliE,EAAU,EAId,IAAM,MAAM2hE,KAAWN,EAAUhG,SAAW,CAE3C,GAAKsG,EAAQQ,oBAAsB,CAOlC,IAAiB,IALD1jE,KAAK+C,MAAM4gE,YAAaT,GAKf,QAE1B,CAEA,GAAKA,EAAQU,gBAAkB,CAEdV,EAAQ34D,UAIvB+yD,EAAQuG,cAAeX,EAIzB,MAAO,GAAKA,EAAQY,UAEnBZ,EAAQ34D,cAEF,GAAK24D,EAAQC,iBAAmB,CAEtC,MAAMY,EAAsB/jE,KAAK0O,SAAS5N,IAAKoiE,EAAQpvC,SAElDovC,EAAQK,oBAAqBQ,EAAoBC,cAAeT,GAAsB,GAE3F,MAAMU,EAAUf,EAAQ34D,SAElBupB,EAAUovC,EAAQpvC,QAEnBmwC,GAEJjkE,KAAK0O,SAAS00D,cAAetvC,GAI9B,MAAMowC,EAAc5G,EAAQx8D,IAAKgzB,GAuBjC,QArBqC/yB,IAAhCmjE,EAAYC,iBAAiCJ,EAAoBK,iBAErEZ,GAAgB,GAIhBC,EAA0B,GAAbA,EAAkB3vC,EAAQ1wB,GACvC7B,GAAWuyB,EAAQvyB,UAIa,IAA5B+7D,EAAQ+G,sBAAoDtjE,IAAxBmjE,EAAYpwC,cAAyD/yB,IAAhCmjE,EAAYC,kBAGzF13D,QAAQkiB,MAAO,iDAAkDu0C,EAASe,EAASnwC,EAASovC,EAAQ5vC,YAAYpwB,MAAOqgE,GAEvHvjE,KAAK0O,SAAS00D,cAAetvC,GAC7ByvC,GAAsB,IAIW,IAA7BzvC,EAAQwwC,iBAA4B,CAExC,MAAMJ,EAAclkE,KAAKc,IAAKgzB,IAEP,IAAlBovC,EAAQqB,MAEZL,EAAYM,aAAc,EAEfxkE,KAAK0O,SAAS+1D,aAAc3wC,KAAyC,IAA5BowC,EAAYM,cAEhExkE,KAAKs9D,QAAQhqB,gBAAiBxf,GAE9BowC,EAAYM,aAAc,EAI5B,CAED,CAED,EAE6B,IAAxBjB,GAEJvjE,KAAKs9D,QAAQoH,eAAgB9B,EAAWhG,EAAU4G,EAAgBC,EAAa,EAAGliE,EAIpF,EAaD,SAASojE,GAAmB9kD,EAAGC,GAE9B,OAAKD,EAAE+kD,aAAe9kD,EAAE8kD,WAEhB/kD,EAAE+kD,WAAa9kD,EAAE8kD,WAEb/kD,EAAEglD,cAAgB/kD,EAAE+kD,YAExBhlD,EAAEglD,YAAc/kD,EAAE+kD,YAEdhlD,EAAE5e,SAASmC,KAAO0c,EAAE7e,SAASmC,GAEjCyc,EAAE5e,SAASmC,GAAK0c,EAAE7e,SAASmC,GAEvByc,EAAEod,IAAMnd,EAAEmd,EAEdpd,EAAEod,EAAInd,EAAEmd,EAIRpd,EAAEzc,GAAK0c,EAAE1c,EAIlB,CAWA,SAAS0hE,GAA0BjlD,EAAGC,GAErC,OAAKD,EAAE+kD,aAAe9kD,EAAE8kD,WAEhB/kD,EAAE+kD,WAAa9kD,EAAE8kD,WAEb/kD,EAAEglD,cAAgB/kD,EAAE+kD,YAExBhlD,EAAEglD,YAAc/kD,EAAE+kD,YAEdhlD,EAAEod,IAAMnd,EAAEmd,EAEdnd,EAAEmd,EAAIpd,EAAEod,EAIRpd,EAAEzc,GAAK0c,EAAE1c,EAIlB,CAUA,SAAS2hE,GAAiB9jE,GAIzB,OAFwBA,EAASiB,aAAe,GAAKjB,EAAS+iC,mBAEpC/iC,EAASk5B,OAAS,QAA2C,IAA7Bl5B,EAAS+jE,eAEpE,CAaA,MAAMC,GASL,WAAAnlE,CAAaq7C,EAAUwC,EAAO/lB,GAO7B53B,KAAKklE,YAAc,GAQnBllE,KAAKmlE,iBAAmB,EAOxBnlE,KAAKolE,OAAS,GAQdplE,KAAKqlE,sBAAwB,GAO7BrlE,KAAKs6C,YAAc,GAOnBt6C,KAAKslE,QAAU,GASftlE,KAAKw3C,WAAa2D,EAASoqB,QAAS5nB,EAAO/lB,GAQ3C53B,KAAKwlE,YAAc,GAOnBxlE,KAAK29C,MAAQA,EAOb39C,KAAK43B,OAASA,EAQd53B,KAAKylE,oBAAsB,CAE5B,CASA,KAAAC,GAaC,OAXA1lE,KAAKmlE,iBAAmB,EAExBnlE,KAAKolE,OAAOphE,OAAS,EACrBhE,KAAKqlE,sBAAsBrhE,OAAS,EACpChE,KAAKs6C,YAAYt2C,OAAS,EAC1BhE,KAAKslE,QAAQthE,OAAS,EAEtBhE,KAAKwlE,YAAYxhE,OAAS,EAE1BhE,KAAKylE,oBAAsB,EAEpBzlE,IAER,CAkBA,iBAAA2lE,CAAmBrlE,EAAQU,EAAUC,EAAU2jE,EAAY3nC,EAAG7hB,EAAOg6B,GAEpE,IAAIwwB,EAAa5lE,KAAKklE,YAAallE,KAAKmlE,kBAkCxC,YAhCoBpkE,IAAf6kE,GAEJA,EAAa,CACZxiE,GAAI9C,EAAO8C,GACX9C,OAAQA,EACRU,SAAUA,EACVC,SAAUA,EACV2jE,WAAYA,EACZC,YAAavkE,EAAOukE,YACpB5nC,EAAGA,EACH7hB,MAAOA,EACPg6B,gBAAiBA,GAGlBp1C,KAAKklE,YAAallE,KAAKmlE,kBAAqBS,IAI5CA,EAAWxiE,GAAK9C,EAAO8C,GACvBwiE,EAAWtlE,OAASA,EACpBslE,EAAW5kE,SAAWA,EACtB4kE,EAAW3kE,SAAWA,EACtB2kE,EAAWhB,WAAaA,EACxBgB,EAAWf,YAAcvkE,EAAOukE,YAChCe,EAAW3oC,EAAIA,EACf2oC,EAAWxqD,MAAQA,EACnBwqD,EAAWxwB,gBAAkBA,GAI9Bp1C,KAAKmlE,mBAEES,CAER,CAcA,IAAA9/D,CAAMxF,EAAQU,EAAUC,EAAU2jE,EAAY3nC,EAAG7hB,EAAOg6B,GAEvD,MAAMwwB,EAAa5lE,KAAK2lE,kBAAmBrlE,EAAQU,EAAUC,EAAU2jE,EAAY3nC,EAAG7hB,EAAOg6B,IAE/D,IAAzB90C,EAAOulE,eAAyB7lE,KAAKylE,uBAEZ,IAAzBxkE,EAASq5C,aAAwBr5C,EAASiB,aAAe,GAExD6iE,GAAiB9jE,IAAajB,KAAKqlE,sBAAsBv/D,KAAM8/D,GAEpE5lE,KAAKs6C,YAAYx0C,KAAM8/D,IAIvB5lE,KAAKolE,OAAOt/D,KAAM8/D,EAIpB,CAcA,OAAAE,CAASxlE,EAAQU,EAAUC,EAAU2jE,EAAY3nC,EAAG7hB,EAAOg6B,GAE1D,MAAMwwB,EAAa5lE,KAAK2lE,kBAAmBrlE,EAAQU,EAAUC,EAAU2jE,EAAY3nC,EAAG7hB,EAAOg6B,IAE/D,IAAzBn0C,EAASq5C,aAAwBr5C,EAASiB,aAAe,GAExD6iE,GAAiB9jE,IAAajB,KAAKqlE,sBAAsBS,QAASF,GAEvE5lE,KAAKs6C,YAAYwrB,QAASF,IAI1B5lE,KAAKolE,OAAOU,QAASF,EAIvB,CAOA,UAAAG,CAAY3qD,GAEXpb,KAAKslE,QAAQx/D,KAAMsV,EAEpB,CAOA,SAAA4qD,CAAWC,GAEVjmE,KAAKwlE,YAAY1/D,KAAMmgE,EAExB,CAQA,IAAAvyD,CAAMwyD,EAAkBC,GAElBnmE,KAAKolE,OAAOphE,OAAS,GAAIhE,KAAKolE,OAAO1xD,KAAMwyD,GAAoBvB,IAC/D3kE,KAAKqlE,sBAAsBrhE,OAAS,GAAIhE,KAAKqlE,sBAAsB3xD,KAAMyyD,GAAyBrB,IAClG9kE,KAAKs6C,YAAYt2C,OAAS,GAAIhE,KAAKs6C,YAAY5mC,KAAMyyD,GAAyBrB,GAEpF,CAMA,MAAA9lB,GAICh/C,KAAKw3C,WAAW4uB,UAAWpmE,KAAKwlE,aAIhC,IAAM,IAAInhE,EAAIrE,KAAKmlE,iBAAkBkB,EAAKrmE,KAAKklE,YAAYlhE,OAAQK,EAAIgiE,EAAIhiE,IAAO,CAEjF,MAAMuhE,EAAa5lE,KAAKklE,YAAa7gE,GAErC,GAAuB,OAAlBuhE,EAAWxiE,GAAc,MAE9BwiE,EAAWxiE,GAAK,KAChBwiE,EAAWtlE,OAAS,KACpBslE,EAAW5kE,SAAW,KACtB4kE,EAAW3kE,SAAW,KACtB2kE,EAAWhB,WAAa,KACxBgB,EAAWf,YAAc,KACzBe,EAAW3oC,EAAI,KACf2oC,EAAWxqD,MAAQ,KACnBwqD,EAAWxwB,gBAAkB,IAE9B,CAED,EAUD,MAAMkxB,GAOL,WAAAxmE,CAAaq7C,GAOZn7C,KAAKm7C,SAAWA,EAOhBn7C,KAAKumE,MAAQ,IAAIhO,EAElB,CASA,GAAAz3D,CAAK68C,EAAO/lB,GAEX,MAAM2uC,EAAQvmE,KAAKumE,MACbziE,EAAO,CAAE65C,EAAO/lB,GAEtB,IAAI4uC,EAAOD,EAAMzlE,IAAKgD,GAStB,YAPc/C,IAATylE,IAEJA,EAAO,IAAIvB,GAAYjlE,KAAKm7C,SAAUwC,EAAO/lB,GAC7C2uC,EAAM/jE,IAAKsB,EAAM0iE,IAIXA,CAER,CAKA,OAAAv7D,GAECjL,KAAKumE,MAAQ,IAAIhO,EAElB,EAID,IAAIkO,GAAQ,EAUZ,MAAMC,GAKL,WAAA5mE,GAOCE,KAAKoD,GAAKqjE,KAQVzmE,KAAKmZ,OAAQ,EAQbnZ,KAAK2mE,YAAa,EAQlB3mE,KAAK4mE,gBAAkB,CAAE9pC,EAAG,EAAGC,EAAG,EAAGjd,EAAG,EAAGD,EAAG,GAQ9C7f,KAAKs3B,OAAQ,EAQbt3B,KAAK6mE,YAAa,EAQlB7mE,KAAK8mE,gBAAkB,EAQvB9mE,KAAK+mE,SAAU,EAQf/mE,KAAKgnE,cAAe,EAQpBhnE,KAAKinE,kBAAoB,EASzBjnE,KAAKqyC,UAAW,EAShBryC,KAAKknE,cAAgB,IAAI,MASzBlnE,KAAKmnE,SAAU,EAOfnnE,KAAKonE,aAAe,IAAI,MASxBpnE,KAAK0O,SAAW,KAShB1O,KAAKqnE,aAAe,KAQpBrnE,KAAKsnE,eAAiB,EAStBtnE,KAAKunE,YAAc,EAQnBvnE,KAAKmC,MAAQ,EAQbnC,KAAKoC,OAAS,EASdpC,KAAKwnE,iBAAkB,CAExB,CAOA,WAAAthE,GAEC,OAAOA,GAAalG,KAErB,EAUD,SAASkG,GAAa0yD,GAErB,MAAM,SAAElqD,EAAQ,eAAE44D,GAAmB1O,EAE/B/yD,EAAS,CAAEyhE,GAEjB,IAAM,MAAMxzC,KAAWplB,EAEtB7I,EAAOC,KAAMguB,EAAQ1wB,IAItB,OAAOmC,EAAWM,EAEnB,CAOA,MAAM4hE,GAKL,WAAA3nE,GAQCE,KAAK68D,UAAY,CAAC,CAEnB,CAUA,GAAA/7D,CAAK68C,EAAQ,KAAM/lB,EAAS,KAAMua,EAAe,MAEhD,MAAMu1B,EAAW,GAWjB,IAAIC,EAEJ,GAZe,OAAVhqB,GAAiB+pB,EAAS5hE,KAAM63C,GACrB,OAAX/lB,GAAkB8vC,EAAS5hE,KAAM8xB,GAEb,IAApB8vC,EAAS1jE,QAEb0jE,EAAS5hE,KAAM,CAAE1C,GAAI,YAOA,OAAjB+uC,EAEJw1B,EAAkB,cAEZ,CAEN,MAAMh6D,EAASwkC,EAAare,QAAQnmB,OAGpCg6D,EAAkB,GAFJx1B,EAAazjC,SAAS1K,UAEH2J,KAAYwkC,EAAaqH,WAAarH,EAAa0G,eAAiB1G,EAAay1B,eAEnH,CAEA,MAAM7K,EAAW/8D,KAAKg9D,YAAa2K,GAEnC,IAAIE,EAAc9K,EAASj8D,IAAK4mE,GAYhC,YAVqB3mE,IAAhB8mE,IAEJA,EAAc,IAAInB,GAElB3J,EAASv6D,IAAKklE,EAAUG,IAIH,OAAjB11B,IAAwB01B,EAAYN,YAAuC,IAAzBp1B,EAAaqH,QAAgB,EAAIrH,EAAaqH,SAE9FquB,CAER,CAQA,WAAA7K,CAAa2K,GAEZ,OAAO3nE,KAAK68D,UAAW8K,KAAuB3nE,KAAK68D,UAAW8K,GAAoB,IAAIpP,GAEvF,CAKA,OAAAttD,GAECjL,KAAK68D,UAAY,CAAC,CAEnB,EAID,MAAMiL,GAAwB,IAAI,MAQlC,MAAMC,WAAiB7K,GAStB,WAAAp9D,CAAagD,EAAUw6D,EAAS1F,GAE/BluD,QAOA1J,KAAK8C,SAAWA,EAOhB9C,KAAKs9D,QAAUA,EAOft9D,KAAK43D,KAAOA,CAEb,CASA,kBAAAoQ,CAAoB71B,EAAc81B,EAAoB,GAErD,MAAMC,EAAmBloE,KAAKc,IAAKqxC,GAE7Bo1B,EAAuC,IAAzBp1B,EAAaqH,QAAgB,EAAIrH,EAAaqH,QAC5D2uB,EAAmBD,EAAiBC,mBAAsBD,EAAiBC,iBAAmB,CAAC,GAE/Fz5D,EAAWyjC,EAAazjC,SAExBsiB,EAAOhxB,KAAKooE,QAAS15D,EAAU,IAE/B25D,EAAWr3C,EAAK7uB,OAAS8lE,EACzBK,EAAYt3C,EAAK5uB,QAAU6lE,EAEjC,IAAIZ,EAAel1B,EAAak1B,cAAgBc,EAAkBF,GAClE,MAAMM,GAA+C,IAA7Bp2B,EAAa0G,cAAuD,IAA/B1G,EAAay1B,cAE1E,IAAIY,GAAqB,OAEHznE,IAAjBsmE,GAA8BkB,IAElClB,EAAe,IAAI,MACnBA,EAAa15D,OAASwkC,EAAay1B,cAAgB,MAAqB,MACxEP,EAAa9/D,KAAO4qC,EAAay1B,cAAgB,MAAqB,MACtEP,EAAatzC,MAAM5xB,MAAQkmE,EAC3BhB,EAAatzC,MAAM3xB,OAASkmE,EAE5BH,EAAkBF,GAAsBZ,GAIpCa,EAAiB/lE,QAAU6uB,EAAK7uB,OAAS6uB,EAAK5uB,SAAW8lE,EAAiB9lE,SAE9EomE,GAAqB,EAEhBnB,IAEJA,EAAaj9D,aAAc,EAC3Bi9D,EAAatzC,MAAM5xB,MAAQkmE,EAC3BhB,EAAatzC,MAAM3xB,OAASkmE,IAM9BJ,EAAiB/lE,MAAQ6uB,EAAK7uB,MAC9B+lE,EAAiB9lE,OAAS4uB,EAAK5uB,OAC/B8lE,EAAiBx5D,SAAWA,EAC5Bw5D,EAAiBb,aAAeA,GAAgB,KAChDa,EAAiB5wC,MAAQ6a,EAAa0G,YACtCqvB,EAAiBnB,QAAU50B,EAAay1B,cACxCM,EAAiB/1B,aAAeA,EAE3B+1B,EAAiBX,cAAgBA,IAErCiB,GAAqB,EAEhBnB,IAEJA,EAAaj9D,aAAc,GAI5B89D,EAAiBX,YAAcA,GAMhC,MAAMlqB,EAAU,CAAEkqB,eAElB,IAAM,IAAIljE,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAE5C,MAAMyvB,EAAUplB,EAAUrK,GAErBmkE,IAAqB10C,EAAQ1pB,aAAc,GAEhDpK,KAAKojE,cAAetvC,EAASupB,EAE9B,CAUA,GARKgqB,GAEJrnE,KAAKojE,cAAeiE,EAAchqB,IAMG,IAAjC6qB,EAAiB/6D,YAAuB,CAE5C+6D,EAAiB/6D,aAAc,EAI/B,MAAMusD,EAAY,KAEjBvnB,EAAalC,oBAAqB,UAAWypB,GAE7C,IAAM,IAAIr1D,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAErCrE,KAAKyoE,gBAAiB/5D,EAAUrK,IAI5BgjE,GAEJrnE,KAAKyoE,gBAAiBpB,GAIvBrnE,KAAKgwC,OAAQmC,EAAc,EAI5BA,EAAajC,iBAAkB,UAAWwpB,EAE3C,CAED,CAUA,aAAA0J,CAAetvC,EAASupB,EAAU,CAAC,GAElC,MAAM6mB,EAAclkE,KAAKc,IAAKgzB,GAC9B,IAAiC,IAA5BowC,EAAY/2D,aAAwB+2D,EAAY3iE,UAAYuyB,EAAQvyB,QAAU,OAEnF,MAAMmnE,EAAiB50C,EAAQwB,uBAAyBxB,EAAQe,gBAAkBf,EAAQyB,qBACpF+nC,EAAUt9D,KAAKs9D,QAarB,GAXKoL,IAA8C,IAA5BxE,EAAY/2D,cAIlCmwD,EAAQqL,eAAgB70C,GACxBwpC,EAAQsL,eAAgB90C,IAMpBA,EAAQyB,qBAAuB,CAEnC,MAAM4c,EAAenyC,KAAK8C,SAASsvC,kBAIlCte,EAAQvsB,KAFJ4qC,EAEWA,EAAare,QAAQvsB,KAIrB,KAIjB,CAIA,MAAM,MAAEpF,EAAK,OAAEC,EAAM,MAAEk1B,GAAUt3B,KAAKooE,QAASt0C,GAU/C,GARAupB,EAAQl7C,MAAQA,EAChBk7C,EAAQj7C,OAASA,EACjBi7C,EAAQ/lB,MAAQA,EAChB+lB,EAAQonB,aAAezkE,KAAKykE,aAAc3wC,GAC1CupB,EAAQwrB,OAASxrB,EAAQonB,aAAezkE,KAAK8oE,aAAch1C,EAAS3xB,EAAOC,GAAW,EAIjFsmE,IAA+C,IAA7B50C,EAAQwwC,iBAE9BhH,EAAQyL,cAAej1C,GACvBwpC,EAAQ0L,cAAel1C,EAASupB,GAEhC6mB,EAAYF,WAAalwC,EAAQvyB,YAE3B,CAMN,IAJgD,IAA5B2iE,EAAY/2D,aAEbmwD,EAAQyL,cAAej1C,GAErCA,EAAQvyB,QAAU,EAAI,CAE1B,MAAMwyB,EAAQD,EAAQC,MAEtB,QAAehzB,IAAVgzB,EAEJtnB,QAAQC,KAAM,0EAER,IAAwB,IAAnBqnB,EAAMk1C,SAEjBx8D,QAAQC,KAAM,0EAER,CAEN,GAAKonB,EAAQnlB,OAAS,CAErB,MAAMA,EAAS,GAEf,IAAM,MAAMolB,KAASD,EAAQnlB,OAE5BA,EAAO7I,KAAMiuB,GAIdspB,EAAQ1uC,OAASA,CAElB,MAEC0uC,EAAQtpB,MAAQA,OAIqBhzB,IAAjCmjE,EAAYE,mBAAmE,IAAjCF,EAAYE,mBAE9D9G,EAAQ0L,cAAel1C,EAASupB,GAEhC6mB,EAAYE,kBAAmB,EAC/BF,EAAYF,WAAalwC,EAAQvyB,UAIA,IAA7BuyB,EAAQzV,OAAO6qD,WAAqB5L,EAAQ8F,cAAetvC,EAASupB,GAEpEA,EAAQonB,cAA2C,IAA3B3wC,EAAQq1C,QAAQnlE,QAAes5D,EAAQhqB,gBAAiBxf,EAEtF,CAED,MAICwpC,EAAQ8L,qBAAsBt1C,GAE9BowC,EAAYE,kBAAmB,EAC/BF,EAAYF,WAAalwC,EAAQvyB,OAInC,CAIA,IAAiC,IAA5B2iE,EAAY/2D,YAAuB,CAEvC+2D,EAAY/2D,aAAc,EAC1B+2D,EAAYF,WAAalwC,EAAQvyB,QAIjCvB,KAAK43D,KAAK+G,OAAOjwD,WAIjB,MAAMgrD,EAAY,KAEjB5lC,EAAQmc,oBAAqB,UAAWypB,GAExC15D,KAAKyoE,gBAAiB30C,GAEtB9zB,KAAK43D,KAAK+G,OAAOjwD,UAAW,EAI7BolB,EAAQoc,iBAAkB,UAAWwpB,EAEtC,CAIAwK,EAAY3iE,QAAUuyB,EAAQvyB,OAE/B,CAcA,OAAA6mE,CAASt0C,EAAS1V,EAAS0pD,IAE1B,IAAI/zC,EAAQD,EAAQnlB,OAASmlB,EAAQnlB,OAAQ,GAAMmlB,EAAQC,MAgB3D,OAdKA,QAEiBhzB,IAAhBgzB,EAAMA,QAAsBA,EAAQA,EAAMA,OAE/C3V,EAAOjc,MAAQ4xB,EAAM5xB,OAAS,EAC9Bic,EAAOhc,OAAS2xB,EAAM3xB,QAAU,EAChCgc,EAAOkZ,MAAQxD,EAAQ6mB,cAAgB,EAAM5mB,EAAMuD,OAAS,GAI5DlZ,EAAOjc,MAAQic,EAAOhc,OAASgc,EAAOkZ,MAAQ,EAIxClZ,CAER,CAUA,YAAA0qD,CAAch1C,EAAS3xB,EAAOC,GAE7B,IAAIinE,EAoBJ,OAdEA,EAJGv1C,EAAQw1C,oBAEPx1C,EAAQq1C,QAEIr1C,EAAQq1C,QAAQnlE,OAIhB,EAMDiB,KAAKshB,MAAOthB,KAAKmhB,KAAMnhB,KAAKoM,IAAKlP,EAAOC,KAAe,EAIjEinE,CAER,CAQA,YAAA5E,CAAc3wC,GAEb,OAAO9zB,KAAKupE,qBAAsBz1C,KAA6C,IAAhCA,EAAQw1C,qBAAgCx1C,EAAQwf,eAEhG,CAQA,oBAAAi2B,CAAsBz1C,GAErB,MAAMlF,EAAUkF,EAAQlF,QAExB,OAASA,IAAY,OAAoCA,IAAY,OAAwCA,IAAY,OAAyBA,IAAY,KAE/J,CAQA,eAAA65C,CAAiB30C,GAEhB9zB,KAAKs9D,QAAQqL,eAAgB70C,GAC7B9zB,KAAKs9D,QAAQsL,eAAgB90C,GAE7B9zB,KAAKgwC,OAAQlc,EAEd,EAYD,MAAM01C,WAAe,MAUpB,WAAA1pE,CAAag9B,EAAGC,EAAGjd,EAAGD,EAAI,GAEzBnW,MAAOozB,EAAGC,EAAGjd,GAEb9f,KAAK6f,EAAIA,CAEV,CAWA,GAAArd,CAAKs6B,EAAGC,EAAGjd,EAAGD,EAAI,GAIjB,OAFA7f,KAAK6f,EAAIA,EAEFnW,MAAMlH,IAAKs6B,EAAGC,EAAGjd,EAEzB,CAQA,IAAAvc,CAAM4V,GAIL,YAFiBpY,IAAZoY,EAAM0G,IAAkB7f,KAAK6f,EAAI1G,EAAM0G,GAErCnW,MAAMnG,KAAM4V,EAEpB,CAOA,KAAAtX,GAEC,OAAO,IAAI7B,KAAKF,YAAaE,KAAK88B,EAAG98B,KAAK+8B,EAAG/8B,KAAK8f,EAAG9f,KAAK6f,EAE3D,EAWD,MAAM4pD,WAAsBxtD,GAE3B,eAAW1U,GAEV,MAAO,eAER,CAQA,WAAAzH,CAAa2J,EAAU/G,EAAO,MAE7BgH,MAAOD,EAAU/G,GASjB1C,KAAK0pE,iBAAkB,CAExB,CAEA,OAAAp+D,GAEC,OAAOtL,KAAK8J,IAEb,CAEA,QAAAwC,GAEC,OAAOtM,KAAK0C,IAEb,EAsBD,MAAMinE,WAAkBngE,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAOA,WAAAzH,CAAasxB,EAAS,MAErB1nB,QAOA1J,KAAK+C,MAAQ,GAQb/C,KAAK8L,WAAa,KAQlB9L,KAAKoxB,OAASA,EASdpxB,KAAK4pE,aAAe,KASpB5pE,KAAKkU,aAAc,CAEpB,CAEA,WAAAvI,CAAa5L,GAEZ,OAAOC,KAAK8L,WAAa9L,KAAK8L,WAAWH,YAAa5L,GAAY,MAEnE,CAQA,GAAAqU,CAAKjO,GAIJ,OAFAnG,KAAK+C,MAAM+C,KAAMK,GAEVnG,IAER,CASA,EAAAiZ,CAAI4wD,EAAUnoD,GAEb,MAAMooD,EAAa,IAAIvxD,GAAYmJ,GAGnC,OAFA1hB,KAAK4pE,aAAe7+C,GAAQ8+C,EAAUC,GAE/B9pE,KAAKoU,IAAKpU,KAAK4pE,aAEvB,CASA,MAAAjb,CAAQkb,EAAUnoD,GAEjB,MAAMooD,EAAa,IAAIvxD,GAAYmJ,GAC7BuI,EAASc,GAAQ8+C,EAAUC,GAKjC,OAHA9pE,KAAK4pE,aAAa1/C,SAAWD,EAC7BjqB,KAAK4pE,aAAe3/C,EAEbjqB,IAER,CAQA,IAAA0uD,CAAMhtC,GAIL,OAFA1hB,KAAK4pE,aAAa1/C,SAAW,IAAI3R,GAAYmJ,GAEtC1hB,IAER,CAEA,KAAAqM,CAAOtM,KAAY2F,GAElB,MAAMqkE,EAAgB/wD,KAEtBD,GAAiB/Y,MAEjB,IAAM,MAAMmG,KAAQnG,KAAK+C,MAExBoD,EAAKkG,MAAOtM,EAAS,QAMtB,OAFAgZ,GAAiBgxD,GAEV/pE,KAAK8L,WAAa9L,KAAK8L,WAAWO,MAAOtM,KAAY2F,GAAWgE,MAAM2C,MAAOtM,KAAY2F,EAEjG,CAIA,QAASA,GAGR,OADA+G,QAAQC,KAAM,uDACP1M,KAAK0uD,QAAShpD,EAEtB,CAEA,MAAAskE,IAAWtkE,GAGV,OADA+G,QAAQC,KAAM,2DACP1M,KAAK2uD,UAAWjpD,EAExB,EAWD,MAAM8Q,GAAsBoC,GAAW+wD,IAk8Bf,IAAI,MACZ,IAAI,MACY,IAAI,MACP,IAAI,MACT,IAAI,MACJ,IAAI,MAAS,EAAG,GAAK,GAC3B,IAAI,MAER,IAAI,MACF,IAAI,MACT,IAAI,MAEC,IAAI,MA9BpB,MAgCMM,GAAa,IAAI,MACJj3B,GAASk3B,QAE5BD,GAAW5C,aAAe,IAAI,MAAc,EAAG,GA6c/C,MAEM8C,GAAwB,IAAI,OAAsB,EAAG,EAAG,GAAK,EAAG,EAAG,GAUzE,MAAMC,WAAqB,MAO1B,WAAAtqE,CAAau1B,GAAQ,GAEpB3rB,QAEA,MAAMyf,GAAe,IAAVkM,EAAkB,CAAE,GAAK,EAAG,EAAG,EAAG,EAAG,GAAM,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GAEvEr1B,KAAKqqE,aAAc,WAAY,IAAI,MAAwB,EAAI,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,EAAG,GAAK,IAClGrqE,KAAKqqE,aAAc,KAAM,IAAI,MAAwBlhD,EAAI,GAE1D,EAID,MAAMmhD,GAA0B,IAAIF,GAYpC,MAAMG,WAAiB,MAOtB,WAAAzqE,CAAamB,EAAW,MAEvByI,MAAO4gE,GAAWrpE,GAQlBjB,KAAK43B,OAASuyC,GASdnqE,KAAKwqE,YAAa,CAEnB,CASA,iBAAMC,CAAa3nE,GAElB,OAAOA,EAAS2nE,YAAazqE,KAAMmqE,GAEpC,CAOA,MAAAjL,CAAQp8D,GAEPA,EAASo8D,OAAQl/D,KAAMmqE,GAExB,EAsW6C,MA2CT,MA0rBrC,MAEMO,GAAoB,IAAI,MACxBC,GAAoB,IAAI,MAc9B,MAAMC,WAAkBphE,EAEvB,eAAWjC,GAEV,MAAO,WAER,CAQA,WAAAzH,CAAaqV,EAAQy1D,GAAUC,sBAAuBltB,EAAQ,MAE7Dj0C,QAOA1J,KAAKmV,MAAQA,EAQbnV,KAAK29C,MAAQA,CAEd,CASA,KAAAzxC,CAAOnM,GAEN,MAAMoV,EAAQnV,KAAKmV,MACbwoC,EAAuB,OAAf39C,KAAK29C,MAAiB39C,KAAK29C,MAAQ59C,EAAQ49C,MAEzD,IAAIpxC,EAyCJ,OAvCK4I,IAAUy1D,GAAUC,sBAExBt+D,EAASshB,GAAW,uBAAwB,QAAS8vB,GAE1CxoC,IAAUy1D,GAAUE,qBAE/Bv+D,EAASshB,GAAW,sBAAuB,QAAS8vB,GAEzCxoC,IAAUy1D,GAAUG,oBAE/Bx+D,EAASuP,GAAS,QAASZ,MAAO,sBAAuBC,SAAUN,IAAcnQ,gBAAgB,KAEhG,MAAMsgE,EAAartB,EAAMqtB,WAiBzB,OAfoB,OAAfA,GAAuBA,EAAW7nE,WAAa6nE,EAAWp8C,UAAY,OAE1E87C,GAAInnE,KAAMo6C,EAAMstB,oBAGhBP,GAAI9gD,IAAO,EAAG8gD,GAAI5gD,IAAO,EAAG4gD,GAAIztC,IAAO,EAEvC0tC,GAAIO,sBAAuBR,KAI3BC,GAAIQ,WAIER,EAAG,IAMXl+D,QAAQkiB,MAAO,kCAAmCxZ,GAI5C5I,CAER,EAIDq+D,GAAUC,sBAAwB,uBAClCD,GAAUE,qBAAuB,sBACjCF,GAAUG,oBAAsB,qBAOhC,MAAMK,GAAqCvyD,GAAe+xD,GAAWA,GAAUC,uBAOzEQ,GAAoCxyD,GAAe+xD,GAAWA,GAAUE,sBAOxEG,GAAmCpyD,GAAe+xD,GAAWA,GAAUG,qBA8SzD,IAAI7qE,QAsfxB,MAIMorE,GAAsB,IAAI,MAOhC,MAAMC,WAAwBt3C,GAE7B,eAAW1sB,GAEV,MAAO,iBAER,CAQA,WAAAzH,CAAa0rE,EAAU13C,GAEtBpqB,MAAOoqB,GAOP9zB,KAAKwrE,SAAWA,EAEhBxrE,KAAK40B,iBAAiB,EAEvB,CAEA,KAAA1oB,CAAOnM,GAIN,OAFKA,EAAQO,OAAOkqE,YAAaxqE,KAAKwrE,SAASn/D,MAAOtM,GAE/C2J,MAAMwC,MAAOnM,EAErB,CAEA,KAAA8B,GAEC,OAAO,IAAI7B,KAAKF,YAAaE,KAAKwrE,SAAUxrE,KAAKkD,MAElD,EAUD,MAAMuoE,WAAgCF,GAErC,eAAWhkE,GAEV,MAAO,yBAER,CASA,WAAAzH,CAAa0rE,EAAUE,EAAaC,GAAkB,GAMrDjiE,MAAO8hE,EAAU,MAOjBxrE,KAAK0rE,YAAcA,EAOnB1rE,KAAK2rE,gBAAkBA,CAExB,CAKA,aAAAvI,GAECpjE,KAAKkD,MAAQlD,KAAK2rE,gBAAkB3rE,KAAKwrE,SAASI,mBAAoB5rE,KAAK0rE,aAAgB1rE,KAAKwrE,SAASzqC,WAAY/gC,KAAK0rE,YAE3H,CAEA,KAAAx/D,CAAOnM,GAIN,OAFAC,KAAKojE,gBAEE15D,MAAMwC,MAAOnM,EAErB,CAEA,KAAA8B,GAEC,OAAO,IAAI7B,KAAKF,YAAaE,KAAKwrE,SAAUxrE,KAAK0rE,YAAa1rE,KAAK2rE,gBAEpE,EAmBD,MAAME,WAAiBn8D,EAEtB,eAAWnI,GAEV,MAAO,UAER,CAUA,WAAAzH,CAAaqV,EAAOwoC,EAAO/lB,EAAQylB,EAAU,CAAC,GAE7C3zC,MAAO,QAOP1J,KAAKmV,MAAQA,EAObnV,KAAK29C,MAAQA,EAOb39C,KAAK43B,OAASA,EAOd53B,KAAKq9C,QAAUA,EASfr9C,KAAK8rE,YAAc,EAQnB9rE,KAAK2xD,OAAS,EAQd3xD,KAAK4xD,QAAU,EAEf,MAAMyV,EAAe,IAAI,MACzBA,EAAa/xC,uBAAwB,EAErC+xC,EAAa3kE,KAAO,QAEpB,MAAMyvC,EAAe,IAAI,MAAcnyC,KAAK2xD,OAAS3xD,KAAK8rE,YAAa9rE,KAAK4xD,QAAU5xD,KAAK8rE,YAAa,CAAEvkE,KAAM,SAAkB81C,IAClIlL,EAAare,QAAQpxB,KAAO,SAC5ByvC,EAAak1B,aAAeA,EAO5BrnE,KAAKmyC,aAAeA,EAQpBnyC,KAAK+rE,UAAY,CAChBx/D,OAAQ4lC,EAAare,QACrBwD,MAAO+vC,GASRrnE,KAAKgsE,cAAgB,CAAC,EAQtBhsE,KAAKisE,kBAAoB,CAAC,EAQ1BjsE,KAAKksE,YAAc,CAAC,EASpBlsE,KAAKmsE,kBAAoB,CAAC,EAS1BnsE,KAAKosE,sBAAwB,CAAC,EAQ9BpsE,KAAKqsE,YAAcvwD,GAAS,GAQ5B9b,KAAKssE,WAAaxwD,GAAS,GAS3B9b,KAAKusE,KAAO,KASZvsE,KAAKwsE,YAAa,EASlBxsE,KAAK4J,iBAAmBlB,EAAeE,KAExC,CAQA,MAAAi1C,CAAQpR,GAIP,OAFAzsC,KAAKusE,KAAO9/B,EAELzsC,IAER,CAOA,MAAA0sC,GAEC,OAAO1sC,KAAKusE,IAEb,CAOA,QAAAxhE,GAEC,OAAO,CAER,CAQA,UAAAg2B,CAAYr+B,GAEX,IAAIoxB,EAAU9zB,KAAK+rE,UAAWrpE,GAE9B,QAAiB3B,IAAZ+yB,EAAwB,CAI5BA,EAFmB9zB,KAAKmyC,aAAare,QAEhBjyB,QACrBiyB,EAAQpxB,KAAOA,EAEf1C,KAAK+rE,UAAWrpE,GAASoxB,EAEzB9zB,KAAKmyC,aAAazjC,SAAS5I,KAAMguB,EAElC,CAEA,OAAOA,CAER,CAQA,kBAAA83C,CAAoBlpE,GAEnB,IAAIoxB,EAAU9zB,KAAKmsE,kBAAmBzpE,GAUtC,YARiB3B,IAAZ+yB,IAEJA,EAAU9zB,KAAK+gC,WAAYr+B,GAAOb,QAElC7B,KAAKmsE,kBAAmBzpE,GAASoxB,GAI3BA,CAER,CAOA,aAAA24C,CAAe/pE,GAEd,MAAMgqE,EAAc1sE,KAAKmsE,kBAAmBzpE,GAE5C,QAAqB3B,IAAhB2rE,EAA4B,CAEhC,MAAM54C,EAAU9zB,KAAK+rE,UAAWrpE,GAE1BpB,EAAQtB,KAAKmyC,aAAazjC,SAAS4C,QAASwiB,GAClD9zB,KAAKmyC,aAAazjC,SAAUpN,GAAUorE,EAEtC1sE,KAAK+rE,UAAWrpE,GAASgqE,EACzB1sE,KAAKmsE,kBAAmBzpE,GAASoxB,EAEjC9zB,KAAKgsE,cAAetpE,GAAO0gE,gBAC3BpjE,KAAKosE,sBAAuB1pE,GAAO0gE,eAEpC,CAED,CAQA,cAAAuJ,CAAgBjqE,EAAO,UAEtB,IAAI4wB,EAActzB,KAAKgsE,cAAetpE,GAUtC,YARqB3B,IAAhBuyB,IAEJA,EAAc/e,GAAY,IAAIk3D,GAAyBzrE,KAAM0C,IAC7D4wB,EAAY8vC,gBACZpjE,KAAKgsE,cAAetpE,GAAS4wB,GAIvBA,CAER,CAQA,sBAAAs5C,CAAwBlqE,EAAO,UAE9B,IAAI4wB,EAActzB,KAAKosE,sBAAuB1pE,GAY9C,YAVqB3B,IAAhBuyB,SAEgCvyB,IAA/Bf,KAAKgsE,cAAetpE,IAAuB1C,KAAK2sE,eAAgBjqE,GAErE4wB,EAAc/e,GAAY,IAAIk3D,GAAyBzrE,KAAM0C,GAAM,IACnE4wB,EAAY8vC,gBACZpjE,KAAKosE,sBAAuB1pE,GAAS4wB,GAI/BA,CAER,CAQA,YAAAu5C,CAAcnqE,EAAO,SAEpB,IAAIoqE,EAAY9sE,KAAKksE,YAAaxpE,GAElC,QAAmB3B,IAAd+rE,EAA0B,CAE9B,MAAMn1C,EAAa33B,KAAKqsE,YAClBv0C,EAAY93B,KAAKssE,WAEvBtsE,KAAKksE,YAAaxpE,GAASoqE,EAAYn4B,GAAyB30C,KAAK2sE,eAAgBjqE,GAAQi1B,EAAYG,EAE1G,CAEA,OAAOg1C,CAER,CAQA,kBAAAC,CAAoBrqE,EAAO,SAE1B,IAAIsqE,EAAkBhtE,KAAKisE,kBAAmBvpE,GAE9C,QAAyB3B,IAApBisE,EAAgC,CAEpC,MAAMr1C,EAAa33B,KAAKqsE,YAClBv0C,EAAY93B,KAAKssE,WACjBQ,EAAY9sE,KAAK6sE,aAAcnqE,GAIrC1C,KAAKisE,kBAAmBvpE,GAASsqE,EAAkBx4B,GAA0Bs4B,EAAWn1C,EAAYG,EAErG,CAEA,OAAOk1C,CAER,CAEA,KAAA9gE,EAAO,SAAEpJ,IAWR,OATA9C,KAAKmyC,aAAaqH,aAAmCz4C,IAAzBf,KAAKq9C,QAAQ7D,QAAwB12C,EAAS02C,QAAUx5C,KAAKq9C,QAAQ7D,SAGxD,IAApC12C,EAASw6D,QAAQ2P,iBAErBjtE,KAAKmyC,aAAaqH,QAAU,GAItBx5C,KAAKmV,QAAU02D,GAAS7qC,MAAQhhC,KAAK2sE,iBAAmB3sE,KAAK+sE,oBAErE,CAEA,YAAAvgE,CAAc+O,GAEb,MAAM,SAAEzY,GAAayY,GACf,MAAEoiC,EAAK,OAAE/lB,GAAW53B,KAE1BA,KAAK8rE,YAAchpE,EAAS0vC,gBAE5B,MAAMxhB,EAAOluB,EAASslE,QAASkD,IAE/BtrE,KAAKktE,QAASl8C,EAAK7uB,MAAO6uB,EAAK5uB,QAE/B,MAAM+qE,EAAsBrqE,EAASsvC,kBAC/BwL,EAAa96C,EAAS4pC,SAE5B1sC,KAAKqsE,YAAYnpE,MAAQ00B,EAAOC,KAChC73B,KAAKssE,WAAWppE,MAAQ00B,EAAOG,IAE/B,IAAM,MAAMr1B,KAAQ1C,KAAKmsE,kBAExBnsE,KAAKysE,cAAe/pE,GAIrBI,EAASsqE,gBAAiBptE,KAAKmyC,cAC/BrvC,EAAS+6C,OAAQ79C,KAAKusE,MAEtBzpE,EAASo8D,OAAQvhB,EAAO/lB,GAExB90B,EAASsqE,gBAAiBD,GAC1BrqE,EAAS+6C,OAAQD,EAElB,CAQA,OAAAsvB,CAAS/qE,EAAOC,GAEfpC,KAAK2xD,OAASxvD,EACdnC,KAAK4xD,QAAUxvD,EAEf,MAAMirE,EAAiBrtE,KAAK2xD,OAAS3xD,KAAK8rE,YACpCwB,EAAkBttE,KAAK4xD,QAAU5xD,KAAK8rE,YAE5C9rE,KAAKmyC,aAAa+6B,QAASG,EAAgBC,EAE5C,CAOA,aAAAC,CAAeC,GAEdxtE,KAAK8rE,YAAc0B,EAEnBxtE,KAAKktE,QAASltE,KAAK2xD,OAAQ3xD,KAAK4xD,QAEjC,CAKA,OAAA3mD,GAECjL,KAAKmyC,aAAalnC,SAEnB,EAKD4gE,GAAS7qC,MAAQ,QACjB6qC,GAASx3B,MAAQ,QA6MjB,MAYMo5B,GAAkC/0D,IAAI,EAAIS,EAAO0V,KAE/C1V,EAAMkH,IAAKwO,GAAWlG,UAE1BhS,UAAW,CACdjU,KAAM,oBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,QACvB,CAAE7E,KAAM,WAAY6E,KAAM,YActBmmE,GAAoCh1D,IAAI,EAAIS,EAAO0V,MAExD1V,EAAQA,EAAMkH,IAAKwO,IAENvO,IAAKnH,EAAM/E,IAAK,IAAQuU,UAElChS,UAAW,CACdjU,KAAM,sBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,QACvB,CAAE7E,KAAM,WAAY6E,KAAM,YActBomE,GAAkCj1D,IAAI,EAAIS,EAAO0V,MAMtD,MAAMhP,GAFN1G,GADAA,EAAQA,EAAMkH,IAAKwO,IACLzO,IAAK,MAAQ/O,IAAK,IAEhBgP,IAAKlH,EAAMkH,IAAK,KAAMjM,IAAK,KACrC0L,EAAI3G,EAAMkH,IAAKlH,EAAMkH,IAAK,KAAMjM,IAAK,MAAQA,IAAK,KAExD,OAAOyL,EAAES,IAAKR,GAAIqI,IAAK,IAAK,IAEzBxR,UAAW,CACdjU,KAAM,oBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,QACvB,CAAE7E,KAAM,WAAY6E,KAAM,YAMtBqmE,GAA6Bl1D,IAAI,EAAIS,MAE1C,MAAM0G,EAAI1G,EAAMkH,IAAKlH,EAAM/E,IAAK,WAAcgM,IAAK,UAC7CN,EAAI3G,EAAMkH,IAAKlH,EAAM/E,IAAK,SAAYiM,IAAK,UAAajM,IAAK,SAEnE,OAAOyL,EAAES,IAAKR,EAAG,IAcZ+tD,GAAsCn1D,IAAI,EAAIS,EAAO0V,MAG1D,MAAMi/C,EAAe7zD,GACpB,OAAS,OAAS,OAClB,KAAS,OAAS,OAClB,MAAS,OAAS,QAIb8zD,EAAgB9zD,GACrB,SAAW,QAAW,QACpB,OAAS,SAAW,QACpB,QAAW,OAAS,SAavB,OAVAd,EAAQA,EAAMkH,IAAKwO,GAAWvO,IAAK,IAEnCnH,EAAQ20D,EAAaztD,IAAKlH,GAG1BA,EAAQy0D,GAAcz0D,IAEtBA,EAAQ40D,EAAc1tD,IAAKlH,IAGdwP,OAAO,IAEjBhS,UAAW,CACdjU,KAAM,wBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,QACvB,CAAE7E,KAAM,WAAY6E,KAAM,YAItBymE,GAA8C/zD,GAAMT,GAAM,QAAU,OAAU,OAAUA,IAAQ,MAAQ,QAAU,OAAUA,IAAQ,OAAU,MAAQ,SACtJy0D,GAA8Ch0D,GAAMT,GAAM,MAAQ,MAAQ,OAAUA,GAAM,MAAQ,MAAQ,MAAUA,GAAM,MAAQ,MAAQ,QAE1I00D,GAAyCx1D,IAAI,EAAIy1D,MAEtD,MAAMvkD,EAAIpQ,GAAM20D,GAAc30C,QACxBiqB,EAAKjqC,GAAMoQ,EAAEvJ,IAAKuJ,IAAM4P,QACxB40C,EAAK50D,GAAMiqC,EAAGpjC,IAAKojC,IAAOjqB,QAEhC,OAAO9hB,GAAO,MAAO2I,IAAK+tD,EAAG/tD,IAAKojC,IAAOrjC,IAAKC,GAAK,MAAO+tD,EAAG/tD,IAAKuJ,KAAQxV,IAAKiM,GAAK,MAAO+tD,GAAKhuD,IAAKC,GAAK,MAAOojC,EAAGpjC,IAAKuJ,KAAQxV,IAAKiM,GAAK,MAAQojC,GAAKrvC,IAAKiM,GAAK,MAAQuJ,GAAIxJ,IAAK,UAAe,IAY7LiuD,GAA+B31D,IAAI,EAAIS,EAAO0V,MAEnD,MAAMy/C,EAAY90D,GAAML,GAAQqgB,QAC1B+0C,EAAiBt0D,GAAMT,GAAM,iBAAmB,iBAAmB,iBAAoBA,GAAM,kBAAoB,iBAAmB,mBAAsBA,GAAM,kBAAoB,iBAAmB,mBACvMg1D,EAAkBv0D,GAAMT,GAAM,oBAAsB,mBAAsB,oBAAuBA,IAAQ,mBAAqB,mBAAqB,oBAAuBA,IAAQ,qBAAwB,oBAAsB,qBAChOi1D,EAAW/2D,IAAS,UACpBg3D,EAAWh3D,GAAO,UAcxB,OAbA42D,EAAU3jC,UAAW9b,GACrBy/C,EAAUn6D,OAAQ85D,GAA8B5tD,IAAKiuD,IACrDA,EAAUn6D,OAAQo6D,EAAeluD,IAAKiuD,IACtCA,EAAUn6D,OAAQwT,GAAO2mD,EAAW,QACpCA,EAAUn6D,OAAQiS,GAAMkoD,IACxBA,EAAUn6D,OAAQm6D,EAAUluD,IAAKquD,GAAWnuD,IAAKouD,EAAStuD,IAAKquD,KAC/DH,EAAUn6D,OAAQwU,GAAO2lD,EAAW,EAAK,IACzCA,EAAUn6D,OAAQ+5D,GAA0BI,IAC5CA,EAAUn6D,OAAQq6D,EAAgBnuD,IAAKiuD,IACvCA,EAAUn6D,OAAQgU,GAAKR,GAAOnO,GAAM,GAAO80D,GAAa90D,GAAM,OAC9D80D,EAAUn6D,OAAQ65D,GAA8B3tD,IAAKiuD,IACrDA,EAAUn6D,OAAQwU,GAAO2lD,EAAW,EAAK,IAElCA,CAAS,IAEb33D,UAAW,CACdjU,KAAM,iBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,QACvB,CAAE7E,KAAM,WAAY6E,KAAM,YActBonE,GAAmCj2D,IAAI,EAAIS,EAAO0V,MAEvD,MAAM+/C,EAAmBl3D,GAAO,KAC1Bm3D,EAAen3D,GAAO,KAE5ByB,EAAQA,EAAMkH,IAAKwO,GAEnB,MAAMjF,EAAIlC,GAAOvO,EAAM2jB,EAAGpV,GAAOvO,EAAM4jB,EAAG5jB,EAAM2G,IAC1CgQ,EAAS/E,GAAQnB,EAAElJ,SAAU,KAAQkJ,EAAExJ,IAAKC,GAAK,KAAMuJ,EAAEvJ,IAAKuJ,KAAS,KAE7EzQ,EAAMg3C,UAAWrgC,GAEjB,MAAMg/C,EAAOnnD,GAAOxO,EAAM2jB,EAAGnV,GAAOxO,EAAM4jB,EAAG5jB,EAAM2G,IAEnD7G,GAAI61D,EAAKpuD,SAAUkuD,IAAoB,IAE/Bz1D,IAIR,MAAM41D,EAAI3uD,GAAK,EAAGwuD,GACZI,EAAU5uD,GAAK,EAAG2uD,EAAE1uD,IAAK0uD,GAAIzuD,IAAKwuD,EAAK16D,IAAK26D,EAAE3uD,IAAKwuD,MACzDz1D,EAAMwxB,UAAWqkC,EAAQ1uD,IAAKwuD,IAC9B,MAAM/xC,EAAI3c,GAAK,EAAGE,GAAK,EAAGuuD,EAAaxuD,IAAKyuD,EAAK1uD,IAAK4uD,IAAY56D,IAAK,KAEvE,OAAOsU,GAAKvP,EAAOK,GAAMw1D,GAAWjyC,EAAG,IAEpCpmB,UAAW,CACdjU,KAAM,qBACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,QAAS6E,KAAM,QACvB,CAAE7E,KAAM,WAAY6E,KAAM,YAa5B,MAAM0nE,WAAiBzlE,EAEtB,eAAWjC,GAEV,MAAO,UAER,CASA,WAAAzH,CAAa8gE,EAAO,GAAIzqD,EAAW,GAAI+4D,EAAW,IAEjDxlE,MAAO,QASP1J,KAAKmvE,YAAa,EAQlBnvE,KAAK4gE,KAAOA,EAQZ5gE,KAAKmW,SAAWA,EAQhBnW,KAAKkvE,SAAWA,CAEjB,CAOA,QAAAnkE,GAEC,OAAO,CAER,CAQA,WAAAqkE,CAAaj5D,GAIZ,OAFAnW,KAAKmW,SAAWA,EAETnW,IAER,CAQA,WAAAqvE,GAEC,OAAOrvE,KAAKmW,QAEb,CAEA,QAAA7J,CAAUvM,GAET,MAAMoW,EAAWnW,KAAKqvE,YAAatvE,GAEnC,IAAM,MAAMuvE,KAAWn5D,EAEtBm5D,EAAQjjE,MAAOtM,GAIhB,MAAMwvE,EAAWxvE,EAAQyvE,gBAAiBxvE,KAAMA,KAAK2L,YAAa5L,IAGlE,OAFAwvE,EAAS3O,KAAO5gE,KAAK4gE,KAEd2O,EAAS3O,IAEjB,CAEA,SAAA7yD,CAAWlN,GAEV6I,MAAMqE,UAAWlN,GAEjBA,EAAK+/D,KAAO5gE,KAAK4gE,KACjB//D,EAAKquE,SAAWlvE,KAAKkvE,QAEtB,CAEA,WAAA5gE,CAAazN,GAEZ6I,MAAM4E,YAAazN,GAEnBb,KAAK4gE,KAAO//D,EAAK+/D,KACjB5gE,KAAKkvE,SAAWruE,EAAKquE,QAEtB,EAuED,MAAMO,WAAqBR,GAE1B,eAAW1nE,GAEV,MAAO,cAER,CASA,WAAAzH,CAAa8gE,EAAO,GAAIzqD,EAAW,GAAI+4D,EAAW,IAEjDxlE,MAAOk3D,EAAMzqD,EAAU+4D,EAExB,CAEA,WAAAvjE,CAAa5L,GAEZ,OAAOC,KAAK0vE,gBAAiB3vE,GAAUwH,IAExC,CAQA,SAAAqX,CAAW7e,GAEV,OAAOC,KAAK0vE,gBAAiB3vE,GAAU8T,MAExC,CAQA,eAAA67D,CAAiB3vE,GAEhB,MAAMsN,EAAWtN,EAAQuN,gBAAiBtN,MAE1C,IAAI2vE,EAAetiE,EAASsiE,aAU5B,YARsB5uE,IAAjB4uE,IAEJA,EAAe5vE,EAAQ6vE,OAAOC,cAAe7vE,KAAK4gE,MAElDvzD,EAASsiE,aAAeA,GAIlBA,CAER,CAEA,QAAArjE,CAAUvM,EAASwM,GAElB7C,MAAM4C,SAAUvM,GAEhB,MAAM4vE,EAAe3vE,KAAK0vE,gBAAiB3vE,GAErC2C,EAAOitE,EAAajtE,KACpB6E,EAAOooE,EAAapoE,KAEpBgoE,EAAWxvE,EAAQyvE,gBAAiBxvE,KAAMuH,GAElC,KAAT7E,IAIJ6sE,EAAS7sE,KAAOA,GAIjB,MAAMqN,EAAehQ,EAAQmQ,gBAAiBq/D,GAExC3O,EAAO5gE,KAAK0vE,gBAAiB3vE,GAAU+vE,QAAS//D,GAItD,OAFAw/D,EAAS3O,KAAOA,EAAO,KAEP,aAAXr0D,EAEGwD,EAIAhQ,EAAQ4N,OAAQ,GAAIoC,MAAmBxI,EAAMgF,EAItD,EA8RD,MAAMwjE,WAAkBrpE,IAEvB,GAAA5F,CAAKgO,EAAKxE,EAAW,QAAS5E,GAE7B,GAAK1F,KAAKW,IAAKmO,GAAQ,OAAOpF,MAAM5I,IAAKgO,GAEzC,GAAkB,OAAbxE,EAAoB,CAExB,MAAMpH,EAAQoH,KAAa5E,GAE3B,OADA1F,KAAKwC,IAAKsM,EAAK5L,GACRA,CAER,CAED,EA8C+B,IAAI6sE,GA2pBpC,SAASlD,GAAc9sE,GAEtB,IAAI20C,EAEJ,MAAMs7B,EAAWjwE,EAAQsC,QAAQ2tE,SAQjC,YANkBjvE,IAAbivE,IAEJt7B,EAAQs7B,EAAUhwE,QAIV00C,GAAS5a,GAAamD,GAAIhW,QAEpC,CASA,MAAMgpD,GAAiBv3D,IAAI,EAAImf,EAAME,GAAOh4B,KAE3C,MAAM20C,EAAQm4B,GAAc9sE,GAE5B,OAAOipB,GAAY6O,EAAME,EAAK2c,EAAO,IAYhCw7B,GAAmBx3D,IAAI,EAAIy3D,GAAWpwE,KAE3C,MAAM20C,EAAQm4B,GAAc9sE,GAE5B,OAAOowE,EAAQ9vD,IAAK8vD,EAASz7B,EAAOA,GAAQztB,SAAShB,MAAMiB,UAAU,IAYhEowB,GAAM5+B,IAAI,EAAIS,EAAO/D,KAEnBwE,GAAMxE,EAAOg7D,UAAU1nD,IAAKnc,GAAOwgB,IAAK5T,EAAM8wC,UAAY19C,GAAOsT,KAkczDjH,GAzChB,cAA0BpP,EAOzB,WAAA1J,CAAaqV,GAEZzL,QAEA1J,KAAKmV,MAAQA,CAEd,CAEA,QAAA7I,CAAUvM,GAET,MAAM,MAAEoV,GAAUnV,MACZ,SAAE8C,GAAa/C,GAEoB,IAApC+C,EAASw6D,QAAQ2P,eAErBltE,EAAQ0qB,YAAa,QAAQtV,eAI7BpV,EAAQoQ,gBAAiB,GAAGgF,aAAkBnV,KAIhD,IAkQD,MAAMqwE,WAA2B3gE,EAEhC,eAAWnI,GAEV,MAAO,oBAER,CAUA,WAAAzH,CAAa4hB,EAAQ4uD,EAAat8B,EAAWu8B,EAAY,MAExD7mE,MAAO,QAOP1J,KAAK0hB,OAASA,EAOd1hB,KAAKswE,YAAcA,EAOnBtwE,KAAKg0C,UAAYA,EAQjBh0C,KAAKuwE,UAAYA,CAElB,CASA,YAAA99D,CAAc1S,GAEb,OAAOC,KAAKswE,YAAY3kE,YAAa5L,EAEtC,CAQA,WAAA4L,CAAa5L,GAEZ,OAAOC,KAAKyS,aAAc1S,EAE3B,CAEA,QAAAuM,CAAUvM,GAET,MAAM2hB,EAAS1hB,KAAK0hB,OAEdna,EAAOvH,KAAK2L,YAAa5L,GACzB0iB,EAAYziB,KAAKyS,aAAc1S,GAE/B8f,EAAI7f,KAAKswE,YACTxwD,EAAI9f,KAAKg0C,UAETtuC,EAAS,GAEfA,EAAOI,KAAM,IAAK+Z,EAAExT,MAAOtM,EAAS0iB,MACpC/c,EAAOI,KAAMga,EAAEzT,MAAOtM,EAAS0iB,IAE/B,MAAM+tD,EAAgB,GAAIzwE,EAAQogB,UAAWuB,EAAQna,OAAY7B,EAAOoL,KAAM,UAE9E,GAAwB,OAAnB9Q,KAAKuwE,UAAqB,CAE9B,MAAME,EAAazwE,KAAKuwE,UAAUlkE,MAAOtM,EAAS0iB,GAElD1iB,EAAQoQ,gBAAiB,GAAGsgE,OAAgBD,IAAiBxwE,KAE9D,MAECD,EAAQoQ,gBAAiBqgE,EAAexwE,KAI1C,EAIDqwE,GAAmBK,YAAc,aACjCL,GAAmBM,aAAe,cAClCN,GAAmBO,WAAa,YAChCP,GAAmBQ,WAAa,YAChCR,GAAmBS,WAAa,YAChCT,GAAmBU,WAAa,YAChCV,GAAmBW,WAAa,YAChCX,GAAmBY,UAAY,WAC/BZ,GAAmBa,WAAa,YAYbt4D,GAAWy3D,IA+G9B,IAAIc,GAEJ,SAASC,GAAcnL,GAEtBkL,GAAcA,IAAe,IAAIjxE,QAEjC,IAAImxE,EAAWF,GAAYrwE,IAAKmlE,GAIhC,YAFkBllE,IAAbswE,GAAyBF,GAAY3uE,IAAKyjE,EAAOoL,EAAW,CAAC,GAE3DA,CAER,CASA,SAASC,GAAmBrL,GAE3B,MAAMplE,EAAOuwE,GAAcnL,GAE3B,OAAOplE,EAAK0wE,eAAkB1wE,EAAK0wE,aAAez1D,GAAS,QAASX,SAAUN,IAAcnQ,gBAAgB,MAEjF,IAArBu7D,EAAMuL,YAEVvL,EAAMwL,OAAOC,eAAgBzL,GAIvBA,EAAMwL,OAAOx8C,UAItB,CAUA,SAAS08C,GAAmB1L,GAE3B,MAAMplE,EAAOuwE,GAAcnL,GAE3B,QAA2BllE,IAAtBF,EAAK+wE,aAA6B,CAEtC,MAAMC,EAAiBP,GAAmBrL,GAAQ5lD,IAAKuZ,IAEvD/4B,EAAK+wE,aAAeC,EAAe9uD,IAAIzC,IAAKuxD,EAAe30C,EAG5D,CAEA,OAAOr8B,EAAK+wE,YAEb,CASA,SAAStlB,GAAe2Z,GAEvB,MAAMplE,EAAOuwE,GAAcnL,GAE3B,OAAOplE,EAAKgrC,WAAchrC,EAAKgrC,SAAW/vB,GAAS,IAAI,OAAYX,SAAUN,IAAcnQ,gBAAgB,CAAEwN,EAAGpN,IAAUA,EAAK5H,MAAMm1B,sBAAuB4tC,EAAMrkE,eAEnK,CASA,SAASkwE,GAAqB7L,GAE7B,MAAMplE,EAAOuwE,GAAcnL,GAE3B,OAAOplE,EAAKkxE,iBAAoBlxE,EAAKkxE,eAAiBj2D,GAAS,IAAI,OAAYX,SAAUN,IAAcnQ,gBAAgB,CAAEwN,EAAGpN,IAAUA,EAAK5H,MAAMm1B,sBAAuB4tC,EAAM7nD,OAAOxc,eAEtL,CASA,SAASowE,GAAmB/L,GAE3B,MAAMplE,EAAOuwE,GAAcnL,GAE3B,OAAOplE,EAAKoxE,eAAkBpxE,EAAKoxE,aAAen2D,GAAS,IAAI,OAAYX,SAAUN,IAAcnQ,gBAAgB,EAAIktB,UAAU9sB,KAEhIA,EAAK5H,MAAQ4H,EAAK5H,OAAS,IAAI,MAC/B4H,EAAK5H,MAAMm1B,sBAAuB4tC,EAAMrkE,aAExCkJ,EAAK5H,MAAM+1B,aAAcrB,EAAOO,mBAAoB,IAItD,CASA,MAAM+5C,GAAyBjM,GAAW/tC,GAAiB3P,mBAAoB+jC,GAAe2Z,GAAQ7lD,IAAK0xD,GAAqB7L,KAU1HkM,GAAmB,CAAE/uE,EAAIgvE,KAE9B,IAAM,MAAMC,KAAaD,EAExB,GAAKC,EAAUC,qBAAuBD,EAAUpM,MAAM7iE,KAAOA,EAE5D,OAAOivE,EAMT,OAAO,IAAI,EAINE,GAA+B,IAAIryE,QASzC,MAAMsyE,WAAmBhpE,EAExB,eAAWjC,GAEV,MAAO,YAER,CAKA,WAAAzH,GAEC4J,MAAO,QAOP1J,KAAKyyE,iBAAmBj5D,KAAOggB,MAAO,gBAOtCx5B,KAAK0yE,kBAAoBl5D,KAAOggB,MAAO,iBAOvCx5B,KAAKi5C,kBAAoBz/B,KAAOggB,MAAO,iBAQvCx5B,KAAK2yE,QAAU,GAUf3yE,KAAK4yE,YAAc,KASnB5yE,KAAK6yE,gBAAkB,KAQvB7yE,KAAKgK,QAAS,CAEf,CAQA,cAAAoB,GAEC,MAAM0nE,EAAW,GACXv7B,EAASv3C,KAAK2yE,QAEpB,IAAM,IAAItuE,EAAI,EAAGA,EAAIkzC,EAAOvzC,OAAQK,IAEnCyuE,EAAShtE,KAAMyxC,EAAQlzC,GAAIjB,IAI5B,OAAOmC,EAAWutE,EAEnB,CAQA,OAAAxnE,CAASvL,GAER,GAA8B,OAAzBC,KAAK6yE,gBAA2B,CAEV,OAArB7yE,KAAK4yE,aAAuB5yE,KAAK+yE,gBAAiBhzE,GAEvD,MAAMiM,EAAO,GAEb,IAAM,MAAMqmE,KAAaryE,KAAK4yE,YAE7B5mE,EAAKlG,KAAMusE,EAAUtsE,UAAUuF,WAIhCtL,KAAK6yE,gBAAkB,UAAY7mE,EAAK8E,KAAM,IAE/C,CAEA,OAAO9Q,KAAK6yE,eAEb,CAEA,OAAA1mE,CAASpM,GAER,MAAMmN,EAAanN,EAAQuN,gBAAiBtN,MAE5C,IAAM,MAAMmG,KAAQ+G,EAAWnK,MAE9BoD,EAAKkG,MAAOtM,EAId,CAQA,eAAAgzE,CAAiBhzE,GAEhB,MAAMqyE,EAAa,GAEbY,EAAqBhzE,KAAK4yE,YAE1Br7B,EAjLW,CAAEA,GAEbA,EAAO7jC,MAAM,CAAEmM,EAAGC,IAAOD,EAAEzc,GAAK0c,EAAE1c,KA+KzB6vE,CAAYjzE,KAAK2yE,SAC1BO,EAAcnzE,EAAQ+C,SAAS2rB,QAErC,IAAM,MAAMw3C,KAAS1uB,EAEpB,GAAK0uB,EAAMpjE,OAEVuvE,EAAWtsE,KAAMyO,GAAY0xD,QAEvB,CAEN,IAAIoM,EAAY,KAQhB,GAN4B,OAAvBW,IAEJX,EAAYF,GAAkBlM,EAAM7iE,GAAI4vE,IAItB,OAAdX,EAAqB,CAIzB,MAAMc,EAAiBD,EAAYE,kBAAmBnN,EAAMnmE,aAE5D,GAAwB,OAAnBqzE,EAA0B,CAE9B1mE,QAAQC,KAAM,wDAAyDu5D,EAAMnmE,YAAY4C,QACzF,QAED,CAEA,IAAI2vE,EAAY,KAETE,GAAe5xE,IAAKslE,GAO1BoM,EAAYE,GAAezxE,IAAKmlE,IALhCoM,EAAY99D,GAAY,IAAI4+D,EAAgBlN,IAC5CsM,GAAe/vE,IAAKyjE,EAAOoM,IAQ5BD,EAAWtsE,KAAMusE,EAElB,CAED,CAIDryE,KAAK4yE,YAAcR,CAEpB,CASA,WAAAt3B,CAAa/6C,EAASqyE,GAErB,IAAM,MAAMC,KAAaD,EAExBC,EAAUhmE,MAAOtM,EAInB,CAUA,KAAAmM,CAAOnM,GAEoB,OAArBC,KAAK4yE,aAAuB5yE,KAAK+yE,gBAAiBhzE,GAEvD,MAAMsC,EAAUtC,EAAQsC,QAClByuC,EAAgBzuC,EAAQyuC,cAE9B,IAAImI,EAAoBj5C,KAAKi5C,kBAE7B,GAAKnI,EAAgB,CAEpB,MAAM,YAAE8hC,EAAW,iBAAEH,EAAgB,kBAAEC,GAAsB1yE,KAE7DqC,EAAQg9C,cAAgBpG,EAExB,MAAMziC,EAAQzW,EAAQwW,WAIHxW,EAAQuN,gBAAiBtN,MACjC+C,MAAQyT,EAAMzT,MAIzB+tC,EAAcrvC,MAAOY,EAASmU,EAAOzW,GAIrCC,KAAK86C,YAAa/6C,EAAS6yE,GAI3B9hC,EAAcqO,SAAU98C,EAASmU,EAAOzW,GAIxC,MAAM,SAAE0xC,EAAQ,cAAEC,GAAkBrvC,GAC9B,cAAE6uC,EAAa,eAAEC,EAAc,gBAAEC,EAAe,iBAAEC,GAAqBhvC,EAAQ4uC,eAErF,IAAIoiC,EAAeniC,EAAc98B,IAAKg9B,GAEpB,OAAbK,IAIH4hC,EAAe75D,GAFO,OAAlBk4B,EAEiBA,EAAchpB,IAAK2qD,EAAc5hC,GAIjCA,GAItBpvC,EAAQpB,SAASq5C,aAAc,GAIhCm4B,EAAiBt+D,OAAQk/D,GACzBX,EAAkBv+D,OAAQg9B,EAAe/8B,IAAKi9B,IAE9C4H,EAAkB9kC,OAAQs+D,EAAiBr+D,IAAKs+D,IAIhD5hC,EAAckO,OAAQ38C,EAASmU,EAAOzW,GAItCk5C,EAAoBA,EAAkBpnB,OAAQ9xB,EAAQ0W,cAEvD,CAEA,OAAOwiC,CAER,CAQA,SAAAmtB,CAAW7uB,GAOV,OALAv3C,KAAK2yE,QAAUp7B,EAEfv3C,KAAK4yE,YAAc,KACnB5yE,KAAK6yE,gBAAkB,KAEhB7yE,IAER,CAOA,SAAAq7C,GAEC,OAAOr7C,KAAK2yE,OAEb,CAOA,aAAIp3B,GAEH,OAAOv7C,KAAK2yE,QAAQ3uE,OAAS,CAE9B,EAyBD,MAAMsvE,WAAuB9pE,EAE5B,eAAWjC,GAEV,MAAO,gBAER,CAOA,WAAAzH,CAAammE,GAEZv8D,QAOA1J,KAAKimE,MAAQA,EAQbjmE,KAAK4J,iBAAmBlB,EAAeG,OASvC7I,KAAKuzE,kBAAmB,CAEzB,CAOA,mBAAAC,EAAqB,SAAEvyE,IAItBwyE,GAAoBt/D,OAAQlT,EAAS62C,oBAAsBle,GAE5D,CAOA,OAAA3uB,GAECjL,KAAK4J,iBAAmBlB,EAAeC,IAExC,EASD,MAAM8qE,GAAoCj6D,KAAOggB,MAAO,uBAcxD,SAASk6C,GAAmB5wE,EAAUmrB,EAAQ,CAAC,GAgB9C,OAdAA,EAAMI,YAAcvrB,EAASurB,YAC7BJ,EAAMM,oBAAsBzrB,EAASyrB,oBACrCN,EAAMrB,iBAAmB9pB,EAAS8pB,iBAClCqB,EAAMkkB,aAAervC,EAASsvC,kBAC9BnkB,EAAMq5C,eAAiBxkE,EAAS6wE,oBAChC1lD,EAAMg6C,kBAAoBnlE,EAAS8wE,uBACnC3lD,EAAM4lD,qBAAuB/wE,EAASgxE,0BACtC7lD,EAAMu/C,WAAa1qE,EAAS0vC,gBAC5BvkB,EAAMwe,IAAM3pC,EAAS4pC,SACrBze,EAAM04C,WAAa7jE,EAASixE,cAAe9lD,EAAM04C,YAAc,IAAI,OACnE14C,EAAM+lD,WAAalxE,EAASmxE,gBAC5BhmD,EAAMimD,UAAYpxE,EAASoxE,UAC3BjmD,EAAMkmD,YAAcrxE,EAASsxE,iBAEtBnmD,CAER,CAaA,SAASomD,GAAoBvxE,EAAUmrB,GAStC,OAPAA,EAAQylD,GAAmB5wE,EAAUmrB,GAErCnrB,EAAS+6C,OAAQ,MACjB/6C,EAASwxE,wBAAyB,MAClCxxE,EAASyxE,cAAe,EAAU,GAClCzxE,EAASoxE,WAAY,EAEdjmD,CAER,CASA,SAASumD,GAAsB1xE,EAAUmrB,GAExCnrB,EAASurB,YAAcJ,EAAMI,YAC7BvrB,EAASyrB,oBAAsBN,EAAMM,oBACrCzrB,EAAS8pB,iBAAmBqB,EAAMrB,iBAClC9pB,EAASsqE,gBAAiBn/C,EAAMkkB,aAAclkB,EAAMq5C,eAAgBr5C,EAAMg6C,mBAC1EnlE,EAASwxE,wBAAyBrmD,EAAM4lD,sBACxC/wE,EAASyqE,cAAet/C,EAAMu/C,YAC9B1qE,EAAS+6C,OAAQ5vB,EAAMwe,KACvB3pC,EAASyxE,cAAetmD,EAAM04C,WAAY14C,EAAM+lD,YAChDlxE,EAASoxE,UAAYjmD,EAAMimD,UAC3BpxE,EAAS2xE,eAAgBxmD,EAAMkmD,YAEhC,CAYA,SAASO,GAAgB/2B,EAAO1vB,EAAQ,CAAC,GAMxC,OAJAA,EAAM+8C,WAAartB,EAAMqtB,WACzB/8C,EAAM0mD,eAAiBh3B,EAAMg3B,eAC7B1mD,EAAM2mD,iBAAmBj3B,EAAMi3B,iBAExB3mD,CAER,CAaA,SAAS4mD,GAAiBl3B,EAAO1vB,GAQhC,OANAA,EAAQymD,GAAgB/2B,EAAO1vB,GAE/B0vB,EAAMqtB,WAAa,KACnBrtB,EAAMg3B,eAAiB,KACvBh3B,EAAMi3B,iBAAmB,KAElB3mD,CAER,CASA,SAAS6mD,GAAmBn3B,EAAO1vB,GAElC0vB,EAAMqtB,WAAa/8C,EAAM+8C,WACzBrtB,EAAMg3B,eAAiB1mD,EAAM0mD,eAC7Bh3B,EAAMi3B,iBAAmB3mD,EAAM2mD,gBAEhC,CAkCA,SAASG,GAA4BjyE,EAAU66C,EAAO1vB,GAKrD,OAFAA,EAAQ4mD,GAAiBl3B,EADzB1vB,EAAQomD,GAAoBvxE,EAAUmrB,GAKvC,CAUA,SAAS+mD,GAA8BlyE,EAAU66C,EAAO1vB,GAEvDumD,GAAsB1xE,EAAUmrB,GAChC6mD,GAAmBn3B,EAAO1vB,EAE3B,CAiBA,MAAMgnD,GAAkC,IAAI/0E,QACtCg1E,GAA+Bx8D,IAAI,EAAImzB,EAAUlU,EAAYG,MAElE,IAAIq9C,EAAOv7C,GAAcxZ,IAAKyrB,GAAW7nC,SAIzC,OAHAmxE,EAAOA,EAAK/0D,IAAKuX,GAAarX,IAAKwX,EAAU1X,IAAKuX,IAClDw9C,EAAOA,EAAKrsD,WAELqsD,CAAI,IAiBNC,GAAsBnP,IAE3B,IAAIhlE,EAAWg0E,GAAkBn0E,IAAKmlE,GAEtC,QAAkBllE,IAAbE,EAAyB,CAE7B,MAAMqzB,EAAY2xC,EAAMoP,aAnBG,CAAEpP,IAE9B,MAAMruC,EAASquC,EAAMwL,OAAO75C,OAEtB09C,EAAeznD,GAAW,OAAQ,QAAS+J,GAASzc,SAAUN,IAC9D06D,EAAc1nD,GAAW,MAAO,QAAS+J,GAASzc,SAAUN,IAE5D26D,EAAoBt8C,GAAgB+sC,GAE1C,OAAOiP,GAAgBM,EAAmBF,EAAcC,EAAa,EAU7BE,CAAsBxP,GAAU,KAEvEhlE,EAAW,IAAIm2C,GACfn2C,EAASurB,UAAY5S,GAAM,EAAG,EAAG,EAAG,GACpC3Y,EAASqzB,UAAYA,EACrBrzB,EAASu2D,sBAAuB,EAChCv2D,EAASyB,KAAO,iBAChBzB,EAASq2C,KAAM,EAEf29B,GAAkBzyE,IAAKyjE,EAAOhlE,EAE/B,CAEA,OAAOA,CAAQ,EAcVy0E,GAAkCh9D,IAAI,EAAI2uD,eAAcsO,iBAEtD7hD,GAASuzC,EAAcsO,EAAYtsD,IAAK6N,QAASy+C,EAAY14C,KAc/D24C,GAAgCl9D,IAAI,EAAI2uD,eAAcsO,cAAalE,aAExE,MAAMoE,EAAe,CAAE1sD,EAAI+N,IAAapD,GAASuzC,EAAcl+C,GAAK+N,QAASA,GAEvE4+C,EAAUjoD,GAAW,UAAW,OAAQ4jD,GAASt2D,SAAUN,IAC3Dk7D,EAASloD,GAAW,SAAU,QAAS4jD,GAASt2D,SAAUN,IAE1DgrC,EAAYzsC,GAAM,GAAIkH,IAAKw1D,GAC3BE,EAAMnwB,EAAUj8B,EAAE3C,SAAS5G,IAAK01D,GAChCE,EAAMpwB,EAAU/7B,EAAE7C,SAAS5G,IAAK01D,GAChCG,EAAMrwB,EAAUj8B,EAAEvJ,IAAK01D,GACvBI,EAAMtwB,EAAU/7B,EAAEzJ,IAAK01D,GACvBK,EAAMJ,EAAI11D,IAAK,GACf+1D,EAAMJ,EAAI31D,IAAK,GACfg2D,EAAMJ,EAAI51D,IAAK,GACfi2D,EAAMJ,EAAI71D,IAAK,GAErB,OAAOlM,GACNyhE,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM48D,EAAKC,IAASN,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM,EAAG68D,IAASN,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM88D,EAAKD,IAASN,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAMg9D,EAAKC,IAASV,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM,EAAGi9D,IAASV,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAMk9D,EAAKD,IAASV,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM48D,EAAK,IAAOL,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAMg9D,EAAK,IAAOT,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAIssD,EAAY14C,GAC1C44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAMk9D,EAAK,IAAOX,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM88D,EAAK,IAAOP,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAMg9D,EAAKG,IAASZ,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM,EAAGm9D,IAASZ,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAMk9D,EAAKC,IAASZ,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM48D,EAAKG,IAASR,EAAY14C,GAClE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM,EAAG+8D,IAASR,EAAY14C,GAChE44C,EAAcF,EAAYtsD,GAAGjV,IAAKgF,GAAM88D,EAAKC,IAASR,EAAY14C,IACjE5c,IAAK,EAAI,GAAI,IAcVm2D,GAAoC99D,IAAI,EAAI2uD,eAAcsO,cAAalE,aAE5E,MAAMoE,EAAe,CAAE1sD,EAAI+N,IAAapD,GAASuzC,EAAcl+C,GAAK+N,QAASA,GAEvE4+C,EAAUjoD,GAAW,UAAW,OAAQ4jD,GAASt2D,SAAUN,IAE3DgrC,EAAYzsC,GAAM,GAAIkH,IAAKw1D,GAC3BW,EAAK5wB,EAAUj8B,EACf8sD,EAAK7wB,EAAU/7B,EAEfX,EAAKwsD,EAAYtsD,GACjBy5B,EAAIr8B,GAAO0C,EAAG9I,IAAKy1D,GAAU1hE,IAAK,KAGxC,OAFA+U,EAAGgnC,UAAWrN,EAAEziC,IAAKwlC,IAEdzxC,GACNyhE,EAAc1sD,EAAIwsD,EAAY14C,GAC9B44C,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAI,IAAOd,EAAY14C,GACnD44C,EAAc1sD,EAAG/U,IAAKgF,GAAM,EAAGs9D,IAAQf,EAAY14C,GACnD44C,EAAc1sD,EAAG/U,IAAKyxC,GAAa8vB,EAAY14C,GAC/CvU,GACCmtD,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGxvD,SAAU,IAAO0uD,EAAY14C,GAC5D44C,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGp2D,IAAK,GAAK,IAAOs1D,EAAY14C,GAC5D6lB,EAAEl5B,GAEHlB,GACCmtD,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGxvD,SAAUyvD,IAAQf,EAAY14C,GAC7D44C,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGp2D,IAAK,GAAKq2D,IAAQf,EAAY14C,GAC7D6lB,EAAEl5B,GAEHlB,GACCmtD,EAAc1sD,EAAG/U,IAAKgF,GAAM,EAAGs9D,EAAGzvD,WAAc0uD,EAAY14C,GAC5D44C,EAAc1sD,EAAG/U,IAAKgF,GAAM,EAAGs9D,EAAGr2D,IAAK,KAASs1D,EAAY14C,GAC5D6lB,EAAEh5B,GAEHpB,GACCmtD,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAIC,EAAGzvD,WAAc0uD,EAAY14C,GAC7D44C,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAIC,EAAGr2D,IAAK,KAASs1D,EAAY14C,GAC7D6lB,EAAEh5B,GAEHpB,GACCA,GACCmtD,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGxvD,SAAUyvD,EAAGzvD,WAAc0uD,EAAY14C,GACtE44C,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGp2D,IAAK,GAAKq2D,EAAGzvD,WAAc0uD,EAAY14C,GACtE6lB,EAAEl5B,GAEHlB,GACCmtD,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGxvD,SAAUyvD,EAAGr2D,IAAK,KAASs1D,EAAY14C,GACtE44C,EAAc1sD,EAAG/U,IAAKgF,GAAMq9D,EAAGp2D,IAAK,GAAKq2D,EAAGr2D,IAAK,KAASs1D,EAAY14C,GACtE6lB,EAAEl5B,GAEHk5B,EAAEh5B,IAEFzJ,IAAK,EAAI,EAAG,IAaTs2D,GAAgCj+D,IAAI,EAAI2uD,eAAcsO,kBAE3D,MAAMiB,EAAYl/D,GAAO,GAAI8hB,QAEvBq9C,EAAe/iD,GAASuzC,GAAevwC,OAAQ6+C,EAAYtsD,IAAKoa,GAEhEqzC,EAAajvD,GAAM8tD,EAAY14C,EAAG45C,EAAajtD,GAYrD,OAVA3Q,GAAI69D,EAAWr2D,SAAU/I,GAAO,KAAS,KAExC,MAAMqQ,EAAW4tD,EAAY14C,EAAE7c,IAAKy2D,EAAajtD,GAC3CmtD,EAAWpvD,GAAO,EAAGkvD,EAAa/sD,EAAEzJ,IAAKw2D,EAAa/sD,IAC5D,IAAIktD,EAAsBD,EAASz2D,IAAKy2D,EAAS3iE,IAAK2T,EAAS1H,IAAK0H,KACpEivD,EAAsBruD,GAAOvI,GAAK42D,EAAqB,IAAM12D,IAAK,IAAO,KACzEs2D,EAAUziE,OAAQwU,GAAOhB,GAAOmvD,EAAYE,IAAyB,IAI/DJ,CAAS,IAeXK,GAAgCv+D,IAAI,EAAI8gC,UAASu8B,SAAQ/kD,OAAMkmD,iBAEpE,MAAMC,EAAOz/D,GAAO,GAAI8hB,QAClB49C,EAAc1/D,GAAO,GAAI8hB,QAEzB69C,EAAW79B,EAAQ54B,cAAelJ,GAAO,IAAMqT,OAAQrT,GAAO,GAAKA,GAAO,GAAI4I,IAAKk5B,EAAQp5B,IAAK,KAChGk3D,EAAU99B,EAAQ54B,cAAelJ,GAAO,IAAMqT,OAAQrT,GAAO,GAAKA,IAAS,IAEjFw2B,GAAM,CAAEzsC,MAAO+V,GAAK,GAAK81B,IAAK91B,GAAKgiC,GAAWjyC,KAAM,MAAOgmC,UAAW,MAAO,EAAIlpC,QAEhF,MAAMkzE,EAAWD,EAAQljE,IAAKsD,GAAOrT,GAAIgc,IAAKg3D,IAExC//C,EAAQ4/C,EAAWpgD,OAAQ1iB,GAAKs+B,GAAiBrpB,GAAIjQ,GAAM,EAAGm+D,GAAWl3D,IAAK01D,IAAWz1D,IAAK0Q,IAASpH,EAC7GutD,EAAK9mC,UAAW/Y,GAChB8/C,EAAY/mC,UAAW/Y,EAAMjX,IAAKiX,GAAS,IAI5C6/C,EAAK1uB,UAAWjP,GAChB49B,EAAY3uB,UAAWjP,GAEvB,MAAMg+B,EAAUnxD,GAAM+wD,EAAYh3D,IAAK+2D,EAAK92D,IAAK82D,KACjD,OAAO/9D,GAAM+9D,EAAMK,EAAS,IAevBC,GAAkC/+D,IAAI,EAAI8gC,UAASu8B,SAAQ/kD,OAAMkmD,iBAEtE,MAAMC,EAAOz/D,GAAO,GAAI8hB,QAClB49C,EAAc1/D,GAAO,GAAI8hB,QAEzB69C,EAAW79B,EAAQ54B,cAAelJ,GAAO,IAAMqT,OAAQrT,GAAO,GAAKA,GAAO,GAAI4I,IAAKk5B,EAAQp5B,IAAK,KAChGk3D,EAAU99B,EAAQ54B,cAAelJ,GAAO,IAAMqT,OAAQrT,GAAO,GAAKA,IAAS,IAEjFw2B,GAAM,CAAEzsC,MAAO+V,GAAK,GAAK81B,IAAK91B,GAAKgiC,GAAWjyC,KAAM,MAAOgmC,UAAW,MAAO,EAAIlpC,QAEhF,MAAMkzE,EAAWD,EAAQljE,IAAKsD,GAAOrT,GAAIgc,IAAKg3D,IAExCR,EAAeK,EAAWpgD,OAAQ1iB,GAAKs+B,GAAiBrpB,GAAIjQ,GAAMm+D,EAAU,GAAIl3D,IAAK01D,IAAWz1D,IAAK0Q,IAC3GmmD,EAAK9mC,UAAWwmC,EAAajtD,GAC7BwtD,EAAY/mC,UAAWj8B,GAAKyiE,EAAa/sD,EAAEzJ,IAAKw2D,EAAa/sD,GAAK+sD,EAAajtD,EAAEvJ,IAAKw2D,EAAajtD,IAAO,IAI3GutD,EAAK1uB,UAAWjP,GAChB49B,EAAY3uB,UAAWjP,GAEvB,MAAMg+B,EAAUnxD,GAAM+wD,EAAYh3D,IAAK+2D,EAAK92D,IAAK82D,KACjD,OAAO/9D,GAAM+9D,EAAMK,EAAS,IAIvBE,GAAmB,CAAEhC,GAAmBE,GAAiBY,GAAqBG,IAIpF,IAAIgB,GACJ,MAAMC,GAA4B,IAAIrN,GAOtC,MAAMsN,WAAmBvE,GAExB,eAAW/rE,GAEV,MAAO,YAER,CAQA,WAAAzH,CAAammE,EAAOwL,EAAS,MAE5B/nE,MAAOu8D,GASPjmE,KAAKyxE,OAASA,GAAUxL,EAAMwL,OAQ9BzxE,KAAK83E,UAAY,KASjB93E,KAAK+3E,qBAAuB,KAS5B/3E,KAAKg4E,uBAAyB,KAS9Bh4E,KAAKi4E,oBAAsB,KAS3Bj4E,KAAKk4E,sBAAwB,KAU7Bl4E,KAAKm4E,MAAQ,KASbn4E,KAAKo4E,cAAe,CAErB,CAaA,iBAAAC,CAAmBt4E,GAAS,SAAEu4E,EAAQ,aAAEjR,EAAY,YAAEsO,EAAW,OAAElE,IAElE,MAAM8G,EAAc5C,EAAY/rD,EAAE/I,iBAAkB,GAClDC,IAAK60D,EAAY/rD,EAAEhJ,cAAe,IAClCE,IAAK60D,EAAY7rD,EAAEjJ,iBAAkB,IACrCC,IAAK60D,EAAY7rD,EAAElJ,cAAe,IAClCE,IAAK60D,EAAY14C,EAAErc,cAAe,IAE9Bw2C,EAAakhB,EAAU,CAAEjR,eAAcsO,cAAalE,WAE1D,OAAO8G,EAAYxtD,OAAQqsC,EAAY1/C,GAAO,GAE/C,CASA,gBAAA8gE,CAAkBz4E,EAAS04E,GAE1B,MAAM,OAAEhH,GAAWzxE,MACb,SAAE8C,GAAa/C,EAEfk3B,EAAOpJ,GAAW,OAAQ,QAAS4jD,GAASt2D,SAAUN,IAE5D,IACI69D,EADA/C,EAAc8C,EAGlB,GAAKhH,EAAO75C,OAAO+gD,uBAA4D,IAApC71E,EAAS62C,uBAEnDg8B,EAAcA,EAAY5yD,IAAIzC,IAAKq1D,EAAYz4C,GAE/Cw7C,EAAS/C,EAAY14C,EAEhBn6B,EAAS4f,mBAAqB,QAElCg2D,EAASA,EAAOr4D,IAAK,GAAID,IAAK,QAIzB,CAEN,MAAM8c,EAAIy4C,EAAYz4C,EACtBy4C,EAAcA,EAAYtsD,GAAG/I,IAAK4c,GAKlC,MAAM07C,EAAkB/qD,GAAW,OAAQ,QAAS4jD,EAAO75C,QAASzc,SAAUN,IACxEg+D,EAAiBhrD,GAAW,MAAO,QAAS4jD,EAAO75C,QAASzc,SAAUN,IAE5E69D,EAAS9jC,GAAyB1X,EAAEjW,SAAU2xD,EAAiBC,EAEhE,CAQA,OANAlD,EAAcn8D,GACbm8D,EAAY/rD,EACZ+rD,EAAY7rD,EAAE5C,WACdwxD,EAAOtkE,IAAK6iB,IAGN0+C,CAER,CAQA,iBAAAmD,CAAmBvxE,GAElB,OAAOmwE,GAAkBnwE,EAE1B,CAQA,WAAAwxE,CAAah5E,GAEZ,MAAM,SAAE+C,GAAa/C,GAEf,MAAEkmE,EAAK,OAAEwL,GAAWzxE,KAEpBg5E,EAAgBl2E,EAASg1E,UAAUvwE,KAEnC8/D,EAAe,IAAI,MAAcoK,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,QAC5EilE,EAAa4R,gBAAkB,MAE/B,MAAMnB,EAAY/3E,EAAQm5E,mBAAoBzH,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,QAOnF,GANA01E,EAAUzQ,aAAeA,EAEzBoK,EAAO75C,OAAOuhD,yBAITH,IAAkB,MAAe,CAErC3R,EAAa4R,gBAAkB,KAE/Bj5E,KAAK+3E,qBAAuBh4E,EAAQm5E,mBAAoBzH,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,OAAQ,CAAEuL,OAAQ,MAAUpG,KAAM,QAC/HvH,KAAKg4E,uBAAyBj4E,EAAQm5E,mBAAoBzH,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,OAAQ,CAAEuL,OAAQ,MAAUpG,KAAM,QAEjI,MAAM6xE,EAAqBtlD,GAASuzC,GAC9BgS,EAAuBvlD,GAAS9zB,KAAK+3E,qBAAqBjkD,SAE1D0lB,EAAU3rB,GAAW,cAAe,QAAS4jD,GAASt2D,SAAUN,IAChEk7D,EAASloD,GAAW,SAAU,QAAS4jD,GAASt2D,SAAUN,IAC1DmW,EAAOnD,GAAW,UAAW,OAAQ4jD,GAASt2D,SAAUN,IAE9D,IAAI5Z,EAAWjB,KAAKi4E,sBAAyBj4E,KAAKi4E,oBAAsB,IAAI7gC,IAC5En2C,EAASi3C,aAAe++B,GAAiB,CAAEz9B,UAASu8B,SAAQ/kD,OAAMkmD,WAAYkC,IAAuB/2E,QAAStC,EAAQu5E,oBACtHr4E,EAASyB,KAAO,cAEhBzB,EAAWjB,KAAKk4E,wBAA2Bl4E,KAAKk4E,sBAAwB,IAAI9gC,IAC5En2C,EAASi3C,aAAeu/B,GAAmB,CAAEj+B,UAASu8B,SAAQ/kD,OAAMkmD,WAAYmC,IAAyBh3E,QAAStC,EAAQu5E,oBAC1Hr4E,EAASyB,KAAO,eAEjB,CAIA,MAAM62E,EAAkB1rD,GAAW,YAAa,QAAS4jD,GAASt2D,SAAUN,IACtE2+D,EAAa3rD,GAAW,aAAc,QAAS4jD,GAASt2D,SAAUN,IAElE49D,EAAiBnH,GAAmBrL,GAAQ5lD,IAAKozD,GAAoBr/D,IAAK6mB,GAAuB5a,IAAKm5D,KACtG7D,EAAc31E,KAAKw4E,iBAAkBz4E,EAAS04E,GAI9CH,EAAW7G,EAAOgI,YAAcz5E,KAAK84E,kBAAmBh2E,EAASg1E,UAAUvwE,OAAU,KAE3F,GAAkB,OAAb+wE,EAEJ,MAAM,IAAIjlE,MAAO,4DAIlB,MAAMqmE,EAAuBV,IAAkB,MAAiBh5E,KAAKg4E,uBAAuBlkD,QAAUuzC,EAEhGjQ,EAAap3D,KAAKq4E,kBAAmBt4E,EAAS,CAAEu4E,WAAUqB,cAAe7B,EAAUhkD,QAASuzC,aAAcqS,EAAoB/D,cAAalE,WAE3ImI,EAAc9lD,GAASgkD,EAAUhkD,QAAS6hD,GAC1CkE,EAAenxD,GAAK,EAAG0uC,EAAWrqC,IAAIrE,IAAKkxD,EAAa,GAAKL,EAAgBl5D,IAAKu5D,EAAY/5D,IAAM2Z,QAK1G,OAHAx5B,KAAK83E,UAAYA,EACjB93E,KAAKyxE,OAAOn6D,IAAMwgE,EAEX+B,CAER,CASA,KAAA3tE,CAAOnM,GAEN,IAA4C,IAAvCA,EAAQ+C,SAASg1E,UAAUjrD,QAEhC,OAAOnU,IAAI,KAEV,IAAIvS,EAAOnG,KAAKm4E,MAsBhB,OApBAn4E,KAAKwzE,oBAAqBzzE,GAEZ,OAAToG,IAEJnG,KAAKm4E,MAAQhyE,EAAOnG,KAAK+4E,YAAah5E,IAIlCA,EAAQkB,SAASm2D,YAErB3qD,QAAQC,KAAM,mFAIV3M,EAAQkB,SAAS82C,qBAErB5xC,EAAOpG,EAAQkB,SAAS82C,mBAAoB5xC,IAItCA,CAAI,GAxBLuS,EA4BR,CAUA,YAAAohE,CAAcv+D,GAEb,MAAM,OAAEk2D,EAAM,UAAEqG,EAAS,MAAE7R,GAAUjmE,MAC/B,SAAE8C,EAAQ,MAAE66C,GAAUpiC,EAE5Bk2D,EAAOC,eAAgBzL,GAEvB6R,EAAU5K,QAASuE,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,QAExDU,EAASo8D,OAAQvhB,EAAO8zB,EAAO75C,OAEhC,CAOA,YAAAmiD,CAAcx+D,GAEb,MAAM,UAAEu8D,EAAS,MAAE7R,EAAK,OAAEwL,GAAWzxE,MAC/B,SAAE8C,EAAQ,MAAE66C,EAAK,OAAE/lB,GAAWrc,EAE9By+D,EAAal3E,EAASg1E,UAAUvwE,KAEhC0yE,EAAenC,EAAUzQ,aAAa9lE,QAC5CvB,KAAKk6E,oBAAsBD,EAE3BxI,EAAO75C,OAAOuiD,OAAOC,KAAOxiD,EAAOuiD,OAAOC,KAE1C,MAAMC,EAA8Bv3E,EAASgxE,0BAEvCl2B,EAAa96C,EAAS4pC,SACtBC,IAAciR,GAAaA,EAAWj9C,IAAK,YAEjDg3E,GAAiB5C,GAA4BjyE,EAAU66C,EAAOg6B,IAE9Dh6B,EAAMi3B,iBAAmBQ,GAAmBnP,GAE5CnjE,EAASwxE,yBAAyB,CAAEh0E,EAAQq9C,EAAOwsB,EAASnpE,EAAUC,EAAUma,KAAU1V,OAE9D,IAAtBpF,EAAOkxE,YAAyBlxE,EAAOi8D,eAAiByd,IAAe,SAEtErtC,IAEJjlC,EAAmBpH,GAASqsC,aAAc,GAI3CrsC,EAAOg6E,eAAgBx3E,EAAUxC,EAAQs3B,EAAQ65C,EAAO75C,OAAQ52B,EAAU28C,EAAMi3B,iBAAkBx5D,GAElGtY,EAASpC,aAAcJ,EAAQq9C,EAAOwsB,EAASnpE,EAAUC,EAAUma,KAAU1V,GAE7EpF,EAAOi6E,cAAez3E,EAAUxC,EAAQs3B,EAAQ65C,EAAO75C,OAAQ52B,EAAU28C,EAAMi3B,iBAAkBx5D,GAElG,IAIDtY,EAASsqE,gBAAiB0K,GAE1B93E,KAAK85E,aAAcv+D,GAEnBzY,EAASwxE,wBAAyB+F,IAIN,IAAvBpU,EAAMoP,cAAyB2E,IAAe,OAElDh6E,KAAKw6E,QAAS13E,GAIfkyE,GAA8BlyE,EAAU66C,EAAOg6B,GAEhD,CAOA,OAAA6C,CAAS13E,GAER,MAAM,OAAE2uE,GAAWzxE,KAEnBA,KAAK+3E,qBAAqB7K,QAASuE,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,QACxEpC,KAAKg4E,uBAAuB9K,QAASuE,EAAOqE,QAAQ3zE,MAAOsvE,EAAOqE,QAAQ1zE,QAE1EU,EAASsqE,gBAAiBptE,KAAK+3E,sBAC/BH,GAAY32E,SAAWjB,KAAKi4E,oBAC5BL,GAAY1Y,OAAQp8D,GAEpBA,EAASsqE,gBAAiBptE,KAAKg4E,wBAC/BJ,GAAY32E,SAAWjB,KAAKk4E,sBAC5BN,GAAY1Y,OAAQp8D,EAErB,CAKA,OAAAmI,GAECjL,KAAK83E,UAAU7sE,UACfjL,KAAK83E,UAAY,KAEkB,OAA9B93E,KAAK+3E,uBAET/3E,KAAK+3E,qBAAqB9sE,UAC1BjL,KAAK+3E,qBAAuB,KAE5B/3E,KAAKi4E,oBAAoBhtE,UACzBjL,KAAKi4E,oBAAsB,MAIS,OAAhCj4E,KAAKg4E,yBAETh4E,KAAKg4E,uBAAuB/sE,UAC5BjL,KAAKg4E,uBAAyB,KAE9Bh4E,KAAKk4E,sBAAsBjtE,UAC3BjL,KAAKk4E,sBAAwB,MAI9BxuE,MAAMuB,SAEP,CAOA,YAAAuB,CAAc+O,GAEb,MAAM,OAAEk2D,GAAWzxE,MAECyxE,EAAOrnE,aAAeqnE,EAAOgJ,cAIhDz6E,KAAK+5E,aAAcx+D,GAEdvb,KAAK83E,UAAUzQ,aAAa9lE,UAAYvB,KAAKk6E,sBAEjDzI,EAAOrnE,aAAc,GAMxB,EAYD,MAAMqnE,GAAS,CAAExL,EAAOwL,IAAYl9D,GAAY,IAAIsjE,GAAY5R,EAAOwL,IAOvE,MAAMiJ,WAA0BlqC,GAE/B,eAAWjpC,GAEV,MAAO,mBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,QAQA1J,KAAKimE,MAAQA,EAObjmE,KAAKmZ,MAAQ,IAAI,MAQjBnZ,KAAKwsB,UAAcy5C,GAASA,EAAMz5C,WAAe1Q,GAAS9b,KAAKmZ,OAAQgC,SAAUN,IASjF7a,KAAK26E,cAAgB,KAQrB36E,KAAKo3D,WAAa,KAQlBp3D,KAAK46E,gBAAkB,KASvB56E,KAAKsyE,qBAAsB,EAS3BtyE,KAAK2J,WAAajB,EAAeE,KAElC,CAQA,cAAAwC,GAEC,OAAO3F,EAAQzF,KAAKimE,MAAM7iE,GAAIpD,KAAKimE,MAAMuL,WAAa,EAAI,EAE3D,CAEA,OAAAlmE,GAEC,OAAOtL,KAAKimE,MAAMn8D,IAEnB,CAQA,eAAA+wE,GAEC,OAAOpJ,GAAQzxE,KAAKimE,MAErB,CASA,WAAA8S,CAAah5E,GAEZ,MAAM,SAAE+C,GAAa/C,EAErB,IAAoC,IAA/B+C,EAASg1E,UAAUjrD,QAAoB,OAE5C,IAAI+tD,EAAkB56E,KAAK46E,gBAE3B,GAAyB,OAApBA,EAA2B,CAE/B,MAAME,EAAmB96E,KAAKimE,MAAMwL,OAAOra,WAE3C,IAAIA,EAIHA,OAFyBr2D,IAArB+5E,EAESvmE,GAAYumE,GAIZ96E,KAAK66E,gBAAiB96E,GAIpCC,KAAKo3D,WAAaA,EAElBp3D,KAAK46E,gBAAkBA,EAAkB56E,KAAKwsB,UAAUnM,IAAK+2C,GAE7Dp3D,KAAK26E,cAAgB36E,KAAKwsB,SAE3B,CAIAxsB,KAAKwsB,UAAYouD,CAElB,CASA,KAAA1uE,CAAOnM,GAENC,KAAKwsB,UAAYxsB,KAAK26E,eAAiB36E,KAAKwsB,UAEvCxsB,KAAKimE,MAAMuL,WAEVzxE,EAAQO,OAAOi8D,eAEnBv8D,KAAK+4E,YAAah5E,GAIY,OAApBC,KAAKo3D,aAEhBp3D,KAAKo3D,WAAWnsD,UAChBjL,KAAKo3D,WAAa,KAClBp3D,KAAK46E,gBAAkB,KAIzB,CASA,MAAArwE,GAEC,MAAM,MAAE07D,GAAUjmE,KAElBA,KAAKmZ,MAAM5V,KAAM0iE,EAAM9sD,OAAQo5B,eAAgB0zB,EAAMrT,UAEtD,EAgBD,MAAMmoB,GAAuCriE,IAAM7E,IAElD,MAAM,cAAEmnE,EAAa,eAAEC,EAAc,cAAEC,GAAkBrnE,EAKnDsnE,EAAkBH,EAAc7yD,IAAK+yD,GAAgB7pE,IAAK,KAAOiW,aAEvE,OAAO2zD,EAAet6D,YAAa,GAAIoK,OACtCowD,EAAgB96D,IAAK26D,EAAc16D,IAAK26D,GAAiB3yD,OAAOpB,WAAWyB,QAAQP,QACnF+yD,EACA,IAMIC,GAA8B,IAAI,MAmBlCC,GAAyB3iE,IAAI,EAAImyC,EAAKywB,MAE3C,MAAMjjE,EAAIwyC,EAAIrxB,QAIR+hD,EAAOl4D,GAAKhL,GAIZmjE,EAAcl7D,GAAK,EAAKqH,GAAO4zD,EAAK3xD,EAAGjC,GAAO4zD,EAAKzxD,EAAGyxD,EAAKt+C,KACjEs+C,EAAK5wC,UAAW6wC,GAKhBnjE,EAAEsyB,UAAW6wC,EAAYn7D,IAAKi7D,EAAWj7D,IAAK,GAAI6G,aASlD,MAAMu0D,EAASriE,GAAMf,EAAEgR,IAAKmQ,QAGtBkiD,EADeJ,EAAWj7D,IAAK,KACN6G,WA2B/B,OAzBAjO,GAAIsiE,EAAKt+C,EAAEpc,iBAAkB66D,IAAa,KAEzCziE,GAAIZ,EAAE4kB,EAAEtc,YAAa,IAAO,KAE3B86D,EAAO7xD,EAAEzV,OAAQiM,GAAK,EAAK/H,EAAEuR,GAAK,GAEhC,IAEA+kC,OAAQ4sB,EAAK3xD,EAAE/I,iBAAkB66D,IAAa,KAEjD,MAAMC,EAAQ30D,GAAM3O,EAAEuR,GACtB6xD,EAAO7xD,EAAEzV,OAAQkE,EAAE4kB,EAAE5c,IAAKs7D,GAAQvnE,IAAKunE,EAAMt7D,IAAK,IAAS,IAExDsuC,OAAQ4sB,EAAKzxD,EAAEjJ,iBAAkB66D,IAAa,KAEjD,MAAME,EAAQ50D,GAAM3O,EAAEyR,GACtB2xD,EAAO7xD,EAAEzV,OAAQkE,EAAEuR,EAAExV,IAAKwnE,EAAMv7D,IAAK,IAAQjM,IAAK,IAClDqnE,EAAO3xD,EAAE3V,OAAQkE,EAAE4kB,EAAE5c,IAAKu7D,GAAQx7D,IAAK,GAAO,IAQxChH,GAAM,KAAO,KAAOiH,IAAKo7D,GAASrnE,IAAKgF,GAAM,KAAO,MAASic,OAAO,IAExE1e,UAAW,CACdjU,KAAM,WACN6E,KAAM,OACNsM,OAAQ,CACP,CAAEnR,KAAM,MAAO6E,KAAM,QACrB,CAAE7E,KAAM,aAAc6E,KAAM,YAIxBs0E,GAAuCnjE,IAAI,EAAI2uD,eAAcyU,OAAMC,KAAIl2B,eAErE/xB,GAASuzC,EAAcgU,GAAUS,EAAMj2B,EAAU/7B,IAAMoN,QAAS6kD,KAIlEC,GAAkCtjE,IAAI,EAAI2uD,eAAcyU,OAAMC,KAAIl2B,YAAW4rB,aAElF,MAAMsE,EAASloD,GAAW,SAAU,QAAS4jD,GAASt2D,SAAUN,IAC1DiV,EAAS1W,IAAQ,EAAK,GAAMiH,IAAK01D,GAAS11D,IAAKwlC,EAAU/7B,GAE/D,OAAOgK,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOmsD,KAAOp2B,EAAU/7B,IAAMoN,QAAS6kD,GACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOosD,KAAOr2B,EAAU/7B,IAAMoN,QAAS6kD,IACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOqsD,KAAOt2B,EAAU/7B,IAAMoN,QAAS6kD,IACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOssD,KAAOv2B,EAAU/7B,IAAMoN,QAAS6kD,IACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAMj2B,EAAU/7B,IAAMoN,QAAS6kD,IACrE3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOusD,KAAOx2B,EAAU/7B,IAAMoN,QAAS6kD,IACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOwsD,KAAOz2B,EAAU/7B,IAAMoN,QAAS6kD,IACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAOysD,KAAO12B,EAAU/7B,IAAMoN,QAAS6kD,IACvF3nE,IAAK0f,GAASuzC,EAAcgU,GAAUS,EAAK1nE,IAAK0b,EAAO0sD,KAAO32B,EAAU/7B,IAAMoN,QAAS6kD,IACvF17D,IAAK,EAAM,EAAK,IAIbo8D,GAAkC/jE,IAAI,EAAI4/D,WAAUjR,eAAcsO,cAAalE,aAIpF,MAAMiL,EAAkB/G,EAAY5yD,IAAIyW,QAClCmjD,EAAwBD,EAAgB14E,SAExC40E,EAAkB98D,GAAS,SAAUX,SAAUN,IAAcnQ,gBAAgB,IAAM+mE,EAAO75C,OAAOC,OACjGghD,EAAiB/8D,GAAS,SAAUX,SAAUN,IAAcnQ,gBAAgB,IAAM+mE,EAAO75C,OAAOG,MAChGd,EAAOpJ,GAAW,OAAQ,QAAS4jD,GAASt2D,SAAUN,IACtDi7D,EAAUh6D,GAAS21D,EAAOqE,SAAU36D,SAAUN,IAE9C9N,EAAS2K,GAAO,GAAM8hB,QAiB5B,OAfAvgB,GAAI0jE,EAAsBv8D,IAAKy4D,GAAiBj4D,cAAe,GAAME,IAAK67D,EAAsBv8D,IAAKw4D,GAAkB/3D,iBAAkB,KAAS,KAGjJ,MAAMk7D,EAAKY,EAAsBv8D,IAAKw4D,GAAkBt4D,IAAKu4D,EAAez4D,IAAKw4D,IAAoBp/C,QACrGuiD,EAAG1rC,UAAWpZ,GAGd,MAAM6kD,EAAOY,EAAgB15D,YACvB6iC,EAAYzsC,GAAM,GAAMkH,IAAKw1D,EAAQz1D,IAAKjH,GAAM,EAAK,KAG3DrM,EAAOoH,OAAQmkE,EAAU,CAAEjR,eAAcyU,OAAMC,KAAIl2B,YAAW4rB,WAAY,IAIpE1kE,CAAM,IAIR6vE,GAA0B,IAAI,MAC9BC,GAA8B,IAAI,MAClCC,GAA+B,IAAI,MAQzC,MAAMC,WAAwBlF,GAE7B,eAAWtwE,GAEV,MAAO,iBAER,CAQA,WAAAzH,CAAammE,EAAOwL,EAAS,MAE5B/nE,MAAOu8D,EAAOwL,EAEf,CASA,iBAAAqH,CAAmBvxE,GAElB,OAAOA,IAAS,MAAiBs0E,GAAyBG,EAE3D,CASA,gBAAAxD,CAAkBz4E,EAAS04E,GAE1B,OAAOA,CAER,CAeA,iBAAAJ,CAAmBt4E,GAAS,SAAEu4E,EAAQ,cAAEqB,EAAa,aAAEtS,EAAY,YAAEsO,EAAW,OAAElE,IAEjF,OAAOgL,GAAmB,CAAEnE,WAAUqB,gBAAetS,eAAcsO,cAAalE,UAEjF,CAQA,YAAAqI,CAAcv+D,GAEb,MAAM,OAAEk2D,EAAM,UAAEqG,EAAS,MAAE7R,GAAUjmE,MAC/B,SAAE8C,EAAQ,MAAE66C,GAAUpiC,EAEtByhE,EAAqBvL,EAAOwL,kBAElCH,GAAev5E,KAAMkuE,EAAOqE,SAC5BgH,GAAeI,SAAUF,GAEzBlF,EAAU5K,QAAS4P,GAAe36E,MAAO26E,GAAe16E,QAExDy6E,GAAct5E,KAAMkuE,EAAOqE,SAI3B,MAAMqH,EAAoBr6E,EAASoxE,UAE7BkJ,EAAqBt6E,EAASixE,cAAeqH,IAC7CiC,EAAqBv6E,EAASmxE,gBAEpCnxE,EAASoxE,WAAY,EACrBpxE,EAASyxE,cAAe9C,EAAO9K,WAAY8K,EAAOuC,YAClDlxE,EAASw6E,QAET,MAAMC,EAAgB9L,EAAO+L,mBAE7B,IAAM,IAAIC,EAAK,EAAGA,EAAKF,EAAeE,IAAQ,CAE7C,MAAMprC,EAAWo/B,EAAOn/B,YAAamrC,GAE/B7zD,EAAIizD,GAAcjzD,EAAIyoB,EAASzoB,EAC/BE,EAAIgzD,GAAehzD,EAAI+yD,GAAc/yD,EAAM+yD,GAAc/yD,EAAIuoB,EAASvoB,EAE5E8yD,GAAUp6E,IACTonB,EACAE,EACA+yD,GAAcjzD,EAAIyoB,EAASpV,EAC3B4/C,GAAc/yD,EAAIuoB,EAASnV,GAG5B46C,EAAUzlC,SAAS9uC,KAAMq5E,IAEzBnL,EAAOC,eAAgBzL,EAAOwX,GAE9B36E,EAASo8D,OAAQvhB,EAAO8zB,EAAO75C,OAEhC,CAIA90B,EAASoxE,UAAYiJ,EACrBr6E,EAASyxE,cAAe6I,EAAoBC,EAE7C,EAYD,MAEMK,GAAmBhlE,IAAI,EAAIS,QAAO64D,oBAAmBiJ,iBAAgBC,iBAAiBn7E,KAE3F,MAAM+wC,EAAgB/wC,EAAQsC,QAAQyuC,cAEhC6sC,EAAU3L,EAAkB5xD,IAAK0Z,IAEjCqmB,EAAiBw9B,EAAQ36D,YACzBg4D,EAAgB2C,EAAQ35E,SAExB45E,EAAmB7C,GAAwB,CAChDC,gBACAC,iBACAC,kBAGKx6B,EAAavnC,EAAMkH,IAAKu9D,GAExB3sC,EAAiBlxC,EAAQsC,QAAQ4uC,eAEvCH,EAAcmO,OAAQ,CACrBkB,iBACAO,aACAzP,kBACElxC,EAAQyW,MAAOzW,EAAS,IAS5B,MAAM89E,WAAuBnD,GAE5B,eAAWnzE,GAEV,MAAO,gBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,GAOPjmE,KAAK89E,mBAAqBhiE,GAAS,GAAIX,SAAUN,IAOjD7a,KAAK+9E,kBAAoBjiE,GAAS,GAAIX,SAAUN,GAEjD,CAOA,MAAAtQ,CAAQgR,GAEP,MAAM,MAAE0qD,GAAUjmE,KAElB0J,MAAMa,OAAQgR,GAEdvb,KAAK89E,mBAAmB56E,MAAQ+iE,EAAMl+C,SACtC/nB,KAAK+9E,kBAAkB76E,MAAQ+iE,EAAM+X,KAEtC,CAOA,eAAAnD,GAEC,MA1FkB,EAAE5U,EAAOwL,IAAYl9D,GAAY,IAAIwoE,GAAiB9W,EAAOwL,IA0FxEwM,CAAaj+E,KAAKimE,MAE1B,CAEA,KAAA/5D,CAAOnM,GAEN2J,MAAMwC,MAAOnM,GAEb29E,GAAkB,CACjBvkE,MAAOnZ,KAAKwsB,UACZwlD,kBAAmBA,GAAmBhyE,KAAKimE,OAC3CgV,eAAgBj7E,KAAK89E,mBACrB5C,cAAel7E,KAAK+9E,oBACjB7kE,QAEL,EAaD,MAgiDMglE,GAAkCxlE,IAAI,EAAI2iB,EAAQ8iD,MAIvD,MAAMv0D,EAAIyR,EAAOzR,EAAGE,EAAIuR,EAAOvR,EAAGmT,EAAI5B,EAAO4B,EAG7C,IAAIlwB,EAASoxE,EAAehkE,QAAS,GAAIkG,IAAK,SAc9C,OAXAtT,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,UAAiBA,IAAKyJ,IAC5E/c,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,UAAiBA,IAAK4c,IAC5ElwB,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,UAAiBA,IAAKuJ,IAG5E7c,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,SAAiBA,IAAKuJ,GAAIvJ,IAAKyJ,IACrF/c,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,SAAiBA,IAAKyJ,GAAIzJ,IAAK4c,IACrFlwB,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK4c,EAAE5c,IAAK4c,GAAI5c,IAAK,SAAWD,IAAK,WACtFrT,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,SAAiBA,IAAKuJ,GAAIvJ,IAAK4c,IACrFlwB,EAASA,EAAOqH,IAAK+pE,EAAehkE,QAAS,GAAIkG,IAAK,SAAWA,IAAKA,GAAKuJ,EAAGA,GAAIxJ,IAAKC,GAAKyJ,EAAGA,MAExF/c,CAAM,IA4hBd,MAAMqxE,GAA8B,IAAI5U,GAQxC,MAAM6U,WAAmBnhB,GAQxB,WAAAp9D,CAAagD,EAAUC,GAEtB2G,QAOA1J,KAAK8C,SAAWA,EAOhB9C,KAAK+C,MAAQA,CAEd,CAYA,MAAAwH,CAAQozC,EAAO2gC,EAAY1lB,GAE1B,MAAM91D,EAAW9C,KAAK8C,SAChBkoE,EAAahrE,KAAK+C,MAAMw7E,kBAAmB5gC,IAAWA,EAAMqtB,WAElE,IAAIwT,GAAa,EAEjB,GAAoB,OAAfxT,EAIJloE,EAAS27E,YAAYC,OAAQN,GAAe,OAC5CA,GAAcv+D,EAAI/c,EAAS27E,YAAY5+D,OAEjC,IAA4B,IAAvBmrD,EAAW5jE,QAItB4jE,EAAW0T,OAAQN,GAAe,OAClCA,GAAcv+D,EAAI,EAElB2+D,GAAa,OAEP,IAA2B,IAAtBxT,EAAWnoE,OAAkB,CAExC,MAAM87E,EAAY3+E,KAAKc,IAAK68C,GACtBg3B,EAAiB3J,EAEvBoT,GAAc76E,KAAMT,EAAS27E,aAE7B,IAAIG,EAAiBD,EAAUC,eAE/B,QAAwB79E,IAAnB69E,EAA+B,CAEnC,MAAMC,EAAqBx8E,GAASuX,GAAM+6D,GAAiBt0D,IAAKgrD,IAAuB,CAEtF31C,MAAO,IAAMu1C,GAAmB5qD,IAAKya,IACrCnF,gBAAiB,IAAMy1C,KAGxB,IAAI0T,EAAWj3C,GACfi3C,EAAWA,EAASC,KAAMD,EAAS5hD,GAEnC,MAAM8hD,EAAe,IAAI5nC,GACzB4nC,EAAat8E,KAAO,sBACpBs8E,EAAa7kD,KAAO,MACpB6kD,EAAapmC,WAAY,EACzBomC,EAAarmC,YAAa,EAC1BqmC,EAAa1nC,KAAM,EACnB0nC,EAAaznC,QAAS,EACtBynC,EAAa7mC,WAAa2mC,EAC1BE,EAAaxyD,UAAYqyD,EAEzBF,EAAUE,mBAAqBA,EAC/BF,EAAUC,eAAiBA,EAAiB,IAAI,MAAM,IAAI,MAAgB,EAAG,GAAI,IAAMI,GACvFJ,EAAeK,eAAgB,EAC/BL,EAAel8E,KAAO,kBAEtBk8E,EAAeM,eAAiB,SAAWp8E,EAAU66C,EAAO/lB,GAE3D53B,KAAK4B,YAAYu9E,aAAcvnD,EAAOh2B,YAEvC,CAED,CAEA,MAAMw9E,EAAqBzK,EAAezuE,cAErCy4E,EAAUS,qBAAuBA,IAErCT,EAAUE,mBAAmB14E,KAAOyT,GAAM+6D,GAAiBt0D,IAAKgrD,IAChEsT,EAAUE,mBAAmBz0E,aAAc,EAE3Cw0E,EAAe39E,SAASmJ,aAAc,EAEtCu0E,EAAUS,mBAAqBA,GAIhCd,EAAWxY,QAAS8Y,EAAgBA,EAAe59E,SAAU49E,EAAe39E,SAAU,EAAG,EAAG,KAAM,KAEnG,MAECwL,QAAQkiB,MAAO,wDAAyDq8C,GAMzE,IAA4B,IAAvBloE,EAASoxE,YAAqC,IAAfsK,EAAsB,CAEzD,MAAM5X,EAAkBhO,EAAcgO,gBAEtCA,EAAgB9pC,EAAIshD,GAActhD,EAClC8pC,EAAgB7pC,EAAIqhD,GAAcrhD,EAClC6pC,EAAgB9mD,EAAIs+D,GAAct+D,EAClC8mD,EAAgB/mD,EAAIu+D,GAAcv+D,GAIO,IAApC/c,EAASw6D,QAAQ2P,iBAA8C,IAAnBnqE,EAASk0C,QAEzD4vB,EAAgB9pC,GAAK8pC,EAAgB/mD,EACrC+mD,EAAgB7pC,GAAK6pC,EAAgB/mD,EACrC+mD,EAAgB9mD,GAAK8mD,EAAgB/mD,GAMtC+4C,EAAcymB,gBAAkBv8E,EAASw8E,YACzC1mB,EAAc2mB,kBAAoBz8E,EAAS08E,cAE3C5mB,EAAc+N,YAAyC,IAA5B7jE,EAAS28E,eACpC7mB,EAAciO,YAAyC,IAA5B/jE,EAAS48E,eACpC9mB,EAAcoO,cAA6C,IAA9BlkE,EAAS68E,gBAEvC,MAEC/mB,EAAc+N,YAAa,EAC3B/N,EAAciO,YAAa,EAC3BjO,EAAcoO,cAAe,CAI/B,EAID,IAAI4Y,GAAQ,EASZ,MAAMC,GAUL,WAAA//E,CAAa4C,EAAO,GAAIk6D,EAAW,GAAIt7D,EAAQ,EAAGw+E,EAAoB,IAOrE9/E,KAAK0C,KAAOA,EAOZ1C,KAAK48D,SAAWA,EAOhB58D,KAAKsB,MAAQA,EAObtB,KAAK8/E,kBAAoBA,EAOzB9/E,KAAKoD,GAAKw8E,IAEX,EAaD,MAAMG,GAgBL,WAAAjgF,CAAamiE,EAAcE,EAAgBX,EAAe7G,EAAgBiC,EAAUojB,EAAaC,EAAmBC,EAAkB3mC,EAASunB,EAAa,IAO3J9gE,KAAKiiE,aAAeA,EAOpBjiE,KAAKmiE,eAAiBA,EAOtBniE,KAAKwhE,cAAgBA,EAQrBxhE,KAAK8gE,WAAaA,EAQlB9gE,KAAK26D,eAAiBA,EAQtB36D,KAAK48D,SAAWA,EAOhB58D,KAAKggF,YAAcA,EAOnBhgF,KAAKigF,kBAAoBA,EAOzBjgF,KAAKkgF,iBAAmBA,EAOxBlgF,KAAKu5C,QAAUA,EAOfv5C,KAAKmgE,UAAY,CAElB,CASA,cAAA9F,GAEC,MAAMuC,EAAW,GAEjB,IAAM,MAAMujB,KAAiBngF,KAAK48D,SAAW,CAI5C,IAAgB,IAFDujB,EAAcvjB,SAAU,GAAI3hD,UAAUV,OAE9B,CAEtB,MAAM6lE,EAAgB,IAAIP,GAAWM,EAAcz9E,KAAM,GAAIy9E,EAAc7+E,MAAO6+E,GAClFvjB,EAAS92D,KAAMs6E,GAEf,IAAM,MAAMC,KAAmBF,EAAcvjB,SAE5CwjB,EAAcxjB,SAAS92D,KAAMu6E,EAAgBx+E,QAI/C,MAEC+6D,EAAS92D,KAAMq6E,EAIjB,CAEA,OAAOvjB,CAER,EAUD,MAAM0jB,GASL,WAAAxgF,CAAa4C,EAAM6E,EAAMpB,EAAO,MAS/BnG,KAAKugF,iBAAkB,EAOvBvgF,KAAK0C,KAAOA,EAOZ1C,KAAKuH,KAAOA,EAQZvH,KAAKmG,KAAOA,CAEb,EAUD,MAAMq6E,GASL,WAAA1gF,CAAa4C,EAAM6E,EAAMpB,GASxBnG,KAAKygF,eAAgB,EAOrBzgF,KAAK0C,KAAOA,EAOZ1C,KAAKuH,KAAOA,EAOZvH,KAAKmG,KAAOA,EAAKJ,SAElB,CAOA,SAAI7C,GAEH,OAAOlD,KAAKmG,KAAKjD,KAElB,CAEA,SAAIA,CAAO8B,GAEVhF,KAAKmG,KAAKjD,MAAQ8B,CAEnB,CAOA,MAAI5B,GAEH,OAAOpD,KAAKmG,KAAK/C,EAElB,CAOA,aAAI6X,GAEH,OAAOjb,KAAKmG,KAAK8U,SAElB,EAUD,MAAMylE,GAQL,WAAA5gF,CAAa4C,EAAM6E,GASlBvH,KAAK2gF,WAAY,EAOjB3gF,KAAK0C,KAAOA,EAOZ1C,KAAKuH,KAAOA,CAEb,EAYD,MAAMq5E,WAAoBF,GAQzB,WAAA5gF,CAAa4C,EAAM6E,GAElBmC,MAAOhH,EAAM6E,GASbvH,KAAKqc,oBAAqB,EAS1Brc,KAAK6gF,eAAgB,CAEtB,EAUD,MAAMC,GASL,WAAAhhF,CAAa4C,EAAM6E,EAAMq5D,EAAO,IAO/B5gE,KAAK0C,KAAOA,EAOZ1C,KAAKuH,KAAOA,EAQZvH,KAAK4gE,KAAOA,EAEZ/8D,OAAOsG,eAAgBnK,KAAM,aAAc,CAAEkD,OAAO,GAErD,EAID,IAAI69E,GAAQ,EAMZ,MAAMC,GAOL,WAAAlhF,CAAasxB,EAAS,MAQrBpxB,KAAKoD,GAAK29E,KAOV/gF,KAAKihF,UAAY,IAAI/gF,QAQrBF,KAAKoxB,OAASA,CAEf,CAQA,OAAA3B,CAAStpB,GAER,IAAItF,EAAOb,KAAKihF,UAAUngF,IAAKqF,GAQ/B,YANcpF,IAATF,GAAsC,OAAhBb,KAAKoxB,SAE/BvwB,EAAOb,KAAKoxB,OAAO3B,QAAStpB,IAItBtF,CAER,CAQA,OAAA6uB,CAASvpB,EAAMtF,GAEdb,KAAKihF,UAAUz+E,IAAK2D,EAAMtF,EAE3B,EAUD,MAAMqgF,WAAuB13E,EAE5B,eAAWjC,GAEV,MAAO,gBAER,CAQA,WAAAzH,CAAa4C,EAAM2X,GAElB3Q,QAOA1J,KAAK0C,KAAOA,EAQZ1C,KAAKqa,MAAQA,EASbra,KAAKmhF,kBAAmB,CAEzB,CAOA,cAAAC,GAEC,OAAOphF,KAAKqa,KAEb,EAUD,MAAMgnE,GAQL,WAAAvhF,CAAa4C,EAAMQ,GAOlBlD,KAAK0C,KAAOA,EAOZ1C,KAAKkD,MAAQA,EASblD,KAAKshF,SAAW,EAQhBthF,KAAK4vB,SAAW,EAQhB5vB,KAAK8vB,OAAS,CAEf,CAOA,QAAAyxD,CAAUr+E,GAETlD,KAAKkD,MAAQA,CAEd,CAOA,QAAAs+E,GAEC,OAAOxhF,KAAKkD,KAEb,EAUD,MAAMu+E,WAAsBJ,GAQ3B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,GAE1BwG,MAAOhH,EAAMQ,GASblD,KAAK0hF,iBAAkB,EAEvB1hF,KAAKshF,SAAW,EAChBthF,KAAK4vB,SAAW,CAEjB,EAUD,MAAM+xD,WAAuBN,GAQ5B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,IAAI,OAE9BwG,MAAOhH,EAAMQ,GASblD,KAAK4hF,kBAAmB,EAExB5hF,KAAKshF,SAAW,EAChBthF,KAAK4vB,SAAW,CAEjB,EAUD,MAAMiyD,WAAuBR,GAQ5B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,IAAI,OAE9BwG,MAAOhH,EAAMQ,GASblD,KAAK8hF,kBAAmB,EAExB9hF,KAAKshF,SAAW,GAChBthF,KAAK4vB,SAAW,CAEjB,EAUD,MAAMmyD,WAAuBV,GAQ5B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,IAAI,OAE9BwG,MAAOhH,EAAMQ,GASblD,KAAKgiF,kBAAmB,EAExBhiF,KAAKshF,SAAW,GAChBthF,KAAK4vB,SAAW,CAEjB,EAUD,MAAMqyD,WAAqBZ,GAQ1B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,IAAI,OAE9BwG,MAAOhH,EAAMQ,GASblD,KAAKkiF,gBAAiB,EAEtBliF,KAAKshF,SAAW,GAChBthF,KAAK4vB,SAAW,CAEjB,EAUD,MAAMuyD,WAAuBd,GAQ5B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,IAAI,OAE9BwG,MAAOhH,EAAMQ,GASblD,KAAKoiF,kBAAmB,EAExBpiF,KAAKshF,SAAW,GAChBthF,KAAK4vB,SAAW,EAEjB,EAUD,MAAMyyD,WAAuBhB,GAQ5B,WAAAvhF,CAAa4C,EAAMQ,EAAQ,IAAI,OAE9BwG,MAAOhH,EAAMQ,GASblD,KAAKsiF,kBAAmB,EAExBtiF,KAAKshF,SAAW,GAChBthF,KAAK4vB,SAAW,EAEjB,EAWD,MAAM2yD,WAA0Bd,GAO/B,WAAA3hF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAWD,MAAMi7E,WAA2Bb,GAOhC,WAAA7hF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAWD,MAAMk7E,WAA2BZ,GAOhC,WAAA/hF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAWD,MAAMm7E,WAA2BX,GAOhC,WAAAjiF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAWD,MAAMo7E,WAAyBV,GAO9B,WAAAniF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAWD,MAAMq7E,WAA2BT,GAOhC,WAAAriF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAWD,MAAMs7E,WAA2BR,GAOhC,WAAAviF,CAAa6b,GAEZjS,MAAOiS,EAAYjZ,KAAMiZ,EAAYzY,OAOrClD,KAAK2b,YAAcA,CAEpB,CAOA,QAAA6lE,GAEC,OAAOxhF,KAAK2b,YAAYzY,KAEzB,CAOA,OAAA2N,GAEC,OAAO7Q,KAAK2b,YAAYpU,IAEzB,EAID,MAMMu7E,GAAkB,CAAE,KAAO,KAAO,IAAM,KAAO,KAAO,MAItDC,GAAc,GAEdC,GAA4B,IAAI,OAAsB,EAAG,EAAG,GAAK,EAAG,EAAG,GACvEC,GAA4B,IAAI,MAAmB,GAAI,GACvDxE,GAA4B,IAAI,MACtC,IAAIyE,GAAa,KACbC,GAAqB,EACrBC,GAAwB,EAG5B,MAAMC,IAAQ,EAAIp+E,KAAKohB,KAAM,IAAQ,EAC/Bi9D,GAAU,EAAID,GAIdE,GAAkB,CACT,IAAI,OAAWF,GAAKC,GAAS,GAC7B,IAAI,MAASD,GAAKC,GAAS,GAC3B,IAAI,OAAWA,GAAS,EAAGD,IAC3B,IAAI,MAASC,GAAS,EAAGD,IACzB,IAAI,MAAS,EAAGA,IAAOC,IACvB,IAAI,MAAS,EAAGD,GAAKC,IACrB,IAAI,OAAW,EAAG,GAAK,GACvB,IAAI,MAAS,EAAG,GAAK,GACrB,IAAI,OAAW,EAAG,EAAG,GACrB,IAAI,MAAS,EAAG,EAAG,IAM5BE,GAAW,CAChB,EAAG,EAAG,EACN,EAAG,EAAG,GAGDj1B,GAAYO,GAAc3lC,KAAMxmB,GAAW,cAAgBqgB,YAC3DqtC,GAAkB72C,GAAM+0C,GAAU3kC,EAAG2kC,GAAUzkC,EAAGykC,GAAUtxB,GAiBlE,MAAMwmD,GAEL,WAAA3jF,CAAagD,GAEZ9C,KAAK0jF,UAAY5gF,EACjB9C,KAAK2jF,sBAAwB,KAE7B3jF,KAAK4jF,QAAU,EACf5jF,KAAK6jF,UAAY,EACjB7jF,KAAK8jF,WAAa,GAClB9jF,KAAK+jF,UAAY,GACjB/jF,KAAKgkF,QAAU,GACfhkF,KAAKikF,WAAa,GAElBjkF,KAAKkkF,cAAgB,KACrBlkF,KAAKmkF,iBAAmB,KACxBnkF,KAAKokF,kBAAoB,KACzBpkF,KAAKqkF,eAAiB,IAEvB,CAEA,mBAAIC,GAEH,OAAOtkF,KAAK0jF,UAAUa,gBAEvB,CAgBA,SAAAC,CAAW7mC,EAAO8mC,EAAQ,EAAG5sD,EAAO,GAAKE,EAAM,IAAKoa,EAAe,MAIlE,GAFAnyC,KAAK0kF,SAAU,MAEe,IAAzB1kF,KAAKskF,gBAA4B,CAErC73E,QAAQC,KAAM,qHAEd,MAAMi4E,EAAqBxyC,GAAgBnyC,KAAK4kF,mBAIhD,OAFA5kF,KAAK6kF,eAAgBlnC,EAAO8mC,EAAO5sD,EAAME,EAAK4sD,GAEvCA,CAER,CAEAzB,GAAaljF,KAAK0jF,UAAUtxC,kBAC5B+wC,GAAqBnjF,KAAK0jF,UAAU/P,oBACpCyP,GAAwBpjF,KAAK0jF,UAAU9P,uBAEvC,MAAM+Q,EAAqBxyC,GAAgBnyC,KAAK4kF,mBAehD,OAdAD,EAAmB9rC,aAAc,EAEjC74C,KAAK8kF,eAAgBnnC,EAAO9lB,EAAME,EAAK4sD,GAElCF,EAAQ,GAEZzkF,KAAK+kF,MAAOJ,EAAoB,EAAG,EAAGF,GAIvCzkF,KAAKglF,YAAaL,GAElB3kF,KAAKilF,SAAUN,GAERA,CAER,CAEA,oBAAME,CAAgBlnC,EAAO8mC,EAAQ,EAAG5sD,EAAO,GAAKE,EAAM,IAAKoa,EAAe,MAI7E,OAF8B,IAAzBnyC,KAAKskF,uBAAkCtkF,KAAK0jF,UAAUwB,OAEpDllF,KAAKwkF,UAAW7mC,EAAO8mC,EAAO5sD,EAAME,EAAKoa,EAEjD,CAWA,mBAAAof,CAAqB4zB,EAAiBhzC,EAAe,MAEpD,IAA8B,IAAzBnyC,KAAKskF,gBAA4B,CAErC73E,QAAQC,KAAM,yIAEd1M,KAAKolF,oBAAqBD,GAE1B,MAAMR,EAAqBxyC,GAAgBnyC,KAAK4kF,mBAIhD,OAFA5kF,KAAKqlF,yBAA0BF,EAAiBR,GAEzCA,CAER,CAEA,OAAO3kF,KAAKslF,aAAcH,EAAiBhzC,EAE5C,CAEA,8BAAMkzC,CAA0BF,EAAiBhzC,EAAe,MAI/D,OAF8B,IAAzBnyC,KAAKskF,uBAAkCtkF,KAAK0jF,UAAUwB,OAEpDllF,KAAKslF,aAAcH,EAAiBhzC,EAE5C,CAWA,WAAAkf,CAAak0B,EAASpzC,EAAe,MAEpC,IAA8B,IAAzBnyC,KAAKskF,gBAA4B,CAErC73E,QAAQC,KAAM,yHAEd1M,KAAKolF,oBAAqBG,GAE1B,MAAMZ,EAAqBxyC,GAAgBnyC,KAAK4kF,mBAIhD,OAFA5kF,KAAKwlF,iBAAkBD,EAASpzC,GAEzBwyC,CAER,CAEA,OAAO3kF,KAAKslF,aAAcC,EAASpzC,EAEpC,CAEA,sBAAMqzC,CAAkBD,EAASpzC,EAAe,MAI/C,OAF8B,IAAzBnyC,KAAKskF,uBAAkCtkF,KAAK0jF,UAAUwB,OAEpDllF,KAAKslF,aAAcC,EAASpzC,EAEpC,CAMA,0BAAMszC,GAE0B,OAA1BzlF,KAAKmkF,mBAETnkF,KAAKmkF,iBAAmBuB,WAClB1lF,KAAK2lF,iBAAkB3lF,KAAKmkF,kBAIpC,CAMA,kCAAMyB,GAE2B,OAA3B5lF,KAAKokF,oBAETpkF,KAAKokF,kBAAoByB,WACnB7lF,KAAK2lF,iBAAkB3lF,KAAKokF,mBAIpC,CAOA,OAAAn5E,GAECjL,KAAK8lF,WAE0B,OAA1B9lF,KAAKmkF,kBAA4BnkF,KAAKmkF,iBAAiBl5E,UAC5B,OAA3BjL,KAAKokF,mBAA6BpkF,KAAKokF,kBAAkBn5E,UACjC,OAAxBjL,KAAKqkF,iBAETrkF,KAAKqkF,eAAerjF,SAASiK,UAC7BjL,KAAKqkF,eAAepjF,SAASgK,UAI/B,CAIA,mBAAAm6E,CAAqBtxD,GAEfA,EAAQlF,UAAY,OAAyBkF,EAAQlF,UAAY,MAErE5uB,KAAK0kF,SAAmC,IAAzB5wD,EAAQC,MAAM/vB,OAAe,GAAO8vB,EAAQC,MAAO,GAAI5xB,OAAS2xB,EAAQC,MAAO,GAAIA,MAAM5xB,OAIxGnC,KAAK0kF,SAAU5wD,EAAQC,MAAM5xB,MAAQ,EAIvC,CAEA,QAAAuiF,CAAUqB,GAET/lF,KAAK4jF,QAAU3+E,KAAKshB,MAAOthB,KAAKmhB,KAAM2/D,IACtC/lF,KAAK6jF,UAAY5+E,KAAKkjB,IAAK,EAAGnoB,KAAK4jF,QAEpC,CAEA,QAAAkC,GAE6B,OAAvB9lF,KAAKkkF,eAAyBlkF,KAAKkkF,cAAcj5E,UAElB,OAA/BjL,KAAK2jF,uBAAiC3jF,KAAK2jF,sBAAsB14E,UAEtE,IAAM,IAAI5G,EAAI,EAAGA,EAAIrE,KAAK8jF,WAAW9/E,OAAQK,IAE5CrE,KAAK8jF,WAAYz/E,GAAI4G,SAIvB,CAEA,QAAAg6E,CAAUe,GAEThmF,KAAK0jF,UAAUtW,gBAAiB8V,GAAYC,GAAoBC,IAChE4C,EAAa7R,aAAc,EAC3B8R,GAAcD,EAAc,EAAG,EAAGA,EAAa7jF,MAAO6jF,EAAa5jF,OAEpE,CAEA,YAAAkjF,CAAcxxD,EAASqe,GAEtBnyC,KAAKolF,oBAAqBtxD,GAE1BovD,GAAaljF,KAAK0jF,UAAUtxC,kBAC5B+wC,GAAqBnjF,KAAK0jF,UAAU/P,oBACpCyP,GAAwBpjF,KAAK0jF,UAAU9P,uBAEvC,MAAM+Q,EAAqBxyC,GAAgBnyC,KAAK4kF,mBAKhD,OAJA5kF,KAAKkmF,iBAAkBpyD,EAAS6wD,GAChC3kF,KAAKglF,YAAaL,GAClB3kF,KAAKilF,SAAUN,GAERA,CAER,CAEA,gBAAAC,GAEC,MAAMziF,EAAQ,EAAI8C,KAAKoM,IAAKrR,KAAK6jF,UAAW,KACtCzhF,EAAS,EAAIpC,KAAK6jF,UAElBn+E,EAAS,CACdg4C,UAAW,MACXrK,UAAW,MACXC,iBAAiB,EACjB/rC,KAAM,MACNoG,OAAQ,MACR+e,WAAY,OAIPi4D,EAAqBwB,GAAqBhkF,EAAOC,EAAQsD,GAE/D,GAAoC,OAA/B1F,KAAK2jF,uBAAkC3jF,KAAK2jF,sBAAsBxhF,QAAUA,GAASnC,KAAK2jF,sBAAsBvhF,SAAWA,EAAS,CAEpG,OAA/BpC,KAAK2jF,uBAET3jF,KAAK8lF,WAIN9lF,KAAK2jF,sBAAwBwC,GAAqBhkF,EAAOC,EAAQsD,GAEjE,MAAM,QAAEk+E,GAAY5jF,OAChBomF,SAAUpmF,KAAK+jF,UAAWsC,UAAWrmF,KAAK8jF,WAAYwC,OAAQtmF,KAAKgkF,QAASuC,UAAWvmF,KAAKikF,YA2SnG,SAAwBuC,GAEvB,MAAMH,EAAY,GACZD,EAAW,GACXE,EAAS,GACTC,EAAY,GAElB,IAAIzgC,EAAM0gC,EAEV,MAAMC,EAAYD,EAlqBH,EAkqBsB,EAAI1D,GAAgB9+E,OAEzD,IAAM,IAAIK,EAAI,EAAGA,EAAIoiF,EAAWpiF,IAAO,CAEtC,MAAMqiF,EAAUzhF,KAAKkjB,IAAK,EAAG29B,GAC7BsgC,EAAStgF,KAAM4gF,GACf,IAAIjC,EAAQ,EAAMiC,EAEbriF,EAAImiF,EA1qBK,EA4qBb/B,EAAQ3B,GAAiBz+E,EAAImiF,EA5qBhB,EA4qBmC,GAE/B,IAANniF,IAEXogF,EAAQ,GAIT6B,EAAOxgF,KAAM2+E,GAEb,MAAM5+B,EAAY,GAAQ6gC,EAAU,GAC9BllC,GAAQqE,EACRx0C,EAAM,EAAIw0C,EACV8gC,EAAM,CAAEnlC,EAAKA,EAAKnwC,EAAKmwC,EAAKnwC,EAAKA,EAAKmwC,EAAKA,EAAKnwC,EAAKA,EAAKmwC,EAAKnwC,GAE/Du1E,EAAY,EACZC,EAAW,EACXC,EAAe,EACfC,EAAS,EACTC,EAAgB,EAEhBn7C,EAAW,IAAI1O,aAAc2pD,EAAeD,EAAWD,GACvDz9D,EAAK,IAAIgU,aAAc4pD,EAASF,EAAWD,GAC3CK,EAAY,IAAI9pD,aAAc6pD,EAAgBH,EAAWD,GAE/D,IAAM,IAAIn4B,EAAO,EAAGA,EAAOm4B,EAAWn4B,IAAU,CAE/C,MAAM7kC,EAAM6kC,EAAO,EAAM,EAAI,EAAI,EAC3B3kC,EAAI2kC,EAAO,EAAI,GAAM,EACrBy4B,EAAc,CACnBt9D,EAAGE,EAAG,EACNF,EAAI,EAAI,EAAGE,EAAG,EACdF,EAAI,EAAI,EAAGE,EAAI,EAAG,EAClBF,EAAGE,EAAG,EACNF,EAAI,EAAI,EAAGE,EAAI,EAAG,EAClBF,EAAGE,EAAI,EAAG,GAGLq9D,EAAU3D,GAAU/0B,GAC1B5iB,EAASrpC,IAAK0kF,EAAaJ,EAAeD,EAAWM,GACrDh+D,EAAG3mB,IAAKmkF,EAAKI,EAASF,EAAWM,GACjC,MAAMC,EAAO,CAAED,EAASA,EAASA,EAASA,EAASA,EAASA,GAC5DF,EAAUzkF,IAAK4kF,EAAMJ,EAAgBH,EAAWM,EAEjD,CAEA,MAAME,EAAS,IAAI,MACnBA,EAAOhd,aAAc,WAAY,IAAI,MAAiBx+B,EAAUi7C,IAChEO,EAAOhd,aAAc,KAAM,IAAI,MAAiBlhD,EAAI49D,IACpDM,EAAOhd,aAAc,YAAa,IAAI,MAAiB4c,EAAWD,IAClEX,EAAUvgF,KAAMuhF,GAChBd,EAAUzgF,KAAM,IAAI,MAAMuhF,EAAQ,OAE7BvhC,EAjuBS,GAmuBbA,GAIF,CAEA,MAAO,CAAEugC,YAAWD,WAAUE,SAAQC,YAEvC,CA7XkHe,CAAe1D,IAE9H5jF,KAAKkkF,cA2ZR,SAAyBsC,EAAQrkF,EAAOC,GAEvC,MAAMwuD,EAAUrzB,GAAc,IAAIx4B,MAAOg+E,IAAcqE,KAAM,IACvDz2B,EAAW70C,GAAS,IAAI,MAAS,EAAG,EAAG,IACvC+0C,EAAS/0C,GAAS,GAClBmrC,EAAIvvC,GAAOqrE,IACXryB,EAAc50C,GAAS,GACvB09B,EAAU19B,GAAS,GACnB4+B,EAAS5mB,GAAS,MAClB67B,EAAS7zC,GAAS,GAClBwzC,EAAqB53C,GAAO,EAAIvV,GAChCotD,EAAsB73C,GAAO,EAAItV,GACjCotD,EAAiB93C,GAAO8uE,GAExBe,EAAmB,CACxBtgC,IACAyJ,cACAE,UACAD,WACAN,mBACAQ,SACArX,UACAkB,SACAiV,SACAL,qBACAC,sBACAC,kBAGKvuD,EAAWumF,GAAc,QAI/B,OAHAvmF,EAASowE,SAAWkW,EACpBtmF,EAASi3C,aAAenhB,GAAM,IAAKwwD,EAAkB72B,YAAaA,EAAYlwC,MAAO,KAE9Evf,CAER,CA9bwBwmF,CAAgB7D,EAASzhF,EAAOC,EAEtD,CAEA,OAAOuiF,CAER,CAEA,sBAAMgB,CAAkB1kF,GAEvB,MAAMymF,EAAU,IAAI,MAAM1nF,KAAK8jF,WAAY,GAAK7iF,SAC1CjB,KAAK0jF,UAAUiE,QAASD,EAAS1E,GAExC,CAEA,cAAA8B,CAAgBnnC,EAAO9lB,EAAME,EAAK4sD,GAEjC,MAAMiD,EAAa3E,GACnB2E,EAAW/vD,KAAOA,EAClB+vD,EAAW7vD,IAAMA,EAGjB,MAAM8vD,EAAS,CAAE,EAAG,EAAG,EAAG,GAAK,EAAG,GAC5BC,EAAc,CAAE,GAAK,EAAG,GAAK,EAAG,GAAK,GAErChlF,EAAW9C,KAAK0jF,UAEhBqE,EAAoBjlF,EAASoxE,UAEnCpxE,EAASixE,cAAe0K,IAExB37E,EAASoxE,WAAY,EAErB,IAAI8T,EAAgBhoF,KAAKqkF,eAEzB,GAAuB,OAAlB2D,EAAyB,CAE7B,MAAMC,EAAqB,IAAI,MAAmB,CACjDvlF,KAAM,mBACNy3B,KAAM,MACNwe,YAAY,EACZC,WAAW,IAGZovC,EAAgB,IAAI,MAAM,IAAI,MAAeC,EAE9C,CAEA,IAAIC,GAAgB,EACpB,MAAMld,EAAartB,EAAMqtB,WAEpBA,EAECA,EAAW5jE,UAEf4gF,EAAc/mF,SAASkY,MAAM5V,KAAMynE,GACnCrtB,EAAMqtB,WAAa,KACnBkd,GAAgB,IAMjBF,EAAc/mF,SAASkY,MAAM5V,KAAMk7E,IACnCyJ,GAAgB,GAIjBplF,EAASsqE,gBAAiBuX,GAE1B7hF,EAASw6E,QAEJ4K,GAEJplF,EAASo8D,OAAQ8oB,EAAeJ,GAIjC,IAAM,IAAIvjF,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAM8jF,EAAM9jF,EAAI,EAEH,IAAR8jF,GAEJP,EAAWQ,GAAG5lF,IAAK,EAAGqlF,EAAQxjF,GAAK,GACnCujF,EAAWS,OAAQP,EAAazjF,GAAK,EAAG,IAErB,IAAR8jF,GAEXP,EAAWQ,GAAG5lF,IAAK,EAAG,EAAGqlF,EAAQxjF,IACjCujF,EAAWS,OAAQ,EAAGP,EAAazjF,GAAK,KAIxCujF,EAAWQ,GAAG5lF,IAAK,EAAGqlF,EAAQxjF,GAAK,GACnCujF,EAAWS,OAAQ,EAAG,EAAGP,EAAazjF,KAIvC,MAAM2sB,EAAOhxB,KAAK6jF,UAElBoC,GAActB,EAAoBwD,EAAMn3D,EAAM3sB,EAAI,EAAI2sB,EAAO,EAAGA,EAAMA,GAEtEluB,EAASo8D,OAAQvhB,EAAOiqC,EAEzB,CAEA9kF,EAASoxE,UAAY6T,EACrBpqC,EAAMqtB,WAAaA,CAEpB,CAEA,gBAAAkb,CAAkBpyD,EAAS6wD,GAE1B,MAAM7hF,EAAW9C,KAAK0jF,UAEhB/oC,EAAkB7mB,EAAQlF,UAAY,OAAyBkF,EAAQlF,UAAY,MAEpF+rB,EAE2B,OAA1B36C,KAAKmkF,mBAETnkF,KAAKmkF,iBAAmBuB,GAAqB5xD,IAMd,OAA3B9zB,KAAKokF,oBAETpkF,KAAKokF,kBAAoByB,GAAsB/xD,IAMjD,MAAM7yB,EAAW05C,EAAgB36C,KAAKmkF,iBAAmBnkF,KAAKokF,kBAC9DnjF,EAASi3C,aAAah1C,MAAQ4wB,EAE9B,MAAM6a,EAAO3uC,KAAKikF,WAAY,GAC9Bt1C,EAAK1tC,SAAWA,EAEhB,MAAM+vB,EAAOhxB,KAAK6jF,UAElBoC,GAActB,EAAoB,EAAG,EAAG,EAAI3zD,EAAM,EAAIA,GAEtDluB,EAASsqE,gBAAiBuX,GAC1B7hF,EAASo8D,OAAQvwB,EAAMq0C,GAExB,CAEA,WAAAgC,CAAaL,GAEZ,MAAM7hF,EAAW9C,KAAK0jF,UAChBxP,EAAYpxE,EAASoxE,UAC3BpxE,EAASoxE,WAAY,EACrB,MAAMjtB,EAAIjnD,KAAK8jF,WAAW9/E,OAE1B,IAAM,IAAIK,EAAI,EAAGA,EAAI4iD,EAAG5iD,IAAO,CAE9B,MAAMogF,EAAQx/E,KAAKohB,KAAMrmB,KAAKgkF,QAAS3/E,GAAMrE,KAAKgkF,QAAS3/E,GAAMrE,KAAKgkF,QAAS3/E,EAAI,GAAMrE,KAAKgkF,QAAS3/E,EAAI,IAErGssD,EAAW4yB,IAAmBt8B,EAAI5iD,EAAI,GAAMk/E,GAAgBv/E,QAElEhE,KAAK+kF,MAAOJ,EAAoBtgF,EAAI,EAAGA,EAAGogF,EAAO9zB,EAElD,CAEA7tD,EAASoxE,UAAYA,CAEtB,CAeA,KAAA6Q,CAAOJ,EAAoB2D,EAAOC,EAAQ9D,EAAO9zB,GAEhD,MAAM63B,EAAuBxoF,KAAK2jF,sBAElC3jF,KAAKyoF,UACJ9D,EACA6D,EACAF,EACAC,EACA9D,EACA,cACA9zB,GAED3wD,KAAKyoF,UACJD,EACA7D,EACA4D,EACAA,EACA9D,EACA,eACA9zB,EAEF,CAEA,SAAA83B,CAAWC,EAAUC,EAAWL,EAAOC,EAAQK,EAAcr6B,EAAWoC,GAEvE,MAAM7tD,EAAW9C,KAAK0jF,UAChBmF,EAAe7oF,KAAKkkF,cAEP,gBAAd31B,GAA6C,iBAAdA,GAEnC9hD,QAAQkiB,MAAO,8DAKhB,MAEMm6D,EAAW9oF,KAAKikF,WAAYsE,GAClCO,EAAS7nF,SAAW4nF,EAEpB,MAAME,EAAeF,EAAaxX,SAE5B2X,EAAShpF,KAAK+jF,UAAWuE,GAAU,EACnCW,EAAkBC,SAAUN,GAAiB3jF,KAAK+R,IAAO,EAAIgyE,GAAW,EAAI/jF,KAAK+R,GAAK,GACtFmyE,EAAcP,EAAeK,EAC7BzvC,EAAU0vC,SAAUN,GAAiB,EAAI3jF,KAAKshB,MAVxB,EAUqD4iE,GAAgBpG,GAE5FvpC,EAAUupC,IAEdt2E,QAAQC,KAAM,iBACbk8E,kDACApvC,2CAIF,MAAMoX,EAAU,GAChB,IAAIw4B,EAAM,EAEV,IAAM,IAAI/kF,EAAI,EAAGA,EAAI0+E,KAAgB1+E,EAAI,CAExC,MAAMulB,EAAIvlB,EAAI8kF,EACRE,EAASpkF,KAAKghB,KAAO2D,EAAIA,EAAI,GACnCgnC,EAAQ9qD,KAAMujF,GAEH,IAANhlF,EAEJ+kF,GAAOC,EAEIhlF,EAAIm1C,IAEf4vC,GAAO,EAAIC,EAIb,CAEA,IAAM,IAAIhlF,EAAI,EAAGA,EAAIusD,EAAQ5sD,OAAQK,IAEpCusD,EAASvsD,GAAMusD,EAASvsD,GAAM+kF,EAI/BV,EAAS50D,QAAQvY,OAAUmtE,EAAS50D,QAAQvY,OAAS,GAAM,EAE3DwtE,EAAaruC,OAAOx3C,MAAQwlF,EAAS50D,QACrCi1D,EAAavvC,QAAQt2C,MAAQs2C,EAC7BuvC,EAAan4B,QAAQprD,MAAQorD,EAC7Bm4B,EAAar4B,YAAYxtD,MAAsB,gBAAdqrD,EAA8B,EAAI,EAE9DoC,IAEJo4B,EAAap4B,SAASztD,MAAQytD,GAI/B,MAAM,QAAEizB,GAAY5jF,KACpB+oF,EAAal4B,OAAO3tD,MAAQ+lF,EAC5BF,EAAap5B,OAAOzsD,MAAQ0gF,EAAU0E,EAEtC,MAAMgB,EAAatpF,KAAK+jF,UAAWwE,GAInCtC,GAAc0C,EAHJ,EAAIW,GAAef,EAAS3E,EA9oBxB,EA8oB4C2E,EAAS3E,EA9oBrD,EA8oByE,GAC7E,GAAM5jF,KAAK6jF,UAAYyF,GAEF,EAAIA,EAAY,EAAIA,GACnDxmF,EAASsqE,gBAAiBub,GAC1B7lF,EAASo8D,OAAQ4pB,EAAU9F,GAE5B,EAwFD,SAASmD,GAAqBhkF,EAAOC,EAAQsD,GAE5C,MAAMi/E,EAAqB,IAAI,MAAcxiF,EAAOC,EAAQsD,GAK5D,OAJAi/E,EAAmB7wD,QAAQlF,QAAU,KACrC+1D,EAAmB7wD,QAAQpxB,KAAO,eAClCiiF,EAAmB7wD,QAAQw+B,gBAAiB,EAC5CqyB,EAAmBxQ,aAAc,EAC1BwQ,CAER,CAEA,SAASsB,GAAc7nE,EAAQwL,EAAGE,EAAG3nB,EAAOC,GAE3Cgc,EAAOi0B,SAAS7vC,IAAKonB,EAAGE,EAAG3nB,EAAOC,GAClCgc,EAAO+oD,QAAQ3kE,IAAKonB,EAAGE,EAAG3nB,EAAOC,EAElC,CAEA,SAASolF,GAAcjgF,GAEtB,MAAMtG,EAAW,IAAIm2C,GAMrB,OALAn2C,EAAS23C,WAAY,EACrB33C,EAAS03C,YAAa,EACtB13C,EAASs5C,SAAW,MACpBt5C,EAASyB,KAAO,SAAU6E,IAEnBtG,CAER,CAuCA,SAASykF,GAAqB6D,GAE7B,MAAMtoF,EAAWumF,GAAc,WAG/B,OAFAvmF,EAASi3C,aAAehc,GAAaqtD,EAAYl5B,IAE1CpvD,CAER,CAEA,SAAS4kF,GAAsB0D,GAE9B,MAAMtoF,EAAWumF,GAAc,YAG/B,OAFAvmF,EAASi3C,aAAepkB,GAASy1D,EAAYpsC,GAAYkT,IAAmB,GAErEpvD,CAER,CAEA,MAAMuoF,GAAgB,IAAItpF,QAEpBupF,GAAgB,IAAI/iF,IAAK,CAC9B,CAAEgjF,UAAW,OACb,CAAEC,WAAY,OACd,CAAEtsD,WAAY,OACd,CAAEv1B,WAAY,QACd,CAAE8hF,YAAa,QACf,CAAEtsD,YAAa,QACf,CAAEH,aAAc,WAGXizC,GAAYltE,GAEZ,KAAKoR,KAAMpR,GAER6E,OAAQ7E,GAAQsQ,QAAS,MAAO,KAIvCtQ,EAAQiL,OAAQjL,KAECA,EAAQ,EAAI,GAAK,MAUpC,MAAM2mF,GASL,WAAA/pF,CAAaQ,EAAQwC,EAAU8sE,GAO9B5vE,KAAKM,OAASA,EAOdN,KAAKiB,SAAaX,GAAUA,EAAOW,UAAc,KAOjDjB,KAAKgB,SAAaV,GAAUA,EAAOU,UAAc,KAOjDhB,KAAK8C,SAAWA,EAOhB9C,KAAK4vE,OAASA,EAQd5vE,KAAK29C,MAAQ,KAQb39C,KAAK43B,OAAS,KAQd53B,KAAK+C,MAAQ,GAOb/C,KAAK8pF,gBAAkB,GAOvB9pF,KAAKggF,YAAc,GAOnBhgF,KAAKigF,kBAAoB,GAOzBjgF,KAAKkgF,iBAAmB,GAOxBlgF,KAAK+pF,UAAY,CAAC,EAQlB/pF,KAAKu5C,QAAU,KAQfv5C,KAAKw3C,WAAa,KAQlBx3C,KAAK2zD,gBAAkB,KAQvB3zD,KAAKw7C,QAAU,KAOfx7C,KAAKo1C,gBAAkB,KAOvBp1C,KAAKiiE,aAAe,KAOpBjiE,KAAKmiE,eAAiB,KAOtBniE,KAAKwhE,cAAgB,KAOrBxhE,KAAKgqF,UAAY,CAAEnwC,OAAQ,GAAIqnB,SAAU,GAAIhwC,QAAS,IAOtDlxB,KAAKiqF,SAAW,CAAEpwC,OAAQ,GAAIqnB,SAAU,GAAIhwC,QAAS,IAQrDlxB,KAAKqxE,SAAW,CAAEx3B,OAAQ,GAAIqnB,SAAU,GAAIhwC,QAAS,GAAI5vB,MAAO,GAQhEtB,KAAKkqF,QAAU,CAAErwC,OAAQ,GAAIqnB,SAAU,GAAIhwC,QAAS,GAAI5vB,MAAO,GAO/DtB,KAAK48D,SAAW,CAAE/iB,OAAQ,CAAC,EAAGqnB,SAAU,CAAC,EAAGhwC,QAAS,CAAC,GAOtDlxB,KAAKmqF,gBAAkB,CAAC,EAOxBnqF,KAAKoqF,WAAa,KAQlBpqF,KAAKmB,WAAa,GAQlBnB,KAAKqqF,iBAAmB,GAOxBrqF,KAAKsqF,SAAW,GAQhBtqF,KAAKuqF,MAAQ,CAAC,EAQdvqF,KAAKwqF,KAAO,CAAC,EAQbxqF,KAAKyqF,KAAO,CAAE7pB,KAAM,IAQpB5gE,KAAK0qF,SAAW,GAShB1qF,KAAKwW,MAAQA,KAQbxW,KAAK2qF,OAAS,GAQd3qF,KAAK0qB,IAAM,KAQX1qB,KAAKkW,oBAAsB,KAO3BlW,KAAKqC,QAAU,CACdpB,SAAUjB,KAAKiB,UAQhBjB,KAAK6O,MAAQ,IAAImyE,GAUjBhhF,KAAKwvB,YAAcxvB,KAAK6O,MAExB7O,KAAK4qF,UAAY,IAAI1qF,QAOrBF,KAAK6b,YAAc,KAOnB7b,KAAKgN,WAAa,KAQlBhN,KAAKkgB,qBAAsB,CAE5B,CAOA,kBAAA2qE,GAEC,IAAIC,EAAkBtB,GAAc1oF,IAAKd,KAAK8C,UAU9C,YARyB/B,IAApB+pF,IAEJA,EAAkB,IAAIvyB,GAEtBixB,GAAchnF,IAAKxC,KAAK8C,SAAUgoF,IAI5BA,CAER,CAWA,kBAAA5R,CAAoB/2E,EAAOC,EAAQi7C,GAElC,OAAO,IAAI,MAAcl7C,EAAOC,EAAQi7C,EAEzC,CAUA,sBAAA0tC,CAAwB/5D,EAAMqsB,GAE7B,OAAO,IAAID,GAAkBpsB,EAAMqsB,EAEpC,CAOA,oBAAAkV,GAIC,OAAO,IAAIkxB,GAAgBzjF,KAAK8C,SAEjC,CAQA,QAAAqT,CAAUhQ,GAET,OAAOnG,KAAK+C,MAAMoT,SAAUhQ,EAE7B,CAUA,aAAA6kF,CAAeC,EAAWruB,GAEzB,MAAMkuB,EAAkB9qF,KAAK6qF,qBAIvBK,EAAgB,GAEtB,IAYItoB,EAZAuoB,GAAc,EAElB,IAAM,MAAMjoB,KAAWtG,EAEtBsuB,EAAcplF,KAAMo9D,GAEpBioB,EAAcA,IAA4C,IAA7BjoB,EAAQjoD,UAAUV,OA0BhD,OAlBK4wE,GAEJvoB,EAAYkoB,EAAgBhqF,IAAKoqF,QAEdnqF,IAAd6hE,IAEJA,EAAY,IAAIid,GAAWoL,EAAWC,EAAelrF,KAAKmqF,gBAAiBc,GAAY7vE,MAAO8vE,GAE9FJ,EAAgBtoF,IAAK0oF,EAAetoB,KAMrCA,EAAY,IAAIid,GAAWoL,EAAWC,EAAelrF,KAAKmqF,gBAAiBc,GAAY7vE,MAAO8vE,GAIxFtoB,CAER,CASA,iBAAAwoB,CAAmBH,EAAWpvE,GAE7B,MAAM+gD,EAAW58D,KAAK48D,SAAU/gD,GAEhC,IAAI+mD,EAAYhG,EAAUquB,GAc1B,YAZmBlqF,IAAd6hE,SAEuC7hE,IAAtCf,KAAKmqF,gBAAiBc,KAE1BjrF,KAAKmqF,gBAAiBc,GAAc,CAAE/nB,QAAS,EAAG9nD,MAAOvX,OAAOC,KAAM9D,KAAKmqF,iBAAkBnmF,SAI9F44D,EAAUquB,GAAcroB,EAAY,IAI9BA,CAER,CAOA,WAAAxI,GAEC,IAAIixB,EAAiBrrF,KAAKoqF,WAE1B,GAAwB,OAAnBiB,EAA0B,CAE9B,MAAMC,EAAS,CAAC,EACV1uB,EAAW58D,KAAK48D,SAEtB,IAAM,MAAM/gD,KAAexS,EAE1B,IAAM,MAAM4hF,KAAaruB,EAAU/gD,GAAgB,CAElD,MAAMw1D,EAAWzU,EAAU/gD,GAAeovE,IAEpBK,EAAQL,KAAiBK,EAAQL,GAAc,KACvDnlF,QAASurE,EAExB,CAIDga,EAAiB,GAEjB,IAAM,MAAMJ,KAAaK,EAAS,CAEjC,MAAMlwE,EAAQkwE,EAAQL,GAEhB7K,EAAgBpgF,KAAKgrF,cAAeC,EAAW7vE,GAErDiwE,EAAevlF,KAAMs6E,EAEtB,CAEApgF,KAAKoqF,WAAaiB,CAEnB,CAEA,OAAOA,CAER,CAKA,iBAAAE,GAEC,MAAMF,EAAiBrrF,KAAKo6D,cAE5BixB,EAAe33E,MAAM,CAAEmM,EAAGC,IAASD,EAAE+8C,SAAU,GAAI3hD,UAAUT,MAAQsF,EAAE88C,SAAU,GAAI3hD,UAAUT,QAE/F,IAAM,IAAInW,EAAI,EAAGA,EAAIgnF,EAAernF,OAAQK,IAAO,CAElD,MAAMmnF,EAAeH,EAAgBhnF,GACrCrE,KAAKmqF,gBAAiBqB,EAAa9oF,MAAO0Y,MAAQ/W,EAElDmnF,EAAalqF,MAAQ+C,CAEtB,CAED,CASA,WAAAoX,CAAatV,EAAM6F,GAElBhM,KAAK+pF,UAAW/9E,GAAS7F,CAE1B,CAOA,OAAA0G,CAAS1G,IAE6B,IAAhCnG,KAAK+C,MAAMoT,SAAUhQ,KAEzBnG,KAAK+C,MAAM+C,KAAMK,GAEjBnG,KAAKyb,YAAatV,EAAMA,EAAKmF,QAAStL,OAIxC,CASA,iBAAA6N,CAAmB1H,IAE6B,IAA1CnG,KAAK8pF,gBAAgB3zE,SAAUhQ,IAEnCnG,KAAK8pF,gBAAgBhkF,KAAMK,EAI7B,CAKA,gBAAAslF,GAEC,IAAM,MAAMtlF,KAAQnG,KAAK+C,MAAQ,CAEboD,EAAKoF,kBAEJ7C,EAAeC,MAElC3I,KAAKggF,YAAYl6E,KAAMK,EAAKJ,UAI9B,CAEA,IAAM,MAAMI,KAAQnG,KAAK8pF,gBAAkB,CAE1C,MAAMlgF,EAAmBzD,EAAKqF,sBACxB3B,EAAkB1D,EAAKsF,qBAExB7B,IAAqBlB,EAAeC,MAExC3I,KAAKigF,kBAAkBn6E,KAAMK,EAAKJ,WAI9B8D,IAAoBnB,EAAeC,MAEvC3I,KAAKkgF,iBAAiBp6E,KAAMK,EAAKJ,UAInC,CAED,CAQA,eAAI2lF,GAEH,OAAO1rF,KAAK0qF,SAAU1qF,KAAK0qF,SAAS1mF,OAAS,EAE9C,CAQA,iBAAA2nF,CAAmB73D,GAElB,OAASA,EAAQ4pB,YAAc,OAAgB5pB,EAAQ4pB,YAAc,OAA6B5pB,EAAQ4pB,YAAc,OAA6B5pB,EAAQ4pB,YAAc,OAC1K5pB,EAAQuf,YAAc,OAAgBvf,EAAQuf,YAAc,OAA6Bvf,EAAQuf,YAAc,OAA6Bvf,EAAQuf,YAAc,KAEpK,CAQA,QAAAvmC,CAAU3G,GAUTnG,KAAK0qF,SAAS5kF,KAAMK,EAErB,CAOA,WAAAyH,CAAazH,GAIZ,GAFkBnG,KAAK0qF,SAASkB,QAEbzlF,EAElB,MAAM,IAAIkN,MAAO,sCAInB,CAWA,SAAA8M,CAAWuB,GAEV,OAAOA,CAER,CAQA,eAAAzV,CAAiBD,GAEhB,OAAOhM,KAAK+pF,UAAW/9E,EAExB,CASA,OAAAwsC,CAAS38B,EAAa1V,GAIrB,OAFAnG,KAAKgqF,UAAWnuE,GAAc/V,KAAMK,GAE7BA,CAER,CAOA,UAAAklB,CAAYhpB,GAEXrC,KAAKqC,QAAUA,CAEhB,CAOA,UAAA+oB,GAEC,OAAOprB,KAAKqC,OAEb,CAQA,gBAAAi3E,GAIC,OAFMt5E,KAAKqC,QAEJrC,KAAKqC,OAEb,CAOA,QAAAovB,CAAU5iB,GAET7O,KAAK6O,MAAQA,CAEd,CAOA,QAAA0iB,GAEC,OAAOvxB,KAAK6O,KAEb,CASA,gBAAA2iB,CAAkBrrB,EAAMirB,GAAS,GAEhC,MAAMvwB,EAAOb,KAAKsN,gBAAiBnH,GAGnC,YAFoBpF,IAAfF,EAAKgO,QAAsBhO,EAAKgO,MAAQ,IAAImyE,GAAW5vD,EAASpxB,KAAKuxB,WAAa,OAEhF1wB,EAAKgO,KAEb,CASA,WAAAqP,GAEC,OAAO,CAER,CAQA,cAAA+pB,GAECx7B,QAAQC,KAAM,qBAEf,CAQA,gBAAAy7B,GAEC17B,QAAQC,KAAM,qBAEf,CASA,YAAA27B,GAEC57B,QAAQC,KAAM,qBAEf,CAQA,cAAA0tB,GAEC3tB,QAAQC,KAAM,qBAEf,CAQA,YAAAomC,GAECrmC,QAAQC,KAAM,qBAEf,CASA,OAAAyoB,GAEC,OAAO,CAER,CAQA,aAAA/oB,CAAejG,GAEd,MAAMkH,EAAWrN,KAAKsN,gBAAiBnH,GAGvC,OAFAkH,EAASwC,gBAAqC9O,IAAxBsM,EAASwC,WAA2B,EAAIxC,EAASwC,WAAa,EAE7ExC,EAASwC,UAEjB,CAWA,eAAA4mB,GAEChqB,QAAQC,KAAM,qBAEf,CAYA,kBAAAm/E,GAECp/E,QAAQC,KAAM,qBAEf,CASA,aAAAsG,CAAezL,EAAMrE,EAAQ,MAa5B,GAXe,OAAVA,IAEU,UAATqE,GAA6B,QAATA,GAA2B,SAATA,EAAkBrE,EAAQ,EAClD,SAATqE,EAAkBrE,GAAQ,EACjB,UAATqE,EAAmBrE,EAAQ,IAAI,MACtB,SAATqE,EAAkBrE,EAAQ,IAAI,MACrB,SAATqE,EAAkBrE,EAAQ,IAAI,MACrB,SAATqE,IAAkBrE,EAAQ,IAAI,QAI3B,UAATqE,EAAmB,OAAO6oE,GAASltE,GACxC,GAAc,QAATqE,EAAiB,MAAO,GAAItC,KAAKoiB,MAAOnkB,KAC7C,GAAc,SAATqE,EAAkB,OAAOrE,GAAS,EAAI,GAAI+B,KAAKoiB,MAAOnkB,MAAc,KACzE,GAAc,SAATqE,EAAkB,OAAOrE,EAAQ,OAAS,QAC/C,GAAc,UAATqE,EAAmB,MAAO,GAAIvH,KAAK6Q,QAAS,YAAeu/D,GAASltE,EAAM45B,OAAUszC,GAASltE,EAAM65B,OAAUqzC,GAASltE,EAAM4c,OAEjI,MAAMN,EAAaxf,KAAKyP,cAAelI,GAEjCsK,EAAgB7R,KAAKwQ,iBAAkBjJ,GAEvCyL,EAAgB9P,GAASlD,KAAKgT,cAAenB,EAAe3O,GAElE,GAAoB,IAAfsc,EAEJ,MAAO,GAAIxf,KAAK6Q,QAAStJ,OAAayL,EAAe9P,EAAM0mB,OAAU5W,EAAe9P,EAAM4mB,OAEpF,GAAoB,IAAftK,EAEX,MAAO,GAAIxf,KAAK6Q,QAAStJ,OAAayL,EAAe9P,EAAM0mB,OAAU5W,EAAe9P,EAAM4mB,OAAU9W,EAAe9P,EAAM+5B,OAEnH,GAAoB,IAAfzd,EAEX,MAAO,GAAIxf,KAAK6Q,QAAStJ,OAAayL,EAAe9P,EAAM0mB,OAAU5W,EAAe9P,EAAM4mB,OAAU9W,EAAe9P,EAAM+5B,OAAUjqB,EAAe9P,EAAMg6B,OAElJ,GAAK1d,EAAa,GAAKtc,IAAWA,EAAMgE,WAAahE,EAAMiE,WAEjE,MAAO,GAAInH,KAAK6Q,QAAStJ,OAAarE,EAAM85B,SAAS1lB,IAAKtE,GAAgBlC,KAAM,UAE1E,GAAK0O,EAAa,EAExB,MAAO,GAAIxf,KAAK6Q,QAAStJ,OAI1B,MAAM,IAAI8L,MAAO,sBAAsB9L,6CAExC,CASA,OAAAsJ,CAAStJ,GAER,MAAc,UAATA,EAA0B,OAExBA,CAER,CAQA,oBAAA0rB,CAAsBvwB,GAErB,OAAO1C,KAAKgB,eAAmDD,IAAvCf,KAAKgB,SAASkyB,aAAcxwB,EAErD,CASA,YAAAwwB,CAAcxwB,EAAM6E,GAEnB,MAAMpG,EAAanB,KAAKmB,WAIxB,IAAM,MAAMwB,KAAaxB,EAExB,GAAKwB,EAAUD,OAASA,EAEvB,OAAOC,EAQT,MAAMA,EAAY,IAAI29E,GAAe59E,EAAM6E,GAI3C,OAFApG,EAAW2E,KAAMnD,GAEVA,CAER,CASA,eAAAuN,CAAiB/J,GAEhB,OAAOA,EAAKzD,IAEb,CAQA,QAAAgd,CAAUnY,GAET,MAAO,QAAQ+M,KAAM/M,EAEtB,CAQA,QAAAkY,CAAUlY,GAET,MAAO,QAAQ+M,KAAM/M,EAEtB,CAQA,WAAAmvB,CAAanvB,GAEZ,MAAgB,SAATA,GAA4B,aAATA,GAAgC,YAATA,GAA+B,YAATA,GAA+B,gBAATA,GAAmC,mBAATA,GAAsC,iBAATA,GAAoC,cAATA,CAEhL,CASA,wBAAAovB,GAEC,OAAO,CAER,CAQA,2BAAAm1D,CAA6Bh4D,GAE5B,MAAMvsB,EAAOusB,EAAQvsB,KAErB,GAAKusB,EAAQi4D,cAAgB,CAE5B,GAAKxkF,IAAS,MAAU,MAAO,MAC/B,GAAKA,IAAS,MAAkB,MAAO,MAExC,CAEA,MAAO,OAER,CAQA,cAAAmE,CAAgBnE,GAEf,MAAc,SAATA,EAAyB,OAChB,SAATA,EAAyB,OAChB,SAATA,EAAyB,OAEvBvH,KAAKwQ,iBAAkBjJ,EAE/B,CAQA,gBAAAiJ,CAAkBjJ,GAIjB,GAAc,WAFdA,EAAOvH,KAAK8P,cAAevI,KAEO,SAATA,GAA4B,QAATA,GAA2B,SAATA,EAAkB,OAAOA,EAEvF,MAAMsK,EAAgB,2BAA2Bm6E,KAAMzkF,GAEvD,OAAuB,OAAlBsK,EAAgC,KAET,MAAvBA,EAAe,GAAqB,OACb,MAAvBA,EAAe,GAAqB,MACb,MAAvBA,EAAe,GAAqB,OAElC,OAER,CAQA,aAAA/B,CAAevI,GAEd,MAAc,UAATA,EAA0B,OACjB,YAATA,GAA+B,gBAATA,GAAmC,mBAATA,GAAsC,cAATA,EAA8B,OAEzGA,CAER,CASA,iBAAAX,CAAmB5C,EAAQ6N,EAAgB,SAE1C,GAAgB,IAAX7N,EAAe,OAAO6N,EAE3B,MAAMo6E,EAAWrlF,EAAmB5C,GAGpC,OAFiC,UAAlB6N,EAA4B,GAAKA,EAAe,IAE/Co6E,CAEjB,CAQA,gBAAAC,CAAkB1mF,GAEjB,OAAOikF,GAAc3oF,IAAK0E,EAAM1F,YAEjC,CAQA,oBAAA6vB,CAAsBhtB,GAErB,IAAIwpF,EAAgBxpF,EAEfA,EAAUk4D,+BAA+BsxB,EAAgBxpF,EAAU9B,MAExE,MAAM2E,EAAQ2mF,EAAc3mF,MACtBoqB,EAAWjtB,EAAUitB,SACrBosC,EAAar5D,EAAUq5D,WAE7B,IAAItuC,EAQJ,OANS/qB,aAAqB,QAA2C,IAAfq5D,IAEzDtuC,EAAY1tB,KAAKksF,iBAAkB1mF,IAI7BxF,KAAK4G,kBAAmBgpB,EAAUlC,EAE1C,CAQA,aAAAje,CAAelI,GAEd,MAAM6kF,EAAUpsF,KAAK8P,cAAevI,GAC9B8kF,EAAS,aAAaL,KAAMI,GAElC,OAAgB,OAAXC,EAAyBl+E,OAAQk+E,EAAQ,IAC7B,UAAZD,GAAmC,SAAZA,GAAkC,QAAZA,GAAiC,SAAZA,EAA4B,GACtE,IAAxB,OAAO93E,KAAM/M,GAAyB,GACd,IAAxB,OAAO+M,KAAM/M,GAAyB,GACd,IAAxB,OAAO+M,KAAM/M,GAAyB,GAEpC,CAER,CAQA,mBAAAoY,CAAqBpY,GAEpB,OAAOA,EAAKiM,QAAS,MAAO,MAE7B,CAWA,mBAAAoM,CAAqBrY,EAAM+kF,GAE1B,OAAOtsF,KAAK4G,kBAAmB5G,KAAKyP,cAAelI,GAAQ+kF,EAE5D,CAQA,cAAA/sE,CAAgBhY,GAEf,MAAMsK,EAAgB7R,KAAKwQ,iBAAkBjJ,GAE7C,MAAuB,QAAlBsK,GAA6C,SAAlBA,EAAkCtK,EAE3DvH,KAAK4f,oBAAqBrY,EAAM,MAExC,CAOA,QAAAgP,GAOC,OALAvW,KAAKwW,MAAQA,GAAOxW,KAAKwW,OAEzBxW,KAAK2qF,OAAO7kF,KAAMkT,MAAqBhZ,KAAKwW,OAC5CuC,GAAiB/Y,KAAKwW,OAEfxW,KAAKwW,KAEb,CAOA,WAAAC,GAEC,MAAM81E,EAAYvsF,KAAKwW,MAKvB,OAJAxW,KAAKwW,MAAQ+1E,EAAUn7D,OAEvBrY,GAAiB/Y,KAAK2qF,OAAOiB,OAEtBW,CAER,CAWA,eAAAj/E,CAAiBnH,EAAM0V,EAAc7b,KAAK6b,YAAahN,EAAQ,MAI9D,IAAIxB,GAFJwB,EAAkB,OAAVA,EAAmB1I,EAAK4E,SAAU/K,MAASA,KAAKwvB,YAAcxvB,KAAK6O,MAAUA,GAEhE4gB,QAAStpB,GAY9B,YAVkBpF,IAAbsM,IAEJA,EAAW,CAAC,EAEZwB,EAAM6gB,QAASvpB,EAAMkH,SAIWtM,IAA5BsM,EAAUwO,KAA8BxO,EAAUwO,GAAgB,CAAC,GAEjExO,EAAUwO,EAElB,CASA,iBAAAhQ,CAAmB1F,EAAM0V,EAAc,OAEtC,MAAMxO,EAAWrN,KAAKsN,gBAAiBnH,EAAM0V,GAE7C,OAAOxO,EAASH,aAAgBG,EAASH,WAAa,CAAEpB,WAAY,MAErE,CASA,0BAAAqkB,CAA4BhqB,EAAMoB,GAEjC,MAAM8F,EAAWrN,KAAKsN,gBAAiBnH,GAEvC,IAAI6pB,EAAkB3iB,EAAS2iB,gBAE/B,QAAyBjvB,IAApBivB,EAAgC,CAEpC,MAAM1uB,EAAQtB,KAAKqxE,SAAS/vE,QAE5B0uB,EAAkB,IAAIswD,GAAe,gBAAkBh/E,EAAOiG,EAAMpB,GAEpEnG,KAAKqqF,iBAAiBvkF,KAAMkqB,GAE5B3iB,EAAS2iB,gBAAkBA,CAE5B,CAEA,OAAOA,CAER,CAUA,qBAAAw8D,CAAuBrmF,EAAMkU,EAAOwB,EAAc7b,KAAK6b,aAEtD,MAAMxO,EAAWrN,KAAKsN,gBAAiBnH,EAAM0V,GAE7C,IAAI4wE,EAAap/E,EAASo/E,WAE1B,QAAoB1rF,IAAf0rF,EAA2B,CAE/B,MAAMnrF,EAAQtB,KAAKkqF,QAAQ5oF,QAE3BmrF,EAAa,IAAIvL,GAAgB,aAAe5/E,EAAO+Y,GAEvDra,KAAKkqF,QAASruE,GAAc/V,KAAM2mF,GAElCp/E,EAASo/E,WAAaA,CAEvB,CAEA,OAAOA,CAER,CAWA,kBAAA7wE,CAAoBzV,EAAMoB,EAAMsU,EAAc7b,KAAK6b,YAAanZ,EAAO,MAEtE,MAAM2K,EAAWrN,KAAKsN,gBAAiBnH,EAAM0V,EAAa7b,KAAKwvB,aAE/D,IAAI7T,EAActO,EAASyO,QAE3B,QAAqB/a,IAAhB4a,EAA4B,CAEhC,MAAMra,EAAQtB,KAAKqxE,SAAS/vE,QAE5Bqa,EAAc,IAAI6kE,GAAa99E,GAAU,cAAgBpB,EAASiG,EAAMpB,GAExEnG,KAAKqxE,SAAUx1D,GAAc/V,KAAM6V,GAEnCtO,EAASyO,QAAUH,CAEpB,CAEA,OAAOA,CAER,CAWA,cAAA1L,CAAgB9J,EAAMzD,EAAO,KAAM6E,EAAOpB,EAAKwF,YAAa3L,MAAQ6b,EAAc7b,KAAK6b,aAEtF,MAAMxO,EAAWrN,KAAKsN,gBAAiBnH,EAAM0V,GAE7C,IAAI7L,EAAU3C,EAASq/E,SAEvB,QAAiB3rF,IAAZiP,EAAwB,CAE5B,MAAMw6E,EAAOxqF,KAAKwqF,KAAM3uE,KAAmB7b,KAAKwqF,KAAM3uE,GAAgB,IAExD,OAATnZ,IAAgBA,EAAO,UAAY8nF,EAAKxmF,QAE7CgM,EAAU,IAAI0wE,GAASh+E,EAAM6E,GAE7BijF,EAAK1kF,KAAMkK,GAEX3C,EAASq/E,SAAW18E,CAErB,CAEA,OAAOA,CAER,CAUA,kBAAAoM,CAAoBjW,EAAMzD,EAAO,KAAM6E,EAAOpB,EAAKwF,YAAa3L,OAE/D,MAAMqN,EAAWrN,KAAKsN,gBAAiBnH,EAAM,OAE7C,IAAIwmF,EAAct/E,EAAS6O,QAE3B,QAAqBnb,IAAhB4rF,EAA4B,CAEhC,MAAMrC,EAAWtqF,KAAKsqF,SAChBhpF,EAAQgpF,EAAStmF,OAET,OAATtB,IAAgBA,EAAO,cAAgBpB,GAE5CqrF,EAAc,IAAI/L,GAAal+E,EAAM6E,GAErC+iF,EAASxkF,KAAM6mF,GAEft/E,EAAS6O,QAAUywE,CAEpB,CAEA,OAAOA,CAER,CAUA,eAAAnd,CAAiBrpE,EAAMoB,EAAMsU,EAAc7b,KAAK6b,aAE/C,MAAMxO,EAAWrN,KAAKsN,gBAAiBnH,GAEvC,IAAIopE,EAAWliE,EAASuzD,KAExB,QAAkB7/D,IAAbwuE,EAAyB,CAE7B,MAAMgb,EAAQvqF,KAAKuqF,MAAO1uE,KAAmB7b,KAAKuqF,MAAO1uE,GAAgB,IACnEva,EAAQipF,EAAMvmF,OAEpBurE,EAAW,IAAIuR,GAAU,WAAax/E,EAAOiG,GAE7CgjF,EAAMzkF,KAAMypE,GAEZliE,EAASuzD,KAAO2O,CAEjB,CAEA,OAAOA,CAER,CAWA,oBAAA7hE,CAAsBvH,EAAMsH,GAE3B,MAAM,UAAED,EAAS,cAAEo/E,GAAkB5sF,KAAKsN,gBAAiBnH,GAE3D,IAAI0mF,GAAgB,EAChBC,EAAqBr/E,EAEzB,KAAQq/E,GAAqB,CAE5B,IAAiD,IAA5CF,EAAc9rF,IAAKgsF,GAAgC,CAEvDD,GAAgB,EAChB,KAED,CAEAC,EAAqB9sF,KAAKsN,gBAAiBw/E,GAAqBxiE,eAEjE,CAEA,GAAKuiE,EAEJ,IAAM,MAAM5C,KAAYz8E,EAEvBxN,KAAKmQ,gBAAiB85E,EAMzB,CASA,oBAAA8C,CAAsB5mF,EAAMy6D,EAAMnzD,GAEjC,MAAMJ,EAAWrN,KAAKsN,gBAAiBnH,GACjCqH,EAAYH,EAASG,YAAeH,EAASG,UAAY,IACzDw/E,EAAY3/E,EAASu/E,gBAAmBv/E,EAASu/E,cAAgB,IAAI1sF,SAE3EsN,EAAU1H,KAAM86D,GAChBosB,EAAUxqF,IAAKiL,GAAW,EAE3B,CASA,eAAA0C,CAAiBywD,EAAMz6D,EAAO,MAE7B,MAAc,KAATy6D,IAES,OAATz6D,GAAiBnG,KAAKqC,QAAQoL,WAElCzN,KAAK+sF,qBAAsB5mF,EAAMy6D,EAAM5gE,KAAKqC,QAAQoL,WAIrDmzD,EAAO5gE,KAAK0qB,IAAMk2C,EAEX,QAAQtsD,KAAMssD,KAEpBA,GAAc,OAIf5gE,KAAKyqF,KAAK7pB,MAAQA,GAhBQ5gE,IAoB3B,CAQA,WAAAyqB,CAAam2C,GAIZ,OAFA5gE,KAAKyqF,KAAK7pB,MAAQA,EAEX5gE,IAER,CAQA,UAAA2qB,GAIC,OAFA3qB,KAAK0qB,KAAO,KAEL1qB,IAER,CAOA,aAAA6qB,GAIC,OAFA7qB,KAAK0qB,IAAM1qB,KAAK0qB,IAAI1oB,MAAO,GAAK,GAEzBhC,IAER,CASA,WAAAitF,CAAa9mF,GAEZ,OAAOnG,KAAK4qF,UAAU9pF,IAAKqF,EAE5B,CAQA,QAAA+mF,CAAU/mF,GAET,MAAMoG,EAASpG,EAAKwF,YAAa3L,MAE3BmtF,EAAWntF,KAAKotF,cAAejnF,EAAMoG,GAI3C,OAFAvM,KAAK4qF,UAAUpoF,IAAK2D,EAAMgnF,GAEnBA,CAER,CASA,iBAAAl3E,CAAmBP,GAElB,MAAMoD,EAAK,IAAI22D,GAET4d,EAAWrtF,KAAKkW,oBAQtB,OANAlW,KAAKkW,oBAAsB4C,EAE3BA,EAAG8nD,KAAO5gE,KAAKstF,kBAAmB53E,GAElC1V,KAAKkW,oBAAsBm3E,EAEpBv0E,CAER,CAQA,cAAAy0E,CAAgB73E,GAEf,MAAMI,EAASJ,EAAWI,OAEpBjC,EAAS,CACd,CAAE25E,OAAOC,YAER,IAAInsF,EAAQ,EACZ,MAAMuE,EAAShC,OAAOgC,OAAQ7F,MAC9B,MAAO,CACN0tF,KAAM,KAAM,CACXxqF,MAAO2C,EAAQvE,GACfqsF,KAAMrsF,KAAYuE,EAAO7B,SAI5B,GAGD,IAAM,MAAM0M,KAASoF,EAAOjC,OAE3BA,EAAQnD,EAAMhO,MAAS,IAAI+mE,GAAe/4D,EAAMnJ,KAAMmJ,EAAMhO,MAM7DgT,EAAWI,OAAS,KAEpB,MAAM6b,EAAWjc,EAAWE,KAAM/B,GAC5Bs5E,EAAWntF,KAAK4tF,eAAgBj8D,EAAU7b,EAAOvO,MAIvD,OAFAmO,EAAWI,OAASA,EAEbq3E,CAER,CASA,cAAAS,CAAgBznF,EAAMoG,EAAS,MAE9B,MAAMshF,EAAe7tF,KAAKyqF,KACpBqD,EAAe9tF,KAAKwqF,KACpBl5D,EAAgBtxB,KAAK6O,MACrBk/E,EAAqB/tF,KAAKgN,WAC1B+8D,EAAgB/pE,KAAKwW,MAErBi0E,EAAO,CACZ7pB,KAAM,IAGP5gE,KAAKyqF,KAAOA,EACZzqF,KAAKwqF,KAAO,CAAC,EACbxqF,KAAK6O,MAAQ,IAAImyE,GACjBhhF,KAAKwW,MAAQA,KAEb,IAAM,MAAMxJ,KAAc5D,EAEzBpJ,KAAKguF,cAAehhF,GAEpBy9E,EAAK19E,OAAS5G,EAAKkG,MAAOrM,KAAMuM,GAajC,OATAk+E,EAAKD,KAAOxqF,KAAKiuF,QAASjuF,KAAK6b,aAE/B7b,KAAKyqF,KAAOoD,EACZ7tF,KAAKwqF,KAAOsD,EACZ9tF,KAAK6O,MAAQyiB,EACbtxB,KAAKwW,MAAQuzD,EAEb/pE,KAAKguF,cAAeD,GAEbtD,CAER,CAUA,mBAAAxqE,GAEC,OAAO,IAER,CASA,aAAAmtE,CAAejnF,EAAMoG,EAAS,MAE7B,MAAMshF,EAAe7tF,KAAKyqF,KAEpBA,EAAO,CACZ7pB,KAAM,IASP,OANA5gE,KAAKyqF,KAAOA,EAEZA,EAAK19E,OAAS5G,EAAKkG,MAAOrM,KAAMuM,GAEhCvM,KAAKyqF,KAAOoD,EAELpD,CAER,CAcA,uBAAAz+D,CAAyBnQ,EAAa1V,EAAMoG,EAAS,KAAMwD,EAAe,MAEzE,MAAMm+E,EAAsBluF,KAAK6b,YAEjC7b,KAAKmuF,eAAgBtyE,GAErB,MAAMsxE,EAAWntF,KAAKotF,cAAejnF,EAAMoG,GAY3C,OAVsB,OAAjBwD,IAEJo9E,EAASvsB,MAAQ,GAAI5gE,KAAK0qB,IAAM3a,OAAoBo9E,EAASpgF,aAI9D/M,KAAKiqF,SAAUpuE,GAAgB7b,KAAKiqF,SAAUpuE,GAAgBsxE,EAASvsB,KAEvE5gE,KAAKmuF,eAAgBD,GAEdf,CAER,CAOA,kBAAAiB,GAEC,OAAOpuF,KAAKmB,WAAWktF,OAAQruF,KAAKqqF,iBAErC,CASA,aAAA3vB,GAECjuD,QAAQC,KAAM,qBAEf,CASA,WAAA4hF,GAEC7hF,QAAQC,KAAM,qBAEf,CASA,MAAAohC,CAAQvmC,EAAM7E,GAEb,MAAO,GAAI1C,KAAK6Q,QAAStJ,MAAY7E,GAEtC,CAQA,OAAAurF,CAASpyE,GAER,IAAItO,EAAU,GAEd,MAAMi9E,EAAOxqF,KAAKwqF,KAAM3uE,GAExB,QAAc9a,IAATypF,EAEJ,IAAM,MAAMkC,KAAYlC,EAEvBj9E,GAAW,GAAIvN,KAAK8tC,OAAQ4+C,EAASnlF,KAAMmlF,EAAShqF,UAMtD,OAAO6K,CAER,CASA,WAAAghF,GAEC9hF,QAAQC,KAAM,qBAEf,CAQA,QAAA8hF,CAAU3yE,GAET,MAAM0uE,EAAQvqF,KAAKuqF,MAAO1uE,GAE1B,IAAI+kD,EAAO,GAEX,QAAe7/D,IAAVwpF,EAEJ,IAAM,MAAMhb,KAAYgb,EAEvB3pB,GAAQ2O,EAAS3O,KAAO,KAM1B,OAAOA,CAER,CAOA,OAAAt1D,GAEC,OAAOtL,KAAKiiE,aAAejiE,KAAKmiE,eAAiBniE,KAAKwhE,aAEvD,CAOA,cAAA2sB,CAAgBtyE,GAEf7b,KAAK6b,YAAcA,CAEpB,CAOA,cAAA4yE,GAEC,OAAOzuF,KAAK6b,WAEb,CAOA,aAAAmyE,CAAehhF,GAEdhN,KAAKgN,WAAaA,CAEnB,CAOA,aAAAC,GAEC,OAAOjN,KAAKgN,UAEb,CAOA,SAAA0hF,GAECjiF,QAAQC,KAAM,qBAEf,CAOA,KAAAL,GAEC,MAAM,OAAE/L,EAAM,SAAEW,EAAQ,SAAE6B,GAAa9C,KAEvC,GAAkB,OAAbiB,EAAoB,CAExB,IAAI+9E,EAAel8E,EAAS2rB,QAAQkgE,aAAc1tF,GAE5B,OAAjB+9E,IAEJvyE,QAAQkiB,MAAO,2BAA4B1tB,EAASsG,4BAEpDy3E,EAAe,IAAI5nC,IAIpB4nC,EAAa3yE,MAAOrM,KAErB,MAECA,KAAKw4C,QAAS,UAAWl4C,GAQ1B,IAAM,MAAM0M,KAAc5D,EAAqB,CAE9CpJ,KAAKguF,cAAehhF,GAEfhN,KAAKqC,QAAQw3C,QAAU75C,KAAKqC,QAAQw3C,OAAOh3C,QAE/C7C,KAAKgsB,wBAAyB,SAAUhsB,KAAKqC,QAAQw3C,QAItD,IAAM,MAAMh+B,KAAexS,EAAe,CAEzCrJ,KAAKmuF,eAAgBtyE,GAErB,MAAMmuE,EAAYhqF,KAAKgqF,UAAWnuE,GAElC,IAAM,MAAM1V,KAAQ6jF,EAEC,aAAfh9E,EAEJhN,KAAKktF,SAAU/mF,GAIfA,EAAKkG,MAAOrM,KAMf,CAED,CAUA,OARAA,KAAKguF,cAAe,MACpBhuF,KAAKmuF,eAAgB,MAIrBnuF,KAAK0uF,YACL1uF,KAAKyrF,mBAEEzrF,IAER,CASA,cAAA4uF,CAAgB91D,EAAavxB,GAE5B,GAAc,UAATA,GAA6B,QAATA,GAA2B,SAATA,EAAkB,OAAO,IAAIg7E,GAAmBzpD,GAC3F,GAAc,SAATvxB,GAA4B,UAATA,GAA6B,UAATA,EAAmB,OAAO,IAAIi7E,GAAoB1pD,GAC9F,GAAc,SAATvxB,GAA4B,UAATA,GAA6B,UAATA,EAAmB,OAAO,IAAIk7E,GAAoB3pD,GAC9F,GAAc,SAATvxB,GAA4B,UAATA,GAA6B,UAATA,EAAmB,OAAO,IAAIm7E,GAAoB5pD,GAC9F,GAAc,UAATvxB,EAAmB,OAAO,IAAIo7E,GAAkB7pD,GACrD,GAAc,SAATvxB,EAAkB,OAAO,IAAIq7E,GAAoB9pD,GACtD,GAAc,SAATvxB,EAAkB,OAAO,IAAIs7E,GAAoB/pD,GAEtD,MAAM,IAAIzlB,MAAO,YAAY9L,mBAE9B,CAYA,MAAAoG,CAAQJ,EAASshF,EAAUC,GAK1B,IAHAD,EAAW7uF,KAAK8P,cAAe++E,OAC/BC,EAAS9uF,KAAK8P,cAAeg/E,KAEU,OAAXA,GAAmB9uF,KAAK02B,YAAao4D,GAEhE,OAAOvhF,EAIR,MAAMwhF,EAAiB/uF,KAAKyP,cAAeo/E,GACrCG,EAAehvF,KAAKyP,cAAeq/E,GAEzC,OAAwB,KAAnBC,GAA0C,IAAjBC,EAEtB,GAAIhvF,KAAK6Q,QAASi+E,MAAcvhF,aAAqBA,aAAqBA,YAI1D,IAAnBwhF,GAAyC,IAAjBC,EAErB,GAAIhvF,KAAK6Q,QAASi+E,MAAcvhF,YAAoBA,WAKvDwhF,EAAiB,GAQjBC,EAAe,GAAsB,IAAjBA,EAJjBzhF,EAYHwhF,IAAmBC,EAEhB,GAAIhvF,KAAK6Q,QAASi+E,OAAevhF,MAIpCwhF,EAAiBC,EAEdhvF,KAAK2N,OAAQ,GAAIJ,KAAa,MAAMvL,MAAO,EAAGgtF,KAAmBhvF,KAAK4G,kBAAmBooF,EAAchvF,KAAKwQ,iBAAkBq+E,IAAcC,GAI9H,IAAjBE,GAAsBD,EAAiB,EAEpC,GAAI/uF,KAAK6Q,QAASi+E,OAAe9uF,KAAK2N,OAAQJ,EAASshF,EAAU,iBAIjD,IAAnBE,EAEG,GAAI/uF,KAAK6Q,QAASi+E,OAAe9uF,KAAK2N,OAAQJ,EAASshF,EAAU,kBAIjD,IAAnBE,GAAwBC,EAAe,GAAKH,IAAa7uF,KAAKwQ,iBAAkBs+E,KAKpFvhF,EAAU,GAAIvN,KAAK6Q,QAAS7Q,KAAKwQ,iBAAkBs+E,QAAiBvhF,OAI9D,GAAIvN,KAAK6Q,QAASi+E,OAAevhF,MAEzC,CAOA,YAAA0hF,GAEC,MAAO,gBAAiB,uBAEzB,CAIA,kBAAAC,CAAoB3nF,EAAO,gBAE1B,MAAM,IAAI8L,MAAO,mEAAoE9L,eAEtF,EAUD,MAAM4nF,GAKL,WAAArvF,GAQCE,KAAKg4D,KAAO,EAQZh4D,KAAKovF,UAAY,EAQjBpvF,KAAK8sC,QAAU,EAQf9sC,KAAKQ,SAAW,EAOhBR,KAAKqvF,UAAY,IAAInvF,QAOrBF,KAAKsvF,gBAAkB,IAAIpvF,QAO3BF,KAAKuvF,eAAiB,IAAIrvF,QAQ1BF,KAAK8C,SAAW,KAQhB9C,KAAKiB,SAAW,KAQhBjB,KAAK43B,OAAS,KAQd53B,KAAKM,OAAS,KAQdN,KAAK29C,MAAQ,IAEd,CAWA,QAAA6xC,CAAUC,EAAcC,GAEvB,IAAIC,EAAOF,EAAa3uF,IAAK4uF,GAa7B,YAXc3uF,IAAT4uF,IAEJA,EAAO,CACNC,UAAW,IAAI1vF,QACf2vF,SAAU,IAAI3vF,SAGfuvF,EAAajtF,IAAKktF,EAASC,IAIrBA,CAER,CAUA,gBAAAG,CAAkB3pF,GAEjB,MAAMwD,EAAaxD,EAAKqF,sBAClBqiB,EAAY1nB,EAAK0E,gBAAiB7K,MAExC,GAAK2J,IAAejB,EAAeE,MAAQ,CAE1C,MAAM,SAAEinF,GAAa7vF,KAAKwvF,SAAUxvF,KAAKsvF,gBAAiBzhE,GAErDgiE,EAAS/uF,IAAK+sB,KAAgB7tB,KAAK8sC,UAEJ,IAA9B3mC,EAAKqG,aAAcxM,OAEvB6vF,EAASrtF,IAAKqrB,EAAW7tB,KAAK8sC,QAMjC,MAAO,GAAKnjC,IAAejB,EAAeG,OAAS,CAElD,MAAM,UAAE+mF,GAAc5vF,KAAKwvF,SAAUxvF,KAAKsvF,gBAAiBzhE,GAEtD+hE,EAAU9uF,IAAK+sB,KAAgB7tB,KAAKQ,WAEL,IAA9B2F,EAAKqG,aAAcxM,OAEvB4vF,EAAUptF,IAAKqrB,EAAW7tB,KAAKQ,SAMlC,MAAYmJ,IAAejB,EAAeI,QAEzC3C,EAAKqG,aAAcxM,KAIrB,CAUA,eAAA+vF,CAAiB5pF,GAEhB,MAAMwD,EAAaxD,EAAKsF,qBAClBoiB,EAAY1nB,EAAK0E,gBAAiB7K,MAExC,GAAK2J,IAAejB,EAAeE,MAAQ,CAE1C,MAAM,SAAEinF,GAAa7vF,KAAKwvF,SAAUxvF,KAAKuvF,eAAgB1hE,GAEpDgiE,EAAS/uF,IAAK+sB,KAAgB7tB,KAAK8sC,UAEL,IAA7B3mC,EAAKwG,YAAa3M,OAEtB6vF,EAASrtF,IAAKqrB,EAAW7tB,KAAK8sC,QAMjC,MAAO,GAAKnjC,IAAejB,EAAeG,OAAS,CAElD,MAAM,UAAE+mF,GAAc5vF,KAAKwvF,SAAUxvF,KAAKuvF,eAAgB1hE,GAErD+hE,EAAU9uF,IAAK+sB,KAAgB7tB,KAAKQ,WAEN,IAA7B2F,EAAKwG,YAAa3M,OAEtB4vF,EAAUptF,IAAKqrB,EAAW7tB,KAAKQ,SAMlC,MAAYmJ,IAAejB,EAAeI,QAEzC3C,EAAKwG,YAAa3M,KAIpB,CAUA,UAAAgwF,CAAY7pF,GAEX,MAAMwD,EAAaxD,EAAKoF,gBAClBsiB,EAAY1nB,EAAK0E,gBAAiB7K,MAExC,GAAK2J,IAAejB,EAAeE,MAAQ,CAE1C,MAAM,SAAEinF,GAAa7vF,KAAKwvF,SAAUxvF,KAAKqvF,UAAWxhE,GAE/CgiE,EAAS/uF,IAAK+sB,KAAgB7tB,KAAK8sC,UAEV,IAAxB3mC,EAAKoE,OAAQvK,OAEjB6vF,EAASrtF,IAAKqrB,EAAW7tB,KAAK8sC,QAMjC,MAAO,GAAKnjC,IAAejB,EAAeG,OAAS,CAElD,MAAM,UAAE+mF,GAAc5vF,KAAKwvF,SAAUxvF,KAAKqvF,UAAWxhE,GAEhD+hE,EAAU9uF,IAAK+sB,KAAgB7tB,KAAKQ,WAEX,IAAxB2F,EAAKoE,OAAQvK,OAEjB4vF,EAAUptF,IAAKqrB,EAAW7tB,KAAKQ,SAMlC,MAAYmJ,IAAejB,EAAeI,QAEzC3C,EAAKoE,OAAQvK,KAIf,CAMA,MAAAuK,GAECvK,KAAK8sC,eAEkB/rC,IAAlBf,KAAKiwF,WAAyBjwF,KAAKiwF,SAAWC,YAAYC,OAE/DnwF,KAAKovF,WAAcc,YAAYC,MAAQnwF,KAAKiwF,UAAa,IAEzDjwF,KAAKiwF,SAAWC,YAAYC,MAE5BnwF,KAAKg4D,MAAQh4D,KAAKovF,SAEnB,EAOD,MAAMgB,GAWL,WAAAtwF,CAAayH,EAAM7E,EAAMhB,EAAQ,KAAM2gD,EAAY,GAAIguC,GAAU,GAOhErwF,KAAKuH,KAAOA,EAOZvH,KAAK0C,KAAOA,EAQZ1C,KAAK0B,MAAQA,EAQb1B,KAAKqiD,UAAYA,EAQjBriD,KAAKqwF,QAAUA,CAEhB,EAIDD,GAAkBE,qBAAsB,EAOxC,MAAMC,WAA6B7V,GAElC,eAAWnzE,GAEV,MAAO,sBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,EAER,CAEA,KAAA/5D,CAAOnM,GAEN2J,MAAMwC,MAAOnM,GAEb,MAAM+wC,EAAgB/wC,EAAQsC,QAAQyuC,cAEhC4P,EAAa1gD,KAAKwsB,UAClB2zB,EAAiB+xB,GAAsBlyE,KAAKimE,OAC5Ch1B,EAAiBlxC,EAAQsC,QAAQ4uC,eAEvCH,EAAcmO,OAAQ,CACrBkB,iBACAO,aACAzP,kBACElxC,EAAQyW,MAAOzW,EAEnB,EAID,MAAMywF,GAA0B,IAAI,MAC9BC,GAA0B,IAAI,MAEpC,IAAIC,GAAU,KAOd,MAAMC,WAA0BjW,GAE/B,eAAWnzE,GAEV,MAAO,mBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,GAOPjmE,KAAKwsD,WAAa1wC,GAAS,IAAI,OAAYX,SAAUN,IAOrD7a,KAAKusD,UAAYzwC,GAAS,IAAI,OAAYX,SAAUN,IASpD7a,KAAK2J,WAAajB,EAAeG,MAElC,CAOA,MAAA0B,CAAQgR,GAEP7R,MAAMa,OAAQgR,GAEd,MAAM,MAAE0qD,GAAUjmE,KAEZ+nD,EAAaxsC,EAAMqc,OAAOO,mBAEhCs4D,GAAUtlB,WACVqlB,GAAUjtF,KAAM0iE,EAAMrkE,aACtB4uF,GAAUI,YAAa7oC,GACvB0oC,GAAUI,gBAAiBL,IAE3BxwF,KAAKusD,UAAUrpD,MAAMV,IAAmB,GAAdyjE,EAAM9jE,MAAa,EAAK,GAClDnC,KAAKwsD,WAAWtpD,MAAMV,IAAK,EAAoB,GAAfyjE,EAAM7jE,OAAc,GAEpDpC,KAAKusD,UAAUrpD,MAAM+1B,aAAcw3D,IACnCzwF,KAAKwsD,WAAWtpD,MAAM+1B,aAAcw3D,GAErC,CAEA,KAAAvkF,CAAOnM,GAIN,IAAI0sD,EAAOC,EAFXhjD,MAAMwC,MAAOnM,GAIRA,EAAQme,YAAa,sBAEzBuuC,EAAQ34B,GAAS48D,GAAQI,aACzBpkC,EAAQ54B,GAAS48D,GAAQK,eAIzBtkC,EAAQ34B,GAAS48D,GAAQM,YACzBtkC,EAAQ54B,GAAS48D,GAAQO,aAI1B,MAAM,UAAEzkE,EAAS,MAAEy5C,GAAUjmE,KACvB8wC,EAAgB/wC,EAAQsC,QAAQyuC,cAEhCwb,EAAgB0lB,GAAmB/L,GACnCh1B,EAAiBlxC,EAAQsC,QAAQ4uC,eAEvCH,EAAcoO,eAAgB,CAC7BwB,WAAYl0B,EACZ8/B,gBACAC,UAAWvsD,KAAKusD,UAChBC,WAAYxsD,KAAKwsD,WACjBvb,iBACAwb,QACAC,SACE3sD,EAAQyW,MAAOzW,EAEnB,CAOA,aAAOmxF,CAAQC,GAEdT,GAAUS,CAEX,EASD,MAAMC,WAAsB1W,GAE3B,eAAWnzE,GAEV,MAAO,eAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,GAOPjmE,KAAKqxF,YAAcv1E,GAAS,GAAIX,SAAUN,IAO1C7a,KAAKsxF,gBAAkBx1E,GAAS,GAAIX,SAAUN,IAO9C7a,KAAK89E,mBAAqBhiE,GAAS,GAAIX,SAAUN,IAOjD7a,KAAK+9E,kBAAoBjiE,GAAS,GAAIX,SAAUN,GAEjD,CAOA,MAAAtQ,CAAQgR,GAEP7R,MAAMa,OAAQgR,GAEd,MAAM,MAAE0qD,GAAUjmE,KAElBA,KAAKqxF,YAAYnuF,MAAQ+B,KAAK0hB,IAAKs/C,EAAMsrB,OACzCvxF,KAAKsxF,gBAAgBpuF,MAAQ+B,KAAK0hB,IAAKs/C,EAAMsrB,OAAU,EAAItrB,EAAMurB,WAEjExxF,KAAK89E,mBAAmB56E,MAAQ+iE,EAAMl+C,SACtC/nB,KAAK+9E,kBAAkB76E,MAAQ+iE,EAAM+X,KAEtC,CAQA,kBAAAyT,CAAoBC,GAEnB,MAAM,YAAEL,EAAW,gBAAEC,GAAoBtxF,KAEzC,OAAOgpB,GAAYqoE,EAAaC,EAAiBI,EAElD,CAEA,KAAAxlF,CAAOnM,GAEN2J,MAAMwC,MAAOnM,GAEb,MAAM+wC,EAAgB/wC,EAAQsC,QAAQyuC,eAEhC,UAAEtkB,EAAS,mBAAEsxD,EAAkB,kBAAEC,EAAiB,MAAE9X,GAAUjmE,KAE9D29E,EAAU3L,GAAmB/L,GAAQ7lD,IAAK0Z,IAE1CqmB,EAAiBw9B,EAAQ36D,YACzB2uE,EAAWxxC,EAAel4B,IAAKiqD,GAAsBjM,IACrD2rB,EAAkB5xF,KAAKyxF,mBAAoBE,GAE3C3W,EAAgB2C,EAAQ35E,SAExB45E,EAAmB7C,GAAwB,CAChDC,gBACAC,eAAgB6C,EAChB5C,cAAe6C,IAGhB,IAAIr9B,EAAal0B,EAAUnM,IAAKuxE,GAAkBvxE,IAAKu9D,GAEvD,GAAK3X,EAAM3uD,IAAM,CAEhB,MAAMu6D,EAAiBF,GAAmB1L,GACpC4rB,EAAmB/9D,GAASmyC,EAAM3uD,IAAKu6D,EAAexoD,IAAK3e,gBAAgB,IAAMu7D,EAAM3uD,MAI7FopC,EAFuBmxB,EAAexxD,IAAK,GAAKD,IAAK,GAAKiD,MAAM3C,SAAU,GAAKmF,MAEnDkF,OAAQ21B,EAAWrgC,IAAKwxE,GAAoBnxC,EAEzE,CAEA,MAAMzP,EAAiBlxC,EAAQsC,QAAQ4uC,eAEvCH,EAAcmO,OAAQ,CACrBkB,iBACAO,aACAzP,kBACElxC,EAAQyW,MAAOzW,EAEnB,EASD,MAAM+xF,WAAyBV,GAE9B,eAAW7pF,GAEV,MAAO,kBAER,CAQA,kBAAAkqF,CAAoBC,GAEnB,MAAMK,EAAS/xF,KAAKimE,MAAM8rB,OAE1B,IAAIH,EAAkB,KAEtB,GAAKG,IAA+B,IAArBA,EAAO5uF,UAAqB,CAE1C,MAAMouF,EAAQG,EAAY5qE,OAAOzG,IAAK,EAAMpb,KAAK+R,IAEjD46E,EAAkB99D,GAASi+D,EAAQ34E,GAAMm4E,EAAO,GAAK,GAAIz0D,CAE1D,MAEC80D,EAAkBloF,MAAM+nF,mBAAoBC,GAI7C,OAAOE,CAER,EASD,MAAMI,WAAyBtX,GAE9B,eAAWnzE,GAEV,MAAO,kBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,EAER,CAEA,KAAA/5D,EAAO,QAAE7J,IAERA,EAAQkvC,WAAWlB,UAAWrwC,KAAKwsB,UAEpC,EASD,MAAMylE,WAA4BvX,GAEjC,eAAWnzE,GAEV,MAAO,qBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,GAOPjmE,KAAKkyF,kBAAoB5lC,GAAe2Z,GAOxCjmE,KAAKmyF,mBAAqBnyF,KAAKkyF,kBAAkBlvE,YAOjDhjB,KAAKoyF,gBAAkBt2E,GAAS,IAAI,OAAUX,SAAUN,GAEzD,CAOA,MAAAtQ,CAAQgR,GAEP,MAAM,MAAE0qD,GAAUjmE,KAElB0J,MAAMa,OAAQgR,GAEdvb,KAAKkyF,kBAAkB35D,SAAW0tC,EAElCjmE,KAAKoyF,gBAAgBlvF,MAAMK,KAAM0iE,EAAMosB,aAAc9/C,eAAgB0zB,EAAMrT,UAE5E,CAEA,KAAA1mD,CAAOnM,GAEN,MAAM,UAAEysB,EAAS,gBAAE4lE,EAAe,mBAAED,GAAuBnyF,KAGrDsyF,EADQ33D,GAAW1S,IAAKkqE,GACE9xE,IAAK,IAAMjM,IAAK,IAE1Cm9B,EAAa7oB,GAAK0pE,EAAiB5lE,EAAW8lE,GAEpDvyF,EAAQsC,QAAQkvC,WAAWlB,UAAWkB,EAEvC,EASD,MAAMghD,WAAuB7X,GAE5B,eAAWnzE,GAEV,MAAO,gBAER,CAOA,WAAAzH,CAAammE,EAAQ,MAEpBv8D,MAAOu8D,GAEP,MAAMzgE,EAAQ,GAEd,IAAM,IAAInB,EAAI,EAAGA,EAAI,EAAGA,IAAOmB,EAAMM,KAAM,IAAI,OAO/C9F,KAAKwyF,WAAaj1D,GAAc/3B,EAEjC,CAOA,MAAA+E,CAAQgR,GAEP,MAAM,MAAE0qD,GAAUjmE,KAElB0J,MAAMa,OAAQgR,GAId,IAAM,IAAIlX,EAAI,EAAGA,EAAI,EAAGA,IAEvBrE,KAAKwyF,WAAWhtF,MAAOnB,GAAId,KAAM0iE,EAAMwsB,GAAGC,aAAcruF,IAAMkuC,eAAgB0zB,EAAMrT,UAItF,CAEA,KAAA1mD,CAAOnM,GAEN,MAAMwxC,EAAa2sC,GAAmBpjD,GAAa96B,KAAKwyF,YAExDzyF,EAAQsC,QAAQkvC,WAAWlB,UAAWkB,EAEvC,EAQD,MAAMohD,GASL,aAAA9iB,GAECpjE,QAAQC,KAAM,qBAEf,EAUD,MAAMkmF,GAUL,WAAA9yF,CAAayH,EAAMsM,EAAQnR,EAAO,GAAI8P,EAAY,IAOjDxS,KAAKuH,KAAOA,EAOZvH,KAAK6T,OAASA,EAQd7T,KAAK0C,KAAOA,EAQZ1C,KAAKwS,UAAYA,CAElB,CASA,OAAAs9D,GAECrjE,QAAQC,KAAM,qBAEf,EAIDkmF,GAAaC,gBAAiB,EAE9B,MAAMC,GAAsB,6EACtBC,GAAqB,eAErBC,GAAa,eAsGnB,MAAMC,WAAyBL,GAO9B,WAAA9yF,CAAaue,GAEZ,MAAM,KAAE9W,EAAI,OAAEsM,EAAM,KAAEnR,EAAI,UAAE8P,EAAS,WAAE0gF,EAAU,UAAEC,EAAS,WAAEC,GA7GhD,CAAE/0E,IAIjB,MAAMg1E,GAFNh1E,EAASA,EAAOi1E,QAEehiF,QAAS0hF,IAElCO,GAAiC,IAAtBF,EAA0Bh1E,EAAOrc,MAAOqxF,EAAkBL,IAAsB30E,EAE3Fm1E,EAAcD,EAASE,MAAOX,IAEpC,GAAqB,OAAhBU,GAA+C,IAAvBA,EAAYxvF,OAAe,CAIvD,MAAMkvF,EAAaM,EAAa,GAC1BE,EAAe,GAErB,IAAIC,EAAY,KAEhB,KAAkE,QAAxDA,EAAYZ,GAAmB/G,KAAMkH,KAE9CQ,EAAa5tF,KAAM6tF,GAMpB,MAAM9/E,EAAS,GAEf,IAAIxP,EAAI,EAER,KAAQA,EAAIqvF,EAAa1vF,QAAS,CAEjC,MAAMqsF,EAAqC,UAA3BqD,EAAcrvF,GAAK,IAElB,IAAZgsF,GAEJhsF,IAID,IAAIg+C,EAAYqxC,EAAcrvF,GAAK,GAEhB,OAAdg+C,GAAoC,QAAdA,GAAqC,UAAdA,EAEjDh+C,IAIAg+C,EAAY,GAIb,MAAM96C,EAAOmsF,EAAcrvF,KAAQ,GAEnC,IAAI3C,EAAQyM,OAAOylF,SAAUF,EAAcrvF,GAAK,KAEjB,IAA1B8J,OAAO0lF,MAAOnyF,GAAoB2C,IAClC3C,EAAQ,KAEb,MAAMgB,EAAOgxF,EAAcrvF,KAAQ,GAEnCwP,EAAO/N,KAAM,IAAIsqF,GAAmB7oF,EAAM7E,EAAMhB,EAAO2gD,EAAWguC,GAEnE,CAIA,MAAM8C,EAAYI,EAASO,UAAWN,EAAa,GAAIxvF,QAEjDtB,OAA4B3B,IAArByyF,EAAa,GAAoBA,EAAa,GAAM,GAOjE,MAAO,CACNjsF,KAPYisF,EAAa,GAQzB3/E,SACAnR,OACA8P,eARsCzR,IAArByyF,EAAa,GAAoBA,EAAa,GAAM,GASrEN,aACAC,YACAC,YATwC,IAAtBC,EAA0Bh1E,EAAOrc,MAAO,EAAGqxF,GAAoB,GAYnF,CAEC,MAAM,IAAIhgF,MAAO,6CAElB,EAkB8E0gF,CAAS11E,GAEtF3U,MAAOnC,EAAMsM,EAAQnR,EAAM8P,GAE3BxS,KAAKkzF,WAAaA,EAClBlzF,KAAKmzF,UAAYA,EACjBnzF,KAAKozF,WAAaA,CAEnB,CAQA,OAAAtjB,CAASptE,EAAO1C,KAAK0C,MAEpB,IAAIk+D,EAEJ,MAAMuyB,EAAYnzF,KAAKmzF,UAEvB,GAAmB,KAAdA,EAAmB,CAEvB,MAAM,KAAE5rF,EAAI,WAAE2rF,EAAU,WAAEE,EAAU,UAAE5gF,GAAcxS,KAEpD,IAAIg0F,EAAkB,GAAIzsF,KAAU7E,OAAYwwF,EAAWI,WAExC,KAAd9gF,IAEJwhF,EAAkB,GAAIxhF,KAAewhF,KAItCpzB,EAAOwyB,EAAaY,EAAkBb,CAEvC,MAICvyB,EAAO,GAIR,OAAOA,CAER,EASD,MAAMqzB,WAAuBtB,GAQ5B,aAAA9iB,CAAexxD,GAEd,OAAO,IAAI40E,GAAkB50E,EAE9B,EAID,MAAM61E,GAAiB,IAAIh0F,QAS3B,MAAMi0F,WAAcj3B,GAQnB,WAAAp9D,CAAagD,EAAUw6D,GAEtB5zD,QAOA1J,KAAK8C,SAAWA,EAOhB9C,KAAKs9D,QAAUA,EAOft9D,KAAKuE,UAAY,IAAI4qF,GAOrBnvF,KAAKo0F,iBAAmB,IAAI1tF,IAO5B1G,KAAKq0F,cAAgB,IAAI97B,GAOzBv4D,KAAKs0F,WAAa,IAAI/7B,GAQtBv4D,KAAKu0F,SAAW,CAAC,CAElB,CAQA,WAAA5wB,CAAa6wB,GAEZ,MAAMv5E,EAAYu5E,EAAkBv5E,UAC9BvY,EAAOuY,EAAUvY,KAIvB,GAAKA,IAASoY,GAAYpY,KAAO,OAAO,EAIxC,GAAKA,IAASmY,GAAYnY,KAAO,CAEhC,MAAM+xF,EAAoBz0F,KAAKc,IAAK0zF,GAC9Bh0F,EAAWR,KAAKuE,UAAU/D,SAEhC,OAAKi0F,EAAkBj0F,WAAaA,IAEnCi0F,EAAkBj0F,SAAWA,GAEtB,EAMT,CAIA,GAAKkC,IAASkY,GAAWlY,KAAO,CAE/B,MAAM+xF,EAAoBz0F,KAAKc,IAAK0zF,GAC9B1nD,EAAU9sC,KAAKuE,UAAUuoC,QAE/B,OAAK2nD,EAAkB3nD,UAAYA,IAElC2nD,EAAkB3nD,QAAUA,GAErB,EAMT,CAIA,MAAM4nD,EAAa,CAAEz5E,EAAWu5E,GAEhC,IAAI3xB,EAAY7iE,KAAKs0F,WAAWxzF,IAAK4zF,GAGrC,YAFmB3zF,IAAd8hE,GAA0B7iE,KAAKs0F,WAAW9xF,IAAKkyF,EAAY7xB,EAAY,CAAC,GAExEA,EAAUthE,UAAY0Z,EAAU1Z,UAEpCshE,EAAUthE,QAAU0Z,EAAU1Z,SAEvB,EAMT,CAQA,oBAAAozF,CAAsBj0F,GAErB,OAAOA,EAAa44D,eAErB,CAQA,YAAAY,CAAcx5D,GAEb,MAAM4C,EAAmBtD,KAAKc,IAAKJ,GAEnC,IAAI4gE,EAAmBh+D,EAAiBg+D,iBAExC,QAA0BvgE,IAArBugE,EAAiC,CAErC,MAAM,iBAAE8yB,GAAqBp0F,KAEvBm5D,EAAWn5D,KAAK20F,qBAAsBj0F,GAI5C,GAFA4gE,EAAmB8yB,EAAiBtzF,IAAKq4D,QAEfp4D,IAArBugE,EAAiC,CAErC,MAAMszB,EAAc50F,KAAKs9D,QAAQu3B,kBAAmBn0F,EAAaJ,OAAQN,KAAK8C,UAC9E8xF,EAAYj3C,MAAQj9C,EAAai9C,MACjCi3C,EAAY3zF,SAAWP,EAAaO,SACpC2zF,EAAYh9D,OAASl3B,EAAak3B,OAClCg9D,EAAYvyF,QAAQpB,SAAWP,EAAaO,SAC5C2zF,EAAYp9C,WAAa92C,EAAa82C,WACtCo9C,EAAYjhC,gBAAkB3zD,KAAK80F,mBAAoBp0F,EAAai9C,OACpEi3C,EAAYp5C,QAAUx7C,KAAK+0F,WAAYr0F,EAAai9C,OACpDi3C,EAAYx/C,gBAAkB10C,EAAa00C,gBAC3Cw/C,EAAYvoF,QAEZi1D,EAAmBthE,KAAKg1F,wBAAyBJ,GAEjDR,EAAiB5xF,IAAK22D,EAAUmI,EAEjC,CAEAA,EAAiBnB,YAEjB78D,EAAiBg+D,iBAAmBA,CAErC,CAEA,OAAOA,CAER,CAQA,OAAQhhE,GAEP,GAAKA,EAAOq5D,eAAiB,CAE5B,MAAM2H,EAAmBthE,KAAKc,IAAKR,GAASghE,iBAC5CA,EAAiBnB,YAEmB,IAA/BmB,EAAiBnB,WAErBngE,KAAKo0F,iBAAiBpkD,OAAQhwC,KAAK20F,qBAAsBr0F,GAI3D,CAEA,OAAOoJ,MAAMsmC,OAAQ1vC,EAEtB,CAQA,aAAA6gE,CAAezwC,GAEd,MAAMukE,EAAcj1F,KAAKc,IAAK4vB,GAE9B,IAAI4wC,EAAmB2zB,EAAY3zB,iBAEnC,QAA0BvgE,IAArBugE,EAAiC,CAErC,MAAMszB,EAAc50F,KAAKs9D,QAAQu3B,kBAAmBnkE,EAAa1wB,KAAK8C,UACtE8xF,EAAYvoF,QAEZi1D,EAAmBthE,KAAKg1F,wBAAyBJ,GAEjDK,EAAY3zB,iBAAmBA,CAEhC,CAEA,OAAOA,CAER,CASA,uBAAA0zB,CAAyBJ,GAExB,OAAO,IAAI7U,GACV6U,EAAY3yB,aACZ2yB,EAAYzyB,eACZyyB,EAAYpzB,cACZozB,EAAYxG,qBACZwG,EAAYx6B,cACZw6B,EAAY5U,YACZ4U,EAAY3U,kBACZ2U,EAAY1U,iBACZ0U,EAAYr7C,QACZq7C,EAAY9zB,WAGd,CASA,kBAAAg0B,CAAoBn3C,GAEnB39C,KAAKk1F,kBAAmBv3C,GAExB,IAAIgW,EAAkB,KAEtB,GAAKhW,EAAMgW,iBAAmBhW,EAAMgW,gBAAgB9wD,OAEnD8wD,EAAkBhW,EAAMgW,oBAElB,CAEN,MAAMgrB,EAAY3+E,KAAKc,IAAK68C,GAEvBghC,EAAUhrB,kBAEdA,EAAkBgrB,EAAUhrB,gBAI9B,CAEA,OAAOA,CAER,CASA,iBAAA4qB,CAAmB5gC,GAElB39C,KAAKm1F,iBAAkBx3C,GAEvB,IAAIg3B,EAAiB,KAErB,GAAKh3B,EAAMg3B,gBAAkBh3B,EAAMg3B,eAAe9xE,OAEjD8xE,EAAiBh3B,EAAMg3B,mBAEjB,CAEN,MAAMgK,EAAY3+E,KAAKc,IAAK68C,GAEvBghC,EAAUhK,iBAEdA,EAAiBgK,EAAUhK,eAI7B,CAEA,OAAOA,CAER,CAQA,UAAAogB,CAAYp3C,GAIX,OAFA39C,KAAKo1F,UAAWz3C,GAETA,EAAMnC,SAAWx7C,KAAKc,IAAK68C,GAAQnC,SAAW,IAEtD,CAYA,WAAAt1C,CAAay3C,EAAOnG,GAEnB,MAAM69C,EAAQ,CAAE13C,EAAOnG,GACjBynB,EAASj/D,KAAK8C,SAAS80D,KAAKuH,MAElC,IAAIm2B,EAAet1F,KAAKq0F,cAAcvzF,IAAKu0F,GAE3C,QAAsBt0F,IAAjBu0F,GAA8BA,EAAar2B,SAAWA,EAAS,CAEnE,MAAMtL,EAAkB3zD,KAAK80F,mBAAoBn3C,GAC3CnC,EAAUx7C,KAAK+0F,WAAYp3C,GAE3B93C,EAAS,GAEV2xC,GAAa3xC,EAAOC,KAAM0xC,EAAWtxC,aAAa,IAClDytD,GAAkB9tD,EAAOC,KAAM6tD,EAAgBztD,eAC/Cs1C,GAAU31C,EAAOC,KAAM01C,EAAQt1C,eAEpCL,EAAOC,KAAM9F,KAAK8C,SAASg1E,UAAUjrD,QAAU,EAAI,GAEnDyoE,EAAe,CACdr2B,SACA9F,SAAU5zD,EAAWM,IAGtB7F,KAAKq0F,cAAc7xF,IAAK6yF,EAAOC,EAEhC,CAEA,OAAOA,EAAan8B,QAErB,CAQA,sBAAIo8B,GAEH,OAAOv1F,KAAK8C,SAASsvC,iBAEtB,CAQA,gBAAA+iD,CAAkBx3C,GAEjB,MAAMghC,EAAY3+E,KAAKc,IAAK68C,GACtBqtB,EAAartB,EAAMqtB,WAEzB,GAAKA,EAAa,CAEjB,MAAMwqB,EAA+C,IAA/B73C,EAAMytB,sBAA8BuT,EAAUvT,qBAAuB,GAASztB,EAAMytB,qBAAuB,GAAwC,IAAnCuT,EAAUvT,qBAEhJ,GAAKuT,EAAU3T,aAAeA,GAAcwqB,EAAc,CAEzD,MAAM7gB,EAAiB30E,KAAKy1F,aAAc,aAAczqB,GAAY,KAEnE,IAAkC,IAA7BA,EAAWrwB,eAA4BqwB,EAAWp8C,UAAY,OAAoCo8C,EAAWp8C,UAAY,OAAoCo8C,EAAWp8C,UAAY,KAA4B,CAEpN,GAAK+uB,EAAMytB,qBAAuB,GAAKJ,EAAWp8C,UAAY,KAE7D,OAAO4jC,GAAcwY,GAEf,CAEN,IAAItwB,EAYJ,OARCA,GAFiC,IAA7BswB,EAAWrwB,cAENze,GAAa8uC,GAIbl3C,GAASk3C,GAIZvsB,GAAa/D,EAErB,CAED,CAAO,IAA8B,IAAzBswB,EAAW7nE,UAEtB,OAAO2wB,GAASk3C,EAAYh4B,GAAS3d,SAAUT,iBAAiB,IAE9B,IAAvBo2C,EAAW5jE,SAEtBqF,QAAQkiB,MAAO,qDAAsDq8C,EAEtE,GAEEwqB,GAEH7W,EAAUhK,eAAiBA,EAC3BgK,EAAU3T,WAAaA,EACvB2T,EAAUvT,qBAAuBztB,EAAMytB,oBAExC,CAED,MAAYuT,EAAUhK,wBAEdgK,EAAUhK,sBACVgK,EAAU3T,WAInB,CAYA,YAAAyqB,CAAcluF,EAAMjH,EAAQgK,EAAUkrF,GAAc,GAEnD,MAAME,EAAY11F,KAAKu0F,SAAUhtF,KAAYvH,KAAKu0F,SAAUhtF,GAAS,IAAIrH,SAEzE,IAAIiG,EAAOuvF,EAAU50F,IAAKR,GAS1B,YAPcS,IAAToF,GAAsBqvF,KAE1BrvF,EAAOmE,IACPorF,EAAUlzF,IAAKlC,EAAQ6F,IAIjBA,CAER,CAQA,SAAAivF,CAAWz3C,GAEV,MAAMghC,EAAY3+E,KAAKc,IAAK68C,GACtBg4C,EAAWh4C,EAAMrG,IAEvB,GAAKq+C,GAEJ,GAAKhX,EAAUrnC,MAAQq+C,EAAW,CAEjC,MAAMn6C,EAAUx7C,KAAKy1F,aAAc,MAAOE,GAAU,KAEnD,GAAKA,EAASC,UAAY,CAEzB,MAAMz8E,EAAQ0U,GAAW,QAAS,QAAS8nE,GAAWx6E,SAAUN,IAC1Ds1D,EAAUtiD,GAAW,UAAW,QAAS8nE,GAAWx6E,SAAUN,IAEpE,OAAOy8B,GAAKn+B,EAAO+2D,GAAkBC,GAEtC,CAAO,GAAKwlB,EAASE,MAAQ,CAE5B,MAAM18E,EAAQ0U,GAAW,QAAS,QAAS8nE,GAAWx6E,SAAUN,IAC1Dgd,EAAOhK,GAAW,OAAQ,QAAS8nE,GAAWx6E,SAAUN,IACxDkd,EAAMlK,GAAW,MAAO,QAAS8nE,GAAWx6E,SAAUN,IAE5D,OAAOy8B,GAAKn+B,EAAO82D,GAAgBp4C,EAAME,GAE1C,CAECtrB,QAAQkiB,MAAO,iDAAkDgnE,EAElE,IAIDhX,EAAUnjC,QAAUA,EACpBmjC,EAAUrnC,IAAMq+C,CAEjB,cAIOhX,EAAUnjC,eACVmjC,EAAUrnC,GAInB,CAQA,iBAAA49C,CAAmBv3C,GAElB,MAAMghC,EAAY3+E,KAAKc,IAAK68C,GACtBgB,EAAchB,EAAMgB,YAE1B,GAAKA,GAEJ,GAAKggC,EAAUhgC,cAAgBA,EAAc,CAE5C,MAAMgV,EAAkB3zD,KAAKy1F,aAAc,cAAe92C,GAAa,KAEnC,IAA9BA,EAAYhE,cAETze,GAAayiB,IAEiB,IAA1BA,EAAYx7C,UAEhB2wB,GAAS6qB,QAIhBlyC,QAAQkiB,MAAO,gDAAiDgwB,KAMlEggC,EAAUhrB,gBAAkBA,EAC5BgrB,EAAUhgC,YAAcA,CAEzB,OAEWggC,EAAUhrB,yBAEdgrB,EAAUhrB,uBACVgrB,EAAUhgC,YAInB,CAEA,YAAAm3C,CAAchzF,EAAW9C,KAAK8C,SAAU66C,EAAQ,KAAMr9C,EAAS,KAAMs3B,EAAS,KAAM32B,EAAW,MAE9F,MAAMsD,EAAYvE,KAAKuE,UAOvB,OANAA,EAAUzB,SAAWA,EACrByB,EAAUo5C,MAAQA,EAClBp5C,EAAUjE,OAASA,EACnBiE,EAAUqzB,OAASA,EACnBrzB,EAAUtD,SAAWA,EAEdsD,CAER,CAEA,qBAAAwxF,CAAuBr1F,GAEtB,OAAOV,KAAK81F,aAAcp1F,EAAaoC,SAAUpC,EAAai9C,MAAOj9C,EAAaJ,OAAQI,EAAak3B,OAAQl3B,EAAaO,SAE7H,CAOA,iBAAA+0F,GAEC,MAAMlzF,EAAW9C,KAAK8C,SAEtB,OAAOA,EAASurB,YAAc,IAAMvrB,EAASmzF,iBAE9C,CASA,eAAAC,CAAiBlQ,GAIhB,OAFiBkO,GAAepzF,IAAKklF,KAEjBhmF,KAAKg2F,mBAE1B,CASA,aAAArgF,CAAeqwE,GAEd,MAAMljF,EAAW9C,KAAK8C,SAChBq2D,EAAWn5D,KAAKg2F,oBAEhBzpF,EAASunB,GAASkyD,EAAchzC,IAAWpgB,aAAc9vB,EAASurB,YAAavrB,EAASmzF,mBAI9F,OAFA/B,GAAe1xF,IAAKwjF,EAAc7sB,GAE3B5sD,CAER,CAQA,YAAAC,CAAc9L,GAEb,MAAMk0F,EAAcl0F,EAAau5D,sBAEjC,IAAM,MAAM9zD,KAAQyuF,EAAY3U,kBAI/BjgF,KAAK+1F,sBAAuBr1F,GAAeovF,iBAAkB3pF,EAI/D,CAQA,WAAAwG,CAAajM,GAEZ,MAAMk0F,EAAcl0F,EAAau5D,sBAEjC,IAAM,MAAM9zD,KAAQyuF,EAAY1U,iBAI/BlgF,KAAK+1F,sBAAuBr1F,GAAeqvF,gBAAiB5pF,EAI9D,CAQA,gBAAA48D,CAAkBryC,GAEjB,MAAMnsB,EAAYvE,KAAK81F,eACjBlB,EAAc50F,KAAKmhE,cAAezwC,GAExC,IAAM,MAAMvqB,KAAQyuF,EAAY5U,YAE/Bz7E,EAAUyrF,WAAY7pF,EAIxB,CAQA,eAAAq4D,CAAiB99D,GAEhB,MAAM6D,EAAYvE,KAAK+1F,sBAAuBr1F,GACxCk0F,EAAcl0F,EAAau5D,sBAEjC,IAAM,MAAM9zD,KAAQyuF,EAAY5U,YAE/Bz7E,EAAUyrF,WAAY7pF,EAIxB,CAQA,YAAA7B,CAAc5D,GAEb,MAAM6D,EAAYvE,KAAK+1F,sBAAuBr1F,GAG9C,OAFgBA,EAAay5D,aAEd71D,aAAc5D,EAAc6D,EAE5C,CAKA,OAAA0G,GAECvB,MAAMuB,UAENjL,KAAKuE,UAAY,IAAI4qF,GACrBnvF,KAAKo0F,iBAAmB,IAAI1tF,IAC5B1G,KAAKu0F,SAAW,CAAC,CAElB,EAID,MAAM4B,GAAuB,IAAI,MAUjC,MAAMC,GAOL,WAAAt2F,CAAau2F,EAAgB,MAQ5Br2F,KAAKuB,QAAU,EAQfvB,KAAKs2F,iBAAmB,KAOxBt2F,KAAKm5D,SAAW,GAQhBn5D,KAAKk3E,YAAa,EAOlBl3E,KAAKu2F,iBAAmB,IAAI,MAO5Bv2F,KAAKw2F,sBAAwB,IAAIt2F,QAOjCF,KAAKq1C,mBAAqB,GAO1Br1C,KAAKs1C,YAAc,GAQnBt1C,KAAKy2F,cAAgB,KAEE,OAAlBJ,IAEJr2F,KAAKu2F,iBAAmBF,EAAcE,iBACtCv2F,KAAKw2F,sBAAwBH,EAAcG,sBAE3Cx2F,KAAKk3E,WAAamf,EAAcnf,WAChCl3E,KAAK+nD,WAAasuC,EAActuC,WAIlC,CAUA,aAAA2uC,CAAer4E,EAAQs4E,EAAa7mE,GAEnC,MAAMsd,EAAI/uB,EAAOra,OAEjB,IAAM,IAAIK,EAAI,EAAGA,EAAI+oC,EAAG/oC,IAAO,CAE9B8xF,GAAO5yF,KAAM8a,EAAQha,IAAM40B,aAAcj5B,KAAK+nD,WAAY/nD,KAAKu2F,kBAE/D,MAAMl+E,EAAIs+E,EAAa7mE,EAASzrB,GAC1Bg3B,EAAS86D,GAAO96D,OAEtBhjB,EAAEuR,GAAMyR,EAAOzR,EACfvR,EAAEyR,GAAMuR,EAAOvR,EACfzR,EAAE4kB,GAAM5B,EAAO4B,EACf5kB,EAAE6kB,EAAIi5D,GAAOS,QAEd,CAED,CAQA,YAAAC,CAAcl5C,EAAO/lB,GAEpB53B,KAAKk3E,WAA0C,OAA3Bv5B,EAAMi3B,kBAA6Bj3B,EAAMi3B,iBAAiBpd,qBAC9Ex3D,KAAK+nD,WAAanwB,EAAOO,mBAEzBn4B,KAAKu2F,iBAAiBj9D,gBAAiBt5B,KAAK+nD,WAE7C,CAQA,MAAAx9C,CAAQ8rF,EAAeS,GAEtB,IAAIvsF,GAAS,EAER8rF,EAAc90F,UAAYvB,KAAKy2F,gBAEnCz2F,KAAKq1C,mBAAqBtwC,MAAMoD,KAAMkuF,EAAchhD,oBACpDr1C,KAAKs1C,YAAcvwC,MAAMoD,KAAMkuF,EAAc/gD,aAC7Ct1C,KAAKy2F,cAAgBJ,EAAc90F,SAI/BvB,KAAKs2F,mBAAqBQ,EAAcR,mBAE5Ct2F,KAAKs2F,iBAAmBQ,EAAcR,iBAEjCt2F,KAAKs2F,iBAETt2F,KAAKs1C,YAAYtxC,OAASqyF,EAAc/gD,YAAYtxC,OAIpDhE,KAAKq1C,mBAAmBrxC,OAASqyF,EAAchhD,mBAAmBrxC,QAMpE,MAAM+yF,EAAoBD,EAAc7gD,eAClC7I,EAAI2pD,EAAkB/yF,OAE5B,IAAIgzF,EACAlnE,EAcJ,GAZK9vB,KAAKs2F,kBAETU,EAAoBh3F,KAAKq1C,mBACzBvlB,EAASumE,EAAchhD,mBAAmBrxC,SAI1CgzF,EAAoBh3F,KAAKs1C,YACzBxlB,EAASumE,EAAc/gD,YAAYtxC,QAI/BgzF,EAAkBhzF,SAAW8rB,EAASsd,EAAI,CAE9C4pD,EAAkBhzF,OAAS8rB,EAASsd,EAEpC,IAAM,IAAI/oC,EAAI,EAAGA,EAAI+oC,EAAG/oC,IAEvB2yF,EAAmBlnE,EAASzrB,GAAM,IAAI,MAIvCkG,GAAS,CAEV,CAEAvK,KAAK02F,cAAeK,EAAmBC,EAAmBlnE,GAErDvlB,IAEJvK,KAAKuB,UACLvB,KAAKm5D,SAAW,GAAIn5D,KAAKq1C,mBAAmBrxC,UAAYhE,KAAKs1C,YAAYtxC,SAI3E,CAQA,eAAAizF,CAAiBH,GAEhB,GAAK92F,KAAKk3E,aAAgB4f,EAAcI,YAAc,OAAOl3F,KAE7D,IAAIqC,EAAUrC,KAAKw2F,sBAAsB11F,IAAKg2F,GAW9C,YATiB/1F,IAAZsB,IAEJA,EAAU,IAAI+zF,GAAiBp2F,MAC/BA,KAAKw2F,sBAAsBh0F,IAAKs0F,EAAez0F,IAIhDA,EAAQkI,OAAQvK,KAAM82F,GAEfz0F,CAER,CAQA,sBAAI23D,GAEH,OAAOh6D,KAAKs1C,YAAYtxC,MAEzB,EAUD,MAAMmzF,GAQL,WAAAr3F,CAAas3F,EAAax/D,GAEzB53B,KAAKo3F,YAAcA,EACnBp3F,KAAK43B,OAASA,CAEf,EASD,MAAMy/D,GAKL,WAAAv3F,GAOCE,KAAKslE,QAAU,IAAI/M,EAEpB,CASA,GAAAz3D,CAAKs2F,EAAax/D,GAEjB,MAAM0tC,EAAUtlE,KAAKslE,QACfxhE,EAAO,CAAEszF,EAAax/D,GAE5B,IAAI31B,EAASqjE,EAAQxkE,IAAKgD,GAS1B,YAPgB/C,IAAXkB,IAEJA,EAAS,IAAIk1F,GAAcC,EAAax/D,GACxC0tC,EAAQ9iE,IAAKsB,EAAM7B,IAIbA,CAER,CAKA,OAAAgJ,GAECjL,KAAKslE,QAAU,IAAI/M,EAEpB,EAYD,MAAM++B,GAKL,WAAAx3F,GAOCE,KAAKoyE,WAAa,IAAIlyE,QAOtBF,KAAKu3F,cAAgB,IAAI7wF,IAQzB1G,KAAKw3F,iBAAmB,IAAI9wF,GAE7B,CAYA,YAAAioF,CAAc1tF,GAEb,GAAKA,EAASo2C,eAAiB,OAAOp2C,EAEtC,IAAI+9E,EAAe,KAEnB,MAAMyY,EAAoBz3F,KAAK03F,qBAAsBz2F,EAASsG,MAE9D,GAA2B,OAAtBkwF,EAA6B,CAEjCzY,EAAe,IAAIyY,EAEnB,IAAM,MAAM3oF,KAAO7N,EAElB+9E,EAAclwE,GAAQ7N,EAAU6N,EAIlC,CAEA,OAAOkwE,CAER,CAQA,cAAA2Y,CAAgBC,EAAiBvpE,GAEhCruB,KAAK63F,QAASD,EAAiBvpE,EAAaruB,KAAKw3F,iBAElD,CAQA,sBAAA9oE,CAAwBL,GAEvB,OAAOruB,KAAKw3F,iBAAiB12F,IAAKutB,IAAiB,IAEpD,CAQA,oBAAAqpE,CAAsBI,GAErB,OAAO93F,KAAKu3F,cAAcz2F,IAAKg3F,IAAkB,IAElD,CAQA,WAAAC,CAAaC,EAAmBC,GAE/Bj4F,KAAK63F,QAASG,EAAmBC,EAAmBj4F,KAAKu3F,cAE1D,CAQA,iBAAAnkB,CAAmBnN,GAElB,OAAOjmE,KAAKoyE,WAAWtxE,IAAKmlE,IAAW,IAExC,CAQA,QAAAiyB,CAAU/kB,EAAgBglB,GAEzBn4F,KAAKo4F,SAAUjlB,EAAgBglB,EAAYn4F,KAAKoyE,WAEjD,CASA,OAAAylB,CAASQ,EAAW9wF,EAAMknB,GAEzB,GAAKA,EAAQ9tB,IAAK4G,GAEjBkF,QAAQC,KAAM,wBAAyBnF,SAFxC,CAOA,GAA0B,mBAAd8wF,EAA2B,MAAM,IAAIhlF,MAAO,cAAeglF,EAAU31F,wBACjF,GAAqB,mBAAT6E,GAAuC,iBAATA,EAAoB,MAAM,IAAI8L,MAAO,cAAe9L,qBAE9FknB,EAAQjsB,IAAK+E,EAAM8wF,EALnB,CAOD,CASA,QAAAD,CAAUC,EAAWC,EAAW7pE,GAE/B,GAAKA,EAAQ9tB,IAAK23F,GAEjB7rF,QAAQC,KAAM,wBAAyB4rF,EAAU51F,YAFlD,CAOA,GAA0B,mBAAd21F,EAA2B,MAAM,IAAIhlF,MAAO,cAAeglF,EAAU31F,wBACjF,GAA0B,mBAAd41F,EAA2B,MAAM,IAAIjlF,MAAO,cAAeilF,EAAU51F,wBAEjF+rB,EAAQjsB,IAAK81F,EAAWD,EALxB,CAOD,EAID,MAAME,GAA+B,IAAI/lB,GAYzC,MAAMgmB,WAAiBjgC,GAKtB,WAAAz4D,GAEC4J,OAED,CAQA,UAAA0xC,CAAY7D,EAAS,IAEpB,OAAO,IAAIi7B,IAAapM,UAAW7uB,EAEpC,CASA,OAAAguB,CAAS5nB,EAAO/lB,GAIf,GAAK+lB,EAAM6sB,WAAa,OAAO+tB,GAI/B,MAAMz0F,EAAO,CAAE65C,EAAO/lB,GAEtB,IAAIzxB,EAAOnG,KAAKc,IAAKgD,GASrB,YAPc/C,IAAToF,IAEJA,EAAOnG,KAAKo7C,aACZp7C,KAAKwC,IAAKsB,EAAMqC,IAIVA,CAER,EAMD,MAAMsyF,GAAuB,IAAI,MAC3BC,GAAmC,IAAI,MACvCC,GAAwB,IAAI,MAC5BC,GAAyB,IAAI,MAC7BC,GAAkC,IAAI,MACtCC,GAAyB,IAAI,MAKnC,MAAMC,GAgBL,WAAAj5F,CAAaw9D,EAAS7+C,EAAa,CAAC,GASnCze,KAAKg5F,YAAa,EAIlB,MAAM,uBACLr/C,GAAyB,EAAK,MAC9B3C,GAAQ,EAAI,MACZ1f,GAAQ,EAAI,QACZyvC,GAAU,EAAK,UACfkyB,GAAY,EAAK,QACjBz/C,EAAU,EAAC,YACX0/C,EAAc,MACXz6E,EASJze,KAAKm5F,WAAa77B,EAAQ87B,gBAO1Bp5F,KAAKs9D,QAAUA,EAQft9D,KAAKw5C,QAAUA,IAA2B,IAAdy/C,EAAuB,EAAI,EAUvDj5F,KAAKk0E,WAAY,EASjBl0E,KAAKy/E,gBAAiB,EAStBz/E,KAAK0/E,gBAAiB,EAStB1/E,KAAK2/E,kBAAmB,EAQxB3/E,KAAKg3C,MAAQA,EAQbh3C,KAAK25C,uBAAyBA,EAQ9B35C,KAAK4sB,iBAAmB,MAQxB5sB,KAAKquB,YAAc,MAQnBruB,KAAKuuB,oBAAsB,EAa3BvuB,KAAKq5F,aAAc,EAQnBr5F,KAAKs3B,MAAQA,EAQbt3B,KAAK+mE,QAAUA,EAQf/mE,KAAK43D,KAAO,IAAIwH,GAEhBp/D,KAAK+C,MAAQ,CACZC,gBAAiB,KACjBC,sBAAuB,MAYxBjD,KAAKyuB,QAAU,IAAI6oE,GAOnBt3F,KAAKm7C,SAAW,IAAIq9C,GAUpBx4F,KAAKs5F,aAAeJ,EASpBl5F,KAAK8rE,YAAc,EAQnB9rE,KAAK2xD,OAAS3xD,KAAKm5F,WAAWh3F,MAQ9BnC,KAAK4xD,QAAU5xD,KAAKm5F,WAAW/2F,OAQ/BpC,KAAK48E,UAAY,IAAI,MAAS,EAAG,EAAG58E,KAAK2xD,OAAQ3xD,KAAK4xD,SAQtD5xD,KAAKu5F,SAAW,IAAI,MAAS,EAAG,EAAGv5F,KAAK2xD,OAAQ3xD,KAAK4xD,SAQrD5xD,KAAKw5F,cAAe,EASpBx5F,KAAKy5F,YAAc,KASnBz5F,KAAK84D,YAAc,KASnB94D,KAAK64D,OAAS,KASd74D,KAAK05F,WAAa,KASlB15F,KAAKw5D,UAAY,KASjBx5D,KAAK25F,SAAW,KAShB35F,KAAK45F,WAAa,KASlB55F,KAAK65F,SAAW,KAShB75F,KAAK85F,aAAe,KASpB95F,KAAK+5F,gBAAkB,KASvB/5F,KAAK+rE,UAAY,KASjB/rE,KAAKg6F,YAAc,KASnBh6F,KAAKi6F,MAAQ,IAAI1vB,GAAU,IAAInzB,IAC/Bp3C,KAAKi6F,MAAMh5F,SAASyB,KAAO,kBAS3B1C,KAAKk6F,sBAAwB,KAS7Bl6F,KAAKm6F,YAAc,KASnBn6F,KAAKo6F,iBAAmB,KASxBp6F,KAAKq6F,mBAAqB,KAE1B,MAAMC,GAA4B,IAAft6F,KAAKg3C,MAAiB,EAAI,EAQ7Ch3C,KAAKy+E,YAAc,IAAIjV,GAAQ,EAAG,EAAG,EAAG8wB,GASxCt6F,KAAKs/E,YAAc,EASnBt/E,KAAKw/E,cAAgB,EASrBx/E,KAAKu6F,cAAgB,KASrBv6F,KAAKw6F,gBAAkB,EASvBx6F,KAAKy6F,mBAAqB,EAS1Bz6F,KAAKusE,KAAO,KAUZvsE,KAAK06F,sBAAwB,KAS7B16F,KAAK26F,6BAA+B,KASpC36F,KAAK46F,qBAAuB,KAc5B56F,KAAK66F,sBAAwB76F,KAAK86F,oBAWlC96F,KAAK+6F,eAAgB,EAOrB/6F,KAAKg7F,aAAeh7F,KAAKi7F,cASzBj7F,KAAKk7F,cAAe,EASpBl7F,KAAKm7F,aAAe,KASpBn7F,KAAKo7F,qBAAuB,KAQ5Bp7F,KAAKs6C,aAAc,EAQnBt6C,KAAKolE,QAAS,EAcdplE,KAAK83E,UAAY,CAChBjrD,SAAS,EACTtlB,KAAM,OAcPvH,KAAKq7F,GAAK,CACTxuE,SAAS,GAgBV7sB,KAAKs7F,MAAQ,CACZC,mBAAmB,EACnBC,cAAe,KACfC,eAAgBC,MAAQ/9C,EAAO/lB,EAAQt3B,WAEhCN,KAAK27F,aAAch+C,EAAO/lB,GAEhC,MAAM0mD,EAAat+E,KAAK85F,aAAah5F,IAAK68C,EAAO/lB,GAC3CghC,EAAgB54D,KAAK+5F,gBAAgBj5F,IAAK68C,EAAO/lB,EAAQ53B,KAAKu6F,eAE9Dt5F,EAAW08C,EAAMi3B,kBAAoBt0E,EAAOW,SAE5CP,EAAeV,KAAK25F,SAAS74F,IAAKR,EAAQW,EAAU08C,EAAO/lB,EAAQ0mD,EAAW9mC,WAAYohB,EAAeA,EAAcxjB,kBAEvH,eAAE+sB,EAAc,aAAEF,GAAiBvhE,EAAau5D,sBAEtD,MAAO,CAAEkI,iBAAgBF,eAAc,EAK1C,CAQA,UAAMijB,GAEL,GAAKllF,KAAKk7F,aAET,MAAM,IAAI7nF,MAAO,mDAIlB,OAA2B,OAAtBrT,KAAKm7F,eAMVn7F,KAAKm7F,aAAe,IAAIS,SAASF,MAAQG,EAASC,KAEjD,IAAIx+B,EAAUt9D,KAAKs9D,QAEnB,UAEOA,EAAQ4nB,KAAMllF,KAErB,CAAE,MAAQ2uB,GAET,GAA2B,OAAtB3uB,KAAKs5F,aAmBT,YADAwC,EAAQntE,GAdR,IAEC3uB,KAAKs9D,QAAUA,EAAUt9D,KAAKs5F,aAAc3qE,SACtC2uC,EAAQ4nB,KAAMllF,KAErB,CAAE,MAAQ2uB,GAGT,YADAmtE,EAAQntE,EAGT,CASF,CAEA3uB,KAAK64D,OAAS,IAAIs7B,GAAOn0F,KAAMs9D,GAC/Bt9D,KAAK05F,WAAa,IAAI/hC,GAAW33D,KAAK64D,OAAQ74D,KAAK43D,MACnD53D,KAAKy5F,YAAc,IAAIp8B,GAAYC,GACnCt9D,KAAKg6F,YAAc,IAAI3b,GAAYr+E,KAAMA,KAAK64D,QAC9C74D,KAAK84D,YAAc,IAAIuF,GAAYr+D,KAAKy5F,YAAaz5F,KAAK43D,MAC1D53D,KAAK+rE,UAAY,IAAIhE,GAAU/nE,KAAMs9D,EAASt9D,KAAK43D,MACnD53D,KAAK45F,WAAa,IAAI74B,GAAWzD,EAASt9D,KAAK64D,QAC/C74D,KAAKw5D,UAAY,IAAImJ,GAAUrF,EAASt9D,KAAK64D,OAAQ74D,KAAK+rE,UAAW/rE,KAAKy5F,YAAaz5F,KAAK45F,WAAY55F,KAAK43D,MAC7G53D,KAAK25F,SAAW,IAAIj9B,GAAe18D,KAAMA,KAAK64D,OAAQ74D,KAAK84D,YAAa94D,KAAK45F,WAAY55F,KAAKw5D,UAAWx5D,KAAK43D,MAC9G53D,KAAK85F,aAAe,IAAIxzB,GAAatmE,KAAKm7C,UAC1Cn7C,KAAK65F,SAAW,IAAIxC,GACpBr3F,KAAK+5F,gBAAkB,IAAItyB,GAI3BznE,KAAK05F,WAAWj4F,QAChBzB,KAAKk7F,cAAe,EAEpBW,GAAS,KAzDF77F,KAAKm7F,YA+Dd,CAUA,oBAAIz4E,GAEH,OAAO1iB,KAAKs9D,QAAQ56C,gBAErB,CAiBA,kBAAMi5E,CAAch+C,EAAO/lB,EAAQmkE,EAAc,MAEhD,IAA4B,IAAvB/7F,KAAK+6F,cAAyB,QAER,IAAtB/6F,KAAKk7F,oBAA+Bl7F,KAAKklF,OAI9C,MAAM3gF,EAAYvE,KAAK64D,OAAOt0D,UAExBy3F,EAAmBz3F,EAAU/D,SAC7By7F,EAAwBj8F,KAAKk6F,sBAC7BgC,EAA+Bl8F,KAAK26F,6BACpCwB,EAA8Bn8F,KAAKo7F,qBAInCgB,GAA+B,IAAlBz+C,EAAM0+C,QAAqB1+C,EAAQ86C,GAEjC,OAAhBsD,IAAuBA,EAAcp+C,GAE1C,MAAMxL,EAAenyC,KAAKu6F,cACpB3hC,EAAgB54D,KAAK+5F,gBAAgBj5F,IAAKi7F,EAAankE,EAAQua,GAC/D81B,EAAoBjoE,KAAKy6F,mBAEzB6B,EAAsB,GAE5Bt8F,KAAKk6F,sBAAwBthC,EAC7B54D,KAAK26F,6BAA+B36F,KAAKU,aAEzCV,KAAK66F,sBAAwB76F,KAAKu8F,sBAElCv8F,KAAKo7F,qBAAuBkB,EAE5B/3F,EAAU/D,WAIV+D,EAAUgG,SAIVquD,EAActhC,MAAQt3B,KAAKs3B,MAC3BshC,EAAcmO,QAAU/mE,KAAK+mE,QAEtBnO,EAAcxjB,kBAAkBwjB,EAAcxjB,gBAAkB,IAAIghD,IAC3Ex9B,EAAcxjB,gBAAgByhD,aAAcuF,EAAUxkE,GAItDwkE,EAASld,eAAgBl/E,KAAM29C,EAAO/lB,EAAQua,GAI9C,MAAMmsC,EAAat+E,KAAK85F,aAAah5F,IAAK68C,EAAO/lB,GAwBjD,GAvBA0mD,EAAW5Y,QAEX1lE,KAAKw8F,eAAgB7+C,EAAO/lB,EAAQ,EAAG0mD,EAAY1lB,EAAcxjB,iBAG5D2mD,IAAgBp+C,GAEpBo+C,EAAYU,iBAAiB,SAAWn8F,GAElCA,EAAOo8F,SAAWp8F,EAAO65E,OAAO7lE,KAAMsjB,EAAOuiD,SAEjDmE,EAAWtY,UAAW1lE,EAIxB,IAIDg+E,EAAWt/B,SAIW,OAAjB7M,EAAwB,CAE5BnyC,KAAK+rE,UAAU/D,mBAAoB71B,EAAc81B,GAEjD,MAAMC,EAAmBloE,KAAK+rE,UAAUjrE,IAAKqxC,GAE7CymB,EAAclqD,SAAWw5D,EAAiBx5D,SAC1CkqD,EAAcyO,aAAea,EAAiBb,YAE/C,MAECzO,EAAclqD,SAAW,KACzBkqD,EAAcyO,aAAe,KAM9BrnE,KAAKg6F,YAAYzvF,OAAQ6xF,EAAU9d,EAAY1lB,GAI/C,MAAM+jC,EAAgBre,EAAWlZ,OAC3Bw3B,EAAqBte,EAAWhkC,YAChCuiD,EAA+Bve,EAAWjZ,sBAC1C7tB,EAAa8mC,EAAW9mC,YAET,IAAhBx3C,KAAKolE,QAAmBu3B,EAAc34F,OAAS,GAAIhE,KAAK88F,eAAgBH,EAAe/kE,EAAQwkE,EAAU5kD,IACpF,IAArBx3C,KAAKs6C,aAAwBsiD,EAAmB54F,OAAS,GAAIhE,KAAK+8F,oBAAqBH,EAAoBC,EAA8BjlE,EAAQwkE,EAAU5kD,GAIhKjzC,EAAU/D,SAAWw7F,EAErBh8F,KAAKk6F,sBAAwB+B,EAC7Bj8F,KAAK26F,6BAA+BuB,EACpCl8F,KAAKo7F,qBAAuBe,EAE5Bn8F,KAAK66F,sBAAwB76F,KAAK86F,0BAI5Bc,QAAQ/1E,IAAKy2E,EAEpB,CAUA,iBAAM7xB,CAAa9sB,EAAO/lB,IAEE,IAAtB53B,KAAKk7F,oBAA+Bl7F,KAAKklF,OAE9C,MAAMtsB,EAAgB54D,KAAKg9F,aAAcr/C,EAAO/lB,SAE1C53B,KAAKs9D,QAAQ2/B,sBAAuBrkC,EAAe,SAE1D,CASA,gBAAMskC,SAECl9F,KAAKs9D,QAAQ4/B,YAEpB,CAQA,MAAAr/C,CAAQpR,GAIP,OAFAzsC,KAAKusE,KAAO9/B,EAELzsC,IAER,CAOA,MAAA0sC,GAEC,OAAO1sC,KAAKusE,IAEb,CAQA,aAAA0uB,CAAerjC,GAEd,IAAIulC,EAAe,yBAAyBvlC,EAAKwlC,gCAAgCxlC,EAAKylC,UAEjFzlC,EAAK0lC,SAETH,GAAgB,aAAavlC,EAAK0lC,UAInC7wF,QAAQkiB,MAAOwuE,GAEfn9F,KAAK+6F,eAAgB,CAEtB,CAUA,aAAAwC,CAAet7F,EAAQm6F,EAAU5kD,GAEhC,MAAM,YAAE4/C,EAAW,OAAEx/D,EAAM,WAAE0mD,GAAer8E,EAEtC22D,EAAgB54D,KAAKk6F,sBAIrBsD,EAAex9F,KAAK65F,SAAS/4F,IAAKs2F,EAAax/D,GAC/C6lE,EAAmBz9F,KAAKs9D,QAAQx8D,IAAK08F,QAEFz8F,IAApC08F,EAAiBC,iBAA+BD,EAAiBC,eAAiB,IAAI9iC,KAI3F,MAAMxwD,EAAcgtF,EAAY71F,UAAYk8F,EAAiBl8F,QACvDo8F,GAAmF,IAAzDF,EAAiBC,eAAe/8F,IAAKi4D,IAA6BxuD,EAIlG,GAFAqzF,EAAiBC,eAAetpF,IAAKwkD,GAEhC+kC,EAA0B,CAE9B39F,KAAKs9D,QAAQsgC,YAAahlC,SAEc73D,IAAnC08F,EAAiBx9F,eAA+BmK,KAEpDqzF,EAAiBx9F,cAAgB,IAIlCD,KAAK46F,qBAAuB4C,EAE5B,MAAMb,EAAgBre,EAAWlZ,QAEZ,IAAhBplE,KAAKolE,QAAmBu3B,EAAc34F,OAAS,GAAIhE,KAAK88F,eAAgBH,EAAe/kE,EAAQwkE,EAAU5kD,GAE9Gx3C,KAAK46F,qBAAuB,KAI5B56F,KAAKs9D,QAAQugC,aAAcjlC,EAAe4kC,GAE1CC,EAAiBl8F,QAAU61F,EAAY71F,OAExC,KAAO,CAEN,MAAM,cAAEtB,GAAkBw9F,EAE1B,IAAM,IAAIp5F,EAAI,EAAG+oC,EAAIntC,EAAc+D,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAExD,MAAM3D,EAAeT,EAAeoE,GAE/BrE,KAAK64D,OAAOv0D,aAAc5D,KAE9BV,KAAK64D,OAAOrsD,aAAc9L,GAE1BV,KAAK64D,OAAO2F,gBAAiB99D,GAC7BV,KAAKw5D,UAAUgF,gBAAiB99D,GAEhCV,KAAK64D,OAAOlsD,YAAajM,GAI3B,CAED,CAEAV,KAAKs9D,QAAQwgC,UAAWllC,EAAe4kC,EAExC,CAcA,MAAAt+B,CAAQvhB,EAAO/lB,GAEd,IAA2B,IAAtB53B,KAAKk7F,aAIT,OAFAzuF,QAAQC,KAAM,yGAEP1M,KAAKyqE,YAAa9sB,EAAO/lB,GAIjC53B,KAAKg9F,aAAcr/C,EAAO/lB,EAE3B,CAUA,qBAAAmmE,GAEC,MAAM,mBAAEC,EAAkB,kBAAE/H,GAAsBj2F,KAE5Ci+F,EAAiBD,IAAuB,MACxCE,EAAgBjI,IAAsB,MAE5C,IAAwB,IAAnBgI,IAA8C,IAAlBC,EAA0B,OAAO,KAElE,MAAM,MAAE/7F,EAAK,OAAEC,GAAWpC,KAAKyyC,qBAAsBimD,KAC/C,MAAEphE,EAAK,QAAEyvC,GAAY/mE,KAE3B,IAAIm+F,EAAoBn+F,KAAKq6F,mBA+B7B,OA7B2B,OAAtB8D,IAEJA,EAAoB,IAAI,MAAch8F,EAAOC,EAAQ,CACpDy2C,YAAavhB,EACbswC,cAAeb,EACfx/D,KAAM,MACNoG,OAAQ,MACR+e,WAAY,MACZ4mB,iBAAiB,EACjBD,UAAW,MACXqK,UAAW,MACXlE,QAASx5C,KAAKw5C,UAGf2kD,EAAkBC,8BAA+B,EAEjDp+F,KAAKq6F,mBAAqB8D,GAI3BA,EAAkBtlD,YAAcvhB,EAChC6mE,EAAkBv2B,cAAgBb,EAClCo3B,EAAkBjxB,QAAS/qE,EAAOC,GAClC+7F,EAAkB9rD,SAAS9uC,KAAMvD,KAAK48E,WACtCuhB,EAAkBh3B,QAAQ5jE,KAAMvD,KAAKu5F,UACrC4E,EAAkB9rD,SAASE,eAAgBvyC,KAAK8rE,aAChDqyB,EAAkBh3B,QAAQ50B,eAAgBvyC,KAAK8rE,aAC/CqyB,EAAkBhqB,YAAcn0E,KAAKw5F,aAE9B2E,CAER,CAWA,YAAAnB,CAAcr/C,EAAO/lB,EAAQymE,GAAuB,GAEnD,IAA4B,IAAvBr+F,KAAK+6F,cAAyB,OAEnC,MAAMoD,EAAoBE,EAAuBr+F,KAAK+9F,wBAA0B,KAI1Ex5F,EAAYvE,KAAK64D,OAAOt0D,UAExBy3F,EAAmBz3F,EAAU/D,SAC7By7F,EAAwBj8F,KAAKk6F,sBAC7BgC,EAA+Bl8F,KAAK26F,6BAIpCyB,GAA+B,IAAlBz+C,EAAM0+C,QAAqB1+C,EAAQ86C,GAEhD6F,EAAqBt+F,KAAKu6F,cAE1BjzB,EAAiBtnE,KAAKw6F,gBACtBvyB,EAAoBjoE,KAAKy6F,mBAI/B,IAAItoD,EAEuB,OAAtBgsD,GAEJhsD,EAAegsD,EAEfn+F,KAAKotE,gBAAiBj7B,IAItBA,EAAemsD,EAMhB,MAAM1lC,EAAgB54D,KAAK+5F,gBAAgBj5F,IAAK68C,EAAO/lB,EAAQua,GAE/DnyC,KAAKk6F,sBAAwBthC,EAC7B54D,KAAK26F,6BAA+B36F,KAAK06F,uBAAyB16F,KAAKU,aAIvEV,KAAK43D,KAAKuH,QACVn/D,KAAK43D,KAAKsH,OAAOC,QACjBn/D,KAAK43D,KAAKsH,OAAOG,aAEjB96D,EAAU/D,SAAWR,KAAK43D,KAAKuH,MAI/B,MAAMz8C,EAAmB1iB,KAAK0iB,iBAEzBkV,EAAOlV,mBAAqBA,IAEhCkV,EAAOlV,iBAAmBA,EAE1BkV,EAAOuhD,2BAM6B,IAAhCx7B,EAAM4gD,uBAAiC5gD,EAAM6gD,oBAE3B,OAAlB5mE,EAAOxG,SAAoD,IAAjCwG,EAAO2mE,uBAAiC3mE,EAAO4mE,oBAI9E,IAAInsD,EAAWryC,KAAK48E,UAChBzV,EAAUnnE,KAAKu5F,SACf/rB,EAAaxtE,KAAK8rE,YAEA,OAAjB35B,IAEJE,EAAWF,EAAaE,SACxB80B,EAAUh1B,EAAag1B,QACvBqG,EAAa,GAIdxtE,KAAKyyC,qBAAsBimD,IAE3BC,GAAQn2F,IAAK,EAAG,EAAGk2F,GAAmBv2F,MAAOu2F,GAAmBt2F,QAEhE,MAAMq8F,OAAmC19F,IAAtBsxC,EAASosD,SAA2B,EAAIpsD,EAASosD,SAC9DC,OAAmC39F,IAAtBsxC,EAASqsD,SAA2B,EAAIrsD,EAASqsD,SAEpE9lC,EAAcsO,cAAc3jE,KAAM8uC,GAAWE,eAAgBi7B,GAAajnD,QAC1EqyC,EAAcsO,cAAc/kE,QAAU8lE,EACtCrP,EAAcsO,cAAc9kE,SAAW6lE,EACvCrP,EAAcsO,cAAcu3B,SAAWA,EACvC7lC,EAAcsO,cAAcw3B,SAAWA,EACvC9lC,EAAcvmB,UAA6D,IAAlDumB,EAAcsO,cAAc7jE,OAAQs1F,IAE7D//B,EAAcwO,aAAa7jE,KAAM4jE,GAAU50B,eAAgBi7B,GAAajnD,QACxEqyC,EAAcuO,QAAUnnE,KAAKw5F,eAAiE,IAAjD5gC,EAAcwO,aAAa/jE,OAAQs1F,IAChF//B,EAAcwO,aAAajlE,QAAU8lE,EACrCrP,EAAcwO,aAAahlE,SAAW6lE,EAE/BrP,EAAcxjB,kBAAkBwjB,EAAcxjB,gBAAkB,IAAIghD,IAC3Ex9B,EAAcxjB,gBAAgByhD,aAAcuF,EAAUxkE,GAItDwkE,EAASld,eAAgBl/E,KAAM29C,EAAO/lB,EAAQua,GAI9C0mD,GAAkB8F,iBAAkB/mE,EAAOK,iBAAkBL,EAAOO,oBACpEygE,GAASgG,wBAAyB/F,GAAmBn2E,GAErD,MAAM47D,EAAat+E,KAAK85F,aAAah5F,IAAK68C,EAAO/lB,GAejD,GAdA0mD,EAAW5Y,QAEX1lE,KAAKw8F,eAAgB7+C,EAAO/lB,EAAQ,EAAG0mD,EAAY1lB,EAAcxjB,iBAEjEkpC,EAAWt/B,UAEe,IAArBh/C,KAAKq5F,aAET/a,EAAW5qE,KAAM1T,KAAKm6F,YAAan6F,KAAKo6F,kBAMnB,OAAjBjoD,EAAwB,CAE5BnyC,KAAK+rE,UAAU/D,mBAAoB71B,EAAc81B,GAEjD,MAAMC,EAAmBloE,KAAK+rE,UAAUjrE,IAAKqxC,GAE7CymB,EAAclqD,SAAWw5D,EAAiBx5D,SAC1CkqD,EAAcyO,aAAea,EAAiBb,aAC9CzO,EAAcz2D,MAAQ+lE,EAAiB/lE,MACvCy2D,EAAcx2D,OAAS8lE,EAAiB9lE,OACxCw2D,EAAczmB,aAAeA,EAC7BymB,EAActhC,MAAQ6a,EAAa0G,YACnC+f,EAAcmO,QAAU50B,EAAay1B,aAEtC,MAEChP,EAAclqD,SAAW,KACzBkqD,EAAcyO,aAAe,KAC7BzO,EAAcz2D,MAAQnC,KAAKm5F,WAAWh3F,MACtCy2D,EAAcx2D,OAASpC,KAAKm5F,WAAW/2F,OACvCw2D,EAActhC,MAAQt3B,KAAKs3B,MAC3BshC,EAAcmO,QAAU/mE,KAAK+mE,QAI9BnO,EAAcz2D,QAAU8lE,EACxBrP,EAAcx2D,SAAW6lE,EACzBrP,EAAc0O,eAAiBA,EAC/B1O,EAAcqP,kBAAoBA,EAClCrP,EAAc6M,oBAAsB6Y,EAAW7Y,oBAI/CzlE,KAAKg6F,YAAYzvF,OAAQ6xF,EAAU9d,EAAY1lB,GAI/C54D,KAAKs9D,QAAQuhC,YAAajmC,GAI1B,MAAM,QACL0M,EAAO,WACP9tB,EACA6tB,sBAAuBw3B,EACvBviD,YAAasiD,EACbx3B,OAAQu3B,GACLre,EAmBJ,GAjBKhZ,EAAQthE,OAAS,GAAIhE,KAAK8+F,eAAgBx5B,EAAS82B,EAAU5kD,IAC7C,IAAhBx3C,KAAKolE,QAAmBu3B,EAAc34F,OAAS,GAAIhE,KAAK88F,eAAgBH,EAAe/kE,EAAQwkE,EAAU5kD,IACpF,IAArBx3C,KAAKs6C,aAAwBsiD,EAAmB54F,OAAS,GAAIhE,KAAK+8F,oBAAqBH,EAAoBC,EAA8BjlE,EAAQwkE,EAAU5kD,GAIhKx3C,KAAKs9D,QAAQyhC,aAAcnmC,GAI3Br0D,EAAU/D,SAAWw7F,EAErBh8F,KAAKk6F,sBAAwB+B,EAC7Bj8F,KAAK26F,6BAA+BuB,EAIT,OAAtBiC,EAA6B,CAEjCn+F,KAAKotE,gBAAiBkxB,EAAoBh3B,EAAgBW,GAE1D,MAAM+2B,EAAOh/F,KAAKi6F,MAEbj6F,KAAK64D,OAAOq9B,gBAAiB/jD,EAAare,WAE9CkrE,EAAK/9F,SAASi3C,aAAel4C,KAAK64D,OAAOljD,cAAew8B,EAAare,SACrEkrE,EAAK/9F,SAASmJ,aAAc,GAI7BpK,KAAKg9F,aAAcgC,EAAMA,EAAKpnE,QAAQ,EAEvC,CAQA,OAJAwkE,EAAS6C,cAAej/F,KAAM29C,EAAO/lB,EAAQua,GAItCymB,CAER,CAOA,gBAAAsmC,GAEC,OAAOl/F,KAAKs9D,QAAQ4hC,kBAErB,CAOA,iBAAAvrB,GAEC,OAAO3zE,KAAKw6F,eAEb,CAOA,oBAAA5mB,GAEC,OAAO5zE,KAAKy6F,kBAEb,CAWA,sBAAMniC,CAAkBhuD,IAEI,IAAtBtK,KAAKk7F,oBAA+Bl7F,KAAKklF,OAE9CllF,KAAK05F,WAAWphC,iBAAkBhuD,EAEnC,CAUA,yBAAM60F,CAAqBx8F,GAE1B,aAAa3C,KAAKs9D,QAAQ6hC,oBAAqBx8F,EAEhD,CAOA,UAAAyoB,GAEC,OAAOprB,KAAKs9D,QAAQlyC,YAErB,CAOA,aAAAonB,GAEC,OAAOxyC,KAAK8rE,WAEb,CAQA,oBAAAr5B,CAAsBr0B,GAErB,OAAOA,EAAO5b,IAAKxC,KAAK2xD,OAAS3xD,KAAK8rE,YAAa9rE,KAAK4xD,QAAU5xD,KAAK8rE,aAAcvlD,OAEtF,CAQA,OAAA6hD,CAAShqD,GAER,OAAOA,EAAO5b,IAAKxC,KAAK2xD,OAAQ3xD,KAAK4xD,QAEtC,CAOA,aAAA2b,CAAerqE,EAAQ,GAEjBlD,KAAK8rE,cAAgB5oE,IAE1BlD,KAAK8rE,YAAc5oE,EAEnBlD,KAAKktE,QAASltE,KAAK2xD,OAAQ3xD,KAAK4xD,SAAS,GAE1C,CAeA,oBAAAwtC,CAAsBj9F,EAAOC,EAAQorE,GAEpCxtE,KAAK2xD,OAASxvD,EACdnC,KAAK4xD,QAAUxvD,EAEfpC,KAAK8rE,YAAc0B,EAEnBxtE,KAAKm5F,WAAWh3F,MAAQ8C,KAAKshB,MAAOpkB,EAAQqrE,GAC5CxtE,KAAKm5F,WAAW/2F,OAAS6C,KAAKshB,MAAOnkB,EAASorE,GAE9CxtE,KAAKq/F,YAAa,EAAG,EAAGl9F,EAAOC,GAE1BpC,KAAKk7F,cAAel7F,KAAKs9D,QAAQgiC,YAEvC,CASA,OAAApyB,CAAS/qE,EAAOC,EAAQm9F,GAAc,GAErCv/F,KAAK2xD,OAASxvD,EACdnC,KAAK4xD,QAAUxvD,EAEfpC,KAAKm5F,WAAWh3F,MAAQ8C,KAAKshB,MAAOpkB,EAAQnC,KAAK8rE,aACjD9rE,KAAKm5F,WAAW/2F,OAAS6C,KAAKshB,MAAOnkB,EAASpC,KAAK8rE,cAE9B,IAAhByzB,IAEJv/F,KAAKm5F,WAAWqG,MAAMr9F,MAAQA,EAAQ,KACtCnC,KAAKm5F,WAAWqG,MAAMp9F,OAASA,EAAS,MAIzCpC,KAAKq/F,YAAa,EAAG,EAAGl9F,EAAOC,GAE1BpC,KAAKk7F,cAAel7F,KAAKs9D,QAAQgiC,YAEvC,CAQA,aAAAG,CAAe/9E,GAEd1hB,KAAKm6F,YAAcz4E,CAEpB,CAQA,kBAAAg+E,CAAoBh+E,GAEnB1hB,KAAKo6F,iBAAmB14E,CAEzB,CAQA,UAAAi+E,CAAYvhF,GAEX,MAAM+oD,EAAUnnE,KAAKu5F,SAOrB,OALAn7E,EAAOwL,EAAIu9C,EAAQv9C,EACnBxL,EAAO0L,EAAIq9C,EAAQr9C,EACnB1L,EAAOjc,MAAQglE,EAAQhlE,MACvBic,EAAOhc,OAAS+kE,EAAQ/kE,OAEjBgc,CAER,CAWA,UAAAwhF,CAAYh2E,EAAGE,EAAG3nB,EAAOC,GAExB,MAAM+kE,EAAUnnE,KAAKu5F,SAEhB3vE,EAAE3iB,UAENkgE,EAAQ5jE,KAAMqmB,GAIdu9C,EAAQ3kE,IAAKonB,EAAGE,EAAG3nB,EAAOC,EAI5B,CAOA,cAAAgyE,GAEC,OAAOp0E,KAAKw5F,YAEb,CAOA,cAAA/kB,CAAgBorB,GAEf7/F,KAAKw5F,aAAeqG,EAEpB7/F,KAAKs9D,QAAQmX,eAAgBorB,EAE9B,CAQA,WAAAvtD,CAAal0B,GAEZ,OAAOA,EAAO7a,KAAMvD,KAAK48E,UAE1B,CAYA,WAAAyiB,CAAaz1E,EAAGE,EAAG3nB,EAAOC,EAAQq8F,EAAW,EAAGC,EAAW,GAE1D,MAAMrsD,EAAWryC,KAAK48E,UAEjBhzD,EAAE3iB,UAENorC,EAAS9uC,KAAMqmB,GAIfyoB,EAAS7vC,IAAKonB,EAAGE,EAAG3nB,EAAOC,GAI5BiwC,EAASosD,SAAWA,EACpBpsD,EAASqsD,SAAWA,CAErB,CAQA,aAAA3qB,CAAe31D,GAEd,OAAOA,EAAO7a,KAAMvD,KAAKy+E,YAE1B,CAQA,aAAAlK,CAAep7D,EAAO69B,EAAQ,GAE7Bh3C,KAAKy+E,YAAYj8E,IAAK2W,GACtBnZ,KAAKy+E,YAAY5+D,EAAIm3B,CAEtB,CAOA,aAAAi9B,GAEC,OAAOj0E,KAAKy+E,YAAY5+D,CAEzB,CAOA,aAAAigF,CAAe9oD,GAEdh3C,KAAKy+E,YAAY5+D,EAAIm3B,CAEtB,CAOA,aAAA+oD,GAEC,OAAO//F,KAAKs/E,WAEb,CAOA,aAAA0gB,CAAe1oE,GAEdt3B,KAAKs/E,YAAchoD,CAEpB,CAOA,eAAA2oE,GAEC,OAAOjgG,KAAKw/E,aAEb,CAOA,eAAA0gB,CAAiBn5B,GAEhB/mE,KAAKw/E,cAAgBzY,CAEtB,CAUA,UAAAo5B,CAAY7/F,GAEX,MAAMs4D,EAAgB54D,KAAKk6F,sBAE3B,OAAOthC,GAAiB54D,KAAKs9D,QAAQ6iC,WAAYvnC,EAAet4D,EAEjE,CAWA,KAAAg9E,CAAOnkE,GAAQ,EAAMme,GAAQ,EAAMyvC,GAAU,GAE5C,IAA2B,IAAtB/mE,KAAKk7F,aAIT,OAFAzuF,QAAQC,KAAM,uGAEP1M,KAAKogG,WAAYjnF,EAAOme,EAAOyvC,GAIvC,MAAM50B,EAAenyC,KAAKu6F,eAAiBv6F,KAAK+9F,wBAEhD,IAAInlC,EAAgB,KAEpB,GAAsB,OAAjBzmB,EAAwB,CAE5BnyC,KAAK+rE,UAAU/D,mBAAoB71B,GAEnC,MAAM+1B,EAAmBloE,KAAK+rE,UAAUjrE,IAAKqxC,GAE7CymB,EAAgB54D,KAAK+5F,gBAAgBj5F,IAAK,KAAM,KAAMqxC,GACtDymB,EAAclqD,SAAWw5D,EAAiBx5D,SAC1CkqD,EAAcyO,aAAea,EAAiBb,aAC9CzO,EAAcz2D,MAAQ+lE,EAAiB/lE,MACvCy2D,EAAcx2D,OAAS8lE,EAAiB9lE,OACxCw2D,EAAczmB,aAAeA,EAC7BymB,EAActhC,MAAQ6a,EAAa0G,YACnC+f,EAAcmO,QAAU50B,EAAay1B,aAEtC,CAIA,GAFA5nE,KAAKs9D,QAAQggB,MAAOnkE,EAAOme,EAAOyvC,EAASnO,GAErB,OAAjBzmB,GAAgD,OAAvBnyC,KAAKu6F,cAAyB,CAK3D,MAAMyE,EAAOh/F,KAAKi6F,MAEbj6F,KAAK64D,OAAOq9B,gBAAiB/jD,EAAare,WAE9CkrE,EAAK/9F,SAASi3C,aAAel4C,KAAK64D,OAAOljD,cAAew8B,EAAare,SACrEkrE,EAAK/9F,SAASmJ,aAAc,GAI7BpK,KAAKg9F,aAAcgC,EAAMA,EAAKpnE,QAAQ,EAEvC,CAED,CAQA,UAAA+uC,GAEC,OAAO3mE,KAAKs9E,OAAO,GAAM,GAAO,EAEjC,CAQA,UAAAzW,GAEC,OAAO7mE,KAAKs9E,OAAO,GAAO,GAAM,EAEjC,CAQA,YAAAtW,GAEC,OAAOhnE,KAAKs9E,OAAO,GAAO,GAAO,EAElC,CAWA,gBAAM8iB,CAAYjnF,GAAQ,EAAMme,GAAQ,EAAMyvC,GAAU,IAE5B,IAAtB/mE,KAAKk7F,oBAA+Bl7F,KAAKklF,OAE9CllF,KAAKs9E,MAAOnkE,EAAOme,EAAOyvC,EAE3B,CAQA,qBAAMs5B,GAELrgG,KAAKogG,YAAY,GAAM,GAAO,EAE/B,CAQA,qBAAME,GAELtgG,KAAKogG,YAAY,GAAO,GAAM,EAE/B,CAQA,uBAAMG,GAELvgG,KAAKogG,YAAY,GAAO,GAAO,EAEhC,CAQA,sBAAIpC,GAEH,OAA8B,OAAvBh+F,KAAKu6F,cAAyB,MAAgBv6F,KAAKquB,WAE3D,CAQA,qBAAI4nE,GAEH,OAA8B,OAAvBj2F,KAAKu6F,cAAyB,MAAuBv6F,KAAK4sB,gBAElE,CAMA,OAAA3hB,GAECjL,KAAK43D,KAAK3sD,UACVjL,KAAKs9D,QAAQryD,UAEbjL,KAAK05F,WAAWzuF,UAChBjL,KAAK25F,SAAS1uF,UACdjL,KAAK45F,WAAW3uF,UAChBjL,KAAK64D,OAAO5tD,UACZjL,KAAKw5D,UAAUvuD,UACfjL,KAAK85F,aAAa7uF,UAClBjL,KAAK+5F,gBAAgB9uF,UACrBjL,KAAK+rE,UAAU9gE,UAEfjL,KAAKotE,gBAAiB,MACtBptE,KAAKs4D,iBAAkB,KAExB,CAWA,eAAA8U,CAAiBj7B,EAAcm1B,EAAiB,EAAGW,EAAoB,GAEtEjoE,KAAKu6F,cAAgBpoD,EACrBnyC,KAAKw6F,gBAAkBlzB,EACvBtnE,KAAKy6F,mBAAqBxyB,CAE3B,CAOA,eAAA71B,GAEC,OAAOpyC,KAAKu6F,aAEb,CA4BA,uBAAAjmB,CAAyBT,GAExB7zE,KAAK06F,sBAAwB7mB,CAE9B,CAOA,uBAAAC,GAEC,OAAO9zE,KAAK06F,qBAEb,CASA,OAAAxpE,CAASsvE,GAER,IAA2B,IAAtBxgG,KAAKygG,aAAwB,OAElC,IAA2B,IAAtBzgG,KAAKk7F,aAIT,OAFAzuF,QAAQC,KAAM,2GAEP1M,KAAK0gG,aAAcF,GAM3B,MAAMj8F,EAAYvE,KAAK64D,OAAOt0D,UAExBy3F,EAAmBz3F,EAAU/D,SAInCR,KAAK43D,KAAKuH,QACVn/D,KAAK43D,KAAK1mC,QAAQiuC,QAClBn/D,KAAK43D,KAAK1mC,QAAQmuC,aAElB96D,EAAU/D,SAAWR,KAAK43D,KAAKuH,MAI/B,MAAM7B,EAAUt9D,KAAKs9D,QACfX,EAAY38D,KAAK45F,WACjBh9B,EAAW58D,KAAKw5D,UAChBz2D,EAAQ/C,KAAK64D,OAEb8nC,EAAc57F,MAAMuB,QAASk6F,GAAiBA,EAAe,CAAEA,GAErE,QAA0Bz/F,IAArB4/F,EAAa,KAAwD,IAAnCA,EAAa,GAAI/vE,cAEvD,MAAM,IAAIvd,MAAO,qDAIlBiqD,EAAQsjC,aAAcJ,GAEtB,IAAM,MAAM9vE,KAAeiwE,EAAc,CAIxC,IAAsC,IAAjChkC,EAAUh8D,IAAK+vB,GAA0B,CAE7C,MAAMzlB,EAAU,KAEfylB,EAAYuf,oBAAqB,UAAWhlC,GAE5C0xD,EAAU3sB,OAAQtf,GAClBksC,EAAS5sB,OAAQtf,GACjB3tB,EAAMitC,OAAQtf,EAAa,EAI5BA,EAAYwf,iBAAkB,UAAWjlC,GAIzC,MAAM41F,EAAWnwE,EAAYI,eAEX,OAAb+vE,GAEJA,EAASjrF,KAAM8a,EAAa,CAAE5tB,SAAU9C,MAI1C,CAEA+C,EAAMggE,iBAAkBryC,GACxBksC,EAASmG,iBAAkBryC,GAE3B,MAAMowE,EAAkBlkC,EAASuE,cAAezwC,GAC1CqwE,EAAkBpkC,EAAUwE,cAAezwC,EAAaowE,GAE9DxjC,EAAQpsC,QAASsvE,EAAc9vE,EAAaowE,EAAiBC,EAE9D,CAEAzjC,EAAQ0jC,cAAeR,GAIvBj8F,EAAU/D,SAAWw7F,CAEtB,CASA,kBAAM0E,CAAcF,IAEQ,IAAtBxgG,KAAKk7F,oBAA+Bl7F,KAAKklF,OAE9CllF,KAAKkxB,QAASsvE,SAERxgG,KAAKs9D,QAAQ2/B,sBAAuBuD,EAAc,UAEzD,CASA,qBAAMS,CAAiBv+F,GAItB,OAF2B,IAAtB1C,KAAKk7F,oBAA+Bl7F,KAAKklF,OAEvCllF,KAAKs9D,QAAQ4jC,WAAYx+F,EAEjC,CASA,UAAAw+F,CAAYx+F,GAEX,OAA2B,IAAtB1C,KAAKk7F,cAETzuF,QAAQC,KAAM,kHAEP,GAID1M,KAAKs9D,QAAQ4jC,WAAYx+F,EAEjC,CAOA,cAAA6hF,GAEC,OAAOvkF,KAAKk7F,YAEb,CAUA,sBAAMiG,CAAkBrtE,IAEI,IAAtB9zB,KAAKk7F,oBAA+Bl7F,KAAKklF,OAE9CllF,KAAK+rE,UAAU3I,cAAetvC,EAE/B,CAUA,WAAAstE,CAAattE,IAEe,IAAtB9zB,KAAKk7F,cAETzuF,QAAQC,KAAM,mHAIf1M,KAAK+rE,UAAU3I,cAAetvC,EAE/B,CAQA,wBAAA2f,CAA0BL,EAAoBiuD,EAAY,MAEzD,GAAmB,OAAdA,EAEJ,GAAKA,EAAUt6F,UAEds6F,EAAYvI,GAASt2F,IAAK6+F,EAAUz3E,EAAGy3E,EAAUv3E,EAAGspB,EAAmBrf,MAAM5xB,MAAOixC,EAAmBrf,MAAM3xB,QAASmkB,YAEhH,KAAK86E,EAAUp6F,UAQrB,YAFAwF,QAAQkiB,MAAO,+DAJf0yE,EAAYvI,GAASv1F,KAAM89F,GAAY96E,OAQxC,MAIA86E,EAAYvI,GAASt2F,IAAK,EAAG,EAAG4wC,EAAmBrf,MAAM5xB,MAAOixC,EAAmBrf,MAAM3xB,QAM1F,IACI+vC,EADAymB,EAAgB54D,KAAKk6F,sBAGF,OAAlBthC,EAEJzmB,EAAeymB,EAAczmB,cAI7BA,EAAenyC,KAAKu6F,eAAiBv6F,KAAK+9F,wBAEpB,OAAjB5rD,IAEJnyC,KAAK+rE,UAAU/D,mBAAoB71B,GAEnCymB,EAAgB54D,KAAK+rE,UAAUjrE,IAAKqxC,KAQtCnyC,KAAK+rE,UAAU3I,cAAehwB,EAAoB,CAAEjB,iBAEpDnyC,KAAKs9D,QAAQ7pB,yBAA0BL,EAAoBwlB,EAAeyoC,EAE3E,CAWA,oBAAAC,CAAsBC,EAAYC,EAAYC,EAAY,KAAMC,EAAc,KAAMhuE,EAAQ,GAE3F1zB,KAAK+rE,UAAU3I,cAAem+B,GAC9BvhG,KAAK+rE,UAAU3I,cAAeo+B,GAE9BxhG,KAAKs9D,QAAQgkC,qBAAsBC,EAAYC,EAAYC,EAAWC,EAAahuE,EAEpF,CAeA,iCAAMiuE,CAA6BxvD,EAAcvoB,EAAGE,EAAG3nB,EAAOC,EAAQw/F,EAAe,EAAG3a,EAAY,GAEnG,OAAOjnF,KAAKs9D,QAAQukC,oBAAqB1vD,EAAazjC,SAAUkzF,GAAgBh4E,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,EAEtG,CAYA,cAAAuV,CAAgBl8F,EAAQs3B,EAAQgtC,EAAY0Z,EAAYlpC,GAEvD,IAAwB,IAAnB90C,EAAOwhG,QAAoB,OAIhC,GAFgBxhG,EAAO65E,OAAO7lE,KAAMsjB,EAAOuiD,QAI1C,GAAK75E,EAAOyhG,QAEXn9B,EAAatkE,EAAOukE,YAEfvkE,EAAO0hG,iBAAmB1hG,EAAOusB,UAAUuoB,EAAkBA,EAAgB6hD,gBAAiB32F,SAE7F,GAAKA,EAAO2hG,OAES,IAAtB3hG,EAAOm6E,YAAsBn6E,EAAOiK,OAAQqtB,QAE3C,GAAKt3B,EAAOo8F,QAElBpe,EAAWtY,UAAW1lE,QAEhB,GAAKA,EAAOw/D,UAElB,IAAOx/D,EAAO2+E,eAAiB2Z,GAASsJ,iBAAkB5hG,GAAW,EAE1C,IAArBN,KAAKq5F,aAETP,GAASzgE,sBAAuB/3B,EAAOsB,aAAcq3B,aAAc4/D,IAIpE,MAAM,SAAE73F,EAAQ,SAAEC,GAAaX,EAE1BW,EAAS6gG,SAEbxjB,EAAWx4E,KAAMxF,EAAQU,EAAUC,EAAU2jE,EAAYk0B,GAAS77D,EAAG,KAAMmY,EAI7E,OAEM,GAAK90C,EAAOq7D,WAElBlvD,QAAQkiB,MAAO,uHAET,IAAKruB,EAAOu/D,QAAUv/D,EAAOo7D,QAAUp7D,EAAOk7D,aAE7Cl7D,EAAO2+E,eAAiB2Z,GAASuJ,iBAAkB7hG,IAAW,CAEpE,MAAM,SAAEU,EAAQ,SAAEC,GAAaX,EAa/B,IAX0B,IAArBN,KAAKq5F,cAEwB,OAA5Br4F,EAASohG,gBAA0BphG,EAASqhG,wBAEjDvJ,GACEv1F,KAAMvC,EAASohG,eAAetgG,QAC9Bm3B,aAAc34B,EAAOsB,aACrBq3B,aAAc4/D,KAIZ9zF,MAAMuB,QAASrF,GAAa,CAEhC,MAAMqqF,EAAStqF,EAASsqF,OAExB,IAAM,IAAIjnF,EAAI,EAAG+oC,EAAIk+C,EAAOtnF,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAEjD,MAAM+W,EAAQkwE,EAAQjnF,GAChBi+F,EAAgBrhG,EAAUma,EAAMmnF,eAEjCD,GAAiBA,EAAcR,SAEnCxjB,EAAWx4E,KAAMxF,EAAQU,EAAUshG,EAAe19B,EAAYk0B,GAAS77D,EAAG7hB,EAAOg6B,EAInF,CAED,MAAYn0C,EAAS6gG,SAEpBxjB,EAAWx4E,KAAMxF,EAAQU,EAAUC,EAAU2jE,EAAYk0B,GAAS77D,EAAG,KAAMmY,EAI7E,CAMF,IAA8B,IAAzB90C,EAAOkiG,oBAAuDzhG,IAA7Bf,KAAKs9D,QAAQsgC,YAA4B,CAE9E,MAAM6E,EAAiBnkB,GAGvBA,EAAat+E,KAAK85F,aAAah5F,IAAKR,EAAQs3B,IAEjC8tC,QAEX+8B,EAAe18B,WAAY,CAC1BqxB,YAAa92F,EACbs3B,SACA0mD,eAGDA,EAAWt/B,QAEZ,CAEA,MAAM0jD,EAAWpiG,EAAOoiG,SAExB,IAAM,IAAIr+F,EAAI,EAAG+oC,EAAIs1D,EAAS1+F,OAAQK,EAAI+oC,EAAG/oC,IAE5CrE,KAAKw8F,eAAgBkG,EAAUr+F,GAAKuzB,EAAQgtC,EAAY0Z,EAAYlpC,EAItE,CAUA,cAAA0pD,CAAgBx5B,EAAS82B,EAAU5kD,GAElC,IAAM,MAAMv1C,KAAUqjE,EAErBtlE,KAAKu9F,cAAet7F,EAAQm6F,EAAU5kD,EAIxC,CAYA,mBAAAulD,CAAqBze,EAAYqkB,EAAgB/qE,EAAQ+lB,EAAOnG,GAE/D,GAAKmrD,EAAe3+F,OAAS,EAAI,CAIhC,IAAM,MAAM,SAAE/C,KAAc0hG,EAE3B1hG,EAASk5B,KAAO,MAIjBn6B,KAAK88F,eAAgB6F,EAAgB/qE,EAAQ+lB,EAAOnG,EAAY,YAIhE,IAAM,MAAM,SAAEv2C,KAAc0hG,EAE3B1hG,EAASk5B,KAAO,MAIjBn6B,KAAK88F,eAAgBxe,EAAY1mD,EAAQ+lB,EAAOnG,GAIhD,IAAM,MAAM,SAAEv2C,KAAc0hG,EAE3B1hG,EAASk5B,KAAO,KAIlB,MAECn6B,KAAK88F,eAAgBxe,EAAY1mD,EAAQ+lB,EAAOnG,EAIlD,CAYA,cAAAslD,CAAgBxe,EAAY1mD,EAAQ+lB,EAAOnG,EAAYslB,EAAS,MAI/D,IAAM,IAAIz4D,EAAI,EAAGgiE,EAAKiY,EAAWt6E,OAAQK,EAAIgiE,EAAIhiE,IAAO,CAEvD,MAAMuhE,EAAa0Y,EAAYj6E,IAKzB,OAAE/D,EAAM,SAAEU,EAAQ,SAAEC,EAAQ,MAAEma,EAAK,gBAAEg6B,GAAoBwwB,EAE/D,GAAKhuC,EAAOgrE,cAAgB,CAE3B,MAAMC,EAAUjrE,EAAOirE,QAEvB,IAAM,IAAI14D,EAAI,EAAG24D,EAAKD,EAAQ7+F,OAAQmmC,EAAI24D,EAAI34D,IAAO,CAEpD,MAAM44D,EAAUF,EAAS14D,GAEzB,GAAK7pC,EAAO65E,OAAO7lE,KAAMyuF,EAAQ5oB,QAAW,CAE3C,MAAMsD,EAAKslB,EAAQ1wD,SACbosD,OAA6B19F,IAAhB08E,EAAGghB,SAA2B,EAAIhhB,EAAGghB,SAClDC,OAA6B39F,IAAhB08E,EAAGihB,SAA2B,EAAIjhB,EAAGihB,SAElDx3B,EAAgBlnE,KAAKk6F,sBAAsBhzB,cACjDA,EAAc3jE,KAAMk6E,GAAKlrC,eAAgBvyC,KAAK8rE,aAAcvlD,QAC5D2gD,EAAcu3B,SAAWA,EACzBv3B,EAAcw3B,SAAWA,EAEzB1+F,KAAKs9D,QAAQ0lC,eAAgBhjG,KAAKk6F,uBAElCl6F,KAAK26F,6BAA8Br6F,EAAQq9C,EAAOolD,EAAS/hG,EAAUC,EAAUma,EAAOo8B,EAAYpC,EAAiB0nB,EAEpH,CAED,CAED,MAEC98D,KAAK26F,6BAA8Br6F,EAAQq9C,EAAO/lB,EAAQ52B,EAAUC,EAAUma,EAAOo8B,EAAYpC,EAAiB0nB,EAIpH,CAED,CAgBA,YAAAp8D,CAAcJ,EAAQq9C,EAAO/lB,EAAQ52B,EAAUC,EAAUma,EAAOo8B,EAAYpC,EAAkB,KAAM0nB,EAAS,MAE5G,IAAImmC,EACAC,EACAC,EAQJ,GAJA7iG,EAAO4+E,eAAgBl/E,KAAM29C,EAAO/lB,EAAQ52B,EAAUC,EAAUma,GAIhC,OAA3BuiC,EAAMi3B,iBAA4B,CAEtC,MAAMA,EAAmBj3B,EAAMi3B,iBAE1B3zE,EAAS22C,cAAgB32C,EAAS22C,aAAa/0C,SAEnDogG,EAAuBruB,EAAiBh9B,aACxCg9B,EAAiBh9B,aAAe32C,EAAS22C,cAI1Cg9B,EAAiBx6B,UAAYn5C,EAASm5C,UACtCw6B,EAAiBzzC,SAAWlgC,EAASkgC,SACrCyzC,EAAiBt6B,YAAcr5C,EAASq5C,aAAer5C,EAASiB,aAAe,EAE1E0yE,EAAiBpd,uBAErBod,EAAiBz6C,KAA+B,OAAxBl5B,EAASmiG,WAAsBniG,EAASk5B,KAAOl5B,EAASmiG,WAE3EniG,EAASqzB,WAAarzB,EAASqzB,UAAUzxB,SAE7CsgG,EAAoBvuB,EAAiBtgD,UACrCsgD,EAAiBtgD,UAAYrzB,EAASqzB,WAIlCrzB,EAAS+2C,gBAAkB/2C,EAAS+2C,eAAen1C,SAEvDqgG,EAAoBtuB,EAAiBpoD,UACrCooD,EAAiBpoD,UAAYvrB,EAAS+2C,iBAMxC/2C,EAAW2zE,CAEZ,EAI8B,IAAzB3zE,EAASq5C,aAAwBr5C,EAASk5B,OAAS,QAA2C,IAA7Bl5B,EAAS+jE,iBAE9E/jE,EAASk5B,KAAO,MAChBn6B,KAAK66F,sBAAuBv6F,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYp8B,EAAOg6B,EAAiB,YAEjGn0C,EAASk5B,KAAO,MAChBn6B,KAAK66F,sBAAuBv6F,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYp8B,EAAOg6B,EAAiB0nB,GAEjG77D,EAASk5B,KAAO,OAIhBn6B,KAAK66F,sBAAuBv6F,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYp8B,EAAOg6B,EAAiB0nB,QAMpE/7D,IAAzBkiG,IAEJtlD,EAAMi3B,iBAAiBh9B,aAAeqrD,QAIZliG,IAAtBoiG,IAEJxlD,EAAMi3B,iBAAiBtgD,UAAY6uE,QAITpiG,IAAtBmiG,IAEJvlD,EAAMi3B,iBAAiBpoD,UAAY02E,GAMpC5iG,EAAO2+F,cAAej/F,KAAM29C,EAAO/lB,EAAQ52B,EAAUC,EAAUma,EAEhE,CAgBA,mBAAA0/E,CAAqBx6F,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYp8B,EAAOg6B,EAAiB0nB,GAEzF,MAAMp8D,EAAeV,KAAK25F,SAAS74F,IAAKR,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYx3C,KAAKk6F,sBAAuB9kD,EAAiB0nB,GAClIp8D,EAAac,UAAYlB,EAAOU,SAASQ,UACzCd,EAAa0a,MAAQA,EAIrB,MAAM9W,EAAetE,KAAK64D,OAAOv0D,aAAc5D,GAiB/C,GAfK4D,IAEJtE,KAAK64D,OAAOrsD,aAAc9L,GAE1BV,KAAK84D,YAAY0F,gBAAiB99D,GAElCV,KAAK64D,OAAO2F,gBAAiB99D,GAC7BV,KAAKw5D,UAAUgF,gBAAiB99D,IAIjCV,KAAK45F,WAAWp7B,gBAAiB99D,GAIE,OAA9BV,KAAK46F,qBAAgC,CAEhB56F,KAAKs9D,QAAQx8D,IAAKd,KAAK46F,sBAE/B36F,cAAc6F,KAAMpF,GAErCA,EAAauB,OAASjC,KAAK46F,qBAAqBxD,WAEjD,CAEAp3F,KAAKs9D,QAAQ+lC,KAAM3iG,EAAcV,KAAK43D,MAEjCtzD,GAAetE,KAAK64D,OAAOlsD,YAAajM,EAE9C,CAgBA,qBAAA67F,CAAuBj8F,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYp8B,EAAOg6B,EAAiB0nB,GAE3F,MAAMp8D,EAAeV,KAAK25F,SAAS74F,IAAKR,EAAQW,EAAU08C,EAAO/lB,EAAQ4f,EAAYx3C,KAAKk6F,sBAAuB9kD,EAAiB0nB,GAClIp8D,EAAac,UAAYlB,EAAOU,SAASQ,UACzCd,EAAa0a,MAAQA,EAIrBpb,KAAK64D,OAAOrsD,aAAc9L,GAE1BV,KAAK84D,YAAY0F,gBAAiB99D,GAElCV,KAAK64D,OAAO2F,gBAAiB99D,GAC7BV,KAAKw5D,UAAUgF,gBAAiB99D,GAEhCV,KAAK45F,WAAW1/B,aAAcx5D,EAAcV,KAAKo7F,sBAEjDp7F,KAAK64D,OAAOlsD,YAAajM,EAE1B,CAWA,WAAIinF,GAEH,OAAO3nF,KAAK27F,YAEb,EAaD,MAAM2H,GAOL,WAAAxjG,CAAa4C,EAAO,IAOnB1C,KAAK0C,KAAOA,EAQZ1C,KAAKujG,WAAa,CAEnB,CAOA,aAAAC,CAAeD,GAEdvjG,KAAKujG,YAAcA,CAEpB,CAOA,KAAA1hG,GAEC,OAAOgC,OAAOsQ,OAAQ,IAAInU,KAAKF,YAAeE,KAE/C,EA6BD,MAAMyjG,WAAeH,GAQpB,WAAAxjG,CAAa4C,EAAM4F,EAAS,MAE3BoB,MAAOhH,GASP1C,KAAK0jG,UAAW,EAOhB1jG,KAAK2jG,gBAAkBxmE,aAAaymE,kBAQpC5jG,KAAK6jG,QAAUv7F,CAEhB,CAQA,cAAIw7F,GAEH,OA7DuBC,EA6DA/jG,KAAK6jG,QAAQC,aAzDZ1mC,GAAoB2mC,EAAc3mC,IAAsBA,GAJlF,IAAyB2mC,CA+DxB,CAQA,UAAIz7F,GAEH,OAAOtI,KAAK6jG,OAEb,CAQA,MAAAt5F,GAEC,OAAO,CAER,EAUD,MAAMy5F,WAAsBP,GAQ3B,WAAA3jG,CAAa4C,EAAM4F,EAAS,MAE3BoB,MAAOhH,EAAM4F,GASbtI,KAAK4jE,iBAAkB,CAExB,EAID,IAAIqgC,GAAQ,EASZ,MAAMC,WAA0BF,GAQ/B,WAAAlkG,CAAa6b,EAAaV,GAEzBvR,MAAO,iBAAmBu6F,KAAUtoF,EAAcA,EAAYzY,MAAQ,MAOtElD,KAAK2b,YAAcA,EAOnB3b,KAAKib,UAAYA,CAElB,CAOA,UAAI3S,GAEH,OAAOtI,KAAK2b,YAAYzY,KAEzB,EAWD,MAAMihG,WAAsBH,GAO3B,WAAAlkG,CAAa4C,GAEZgH,MAAOhH,GASP1C,KAAKokG,iBAAkB,EASvBpkG,KAAKqkG,QAAU,KASfrkG,KAAKqxE,SAAW,EAEjB,CAQA,UAAAizB,CAAYxoF,GAIX,OAFA9b,KAAKqxE,SAASvrE,KAAMgW,GAEb9b,IAER,CAQA,aAAAukG,CAAezoF,GAEd,MAAMxa,EAAQtB,KAAKqxE,SAAS//D,QAASwK,GAQrC,OANiB,IAAZxa,GAEJtB,KAAKqxE,SAASmzB,OAAQljG,EAAO,GAIvBtB,IAER,CAOA,UAAI6F,GAQH,OANsB,OAAjB7F,KAAKqkG,UAETrkG,KAAKqkG,QAAUt/F,MAAMoD,KAAMnI,KAAKsI,SAI1BtI,KAAKqkG,OAEb,CAOA,UAAI/7F,GAEH,IAAIA,EAAStI,KAAK6jG,QAElB,GAAgB,OAAXv7F,EAAkB,CAEtB,MAAMw7F,EAAa9jG,KAAK8jG,WAExBx7F,EAAS,IAAI60B,aAAc,IAAI91B,YAAay8F,IAE5C9jG,KAAK6jG,QAAUv7F,CAEhB,CAEA,OAAOA,CAER,CAOA,cAAIw7F,GAEH,IAAIh0E,EAAS,EAEb,IAAM,IAAIzrB,EAAI,EAAG+oC,EAAIptC,KAAKqxE,SAASrtE,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAExD,MAAMyX,EAAU9b,KAAKqxE,SAAUhtE,IAEzB,SAAEi9E,EAAQ,SAAE1xD,GAAa9T,EAIzB2oF,EAAc30E,EAASstC,GAKR,IAAhBqnC,GAJwBrnC,GAAkBqnC,EAIInjB,EAAa,EAI/DxxD,GAAYstC,GAAkBqnC,EAEnBA,EAAcnjB,GAAa,IAItCxxD,GAAY20E,EAAcnjB,GAI3BxlE,EAAQgU,OAAWA,EAAS9vB,KAAK2jG,gBAEjC7zE,GAAYF,EAAW5vB,KAAK2jG,eAE7B,CAEA,OAAO1+F,KAAKuhB,KAAMsJ,EAASstC,IAAoBA,EAEhD,CAWA,MAAA7yD,GAEC,IAAI05D,GAAU,EAEd,IAAM,MAAMnoD,KAAW9b,KAAKqxE,UAEW,IAAjCrxE,KAAK0kG,aAAc5oF,KAEvBmoD,GAAU,GAMZ,OAAOA,CAER,CASA,YAAAygC,CAAc5oF,GAEb,OAAKA,EAAQ4lE,gBAAyB1hF,KAAK2kG,aAAc7oF,GACpDA,EAAQ8lE,iBAA0B5hF,KAAK4kG,cAAe9oF,GACtDA,EAAQgmE,iBAA0B9hF,KAAK6kG,cAAe/oF,GACtDA,EAAQkmE,iBAA0BhiF,KAAK8kG,cAAehpF,GACtDA,EAAQomE,eAAwBliF,KAAK+kG,YAAajpF,GAClDA,EAAQsmE,iBAA0BpiF,KAAKglG,cAAelpF,GACtDA,EAAQwmE,iBAA0BtiF,KAAKilG,cAAenpF,QAE3DrP,QAAQkiB,MAAO,uDAAwD7S,EAExE,CAQA,YAAA6oF,CAAc7oF,GAEb,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTwS,EAAIyD,EAAQ0lE,WACZ1xD,EAAShU,EAAQgU,OACjBvoB,EAAOuU,EAAQjL,UAErB,GAAKgP,EAAGiQ,KAAazX,EAAI,CAEdrY,KAAKklG,kBAAmB39F,GAE/BuoB,GAAWjQ,EAAGiQ,GAAWzX,EAC5B4rD,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAA2gC,CAAe9oF,GAEd,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTwS,EAAIyD,EAAQ0lE,WACZ1xD,EAAShU,EAAQgU,OACjBvoB,EAAOuU,EAAQjL,UAErB,GAAKgP,EAAGiQ,EAAS,KAAQzX,EAAEuR,GAAK/J,EAAGiQ,EAAS,KAAQzX,EAAEyR,EAAI,CAEzD,MAAMhK,EAAI9f,KAAKklG,kBAAmB39F,GAElCuY,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAEuR,EACtC9J,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAEyR,EAEtCm6C,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAA4gC,CAAe/oF,GAEd,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTwS,EAAIyD,EAAQ0lE,WACZ1xD,EAAShU,EAAQgU,OACjBvoB,EAAOuU,EAAQjL,UAErB,GAAKgP,EAAGiQ,EAAS,KAAQzX,EAAEuR,GAAK/J,EAAGiQ,EAAS,KAAQzX,EAAEyR,GAAKjK,EAAGiQ,EAAS,KAAQzX,EAAE4kB,EAAI,CAEpF,MAAMnd,EAAI9f,KAAKklG,kBAAmB39F,GAElCuY,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAEuR,EACtC9J,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAEyR,EACtChK,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAE4kB,EAEtCgnC,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAA6gC,CAAehpF,GAEd,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTwS,EAAIyD,EAAQ0lE,WACZ1xD,EAAShU,EAAQgU,OACjBvoB,EAAOuU,EAAQjL,UAErB,GAAKgP,EAAGiQ,EAAS,KAAQzX,EAAEuR,GAAK/J,EAAGiQ,EAAS,KAAQzX,EAAEyR,GAAKjK,EAAGiQ,EAAS,KAAQzX,EAAE4kB,GAAKpd,EAAGiQ,EAAS,KAAQzX,EAAE6kB,EAAI,CAE/G,MAAMpd,EAAI9f,KAAKklG,kBAAmB39F,GAElCuY,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAEuR,EACtC9J,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAEyR,EACtChK,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAE4kB,EACtCnd,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMzX,EAAE6kB,EAEtC+mC,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,WAAA8gC,CAAajpF,GAEZ,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTwC,EAAIyT,EAAQ0lE,WACZ1xD,EAAShU,EAAQgU,OAEvB,GAAKjQ,EAAGiQ,EAAS,KAAQznB,EAAEy0B,GAAKjd,EAAGiQ,EAAS,KAAQznB,EAAE00B,GAAKld,EAAGiQ,EAAS,KAAQznB,EAAEyX,EAAI,CAEpF,MAAMA,EAAI9f,KAAKsI,OAEfwX,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMznB,EAAEy0B,EACtChd,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMznB,EAAE00B,EACtCjd,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMznB,EAAEyX,EAEtCmkD,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAA+gC,CAAelpF,GAEd,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTs/F,EAAIrpF,EAAQ0lE,WAAWxkD,SACvBlN,EAAShU,EAAQgU,OAEvB,GAAKjQ,EAAGiQ,EAAS,KAAQq1E,EAAG,IAAOtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IAAOtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IACvFtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IAAOtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IAAOtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IACnFtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IAAOtlF,EAAGiQ,EAAS,KAAQq1E,EAAG,IAAOtlF,EAAGiQ,EAAS,MAASq1E,EAAG,GAAM,CAE1F,MAAMrlF,EAAI9f,KAAKsI,OAEfwX,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,GAAMjQ,EAAGiQ,EAAS,GAAMq1E,EAAG,GACvCrlF,EAAGgQ,EAAS,IAAOjQ,EAAGiQ,EAAS,IAAOq1E,EAAG,GAEzClhC,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,aAAAghC,CAAenpF,GAEd,IAAImoD,GAAU,EAEd,MAAMpkD,EAAI7f,KAAK6F,OACTs/F,EAAIrpF,EAAQ0lE,WAAWxkD,SACvBlN,EAAShU,EAAQgU,OAEvB,IAAqC,IAsDvC,SAAsBjQ,EAAGC,EAAGgQ,GAE3B,IAAM,IAAIzrB,EAAI,EAAG+oC,EAAIttB,EAAE9b,OAAQK,EAAI+oC,EAAG/oC,IAErC,GAAKwb,EAAGiQ,EAASzrB,KAAQyb,EAAGzb,GAAM,OAAO,EAI1C,OAAO,CAER,CAhEO+gG,CAAavlF,EAAGslF,EAAGr1E,GAAqB,CAElC9vB,KAAKsI,OACb9F,IAAK2iG,EAAGr1E,GAiCb,SAAmBjQ,EAAGC,EAAGgQ,GAExB,IAAM,IAAIzrB,EAAI,EAAG+oC,EAAIttB,EAAE9b,OAAQK,EAAI+oC,EAAG/oC,IAErCwb,EAAGiQ,EAASzrB,GAAMyb,EAAGzb,EAIvB,CAxCGghG,CAAUxlF,EAAGslF,EAAGr1E,GAChBm0C,GAAU,CAEX,CAEA,OAAOA,CAER,CAQA,iBAAAihC,CAAmB39F,GAElB,MAAc,QAATA,GAA2B,UAATA,GAA6B,UAATA,GAA6B,UAATA,EAA0B,IAAI81B,WAAYr9B,KAAKsI,OAAOA,QACvG,SAATf,GAA4B,UAATA,GAA6B,UAATA,GAA6B,UAATA,EAA0B,IAAI+1B,YAAat9B,KAAKsI,OAAOA,QAChHtI,KAAKsI,MAEb,EAyCD,IAAIg9F,GAAQ,EASZ,MAAMC,WAA0BpB,GAQ/B,WAAArkG,CAAa4C,EAAMuY,GAElBvR,MAAOhH,GAOP1C,KAAKoD,GAAKkiG,KAOVtlG,KAAKib,UAAYA,EASjBjb,KAAK0jE,qBAAsB,CAE5B,EAID,IAAI8hC,GAAQ,EAQZ,MAAMC,WAAuBnC,GAQ5B,WAAAxjG,CAAa4C,EAAMoxB,GAElBpqB,MAAOhH,GAOP1C,KAAKoD,GAAKoiG,KAOVxlG,KAAK8zB,QAAUA,EAOf9zB,KAAKuB,QAAUuyB,EAAUA,EAAQvyB,QAAU,EAQ3CvB,KAAKukE,OAAQ,EASbvkE,KAAKgkE,WAAa,KASlBhkE,KAAKmjE,kBAAmB,CAEzB,CASA,mBAAAI,CAAqBS,GAEpB,MAAM,QAAElwC,GAAY9zB,KAEpB,OAAKgkE,IAAehkE,KAAKgkE,YAExBhkE,KAAKgkE,WAAaA,GAEX,GAIDlwC,EAAQ4xE,cAEhB,CASA,MAAAn7F,GAEC,MAAM,QAAEupB,EAAO,QAAEvyB,GAAYvB,KAE7B,OAAKuB,IAAYuyB,EAAQvyB,UAExBvB,KAAKuB,QAAUuyB,EAAQvyB,SAEhB,EAMT,EAWD,MAAMokG,WAA2BF,GAUhC,WAAA3lG,CAAa4C,EAAM4wB,EAAarY,EAAW2qF,EAAS,MAEnDl8F,MAAOhH,EAAM4wB,EAAcA,EAAYpwB,MAAQ,MAO/ClD,KAAKszB,YAAcA,EAOnBtzB,KAAKib,UAAYA,EAQjBjb,KAAK4lG,OAASA,CAEf,CAQA,mBAAAriC,CAAqBS,GAEpB,OAAOhkE,KAAKszB,YAAYpwB,QAAUlD,KAAK8zB,SAAWpqB,MAAM65D,oBAAqBS,EAE9E,CASA,MAAAz5D,GAEC,MAAM,YAAE+oB,GAAgBtzB,KAExB,OAAKA,KAAK8zB,UAAYR,EAAYpwB,OAEjClD,KAAK8zB,QAAUR,EAAYpwB,OAEpB,GAIDwG,MAAMa,QAEd,EAWD,MAAMs7F,WAA+BF,GAUpC,WAAA7lG,CAAa4C,EAAM4wB,EAAarY,EAAW2qF,EAAS,MAEnDl8F,MAAOhH,EAAM4wB,EAAarY,EAAW2qF,GASrC5lG,KAAK8lG,sBAAuB,CAE7B,EAWD,MAAMC,WAA6BJ,GAUlC,WAAA7lG,CAAa4C,EAAM4wB,EAAarY,EAAW2qF,EAAS,MAEnDl8F,MAAOhH,EAAM4wB,EAAarY,EAAW2qF,GASrC5lG,KAAKgmG,oBAAqB,CAE3B,EAID,MAAMC,GAAc,CACnBC,kBAAmB,cACnB7iG,OAAQ,SAGH8iG,GAAe,CACpBv9E,IAAK,OACLw9E,OAAQ,UACRv9E,KAAM,SAGDw9E,GAAa,CAClBC,eAAe,EACfC,eAAe,GAGVC,GAAoB,ucAqB1B,MAAMC,WAAwB5c,GAE7B,WAAA/pF,CAAaQ,EAAQwC,GAEpB4G,MAAOpJ,EAAQwC,EAAU,IAAImxF,IAE7Bj0F,KAAK0mG,cAAgB,CAAC,EACtB1mG,KAAK8gE,WAAa,GAClB9gE,KAAK2mG,WAAa,CAAC,EACnB3mG,KAAK4mG,SAAW,CAAE/sD,OAAQ,GAAIqnB,SAAU,GAAIhwC,QAAS,IAErDlxB,KAAKkgB,qBAAsB,CAE5B,CAEA,wBAAAyW,CAA0B7C,GAEzB,OAAkC,IAA3BA,EAAQ4xE,gBAA2B5xE,EAAQpH,aAAe,KAElE,CAEA,SAAAvM,CAAWuB,GAEV,OAAOukF,GAAavkF,IAAYA,CAEjC,CAEA,mBAAAmlF,GAEC,MAAO,EAER,CAEA,iBAAAvZ,CAAmB53E,GAElB,MAAMI,EAASJ,EAAWI,OACpBq3E,EAAWntF,KAAKutF,eAAgB73E,GAEhC+I,EAAa,GAEnB,IAAM,MAAM/N,KAASoF,EAAOjC,OAE3B4K,EAAW3Y,KAAM9F,KAAK6Q,QAASH,EAAMnJ,MAAS,IAAMmJ,EAAMhO,MAiB3D,MAXa,GAAI1C,KAAK6Q,QAASiF,EAAOvO,SAAYuO,EAAOpT,SAAW+b,EAAW3N,KAAM,kBAEnFq8E,EAAS3C,WAEV2C,EAASvsB,kBACDusB,EAASpgF,cAQnB,CAEA,QAAA+5F,CAAUC,GAET,MAAMpkG,EAAYokG,EAAkB7jG,MAEpC,QAAuBnC,IAAlB4B,EAAUqkG,IAAoB,CAElC,MAAMC,EAAgBtkG,EAAU6C,MAC1B0hG,EAAcvkG,EAAUjB,MAAQiB,EAAUitB,UAE1C,SAAEA,GAAajtB,EAEfyL,EAAYzL,EAAU6C,MAAM1F,YAAY4C,KAAK8R,cAAc2B,SAAU,OAE3E,IAAIxI,EAASS,EAAY,MAAmB,MAE1B,IAAbwhB,EAEJjiB,EAASS,EAAY,MAAkB,MAEf,IAAbwhB,EAEXjiB,EAASS,EAAY,MAAmB,MAEhB,IAAbwhB,IAEXjiB,EAASS,EAAY,MAAoB,OAI1C,MAAM+4F,EAAU,CACfhqE,aAAc,MACdr1B,WAAY,MACZ8hF,YAAa,MACbtsD,YAAa,MACbosD,UAAW,MACXC,WAAY,MACZtsD,WAAY,MACZ+pE,kBAAmB,OAGdjlG,EAAQ8C,KAAKkjB,IAAK,EAAGljB,KAAKuhB,KAAMvhB,KAAKmhB,KAAMnhB,KAAKohB,KAAM6gF,EAAct3E,MAC1E,IAAIxtB,EAAS6C,KAAKuhB,KAAQ0gF,EAAct3E,EAAaztB,GAChDA,EAAQC,EAASwtB,EAAWs3E,GAAc9kG,IAE/C,MAAMilG,EAAUllG,EAAQC,EAASwtB,EAE3B03E,EAAW,IAAIL,EAAcnnG,YAAaunG,GAEhDC,EAAS9kG,IAAKykG,EAAe,GAE7BtkG,EAAU6C,MAAQ8hG,EAElB,MAAMC,EAAa,IAAI,MAAa5kG,EAAU6C,MAAOrD,EAAOC,EAAQuL,EAAQw5F,EAASxkG,EAAU6C,MAAM1F,YAAY4C,OAAU,OAC3H6kG,EAAWn9F,aAAc,EACzBm9F,EAAWC,cAAe,EAE1B,MAAMR,EAAM,IAAI/yE,GAAaszE,EAAY,KAAM,MAC/CP,EAAIt0F,aAAc,QAElB/P,EAAU8kG,QAAUT,EACpBrkG,EAAUqkG,IAAMA,EAAI9jG,MAEpBlD,KAAK4b,mBAAoBjZ,EAAU8kG,QAAS,UAAWznG,KAAK6b,YAAa7b,KAAKqC,QAAQ6Y,MAEvF,CAED,CAEA,eAAAhL,CAAiB/J,EAAM0V,EAAc7b,KAAK6b,aAEzC,OAAK1V,EAAKs6E,gBAA6C,IAA5Bt6E,EAAKA,KAAKiuB,gBAAqD,IAA3BjuB,EAAKA,KAAK+oB,aAEjErT,EAAY+gB,OAAQ,GAAM,IAAMz2B,EAAKzD,KAItCgH,MAAMwG,gBAAiB/J,EAAM0V,EAErC,CAEA,WAAA6rF,CAAaC,GAEZ,MAAM,KAAExhG,EAAI,UAAE+I,GAAcy4F,EACtBhlG,EAAYwD,EAAKjD,MAEvB,GAAKlD,KAAK8C,SAASw6D,QAAQ38D,IAAKgC,GAAc,CAEvB3C,KAAK8C,SAASw6D,QAAQx8D,IAAK6B,GACnCqkG,IAAMrkG,EAAUqkG,GAE/B,CAEA,MAAMrrF,EAAc3b,KAAK4b,mBAAoBjZ,EAAU8kG,QAAS,UAAWznG,KAAK6b,YAAa7b,KAAKqC,QAAQ6Y,OACpGwwD,EAAc1rE,KAAKkQ,gBAAiByL,GAE1C3b,KAAKoM,cAAe8C,GACpB,MAAM04F,EAAe14F,EAAU7C,MAAOrM,KAAM,QAEtC6nG,EAAkB7nG,KAAKsN,gBAAiBq6F,GAE9C,IAAI53F,EAAe83F,EAAgB93F,aAEnC,QAAsBhP,IAAjBgP,EAA6B,CAIjC,MAAMC,EAAUhQ,KAAKiQ,eAAgB03F,GAErC53F,EAAe/P,KAAKkQ,gBAAiBF,GAIrC,MAAM83F,EAAiB9nG,KAAKsN,gBAAiBnH,GAE7C,IAAI4hG,EAAmBD,EAAeC,sBAEZhnG,IAArBgnG,IAEJA,EAAmBh4F,EAAe,OAElC/P,KAAKiQ,eAAgB9J,EAAM4hG,EAAkB,QAE7C/nG,KAAKmQ,gBAAiB,GAAI43F,0BAA2Cr8B,aAAyBi8B,GAE9FG,EAAeC,iBAAmBA,GAMnC,MAAM,SAAEn4E,GAAajtB,EAEfoyB,EAAU,IAAMzrB,EAAiBwH,KAAM,IAAK9O,MAAO,EAAG4tB,GACtDkG,EAAY,SAAS8xE,OAAmBG,MAAsBH,OAAmBG,KAEjFx6F,EAAUvN,KAAKw2B,oBAAqB,KAAMk1C,EAAa51C,EAAW,KAAM,KAK9E,IAAIkyE,EAAS,OAERrlG,EAAUqkG,IAAIz/F,OAAS,MAE3BygG,EAAS,QAEErlG,EAAUqkG,IAAIz/F,OAAS,QAElCygG,EAAS,SAIVhoG,KAAKmQ,gBAAiB,GAAIJ,OAAmBi4F,KAAWz6F,KAAYwnB,IAAW4yE,GAE/EE,EAAgB93F,aAAeA,CAEhC,CAEA,OAAOA,CAER,CAEA,mBAAAymB,CAAqB1C,EAASL,EAAiBw0E,EAAgBhyE,EAAcF,EAAe,KAE3F,OAAKE,EAEG,eAAgBxC,aAA6Bw0E,MAAqBhyE,QAAqBF,MAIvF,eAAgBtC,MAAsBw0E,MAAqBlyE,KAIpE,CAEA,eAAAU,CAAiB3C,EAASL,EAAiBqC,EAAWG,GAErD,OAAKnC,EAAQe,eAEL,YAAapB,MAAsBqC,SAIrCG,IAAeH,EAAY,SAAUA,MAAgBG,OAEnD,YAAaxC,MAAsBqC,MAI5C,CAEA,oBAAAM,CAAsBtC,EAASL,EAAiBqC,EAAWC,GAE1D,MAAO,eAAgBtC,MAAsBqC,MAAgBC,KAE9D,CAEA,mBAAAM,CAAqBvC,EAASL,EAAiBqC,EAAWE,GAEzD,MAAO,YAAavC,MAAsBqC,MAAgBE,KAE3D,CAEA,mBAAAM,CAAqBxC,EAASL,EAAiBqC,EAAWK,GAEzD,MAAO,gBAAiB1C,MAAsBqC,MAAgBK,EAAa,OAAUA,EAAa,MAEnG,CAEA,sBAAAI,CAAwBzC,EAASL,EAAiBqC,EAAWI,EAAgBD,EAAcpa,EAAc7b,KAAK6b,aAE7G,GAAqB,aAAhBA,EAEJ,MAAO,YAAa4X,YAA4BqC,MAAgBI,QAIhEzpB,QAAQkiB,MAAO,yEAA0E9S,YAI3F,CAEA,OAAAoyE,CAASpyE,GAER,MAAMqsF,EAAW,GAEX1d,EAAOxqF,KAAKwqF,KAAM3uE,GAExB,QAAc9a,IAATypF,EAEJ,IAAM,MAAMkC,KAAYlC,EAEvB0d,EAASpiG,KAAM,GAAI9F,KAAK8tC,OAAQ4+C,EAASnlF,KAAMmlF,EAAShqF,UAM1D,OAAOwlG,EAASp3F,KAAM,OAEvB,CAEA,WAAAy9E,CAAa1yE,GAEZ,MAAMw1D,EAAWrxE,KAAKqxE,SAAUx1D,GAE1BssF,EAAkB,GAClBzB,EAAgB,CAAC,EAEvB,IAAM,MAAM5qF,KAAWu1D,EAAW,CAEjC,IAAI9jE,EAAU,KACV6N,GAAQ,EAEZ,GAAsB,YAAjBU,EAAQvU,KAAqB,CAEjC,MAAMusB,EAAUhY,EAAQ3V,KAAKjD,MAE7B,IAAIklG,EAAa,IAEc,IAA1Bt0E,EAAQi4D,gBAGPj4D,EAAQvsB,OAAS,MAErB6gG,EAAa,IAEFt0E,EAAQvsB,OAAS,QAE5B6gG,EAAa,MAQd76F,EAFIumB,EAAQmlD,gBAEF,mBAAoBn9D,EAAQpZ,SAEI,IAA/BoxB,EAAQu0E,qBAAoE,IAArCv0E,EAAQw0E,yBAEhD,GAAGF,mBAA6BtsF,EAAQpZ,QAIxC,GAAG0lG,cAAwBtsF,EAAQpZ,OAI/C,MAAO,GAAsB,gBAAjBoZ,EAAQvU,KAEnBgG,EAAU,eAAgBuO,EAAQpZ,aAE5B,GAAsB,cAAjBoZ,EAAQvU,KAEnBgG,EAAU,aAAcuO,EAAQpZ,aAE1B,GAAsB,WAAjBoZ,EAAQvU,KAAoB,CAEvC,MAAMipB,EAAa1U,EAAQ3V,KACrB4oB,EAAa/uB,KAAK6Q,QAAS2f,EAAWzB,YACtCqN,EAAc5L,EAAW4L,YAEzBmsE,EAAqBnsE,EAAc,EAAIA,EAAc,GAC3D7uB,EAAU,GAAGijB,EAAW9tB,aAAcqsB,KAAgBjT,EAAQpZ,QAAU6lG,WAEzE,KAAO,CAINh7F,EAAU,GAFSvN,KAAK8P,cAAegM,EAAQvU,SAEjBvH,KAAKkQ,gBAAiB4L,EAASD,MAE7DT,GAAQ,CAET,CAEA,MAAM5I,EAAYsJ,EAAQ3V,KAAKqM,UAQ/B,GANmB,OAAdA,IAEJjF,EAAU44F,GAAc3zF,GAAc,IAAMjF,GAIxC6N,EAAQ,CAEZ7N,EAAU,KAAOA,EAEjB,MAAM09E,EAAYnvE,EAAQb,UAAUvY,MACdgkG,EAAezb,KAAiByb,EAAezb,GAAc,KAErEnlF,KAAMyH,EAErB,MAECA,EAAU,WAAaA,EAEvB46F,EAAgBriG,KAAMyH,EAIxB,CAEA,IAAIhB,EAAS,GAEb,IAAM,MAAM7J,KAAQgkG,EAAgB,CAEnC,MAAM8B,EAAgB9B,EAAehkG,GAErC6J,GAAUvM,KAAKyoG,sBAAuB5sF,EAAc,IAAMnZ,EAAM8lG,EAAc13F,KAAM,OAAW,IAEhG,CAIA,OAFAvE,GAAU47F,EAAgBr3F,KAAM,MAEzBvE,CAER,CAEA,oBAAAojB,CAAsBhtB,GAErB,IAAI8G,EAAWC,MAAMimB,qBAAsBhtB,GAE3C,GAAK,QAAQ2R,KAAM7K,IAAc9G,EAAU+lG,UAAY,MAAU,CAEhE,IAAIvc,EAAgBxpF,EAEfA,EAAUk4D,+BAA+BsxB,EAAgBxpF,EAAU9B,MAExE,MAAM2E,EAAQ2mF,EAAc3mF,OAE6C,IAAlEA,aAAiB83B,aAAe93B,aAAiB63B,cAEvD5zB,EAAWA,EAASzH,MAAO,GAI7B,CAEA,OAAOyH,CAER,CAEA,aAAAixD,CAAe7+C,GAEd,IAAItO,EAAU,GAEd,GAAqB,WAAhBsO,GAA4C,YAAhBA,EAA4B,CAE5D,MAAM1a,EAAanB,KAAKouF,qBAExB,IAAIua,EAAW,EAEf,IAAM,MAAMhmG,KAAaxB,EAExBoM,GAAW,sBAAuBo7F,YAAsBhmG,EAAU4E,QAAU5E,EAAUD,SAIxF,CAEA,OAAO6K,CAER,CAEA,gBAAAq7F,CAAkBC,GAEjB,MAAMX,EAAW,GACXY,EAAUD,EAAOznB,iBAEvB,IAAM,IAAI/8E,EAAI,EAAGA,EAAIykG,EAAQ9kG,OAAQK,IAAO,CAE3C,MAAM0kG,EAASD,EAASzkG,GACxB6jG,EAASpiG,KAAM,sBAAsBzB,WAAY0kG,MAAW1kG,KAE7D,CAEA,OAAO6jG,EAASp3F,KAAM,KAEvB,CAEA,UAAAk4F,CAAYntF,GAEX,MAAMqsF,EAAW,GACXhe,EAAUlqF,KAAKkqF,QAASruE,GAE9B,GAAwB,IAAnBquE,EAAQlmF,OAEZ,MAAO,+CAIR,IAAM,IAAI1C,EAAQ,EAAG0C,EAASkmF,EAAQlmF,OAAQ1C,EAAQ0C,EAAQ1C,IAAW,CAExE,MAAMunG,EAAS3e,EAAS5oF,GAExB,IAAIiM,EAAU,KACdA,GAAWvN,KAAK4oG,iBAAkBC,GAClCt7F,GAAW,KAEX26F,EAASpiG,KAAMyH,EAEhB,CAEA,OAAO26F,EAASp3F,KAAM,OAEvB,CAEA,WAAAw9E,CAAazyE,GAEZ,IAAItO,EAAU,GAEd,MAAM+8E,EAAWtqF,KAAKsqF,SAEtB,GAAqB,WAAhBzuE,GAA4C,YAAhBA,EAEhC,IAAM,MAAMK,KAAWouE,EAAW,CAEZ,YAAhBzuE,IAA4BK,EAAQG,oBAAqB,GAC9D,MAAM9U,EAAOvH,KAAK6Q,QAASqL,EAAQ3U,MAGnCgG,GAAW,GAFEhG,EAAK4O,SAAU,QAAW5O,EAAK4O,SAAU,OAAU5O,EAAK4O,SAAU,MAAS,QAAU,KAE7E+F,EAAQG,mBAAqB,MAAQ,aAAa9U,KAAQ2U,EAAQxZ,SAExF,MAEM,GAAqB,aAAhBmZ,EAEX,IAAM,MAAMK,KAAWouE,EAEtB,GAAKpuE,EAAQG,mBAAqB,CAEjC,MAAM9U,EAAOvH,KAAK6Q,QAASqL,EAAQ3U,MAGnCgG,GAAW,GAFEhG,EAAK4O,SAAU,QAAW5O,EAAK4O,SAAU,OAAU5O,EAAK4O,SAAU,MAAS,QAAU,QAE1E5O,KAAQ2U,EAAQxZ,SAEzC,CAMF,IAAM,MAAMsyC,KAAWh1C,KAAK4mG,SAAU/qF,GAErCtO,GAAW,GAAGynC,OAIf,OAAOznC,CAER,CAEA,cAAA06B,GAEC,MAAO,qBAER,CAEA,gBAAAE,GAEC,MAAO,uBAER,CAEA,uBAAAI,GAMC,MAAO,2BAJevoC,KAAKM,OAAOqwB,cAEPtgB,QAAQ,CAAE44F,EAAKC,IAAUD,EAAMC,GAAM,KAIjE,CAEA,YAAA7gE,GAIC,OAFmBroC,KAAK8C,SAASw6D,QAAQqpC,WAEzBhmG,IAAK,oBAEb,oBAID,IAER,CAEA,cAAAy5B,GAEC,MAAO,gBAER,CAEA,YAAA0Y,GAEC,MAAO,iBAER,CAEA,YAAAqB,GAEC,MAAO,cAER,CAEA,eAAAg1D,CAAiBzmG,EAAM0mG,EAAUvtF,EAAc7b,KAAK6b,aAEnD,MAAMvE,EAAMtX,KAAK2mG,WAAY9qF,KAAmB7b,KAAK2mG,WAAY9qF,GAAgB,IAAInV,MAE5D,IAApB4Q,EAAI3W,IAAK+B,IAEb4U,EAAI9U,IAAKE,EAAM,CACdA,OACA0mG,YAKH,CAEA,aAAAC,CAAextF,GAEd,MAAMqsF,EAAW,GAEjB,GAAqB,WAAhBrsF,EAA2B,CAE/B,MAAMytF,EAAMtpG,KAAK8C,SAASw6D,QAAQqpC,WACZ3mG,KAAKM,OAAO25C,eAEZqvD,EAAI3oG,IAAK,qBAE9BX,KAAKmpG,gBAAiB,sBAAuB,UAAWttF,EAI1D,CAEA,MAAM8qF,EAAa3mG,KAAK2mG,WAAY9qF,GAEpC,QAAoB9a,IAAf4lG,EAEJ,IAAM,MAAM,KAAEjkG,EAAI,SAAE0mG,KAAczC,EAAW9gG,SAE5CqiG,EAASpiG,KAAM,cAAcpD,OAAU0mG,KAMzC,OAAOlB,EAASp3F,KAAM,KAEvB,CAEA,eAAA2lC,GAEC,MAAO,iBAER,CAEA,WAAAv4B,CAAaxb,GAEZ,IAAIqK,EAASs5F,GAAY3jG,GAEzB,QAAgB3B,IAAXgM,EAAuB,CAE3B,IAAIw8F,EAIJ,OAFAx8F,GAAS,EAEArK,GAER,IAAK,oBACJ6mG,EAAgB,2BAChB,MAED,IAAK,eACJA,EAAgB,2BAKlB,QAAuBxoG,IAAlBwoG,EAA8B,CAElC,MAAM5C,EAAa3mG,KAAK8C,SAASw6D,QAAQqpC,WAEpCA,EAAWhmG,IAAK4oG,KAEpB5C,EAAW7lG,IAAKyoG,GAChBx8F,GAAS,EAIX,CAEAs5F,GAAY3jG,GAASqK,CAEtB,CAEA,OAAOA,CAER,CAEA,OAAAooB,GAEC,OAAO,CAER,CAEA,sBAAAohB,CAAwBizD,GAEvBxpG,KAAKmpG,gBAAiB,8BAA+B,WAErDnpG,KAAK4mG,SAAmB,OAAE9gG,KAAM,8BAA+B0jG,MAEhE,CAEA,iBAAAC,CAAmBC,EAAaC,GAE/B3pG,KAAK8gE,WAAWh7D,KAAM,CAAE4jG,cAAaC,iBAEtC,CAEA,aAAAC,GAEC,MAAM9oC,EAAa9gE,KAAK8gE,WAExB,IAAIvzD,EAAU,GAEd,IAAM,IAAIlJ,EAAI,EAAGA,EAAIy8D,EAAW98D,OAAQK,IAAO,CAE9C,MAAMwlG,EAAY/oC,EAAYz8D,GAExByuB,EAAgB9yB,KAAKkQ,gBAAiB25F,EAAUF,eAEtDp8F,GAAW,GAAIs8F,EAAUH,iBAAmB52E,QAE7C,CAEA,OAAOvlB,CAER,CAEA,qBAAAk7F,CAAuB/lG,EAAM8nF,GAE5B,MAAO,8BACkB9nF,QACzB8nF,OAGD,CAEA,kBAAAsf,CAAoBC,GAEnB,MAAO,sBAEN/pG,KAAKivF,qCAGN8a,EAAWpD,+BAGVH,sBAGDuD,EAAW14B,4BAGX04B,EAAWzf,8BAGXyf,EAAW5oG,2BAGX4oG,EAAWxf,0CAKVwf,EAAWvf,8BAGXuf,EAAWjpC,8BAGXipC,EAAWtf,sCAOb,CAEA,oBAAAuf,CAAsBD,GAErB,MAAO,sBAEN/pG,KAAKivF,mCAGLuX,sBAGDuD,EAAW14B,4BAGX04B,EAAWzf,yBAGXyf,EAAWxf,YAEXwf,EAAW7f,4CAKV6f,EAAWvf,wBAGXuf,EAAWtf,aAKb,CAEA,SAAAiE,GAEC,MAAMub,EAAgC,OAAlBjqG,KAAKiB,SAAoB,CAAEigE,SAAU,CAAC,EAAGrnB,OAAQ,CAAC,GAAM,CAAE3oB,QAAS,CAAC,GAExFlxB,KAAKurF,oBAEL,IAAM,MAAM1vE,KAAeouF,EAAc,CAExC,IAAIxf,EAAO,cACXA,GAAQzqF,KAAKiqF,SAAUpuE,GAEvB,MAAMmuE,EAAYhqF,KAAKgqF,UAAWnuE,GAC5BquF,EAAWlgB,EAAWA,EAAUhmF,OAAS,GAE/C,IAAM,MAAMmC,KAAQ6jF,EAAY,CAE/B,MAAMmgB,EAAenqG,KAAKitF,YAAa9mF,GACjCikG,EAAWjkG,EAAKzD,KAEjB0nG,IAEC3f,EAAKzmF,OAAS,IAAIymF,GAAQ,MAE/BA,GAAQ,gBAAiB2f,SAI1B3f,GAAQ,GAAI0f,EAAavpC,WAEpBz6D,IAAS+jG,GAA4B,YAAhBruF,IAEzB4uE,GAAQ,gBAEa,WAAhB5uE,GAEJ4uE,GAAQ,iBACRA,GAAQ,GAAI0f,EAAap9F,WAEE,aAAhB8O,IAEJ1V,EAAK2F,WAAWwtC,qBAEtBmxC,GAAQ,eACRA,GAAQ,GAAI0f,EAAap9F,YAQ7B,CAEA,MAAMs9F,EAAYJ,EAAapuF,GAE/BwuF,EAAU1D,WAAa3mG,KAAKqpG,cAAextF,GAC3CwuF,EAAUh5B,SAAWrxE,KAAKuuF,YAAa1yE,GACvCwuF,EAAUlpG,WAAanB,KAAK06D,cAAe7+C,GAC3CwuF,EAAU/f,SAAWtqF,KAAKsuF,YAAazyE,GACvCwuF,EAAU7f,KAAOxqF,KAAKiuF,QAASpyE,GAC/BwuF,EAAUngB,QAAUlqF,KAAKgpG,WAAYntF,GACrCwuF,EAAU9f,MAAQvqF,KAAKwuF,SAAU3yE,GACjCwuF,EAAUvpC,WAAa9gE,KAAK4pG,cAAe/tF,GAC3CwuF,EAAU5f,KAAOA,CAElB,CAEuB,OAAlBzqF,KAAKiB,UAETjB,KAAKiiE,aAAejiE,KAAK8pG,mBAAoBG,EAAYpwD,QACzD75C,KAAKmiE,eAAiBniE,KAAKgqG,qBAAsBC,EAAY/oC,WAI7DlhE,KAAKwhE,cAAgBxhE,KAAK8pG,mBAAoBG,EAAY/4E,QAI5D,CAEA,kBAAAtV,CAAoBzV,EAAMoB,EAAMsU,EAAanZ,EAAO,MAEnD,MAAMo2B,EAAcpvB,MAAMkS,mBAAoBzV,EAAMoB,EAAMsU,EAAanZ,GACjE2K,EAAWrN,KAAKsN,gBAAiBnH,EAAM0V,EAAa7b,KAAKwvB,aAE/D,IAAI86E,EAAaj9F,EAASi9F,WAE1B,QAAoBvpG,IAAfupG,EAA2B,CAE/B,MAAMlvF,EAAQjV,EAAK8U,UACbgwE,EAAY7vE,EAAM1Y,KAElBk6D,EAAW58D,KAAKorF,kBAAmBH,EAAWpvE,GAEpD,GAAc,YAATtU,EAEJ+iG,EAAa,IAAI3E,GAAoB7sE,EAAYp2B,KAAMo2B,EAAY3yB,KAAMiV,GACzEwhD,EAAS92D,KAAMwkG,QAET,GAAc,gBAAT/iG,EAEX+iG,EAAa,IAAIzE,GAAwB/sE,EAAYp2B,KAAMo2B,EAAY3yB,KAAMiV,GAC7EwhD,EAAS92D,KAAMwkG,QAET,GAAc,cAAT/iG,EAEX+iG,EAAa,IAAIvE,GAAsBjtE,EAAYp2B,KAAMo2B,EAAY3yB,KAAMiV,GAC3EwhD,EAAS92D,KAAMwkG,QAET,GAAc,WAAT/iG,EAAoB,CAE/BpB,EAAKzD,KAAO,cAAeyD,EAAK/C,KAChC01B,EAAYp2B,KAAO,SAAUyD,EAAK/C,KAElC,MAAMkF,EAAS,IAAI47F,GAAmB/9F,EAAMiV,GAC5C9S,EAAO5F,KAAOyD,EAAKzD,KAEnBk6D,EAAS92D,KAAMwC,GAEfgiG,EAAahiG,CAEd,KAAO,CAEN,MAAMiiG,EAAgBvqG,KAAK0mG,cAAe7qF,KAAmB7b,KAAK0mG,cAAe7qF,GAAgB,CAAC,GAElG,IAAI2uF,EAAgBD,EAAetf,QAEZlqF,IAAlBypG,IAEJA,EAAgB,IAAIjF,GAAmB1pF,EAAc,IAAMovE,EAAW7vE,GAGtEmvF,EAAetf,GAAcuf,EAE7B5tC,EAAS92D,KAAM0kG,IAIhBF,EAAatqG,KAAK4uF,eAAgB91D,EAAavxB,GAE/CijG,EAAclG,WAAYgG,EAE3B,CAEAj9F,EAASi9F,WAAaA,CAEvB,CAEA,OAAOxxE,CAER,EAID,IAAI2xE,GAAW,KACXC,GAAU,KAcd,MAAMC,GAOL,WAAA7qG,CAAa2e,EAAa,CAAC,GAO1Bze,KAAKye,WAAa5a,OAAOsQ,OAAQ,CAAC,EAAGsK,GAQrCze,KAAKa,KAAO,IAAIX,QAQhBF,KAAK8C,SAAW,KAQhB9C,KAAKm5F,WAAa,IAEnB,CAWA,UAAMjU,CAAMpiF,GAEX9C,KAAK8C,SAAWA,CAEjB,CASA,oBAAI4f,GAAoB,CAYxB,WAAAm8E,GAAkC,CAUlC,YAAAE,GAAmC,CAUnC,YAAA6B,GAAkC,CAUlC,aAAAI,GAAmC,CAWnC,IAAAqC,GAAiC,CAajC,OAAAnyE,GAA6E,CAU7E,aAAAwwC,GAA+B,CAQ/B,cAAAkpC,GAAgC,CAahC,cAAAvwC,GAAiE,CAWjE,cAAAqK,GAAiE,CAQjE,aAAAb,GAA+B,CAW/B,oBAAAtB,GAAqD,CASrD,qBAAAD,GAAyD,CAWzD,iBAAAI,GAAwC,CASxC,iBAAAF,GAAwC,CAYxC,iBAAAqyB,GAAkD,CAUlD,aAAA9rB,GAA+B,CAQ/B,cAAAJ,GAA+B,CAS/B,oBAAAS,GAAsC,CAStC,aAAAJ,GAA2C,CAS3C,aAAA5F,GAA6C,CAQ7C,eAAA9vB,GAAiC,CAQjC,cAAAs1B,GAAgC,CAchC,mBAAAi5B,GAAoE,CAYpE,oBAAAP,GAAqG,CAUrG,wBAAA7tD,GAAmE,CAUnE,eAAAgqB,GAAmC,CAQnC,oBAAAC,GAAwC,CAQxC,sBAAAC,GAA0C,CAQ1C,eAAAG,GAAmC,CAQnC,gBAAAN,GAAoC,CAUpC,UAAApyC,GAAe,CAQf,UAAAk0E,GAAe,CAQf,cAAA0D,GAAqC,CAcrC,UAAA7C,GAAyC,CAWzC,2BAAMlD,GAAmD,CAUzD,gBAAMC,GAAc,CAUpB,qBAAM+D,GAA8B,CASpC,UAAAC,GAAwB,CAQxB,gBAAAhC,GAAoB,CAOpB,oBAAAzsD,GAIC,OAFAg4D,GAAWA,IAAY,IAAI,MAEpBzqG,KAAK8C,SAAS2vC,qBAAsBg4D,GAE5C,CAQA,cAAAh2B,GAAgC,CAQhC,aAAAV,GAEC,MAAMjxE,EAAW9C,KAAK8C,SAQtB,OANA4nG,GAAUA,IAAW,IAAIlhC,GAEzB1mE,EAASixE,cAAe22B,IAExBA,GAAQhsB,OAAQgsB,GAAS1qG,KAAK8C,SAASmzF,mBAEhCyU,EAER,CAQA,aAAAtR,GAEC,IAAID,EAAan5F,KAAKm5F,WAatB,OAXoB,OAAfA,IAEJA,OAA0Cp4F,IAA3Bf,KAAKye,WAAWosF,OAAyB7qG,KAAKye,WAAWosF,QAAS,WAG5E,iBAAkB1R,GAAaA,EAAW9uB,aAAc,cAAe,aAAa,gBAEzFrqE,KAAKm5F,WAAaA,GAIZA,CAER,CASA,GAAA32F,CAAKlC,EAAQ4C,GAEZlD,KAAKa,KAAK2B,IAAKlC,EAAQ4C,EAExB,CAQA,GAAApC,CAAKR,GAEJ,IAAIgX,EAAMtX,KAAKa,KAAKC,IAAKR,GASzB,YAPaS,IAARuW,IAEJA,EAAM,CAAC,EACPtX,KAAKa,KAAK2B,IAAKlC,EAAQgX,IAIjBA,CAER,CASA,GAAA3W,CAAKL,GAEJ,OAAON,KAAKa,KAAKF,IAAKL,EAEvB,CAOA,OAAQA,GAEPN,KAAKa,KAAKmvC,OAAQ1vC,EAEnB,CAOA,OAAA2K,GAAY,EAIb,IAAI6/F,GAAQ,EAEZ,MAAMC,GAEL,WAAAjrG,CAAay9D,EAAeytC,GAE3BhrG,KAAKirG,QAAU,CAAE1tC,EAAc2tC,UAAWF,GAC1ChrG,KAAKuH,KAAOg2D,EAAch2D,KAC1BvH,KAAK+uB,WAAawuC,EAAcxuC,WAChC/uB,KAAKgnG,IAAMzpC,EAAcypC,IACzBhnG,KAAK8jG,WAAavmC,EAAcumC,WAChC9jG,KAAK2jG,gBAAkBpmC,EAAcqmC,kBACrC5jG,KAAKuB,QAAUg8D,EAAch8D,QAC7BvB,KAAKoO,UAAYmvD,EAAcnvD,UAC/BpO,KAAKmrG,kBAAoB,EACzBnrG,KAAKorG,OAAS7tC,EAAcn6D,EAE7B,CAGA,MAAIA,GAEH,MAAO,GAAIpD,KAAKorG,UAAYprG,KAAKmrG,mBAElC,CAEA,aAAID,GAEH,OAAOlrG,KAAKirG,QAASjrG,KAAKmrG,kBAE3B,CAEA,mBAAIE,GAEH,OAAOrrG,KAAKirG,QAAkC,EAAzBjrG,KAAKmrG,kBAE3B,CAEA,aAAAG,GAECtrG,KAAKmrG,mBAAqB,CAE3B,EAID,MAAMI,GAEL,WAAAzrG,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,CAEhB,CAEA,eAAAG,CAAiB96D,EAAWosB,GAE3B,MAAMuuC,EAAUt9D,KAAKs9D,SACf,GAAExb,GAAOwb,EAET93D,EAAQ7C,EAAU6C,MAClB2pB,EAAQxsB,EAAUwsB,OAAS2yB,EAAG0pD,YAE9Bx7E,EAAkBrtB,EAAUk4D,6BAA+Bl4D,EAAU9B,KAAO8B,EAC5E4sB,EAAa+tC,EAAQx8D,IAAKkvB,GAEhC,IAcIzoB,EAdA2jG,EAAY37E,EAAW27E,UAgB3B,QAdmBnqG,IAAdmqG,IAEJA,EAAYlrG,KAAKyrG,cAAe3pD,EAAI/yB,EAAYvpB,EAAO2pB,GAEvDI,EAAW27E,UAAYA,EACvB37E,EAAWR,WAAaA,EACxBQ,EAAWhuB,QAAUyuB,EAAgBzuB,SAQjCiE,aAAiB23B,aAErB51B,EAAOu6C,EAAG4pD,WAEJ,GAAKlmG,aAAiBokF,YAI3BriF,EAFI5E,EAAUgpG,yBAEP7pD,EAAG8pD,WAIH9pD,EAAG+pD,oBAIL,GAAKrmG,aAAiBmkF,WAE5BpiF,EAAOu6C,EAAGgqD,WAEJ,GAAKtmG,aAAiB83B,YAE5B/1B,EAAOu6C,EAAGiqD,kBAEJ,GAAKvmG,aAAiB63B,WAE5B91B,EAAOu6C,EAAGkqD,SAEJ,GAAKxmG,aAAiBkkF,UAE5BniF,EAAOu6C,EAAGmqD,UAEJ,GAAKzmG,aAAiBsC,WAE5BP,EAAOu6C,EAAGoqD,kBAEJ,MAAK1mG,aAAiB4hG,mBAM5B,MAAM,IAAI/zF,MAAO,uDAAyD7N,GAJ1E+B,EAAOu6C,EAAGoqD,aAMX,CAEA,IAAI3uC,EAAgB,CACnB2tC,YACAn8E,aACAxnB,OACAu8F,WAAYt+F,EAAMs+F,WAClBH,gBAAiBn+F,EAAMo+F,kBACvBriG,QAASoB,EAAUpB,QACnBylG,IAAKrkG,EAAUqkG,IACf54F,UAAW7G,IAASu6C,EAAGkqD,KAAOzkG,IAASu6C,EAAGiqD,cAAgBppG,EAAU+lG,UAAY,MAChFtlG,GAAI0nG,MAGL,GAAKnoG,EAAUo8D,0BAA4Bp8D,EAAUq8D,kCAAoC,CAGxF,MAAMmtC,EAAgBnsG,KAAKyrG,cAAe3pD,EAAI/yB,EAAYvpB,EAAO2pB,GACjEouC,EAAgB,IAAIwtC,GAAmBxtC,EAAe4uC,EAEvD,CAEA7uC,EAAQ96D,IAAKG,EAAW46D,EAEzB,CAEA,eAAAO,CAAiBn7D,GAEhB,MAAM26D,EAAUt9D,KAAKs9D,SACf,GAAExb,GAAOwb,EAET93D,EAAQ7C,EAAU6C,MAClBwqB,EAAkBrtB,EAAUk4D,6BAA+Bl4D,EAAU9B,KAAO8B,EAC5E4sB,EAAa+tC,EAAQx8D,IAAKkvB,GAC1BjB,EAAaQ,EAAWR,WACxBq9E,EAAezpG,EAAUk4D,6BAA+Bl4D,EAAU9B,KAAKurG,aAAezpG,EAAUypG,aAItG,GAFAtqD,EAAGuqD,WAAYt9E,EAAYQ,EAAW27E,WAET,IAAxBkB,EAAapoG,OAIjB89C,EAAGwqD,cAAev9E,EAAY,EAAGvpB,OAE3B,CAEN,IAAM,IAAInB,EAAI,EAAG+oC,EAAIg/D,EAAapoG,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAEvD,MAAMkoG,EAAQH,EAAc/nG,GAC5By9C,EAAGwqD,cAAev9E,EAAYw9E,EAAM9qG,MAAQ+D,EAAMo+F,kBACjDp+F,EAAO+mG,EAAM9qG,MAAO8qG,EAAM7qG,MAE5B,CAEAsuB,EAAgBw8E,mBAEjB,CAEA1qD,EAAGuqD,WAAYt9E,EAAY,MAE3BQ,EAAWhuB,QAAUyuB,EAAgBzuB,OAEtC,CAEA,gBAAAi8D,CAAkB76D,GAEjB,MAAM26D,EAAUt9D,KAAKs9D,SACf,GAAExb,GAAOwb,EAEV36D,EAAUk4D,8BAEdyC,EAAQttB,OAAQrtC,EAAU9B,MAI3B,MAAM08D,EAAgBD,EAAQx8D,IAAK6B,GAEnCm/C,EAAG2qD,aAAclvC,EAAc2tC,WAE/B5tC,EAAQttB,OAAQrtC,EAEjB,CAEA,yBAAMw8F,CAAqBx8F,GAE1B,MAAM26D,EAAUt9D,KAAKs9D,SACf,GAAExb,GAAOwb,EAETttC,EAAkBrtB,EAAUk4D,6BAA+Bl4D,EAAU9B,KAAO8B,GAC5E,UAAEuoG,GAAc5tC,EAAQx8D,IAAKkvB,GAE7BxqB,EAAQ7C,EAAU6C,MAClBs+F,EAAat+F,EAAMs+F,WAEzBhiD,EAAGuqD,WAAYvqD,EAAG4qD,iBAAkBxB,GAEpC,MAAMyB,EAAc7qD,EAAG8qD,eAEvB9qD,EAAGuqD,WAAYvqD,EAAG+qD,kBAAmBF,GACrC7qD,EAAGvyB,WAAYuyB,EAAG+qD,kBAAmB/I,EAAYhiD,EAAGgrD,aAEpDhrD,EAAGirD,kBAAmBjrD,EAAG4qD,iBAAkB5qD,EAAG+qD,kBAAmB,EAAG,EAAG/I,SAEjExmC,EAAQ0vC,MAAMC,mBAEpB,MAAMC,EAAY,IAAIvqG,EAAU6C,MAAM1F,YAAa0F,EAAMxB,QAYzD,OATA89C,EAAGuqD,WAAYvqD,EAAG+qD,kBAAmBF,GAErC7qD,EAAGqrD,iBAAkBrrD,EAAG+qD,kBAAmB,EAAGK,GAE9CprD,EAAG2qD,aAAcE,GAEjB7qD,EAAGuqD,WAAYvqD,EAAG4qD,iBAAkB,MACpC5qD,EAAGuqD,WAAYvqD,EAAG+qD,kBAAmB,MAE9BK,EAAU5kG,MAElB,CAEA,aAAAmjG,CAAe3pD,EAAI/yB,EAAYvpB,EAAO2pB,GAErC,MAAM+7E,EAAYppD,EAAG8qD,eAMrB,OAJA9qD,EAAGuqD,WAAYt9E,EAAYm8E,GAC3BppD,EAAGvyB,WAAYR,EAAYvpB,EAAO2pB,GAClC2yB,EAAGuqD,WAAYt9E,EAAY,MAEpBm8E,CAER,EAID,IAA2BkC,GAAcC,GAArCC,IAAgB,EAEpB,MAAMC,GAEL,WAAAztG,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EAEft9D,KAAK8hD,GAAK9hD,KAAKs9D,QAAQxb,GAEvB9hD,KAAK6sB,QAAU,CAAC,EAChB7sB,KAAKwtG,iBAAmB,KACxBxtG,KAAKytG,gBAAkB,KACvBztG,KAAK0tG,eAAiB,KACtB1tG,KAAK2tG,wBAAyB,EAC9B3tG,KAAK4tG,gBAAkB,KACvB5tG,KAAK6tG,gBAAkB,KACvB7tG,KAAK8tG,gBAAkB,KACvB9tG,KAAK+tG,qBAAuB,KAC5B/tG,KAAKguG,qBAAuB,KAC5BhuG,KAAKiuG,yBAA2B,KAChCjuG,KAAKkuG,2BAA6B,KAClCluG,KAAKmuG,0BAA4B,KACjCnuG,KAAKouG,iBAAmB,KACxBpuG,KAAKquG,iBAAmB,KACxBruG,KAAKsuG,iBAAmB,KACxBtuG,KAAKuuG,mBAAqB,KAC1BvuG,KAAKwuG,kBAAoB,KACzBxuG,KAAKyuG,uBAAyB,KAC9BzuG,KAAK0uG,mBAAqB,KAC1B1uG,KAAK2uG,oBAAsB,KAC3B3uG,KAAK4uG,oBAAsB,KAC3B5uG,KAAK6uG,mBAAqB,KAC1B7uG,KAAK8uG,iBAAmB,KACxB9uG,KAAK+uG,sBAAwB,EAE7B/uG,KAAKgvG,yBAA2B,CAAC,EACjChvG,KAAKivG,mBAAqB,IAAI/uG,QAE9BF,KAAKkvG,YAAclvG,KAAK8hD,GAAGqtD,aAAcnvG,KAAK8hD,GAAGstD,yBACjDpvG,KAAKqvG,mBAAqB,KAC1BrvG,KAAKsvG,qBAAuB,CAAC,EAC7BtvG,KAAKuvG,wBAA0B,CAAC,GAET,IAAlBjC,KAEJttG,KAAK8iE,MAAO9iE,KAAK8hD,IAEjBwrD,IAAgB,EAIlB,CAEA,KAAAxqC,CAAOhhB,GAINsrD,GAAe,CACd,CAAE,OAAetrD,EAAG0tD,SACpB,CAAE,OAAoB1tD,EAAG2tD,cACzB,CAAE,OAA2B3tD,EAAG4tD,uBAGjCrC,GAAa,CACZ,CAAE,OAAcvrD,EAAG6tD,KACnB,CAAE,OAAa7tD,EAAG8tD,IAClB,CAAE,OAAkB9tD,EAAG+tD,UACvB,CAAE,OAAkB/tD,EAAGguD,UACvB,CAAE,OAA0BhuD,EAAGiuD,mBAC/B,CAAE,OAAkBjuD,EAAGkuD,UACvB,CAAE,OAAkBluD,EAAGmuD,UACvB,CAAE,OAA0BnuD,EAAGouD,oBAC/B,CAAE,OAA0BpuD,EAAGquD,oBAC/B,CAAE,OAA0BruD,EAAGsuD,oBAC/B,CAAE,OAA0BtuD,EAAGuuD,oBAGjC,CAEA,MAAAC,CAAQltG,GAEP,MAAM,QAAEypB,GAAY7sB,MAEG,IAAlB6sB,EAASzpB,KAEbpD,KAAK8hD,GAAGwuD,OAAQltG,GAChBypB,EAASzpB,IAAO,EAIlB,CAEA,OAAAmtG,CAASntG,GAER,MAAM,QAAEypB,GAAY7sB,MAEG,IAAlB6sB,EAASzpB,KAEbpD,KAAK8hD,GAAGyuD,QAASntG,GACjBypB,EAASzpB,IAAO,EAIlB,CAEA,YAAAotG,CAAcC,GAEb,GAAKzwG,KAAKwtG,mBAAqBiD,EAAY,CAE1C,MAAM,GAAE3uD,GAAO9hD,KAEVywG,EAEJ3uD,EAAG4uD,UAAW5uD,EAAG6uD,IAIjB7uD,EAAG4uD,UAAW5uD,EAAG8uD,KAIlB5wG,KAAKwtG,iBAAmBiD,CAEzB,CAED,CAEA,WAAAI,CAAaC,GAEZ,MAAM,GAAEhvD,GAAO9hD,KAEV8wG,IAAa,OAEjB9wG,KAAKswG,OAAQxuD,EAAGivD,WAEXD,IAAa9wG,KAAKytG,kBAEjBqD,IAAa,MAEjBhvD,EAAGgvD,SAAUhvD,EAAGkvD,MAELF,IAAa,MAExBhvD,EAAGgvD,SAAUhvD,EAAGmvD,OAIhBnvD,EAAGgvD,SAAUhvD,EAAGovD,kBAQlBlxG,KAAKuwG,QAASzuD,EAAGivD,WAIlB/wG,KAAKytG,gBAAkBqD,CAExB,CAEA,YAAAK,CAAchvG,GAEb,MAAM,iBAAE2sG,EAAgB,GAAEhtD,GAAO9hD,KAE5BmC,IAAU2sG,IAEdhtD,EAAGsvD,UAAWjvG,GAEdnC,KAAK8uG,iBAAmB3sG,EAI1B,CAGA,WAAAkvG,CAAa92D,EAAU+2D,EAAeC,EAAUC,EAAUC,EAAoBC,EAAeC,EAAeC,GAE3G,MAAM,GAAE9vD,GAAO9hD,KAEf,GAAKu6C,IAAa,OAoBlB,IAPqC,IAAhCv6C,KAAK2tG,yBAET3tG,KAAKswG,OAAQxuD,EAAG+vD,OAChB7xG,KAAK2tG,wBAAyB,GAI1BpzD,IAAa,MAmFlBk3D,EAAqBA,GAAsBH,EAC3CI,EAAgBA,GAAiBH,EACjCI,EAAgBA,GAAiBH,EAE5BF,IAAkBtxG,KAAK8xG,sBAAwBL,IAAuBzxG,KAAK+xG,4BAE/EjwD,EAAGkwD,sBAAuB5E,GAAckE,GAAiBlE,GAAcqE,IAEvEzxG,KAAK8xG,qBAAuBR,EAC5BtxG,KAAK+xG,0BAA4BN,GAI7BF,IAAavxG,KAAK6tG,iBAAmB2D,IAAaxxG,KAAK8tG,iBAAmB4D,IAAkB1xG,KAAK+tG,sBAAwB4D,IAAkB3xG,KAAKguG,uBAEpJlsD,EAAGmwD,kBAAmB5E,GAAYkE,GAAYlE,GAAYmE,GAAYnE,GAAYqE,GAAiBrE,GAAYsE,IAE/G3xG,KAAK6tG,gBAAkB0D,EACvBvxG,KAAK8tG,gBAAkB0D,EACvBxxG,KAAK+tG,qBAAuB2D,EAC5B1xG,KAAKguG,qBAAuB2D,GAI7B3xG,KAAK4tG,gBAAkBrzD,EACvBv6C,KAAKiuG,0BAA2B,OA1G/B,GAAK1zD,IAAav6C,KAAK4tG,iBAAmBgE,IAAuB5xG,KAAKiuG,yBAA2B,CAWhG,GATKjuG,KAAK8xG,uBAAyB,OAAe9xG,KAAK+xG,4BAA8B,QAEpFjwD,EAAGwvD,cAAexvD,EAAG0tD,UAErBxvG,KAAK8xG,qBAAuB,MAC5B9xG,KAAK+xG,0BAA4B,OAI7BH,EAEJ,OAASr3D,GAER,KAAK,MACJuH,EAAGmwD,kBAAmBnwD,EAAG8tD,IAAK9tD,EAAGquD,oBAAqBruD,EAAG8tD,IAAK9tD,EAAGquD,qBACjE,MAED,KAAK,MACJruD,EAAGowD,UAAWpwD,EAAG8tD,IAAK9tD,EAAG8tD,KACzB,MAED,KAAK,MACJ9tD,EAAGmwD,kBAAmBnwD,EAAG6tD,KAAM7tD,EAAGouD,oBAAqBpuD,EAAG6tD,KAAM7tD,EAAG8tD,KACnE,MAED,KAAK,MACJ9tD,EAAGmwD,kBAAmBnwD,EAAG6tD,KAAM7tD,EAAG+tD,UAAW/tD,EAAG6tD,KAAM7tD,EAAGguD,WACzD,MAED,QACCrjG,QAAQkiB,MAAO,uCAAwC4rB,QAOzD,OAASA,GAER,KAAK,MACJuH,EAAGmwD,kBAAmBnwD,EAAGguD,UAAWhuD,EAAGquD,oBAAqBruD,EAAG8tD,IAAK9tD,EAAGquD,qBACvE,MAED,KAAK,MACJruD,EAAGowD,UAAWpwD,EAAGguD,UAAWhuD,EAAG8tD,KAC/B,MAED,KAAK,MACJ9tD,EAAGmwD,kBAAmBnwD,EAAG6tD,KAAM7tD,EAAGouD,oBAAqBpuD,EAAG6tD,KAAM7tD,EAAG8tD,KACnE,MAED,KAAK,MACJ9tD,EAAGowD,UAAWpwD,EAAG6tD,KAAM7tD,EAAG+tD,WAC1B,MAED,QACCpjG,QAAQkiB,MAAO,uCAAwC4rB,GAO1Dv6C,KAAK6tG,gBAAkB,KACvB7tG,KAAK8tG,gBAAkB,KACvB9tG,KAAK+tG,qBAAuB,KAC5B/tG,KAAKguG,qBAAuB,KAE5BhuG,KAAK4tG,gBAAkBrzD,EACvBv6C,KAAKiuG,yBAA2B2D,CAEjC,OA7FqC,IAAhC5xG,KAAK2tG,yBAET3tG,KAAKuwG,QAASzuD,EAAG+vD,OACjB7xG,KAAK2tG,wBAAyB,EA6HjC,CAEA,YAAAwE,CAAcC,GAERpyG,KAAKouG,mBAAqBgE,IAE9BpyG,KAAK8hD,GAAGswD,UAAWA,EAAWA,EAAWA,EAAWA,GACpDpyG,KAAKouG,iBAAmBgE,EAI1B,CAEA,YAAAC,CAAcz5D,GAEb,MAAM,GAAEkJ,GAAO9hD,KAEV44C,EAEJ54C,KAAKswG,OAAQxuD,EAAGwwD,YAIhBtyG,KAAKuwG,QAASzuD,EAAGwwD,WAInB,CAEA,YAAAC,CAAcC,GAERxyG,KAAKsuG,mBAAqBkE,IAE9BxyG,KAAK8hD,GAAG0wD,UAAWA,GACnBxyG,KAAKsuG,iBAAmBkE,EAI1B,CAEA,YAAAC,CAAcC,GAEb,GAAK1yG,KAAKquG,mBAAqBqE,EAAY,CAE1C,MAAM,GAAE5wD,GAAO9hD,KAEf,OAAS0yG,GAER,KAAK,MAEJ5wD,EAAG4wD,UAAW5wD,EAAG6wD,OACjB,MAED,KAAK,MAEJ7wD,EAAG4wD,UAAW5wD,EAAG8wD,QACjB,MAED,KAAK,MAEJ9wD,EAAG4wD,UAAW5wD,EAAG+wD,MACjB,MAED,KAAK,MAEJ/wD,EAAG4wD,UAAW5wD,EAAGgxD,QACjB,MAED,KAAK,MAEJhxD,EAAG4wD,UAAW5wD,EAAGixD,OACjB,MAED,KAAK,MAEJjxD,EAAG4wD,UAAW5wD,EAAGkxD,QACjB,MAED,KAAK,MAEJlxD,EAAG4wD,UAAW5wD,EAAGmxD,SACjB,MAED,KAAK,MAEJnxD,EAAG4wD,UAAW5wD,EAAGoxD,UACjB,MAED,QAECpxD,EAAG4wD,UAAW5wD,EAAGgxD,QAInB9yG,KAAKquG,iBAAmBqE,CAEzB,CAED,CAEA,cAAAS,CAAgBC,GAEf,MAAM,GAAEtxD,GAAO9hD,KAEVozG,EAEJpzG,KAAKswG,OAAQxuD,EAAGuxD,cAIhBrzG,KAAKuwG,QAASzuD,EAAGuxD,aAInB,CAEA,cAAAC,CAAgBC,GAEVvzG,KAAK6uG,qBAAuB0E,IAEhCvzG,KAAK8hD,GAAGyxD,YAAaA,GACrBvzG,KAAK6uG,mBAAqB0E,EAI5B,CAEA,cAAAC,CAAgBC,EAAaC,EAAYH,GAEnCvzG,KAAKuuG,qBAAuBkF,GAC/BzzG,KAAKwuG,oBAAsBkF,GAC3B1zG,KAAKyuG,yBAA2B8E,IAEjCvzG,KAAK8hD,GAAG2xD,YAAaA,EAAaC,EAAYH,GAE9CvzG,KAAKuuG,mBAAqBkF,EAC1BzzG,KAAKwuG,kBAAoBkF,EACzB1zG,KAAKyuG,uBAAyB8E,EAIhC,CAEA,YAAAI,CAAcC,EAAaC,EAAcC,GAEnC9zG,KAAK0uG,qBAAuBkF,GAC/B5zG,KAAK2uG,sBAAwBkF,GAC7B7zG,KAAK4uG,sBAAwBkF,IAE9B9zG,KAAK8hD,GAAGiyD,UAAWH,EAAaC,EAAcC,GAE9C9zG,KAAK0uG,mBAAqBkF,EAC1B5zG,KAAK2uG,oBAAsBkF,EAC3B7zG,KAAK4uG,oBAAsBkF,EAI7B,CAEA,WAAAE,CAAa/yG,EAAUgzG,EAAal6C,GAEnC,MAAM,GAAEjY,GAAO9hD,KAEfiB,EAASk5B,OAAS,MACfn6B,KAAKuwG,QAASzuD,EAAGivD,WACjB/wG,KAAKswG,OAAQxuD,EAAGivD,WAEnB,IAAIN,EAAcxvG,EAASk5B,OAAS,MAC/B85E,IAAcxD,GAAcA,GAEjCzwG,KAAKwwG,aAAcC,GAEjBxvG,EAASs5C,WAAa,QAA2C,IAAzBt5C,EAASq5C,YAChDt6C,KAAKqxG,YAAa,OAClBrxG,KAAKqxG,YAAapwG,EAASs5C,SAAUt5C,EAASqwG,cAAerwG,EAASswG,SAAUtwG,EAASuwG,SAAUvwG,EAASwwG,mBAAoBxwG,EAASywG,cAAezwG,EAAS0wG,cAAe1wG,EAAS2wG,oBAE5L5xG,KAAKyyG,aAAcxxG,EAASyxG,WAC5B1yG,KAAKqyG,aAAcpxG,EAAS23C,WAC5B54C,KAAKuyG,aAActxG,EAAS03C,YAC5B34C,KAAKmyG,aAAclxG,EAASizG,YAE5B,MAAMC,EAAelzG,EAASkzG,aAgB9B,GAfAn0G,KAAKmzG,eAAgBgB,GAChBA,IAEJn0G,KAAKszG,eAAgBryG,EAASmzG,kBAC9Bp0G,KAAKwzG,eAAgBvyG,EAASwyG,YAAaxyG,EAASyyG,WAAYzyG,EAASozG,iBACzEr0G,KAAK2zG,aAAc1yG,EAAS2yG,YAAa3yG,EAAS4yG,aAAc5yG,EAAS6yG,eAI1E9zG,KAAKs0G,iBAAkBrzG,EAASszG,cAAetzG,EAASuzG,oBAAqBvzG,EAASwzG,qBAEzD,IAA7BxzG,EAASw4C,iBAA4Bz5C,KAAKs9D,QAAQx6D,SAAS02C,QAAU,EAClEx5C,KAAKswG,OAAQxuD,EAAG4yD,0BAChB10G,KAAKuwG,QAASzuD,EAAG4yD,0BAEf36C,EAAyB,GAExB/5D,KAAK+uG,wBAA0Bh1C,EAAyB,CAE5D,MAAM46C,EAAuB,MAE7B,IAAM,IAAItwG,EAAI,EAAGA,EAAI,EAAGA,IAElBA,EAAI01D,EAER/5D,KAAKswG,OAAQqE,EAAuBtwG,GAIpCrE,KAAKuwG,QAASoE,EAAuBtwG,EAMxC,CAIF,CAEA,gBAAAiwG,CAAkBC,EAAen/F,EAAQw/F,GAExC,MAAM,GAAE9yD,GAAO9hD,KAEVu0G,GAEJv0G,KAAKswG,OAAQxuD,EAAG+yD,qBAEX70G,KAAKkuG,6BAA+B94F,GAAUpV,KAAKmuG,4BAA8ByG,IAErF9yD,EAAGyyD,cAAen/F,EAAQw/F,GAE1B50G,KAAKkuG,2BAA6B94F,EAClCpV,KAAKmuG,0BAA4ByG,IAMlC50G,KAAKuwG,QAASzuD,EAAG+yD,oBAInB,CAEA,UAAAC,CAAYryC,GAEX,OAAKziE,KAAK0tG,iBAAmBjrC,IAE5BziE,KAAK8hD,GAAGgzD,WAAYryC,GAEpBziE,KAAK0tG,eAAiBjrC,GAEf,EAMT,CAKA,eAAAsyC,CAAiB32F,EAAQ42F,GAExB,MAAM,GAAElzD,EAAE,yBAAEktD,GAA6BhvG,KAEzC,OAAKgvG,EAA0B5wF,KAAa42F,IAE3ClzD,EAAGizD,gBAAiB32F,EAAQ42F,GAE5BhG,EAA0B5wF,GAAW42F,EAIhC52F,IAAW0jC,EAAGmzD,mBAElBjG,EAA0BltD,EAAGozD,aAAgBF,GAIzC52F,IAAW0jC,EAAGozD,cAElBlG,EAA0BltD,EAAGmzD,kBAAqBD,IAI5C,EAMT,CAEA,WAAAG,CAAav8C,EAAeo8C,GAE3B,MAAM,GAAElzD,GAAO9hD,KAEf,IAAIm1G,EAAc,GAEd/qG,GAAc,EAElB,GAAgC,OAA3BwuD,EAAclqD,SAAoB,CAEtCymG,EAAcn1G,KAAKivG,mBAAmBnuG,IAAKk0G,QAEtBj0G,IAAhBo0G,IAEJA,EAAc,GACdn1G,KAAKivG,mBAAmBzsG,IAAKwyG,EAAaG,IAK3C,MAAMzmG,EAAWkqD,EAAclqD,SAE/B,GAAKymG,EAAYnxG,SAAW0K,EAAS1K,QAAUmxG,EAAa,KAAQrzD,EAAGszD,kBAAoB,CAE1F,IAAM,IAAI/wG,EAAI,EAAGgiE,EAAK33D,EAAS1K,OAAQK,EAAIgiE,EAAIhiE,IAE9C8wG,EAAa9wG,GAAMy9C,EAAGszD,kBAAoB/wG,EAI3C8wG,EAAYnxG,OAAS0K,EAAS1K,OAE9BoG,GAAc,CAEf,CAGD,MAEM+qG,EAAa,KAAQrzD,EAAGkvD,OAE5BmE,EAAa,GAAMrzD,EAAGkvD,KAEtB5mG,GAAc,GAMXA,GAEJ03C,EAAGqzD,YAAaA,EAIlB,CAKA,aAAAE,CAAeC,GAEd,MAAM,GAAExzD,EAAE,mBAAEutD,EAAkB,YAAEH,GAAgBlvG,UAE7Be,IAAdu0G,IAA0BA,EAAYxzD,EAAGyzD,SAAWrG,EAAc,GAElEG,IAAuBiG,IAE3BxzD,EAAGuzD,cAAeC,GAClBt1G,KAAKqvG,mBAAqBiG,EAI5B,CAEA,WAAAE,CAAaC,EAAWC,EAAcJ,GAErC,MAAM,GAAExzD,EAAE,mBAAEutD,EAAkB,qBAAEC,EAAoB,YAAEJ,GAAgBlvG,UAEnDe,IAAdu0G,IAIHA,EAF2B,OAAvBjG,EAEQvtD,EAAGyzD,SAAWrG,EAAc,EAI5BG,GAMd,IAAIsG,EAAerG,EAAsBgG,QAEnBv0G,IAAjB40G,IAEJA,EAAe,CAAEpuG,UAAMxG,EAAW+yB,aAAS/yB,GAC3CuuG,EAAsBgG,GAAcK,GAIhCA,EAAapuG,OAASkuG,GAAaE,EAAa7hF,UAAY4hF,IAE3DrG,IAAuBiG,IAE3BxzD,EAAGuzD,cAAeC,GAClBt1G,KAAKqvG,mBAAqBiG,GAI3BxzD,EAAG0zD,YAAaC,EAAWC,GAE3BC,EAAapuG,KAAOkuG,EACpBE,EAAa7hF,QAAU4hF,EAIzB,CAEA,cAAAE,CAAgBx3F,EAAQ9c,EAAOgH,GAE9B,MAAM,GAAEw5C,GAAO9hD,KAET8O,EAAM,GAAGsP,KAAU9c,IAEzB,OAAKtB,KAAKuvG,wBAAyBzgG,KAAUxG,IAE5Cw5C,EAAG8zD,eAAgBx3F,EAAQ9c,EAAOgH,GAClCtI,KAAKuvG,wBAAyBzgG,GAAQxG,GAE/B,EAMT,CAGA,aAAAutG,GAEC,MAAM,GAAE/zD,EAAE,mBAAEutD,EAAkB,qBAAEC,GAAyBtvG,KAEnD21G,EAAerG,EAAsBD,QAErBtuG,IAAjB40G,QAAoD50G,IAAtB40G,EAAapuG,OAE/Cu6C,EAAG0zD,YAAaG,EAAapuG,KAAM,MAEnCouG,EAAapuG,UAAOxG,EACpB40G,EAAa7hF,aAAU/yB,EAIzB,EAID,MAAM+0G,GAEL,WAAAh2G,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EAEft9D,KAAK8hD,GAAK9hD,KAAKs9D,QAAQxb,GACvB9hD,KAAK2mG,WAAarpC,EAAQqpC,UAE3B,CAEA,OAAAvsF,CAAS27F,EAAGrpF,EAAa,OAExB,MAAM,GAAEo1B,EAAE,WAAE6kD,GAAe3mG,KAE3B,IAAIg2G,EAEJ,GAAKD,IAAM,MAAmB,OAAOj0D,EAAGoqD,cACxC,GAAK6J,IAAM,MAAwB,OAAOj0D,EAAGm0D,uBAC7C,GAAKF,IAAM,MAAwB,OAAOj0D,EAAGo0D,uBAC7C,GAAKH,IAAM,MAAsB,OAAOj0D,EAAGq0D,yBAE3C,GAAKJ,IAAM,MAAW,OAAOj0D,EAAGmqD,KAChC,GAAK8J,IAAM,MAAY,OAAOj0D,EAAGgqD,MACjC,GAAKiK,IAAM,MAAoB,OAAOj0D,EAAG+pD,eACzC,GAAKkK,IAAM,MAAU,OAAOj0D,EAAGkqD,IAC/B,GAAK+J,IAAM,MAAkB,OAAOj0D,EAAGiqD,aACvC,GAAKgK,IAAM,MAAY,OAAOj0D,EAAG4pD,MAEjC,GAAKqK,IAAM,MAEV,OAAOj0D,EAAG8pD,WAIX,GAAKmK,IAAM,MAAc,OAAOj0D,EAAGs0D,MACnC,GAAKL,IAAM,MAAY,OAAOj0D,EAAGu0D,IACjC,GAAKN,IAAM,MAAa,OAAOj0D,EAAGw0D,KAClC,GAAKP,IAAM,MAAkB,OAAOj0D,EAAGy0D,UACvC,GAAKR,IAAM,MAAuB,OAAOj0D,EAAG00D,gBAC5C,GAAKT,IAAM,MAAc,OAAOj0D,EAAG20D,gBACnC,GAAKV,IAAM,MAAqB,OAAOj0D,EAAG40D,cAI1C,GAAKX,IAAM,MAAY,OAAOj0D,EAAG60D,IACjC,GAAKZ,IAAM,MAAmB,OAAOj0D,EAAG80D,YACxC,GAAKb,IAAM,MAAW,OAAOj0D,EAAG+0D,GAChC,GAAKd,IAAM,MAAkB,OAAOj0D,EAAGg1D,WACvC,GAAKf,IAAM,MAAoB,OAAOj0D,EAAGi1D,aAIzC,GAAKhB,IAAM,OAAwBA,IAAM,OAAyBA,IAAM,OAAyBA,IAAM,MAEtG,GAAKrpF,IAAe,MAAiB,CAIpC,GAFAspF,EAAYrP,EAAW7lG,IAAK,sCAET,OAAdk1G,EASJ,OAAO,KAPP,GAAKD,IAAM,MAAuB,OAAOC,EAAUgB,8BACnD,GAAKjB,IAAM,MAAwB,OAAOC,EAAUiB,oCACpD,GAAKlB,IAAM,MAAwB,OAAOC,EAAUkB,oCACpD,GAAKnB,IAAM,MAAwB,OAAOC,EAAUmB,mCAQtD,KAAO,CAIN,GAFAnB,EAAYrP,EAAW7lG,IAAK,iCAET,OAAdk1G,EASJ,OAAO,KAPP,GAAKD,IAAM,MAAuB,OAAOC,EAAUoB,6BACnD,GAAKrB,IAAM,MAAwB,OAAOC,EAAUqB,8BACpD,GAAKtB,IAAM,MAAwB,OAAOC,EAAUsB,8BACpD,GAAKvB,IAAM,MAAwB,OAAOC,EAAUuB,6BAQtD,CAMD,GAAKxB,IAAM,OAA2BA,IAAM,OAA2BA,IAAM,OAA4BA,IAAM,MAA2B,CAIzI,GAFAC,EAAYrP,EAAW7lG,IAAK,kCAET,OAAdk1G,EASJ,OAAO,KAPP,GAAKD,IAAM,MAA0B,OAAOC,EAAUwB,gCACtD,GAAKzB,IAAM,MAA0B,OAAOC,EAAUyB,gCACtD,GAAK1B,IAAM,MAA2B,OAAOC,EAAU0B,iCACvD,GAAK3B,IAAM,MAA2B,OAAOC,EAAU2B,gCAQzD,CAIA,GAAK5B,IAAM,OAAmBA,IAAM,OAAmBA,IAAM,MAAuB,CAInF,GAFAC,EAAYrP,EAAW7lG,IAAK,gCAET,OAAdk1G,EAOJ,OAAO,KALP,GAAKD,IAAM,OAAmBA,IAAM,MAAkB,OAASrpF,IAAe,MAAmBspF,EAAU4B,sBAAwB5B,EAAU6B,qBAC7I,GAAK9B,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAU8B,iCAAmC9B,EAAU+B,yBAQtI,CAIA,GAAKhC,IAAM,OAAwBA,IAAM,OAAwBA,IAAM,OACtEA,IAAM,OAAwBA,IAAM,OAAwBA,IAAM,OAClEA,IAAM,OAAwBA,IAAM,OAAwBA,IAAM,OAClEA,IAAM,OAAyBA,IAAM,OAAyBA,IAAM,OACpEA,IAAM,OAA0BA,IAAM,MAAyB,CAI/D,GAFAC,EAAYrP,EAAW7lG,IAAK,iCAET,OAAdk1G,EAmBJ,OAAO,KAjBP,GAAKD,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAUgC,qCAAuChC,EAAUiC,6BACxI,GAAKlC,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAUkC,qCAAuClC,EAAUmC,6BACxI,GAAKpC,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAUoC,qCAAuCpC,EAAUqC,6BACxI,GAAKtC,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAUsC,qCAAuCtC,EAAUuC,6BACxI,GAAKxC,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAUwC,qCAAuCxC,EAAUyC,6BACxI,GAAK1C,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAU0C,qCAAuC1C,EAAU2C,6BACxI,GAAK5C,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAU4C,qCAAuC5C,EAAU6C,6BACxI,GAAK9C,IAAM,MAAuB,OAASrpF,IAAe,MAAmBspF,EAAU8C,qCAAuC9C,EAAU+C,6BACxI,GAAKhD,IAAM,MAAwB,OAASrpF,IAAe,MAAmBspF,EAAUgD,sCAAwChD,EAAUiD,8BAC1I,GAAKlD,IAAM,MAAwB,OAASrpF,IAAe,MAAmBspF,EAAUkD,sCAAwClD,EAAUmD,8BAC1I,GAAKpD,IAAM,MAAwB,OAASrpF,IAAe,MAAmBspF,EAAUoD,sCAAwCpD,EAAUqD,8BAC1I,GAAKtD,IAAM,MAAyB,OAASrpF,IAAe,MAAmBspF,EAAUsD,uCAAyCtD,EAAUuD,+BAC5I,GAAKxD,IAAM,MAAyB,OAASrpF,IAAe,MAAmBspF,EAAUwD,uCAAyCxD,EAAUyD,+BAC5I,GAAK1D,IAAM,MAAyB,OAASrpF,IAAe,MAAmBspF,EAAU0D,uCAAyC1D,EAAU2D,8BAQ9I,CAIA,GAAK5D,IAAM,KAAmB,CAI7B,GAFAC,EAAYrP,EAAW7lG,IAAK,gCAET,OAAdk1G,EAMJ,OAAO,KAJP,GAAKD,IAAM,KAAmB,OAASrpF,IAAe,MAAmBspF,EAAU4D,qCAAuC5D,EAAU6D,8BAQtI,CAIA,GAAK9D,IAAM,OAAoBA,IAAM,OAA2BA,IAAM,OAA0BA,IAAM,MAAgC,CAIrI,GAFAC,EAAYrP,EAAW7lG,IAAK,gCAET,OAAdk1G,EASJ,OAAO,KAPP,GAAKD,IAAM,KAAmB,OAAOC,EAAU8D,yBAC/C,GAAK/D,IAAM,MAA0B,OAAOC,EAAU+D,gCACtD,GAAKhE,IAAM,MAAyB,OAAOC,EAAUgE,+BACrD,GAAKjE,IAAM,MAAgC,OAAOC,EAAUiE,qCAQ9D,CAIA,OAAKlE,IAAM,MAEHj0D,EAAGo4D,uBAMUn5G,IAAZ+gD,EAAIi0D,GAAsBj0D,EAAIi0D,GAAM,IAE9C,CAEA,gBAAA9I,GAEC,MAAM,GAAEnrD,GAAO9hD,KAETm6G,EAAOr4D,EAAGs4D,UAAWt4D,EAAGu4D,2BAA4B,GAI1D,OAFAv4D,EAAGw4D,QAEI,IAAI1e,SAAS,CAAEC,EAASC,MAE9B,SAASxnF,IAER,MAAMimG,EAAMz4D,EAAG04D,eAAgBL,EAAMr4D,EAAG24D,wBAAyB,GAEjE,GAAKF,IAAQz4D,EAAG44D,YAKf,OAHA54D,EAAG64D,WAAYR,QAEfre,IAKIye,IAAQz4D,EAAG84D,iBAOhB94D,EAAG64D,WAAYR,GAEfte,KAPC5jC,sBAAuB3jD,EASzB,CAEAA,EAAM,GAIR,EAID,IAAyBumG,GAAcC,GAAYC,GAA/C5tG,IAAc,EAElB,MAAM6tG,GAEL,WAAAl7G,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EAEft9D,KAAK8hD,GAAKwb,EAAQxb,GAClB9hD,KAAK2mG,WAAarpC,EAAQqpC,WAC1B3mG,KAAKi7G,gBAAkB,CAAC,GAEH,IAAhB9tG,KAEJnN,KAAK8iE,MAAO9iE,KAAK8hD,IAEjB30C,IAAc,EAIhB,CAEA,KAAA21D,CAAOhhB,GAIN+4D,GAAe,CACd,CAAE,OAAkB/4D,EAAGo5D,OACvB,CAAE,OAAuBp5D,EAAGq5D,cAC5B,CAAE,OAA0Br5D,EAAGs5D,iBAGhCN,GAAa,CACZ,CAAE,OAAiBh5D,EAAGu5D,QACtB,CAAE,OAA8Bv5D,EAAGw5D,uBACnC,CAAE,OAA6Bx5D,EAAGy5D,sBAElC,CAAE,OAAgBz5D,EAAG05D,OACrB,CAAE,OAA6B15D,EAAG25D,sBAClC,CAAE,OAA4B35D,EAAG45D,sBAGlCX,GAAc,CACb,CAAE,OAAgBj5D,EAAG6wD,MACrB,CAAE,OAAiB7wD,EAAG8wD,OACtB,CAAE,OAAe9wD,EAAG+wD,KACpB,CAAE,OAAoB/wD,EAAGgxD,OACzB,CAAE,OAAgBhxD,EAAGixD,MACrB,CAAE,OAAuBjxD,EAAGkxD,OAC5B,CAAE,OAAkBlxD,EAAGmxD,QACvB,CAAE,OAAmBnxD,EAAGoxD,SAG1B,CAEA,cAAAyI,CAAgB74D,GAEf,MAAM,GAAEhB,GAAO9hD,KAEf,OAAK8iD,IAAM,OAAiBA,IAAM,OAA8BA,IAAM,MAE9DhB,EAAGu5D,QAIJv5D,EAAG05D,MAEX,CAEA,gBAAAI,CAAkB9nF,GAEjB,MAAM,GAAEguB,GAAO9hD,KAEf,IAAI67G,EAqBJ,OAjBCA,GAF8B,IAA1B/nF,EAAQ6mB,cAEImH,EAAGg6D,kBAEuB,IAA/BhoF,EAAQu0E,qBAAoE,IAArCv0E,EAAQw0E,yBAE1CxmD,EAAGi6D,kBAEoB,IAA5BjoF,EAAQkoF,gBAEHl6D,EAAGm6D,WAIHn6D,EAAGo6D,WAKbL,CAER,CAEA,iBAAAM,CAAmBC,EAAoBC,EAAUC,EAAQ5vF,EAAY6vF,GAAsB,GAE1F,MAAM,GAAEz6D,EAAE,WAAE6kD,GAAe3mG,KAE3B,GAA4B,OAAvBo8G,EAA8B,CAElC,QAAkCr7G,IAA7B+gD,EAAIs6D,GAAqC,OAAOt6D,EAAIs6D,GAEzD3vG,QAAQC,KAAM,2EAA8E0vG,EAAqB,IAElH,CAEA,IAAII,EAAiBH,EA+HrB,OA7HKA,IAAav6D,EAAG60D,MAEf2F,IAAWx6D,EAAG4pD,QAAQ8Q,EAAiB16D,EAAG26D,MAC1CH,IAAWx6D,EAAG8pD,aAAa4Q,EAAiB16D,EAAG46D,MAC/CJ,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAG66D,IAClDL,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAG86D,KACnDN,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAG+6D,OACjDP,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAGg7D,KACzCR,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAGi7D,MAC1CT,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAGk7D,OAIzCX,IAAav6D,EAAG80D,cAEf0F,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAGm7D,MAClDX,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAGo7D,OACnDZ,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAG+6D,OACjDP,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAGg7D,KACzCR,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAGi7D,MAC1CT,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAGk7D,OAIzCX,IAAav6D,EAAG+0D,KAEfyF,IAAWx6D,EAAG4pD,QAAQ8Q,EAAiB16D,EAAGq7D,OAC1Cb,IAAWx6D,EAAG8pD,aAAa4Q,EAAiB16D,EAAGs7D,OAC/Cd,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAGu7D,KAClDf,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAGw7D,MACnDhB,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAGy7D,QACjDjB,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAG07D,MACzClB,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAG27D,OAC1CnB,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAG47D,QAIzCrB,IAAav6D,EAAGg1D,aAEfwF,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAG67D,OAClDrB,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAG87D,QACnDtB,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAGy7D,QACjDjB,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAG07D,MACzClB,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAG27D,OAC1CnB,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAG47D,QAIzCrB,IAAav6D,EAAGu0D,MAEfiG,IAAWx6D,EAAG4pD,QAAQ8Q,EAAiB16D,EAAG+7D,QAC1CvB,IAAWx6D,EAAG8pD,aAAa4Q,EAAiB16D,EAAGg8D,QAC/CxB,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAGi8D,MAClDzB,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAGk8D,OACnD1B,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAGm8D,SACjD3B,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAGo8D,OACzC5B,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAGq8D,QAC1C7B,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAGs8D,QACxC9B,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAmB9vF,IAAe,QAA0C,IAAxB6vF,EAAkCz6D,EAAGu8D,MAAQv8D,EAAGi8D,MAClIzB,IAAWx6D,EAAGw8D,uBAAuB9B,EAAiB16D,EAAGy8D,QACzDjC,IAAWx6D,EAAGo0D,yBAAyBsG,EAAiB16D,EAAG08D,SAC3DlC,IAAWx6D,EAAGm0D,yBAAyBuG,EAAiB16D,EAAG28D,MAC3DnC,IAAWx6D,EAAGq0D,2BAA2BqG,EAAiB16D,EAAG48D,UAI9DrC,IAAav6D,EAAG68D,cAEfrC,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAG88D,QAClDtC,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAG+8D,SACnDvC,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAGm8D,SACjD3B,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAGo8D,OACzC5B,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAGq8D,QAC1C7B,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAGs8D,SAIzC/B,IAAav6D,EAAGw0D,OAEfgG,IAAWx6D,EAAG4pD,QAAQ8Q,EAAiB16D,EAAGg9D,SAC1CxC,IAAWx6D,EAAG8pD,aAAa4Q,EAAiB16D,EAAGi9D,SAC/CzC,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAGk9D,OAClD1C,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAGm9D,QACnD3C,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAGo9D,UACjD5C,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAGq9D,QACzC7C,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAGs9D,SAC1C9C,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAGu9D,SACxC/C,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAmB9vF,IAAe,QAA0C,IAAxB6vF,EAAkCz6D,EAAGw9D,aAAex9D,EAAGk9D,OACzI1C,IAAWx6D,EAAGm0D,yBAAyBuG,EAAiB16D,EAAGy9D,OAC3DjD,IAAWx6D,EAAGo0D,yBAAyBsG,EAAiB16D,EAAG08D,UAI5DnC,IAAav6D,EAAGi1D,eAEfuF,IAAWx6D,EAAGoqD,gBAAgBsQ,EAAiB16D,EAAG09D,SAClDlD,IAAWx6D,EAAG+pD,iBAAiB2Q,EAAiB16D,EAAG29D,UACnDnD,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAGo9D,UACjD5C,IAAWx6D,EAAGmqD,OAAOuQ,EAAiB16D,EAAGq9D,QACzC7C,IAAWx6D,EAAGgqD,QAAQ0Q,EAAiB16D,EAAGs9D,SAC1C9C,IAAWx6D,EAAGkqD,MAAMwQ,EAAiB16D,EAAGu9D,UAIzChD,IAAav6D,EAAG20D,kBAEf6F,IAAWx6D,EAAGiqD,eAAeyQ,EAAiB16D,EAAG49D,kBACjDpD,IAAWx6D,EAAG4pD,QAAQ8Q,EAAiB16D,EAAG69D,qBAI3CtD,IAAav6D,EAAG40D,eAEf4F,IAAWx6D,EAAGo4D,oBAAoBsC,EAAiB16D,EAAG49D,kBAIvDlD,IAAmB16D,EAAG46D,MAAQF,IAAmB16D,EAAG26D,MACxDD,IAAmB16D,EAAGs7D,OAASZ,IAAmB16D,EAAGq7D,OACrDX,IAAmB16D,EAAGi9D,SAAWvC,IAAmB16D,EAAGg9D,SAEvDnY,EAAW7lG,IAAK,0BAIV07G,CAER,CAEA,oBAAAoD,CAAsBC,EAAa/rF,GAElC,MAAM,GAAEguB,EAAE,WAAE6kD,EAAU,QAAErpC,GAAYt9D,KAGpC8hD,EAAGg+D,YAAah+D,EAAGi+D,oBAAqBjsF,EAAQuB,OAChDysB,EAAGg+D,YAAah+D,EAAGk+D,+BAAgClsF,EAAQmsF,kBAC3Dn+D,EAAGg+D,YAAah+D,EAAGo+D,iBAAkBpsF,EAAQqsF,iBAC7Cr+D,EAAGg+D,YAAah+D,EAAGs+D,mCAAoCt+D,EAAGn5C,MAE1Dm5C,EAAGu+D,cAAeR,EAAa/9D,EAAGw+D,eAAgBzF,GAAc/mF,EAAQysF,QACxEz+D,EAAGu+D,cAAeR,EAAa/9D,EAAG0+D,eAAgB3F,GAAc/mF,EAAQ2sF,QAEnEZ,IAAgB/9D,EAAGm6D,YAAc4D,IAAgB/9D,EAAGi6D,kBAExDj6D,EAAGu+D,cAAeR,EAAa/9D,EAAG4+D,eAAgB7F,GAAc/mF,EAAQ6sF,QAIzE7+D,EAAGu+D,cAAeR,EAAa/9D,EAAG8+D,mBAAoB9F,GAAYhnF,EAAQ4pB,YAG1E,MAAMmjE,OAAiC9/G,IAApB+yB,EAAQq1C,SAAyBr1C,EAAQq1C,QAAQnlE,OAAS,EAGvEqvC,EAAYvf,EAAQuf,YAAc,OAAgBwtE,EAAa,MAA2B/sF,EAAQuf,UAWxG,GATAyO,EAAGu+D,cAAeR,EAAa/9D,EAAGg/D,mBAAoBhG,GAAYznE,IAE7Dvf,EAAQmlD,kBAEZn3B,EAAGu+D,cAAeR,EAAa/9D,EAAGi/D,qBAAsBj/D,EAAGk/D,wBAC3Dl/D,EAAGu+D,cAAeR,EAAa/9D,EAAGm/D,qBAAsBlG,GAAajnF,EAAQmlD,oBAIlB,IAAvD0tB,EAAWhmG,IAAK,kCAA8C,CAElE,GAAKmzB,EAAQ4pB,YAAc,MAAgB,OAC3C,GAAK5pB,EAAQuf,YAAc,OAA6Bvf,EAAQuf,YAAc,MAA2B,OACzG,GAAKvf,EAAQvsB,OAAS,QAA8D,IAAjDo/F,EAAWhmG,IAAK,4BAAyC,OAE5F,GAAKmzB,EAAQ3W,WAAa,EAAI,CAE7B,MAAM64F,EAAYrP,EAAW7lG,IAAK,kCAClCghD,EAAGo/D,cAAerB,EAAa7J,EAAUmL,2BAA4Bl8G,KAAKu8C,IAAK1tB,EAAQ3W,WAAYmgD,EAAQ4hC,oBAE5G,CAED,CAED,CAEA,oBAAA91B,CAAsBt1C,GAErB,MAAM,GAAEguB,EAAE,QAAEwb,EAAO,gBAAE29C,GAAoBj7G,KAGnC67G,EAAgB77G,KAAK47G,iBAAkB9nF,GAE7C,IAAIstF,EAAanG,EAAiBY,QAEd96G,IAAfqgH,IAEJA,EAAat/D,EAAGknB,gBAEhB1L,EAAQrvC,MAAMunF,YAAaqG,EAAeuF,GAC1Ct/D,EAAGu+D,cAAexE,EAAe/5D,EAAGg/D,mBAAoBh/D,EAAGu5D,SAC3Dv5D,EAAGu+D,cAAexE,EAAe/5D,EAAG8+D,mBAAoB9+D,EAAGu5D,SAI3DJ,EAAiBY,GAAkBuF,GAIpC9jD,EAAQ96D,IAAKsxB,EAAS,CACrBstF,aACAvF,gBACAwF,WAAW,GAGb,CAEA,aAAAr4C,CAAel1C,EAASupB,GAEvB,MAAM,GAAEyE,EAAE,QAAEwb,GAAYt9D,MAClB,OAAE6oE,EAAM,MAAE1mE,EAAK,OAAEC,EAAM,MAAEk1B,GAAU+lB,EAEnCg/D,EAAW/+C,EAAQ0vC,MAAM5yF,QAAS0Z,EAAQnmB,OAAQmmB,EAAQpH,YAC1D4vF,EAASh/C,EAAQ0vC,MAAM5yF,QAAS0Z,EAAQvsB,MACxC+5G,EAAmBthH,KAAKm8G,kBAAmBroF,EAAQ0oF,eAAgBH,EAAUC,EAAQxoF,EAAQpH,WAAYoH,EAAQ4xE,gBAEjH0b,EAAat/D,EAAGknB,gBAChB6yC,EAAgB77G,KAAK47G,iBAAkB9nF,GAE7CwpC,EAAQrvC,MAAMunF,YAAaqG,EAAeuF,GAE1CphH,KAAK4/G,qBAAsB/D,EAAe/nF,GAErCA,EAAQu0E,oBAAsBv0E,EAAQw0E,yBAE1CxmD,EAAGy/D,aAAcz/D,EAAGi6D,iBAAkBlzC,EAAQy4C,EAAkBn/G,EAAOC,EAAQk1B,GAEpExD,EAAQkoF,gBAEnBl6D,EAAGy/D,aAAcz/D,EAAGm6D,WAAYpzC,EAAQy4C,EAAkBn/G,EAAOC,EAAQk1B,GAE5DxD,EAAQ4xE,gBAErB5jD,EAAG0/D,aAAc3F,EAAehzC,EAAQy4C,EAAkBn/G,EAAOC,GAIlEk7D,EAAQ96D,IAAKsxB,EAAS,CACrBstF,aACAvF,gBACAQ,WACAC,SACAgF,oBAGF,CAEA,mBAAAG,CAAqBn5G,EAAQwrB,GAE5B,MAAM,GAAEguB,EAAE,QAAEwb,GAAYt9D,MAElB,WAAEohH,EAAU,cAAEvF,EAAa,SAAEQ,EAAQ,OAAEC,GAAWh/C,EAAQx8D,IAAKgzB,IAE/D,MAAE3xB,EAAK,OAAEC,GAAW0xB,EAAQzV,OAAOxd,KAEzCihD,EAAGuqD,WAAYvqD,EAAG4/D,oBAAqBp5G,GAEvCg1D,EAAQrvC,MAAMunF,YAAaqG,EAAeuF,GAE1Ct/D,EAAGg+D,YAAah+D,EAAGi+D,qBAAqB,GACxCj+D,EAAGg+D,YAAah+D,EAAGk+D,gCAAgC,GACnDl+D,EAAG6/D,cAAe9F,EAAe,EAAG,EAAG,EAAG15G,EAAOC,EAAQi6G,EAAUC,EAAQ,GAE3Ex6D,EAAGuqD,WAAYvqD,EAAG4/D,oBAAqB,MAEvCpkD,EAAQrvC,MAAM4nF,eAef,CAEA,aAAAzyC,CAAetvC,EAASupB,GAEvB,MAAM,GAAEyE,GAAO9hD,MACT,MAAEmC,EAAK,OAAEC,GAAWi7C,GACpB,WAAE+jE,EAAU,cAAEvF,EAAa,SAAEQ,EAAQ,OAAEC,EAAM,iBAAEgF,GAAqBthH,KAAKs9D,QAAQx8D,IAAKgzB,GAE5F,GAAKA,EAAQwB,4BAA0Cv0B,IAAfqgH,EACvC,OAED,MAAMQ,EAAavjG,GAEbA,EAAO0tE,cAEJ1tE,EAAO0V,MAAMlzB,KAEqB,oBAArBghH,kBAAoCxjG,aAAkBwjG,kBAC3C,oBAAtBC,mBAAqCzjG,aAAkByjG,mBACvC,oBAAhB1sF,aAA+B/W,aAAkB+W,aAC1D/W,aAAkB0jG,gBAEX1jG,EAIDA,EAAOxd,KAQf,GAJAb,KAAKs9D,QAAQrvC,MAAMunF,YAAaqG,EAAeuF,GAE/CphH,KAAK4/G,qBAAsB/D,EAAe/nF,GAErCA,EAAQw1C,oBAAsB,CAElC,MAAMH,EAAUr1C,EAAQq1C,QAClBp1C,EAAQspB,EAAQtpB,MAEtB,IAAM,IAAI1vB,EAAI,EAAGA,EAAI8kE,EAAQnlE,OAAQK,IAAO,CAE3C,MAAM29G,EAAS74C,EAAS9kE,GAEnByvB,EAAQw0E,yBAGPx0E,EAAQnmB,SAAWm0C,EAAGw0D,KAER,OAAb+F,EAEJv6D,EAAGmgE,wBAAyBngE,EAAGi6D,iBAAkB13G,EAAG,EAAG,EAAG,EAAG29G,EAAO7/G,MAAO6/G,EAAO5/G,OAAQ2xB,EAAMuD,MAAO+kF,EAAU2F,EAAOnhH,MAIxH4L,QAAQC,KAAM,kGAMfo1C,EAAGogE,cAAepgE,EAAGi6D,iBAAkB13G,EAAG,EAAG,EAAG,EAAG29G,EAAO7/G,MAAO6/G,EAAO5/G,OAAQ2xB,EAAMuD,MAAO+kF,EAAUC,EAAQ0F,EAAOnhH,MAMrG,OAAbw7G,EAEJv6D,EAAGqgE,wBAAyBrgE,EAAGo6D,WAAY73G,EAAG,EAAG,EAAG29G,EAAO7/G,MAAO6/G,EAAO5/G,OAAQi6G,EAAU2F,EAAOnhH,MAIlG4L,QAAQC,KAAM,wCAMjB,CAGD,MAAO,GAAKonB,EAAQ6mB,cAAgB,CAEnC,MAAMhsC,EAAS0uC,EAAQ1uC,OAEvB,IAAM,IAAItK,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAM0vB,EAAQ6tF,EAAUjzG,EAAQtK,IAEhCy9C,EAAG6/D,cAAe7/D,EAAGsgE,4BAA8B/9G,EAAG,EAAG,EAAG,EAAGlC,EAAOC,EAAQi6G,EAAUC,EAAQvoF,EAEjG,CAED,MAAO,GAAKD,EAAQu0E,mBAAqB,CAExC,MAAMt0E,EAAQspB,EAAQtpB,MAEtB+tB,EAAGogE,cAAepgE,EAAGi6D,iBAAkB,EAAG,EAAG,EAAG,EAAGhoF,EAAM5xB,MAAO4xB,EAAM3xB,OAAQ2xB,EAAMuD,MAAO+kF,EAAUC,EAAQvoF,EAAMlzB,KAEpH,MAAO,GAAKizB,EAAQkoF,gBAAkB,CAErC,MAAMjoF,EAAQspB,EAAQtpB,MAEtB+tB,EAAGogE,cAAepgE,EAAGm6D,WAAY,EAAG,EAAG,EAAG,EAAGloF,EAAM5xB,MAAO4xB,EAAM3xB,OAAQ2xB,EAAMuD,MAAO+kF,EAAUC,EAAQvoF,EAAMlzB,KAE9G,MAAO,GAAKizB,EAAQ4xE,eAEnB5xE,EAAQvpB,SAERu3C,EAAGugE,WAAYxG,EAAe,EAAGyF,EAAkBjF,EAAUC,EAAQj/D,EAAQtpB,WAGvE,CAEN,MAAMA,EAAQ6tF,EAAUvkE,EAAQtpB,OAEhC+tB,EAAG6/D,cAAe9F,EAAe,EAAG,EAAG,EAAG15G,EAAOC,EAAQi6G,EAAUC,EAAQvoF,EAE5E,CAED,CAEA,eAAAuf,CAAiBxf,GAEhB,MAAM,GAAEguB,EAAE,QAAEwb,GAAYt9D,MAClB,WAAEohH,EAAU,cAAEvF,GAAkBv+C,EAAQx8D,IAAKgzB,GAEnDwpC,EAAQrvC,MAAMunF,YAAaqG,EAAeuF,GAC1Ct/D,EAAGwgE,eAAgBzG,EAEpB,CAEA,uBAAA0G,CAAyBpwE,GAExB,MAAM,GAAE2P,EAAE,QAAEwb,GAAYt9D,KAGxB,GAAKmyC,EAAe,CAEnB,MAAMqwE,EAAoBllD,EAAQx8D,IAAKqxC,GAIvC,GAFAqwE,EAAkBC,8BAA2B1hH,EAExCyhH,EAAkBE,aAAe,CAErC,IAAM,MAAMvpD,KAAYqpD,EAAkBE,aAEzC5gE,EAAG6gE,kBAAmBH,EAAkBE,aAAcvpD,WAIhDqpD,EAAkBE,YAE1B,CAuBA,GArBKF,EAAkBI,oBAEtB9gE,EAAG+gE,mBAAoBL,EAAkBI,0BAClCJ,EAAkBI,mBAIrBJ,EAAkBM,sBAEtBhhE,EAAG+gE,mBAAoBL,EAAkBM,4BAClCN,EAAkBM,qBAIrBN,EAAkBO,kBAEtBjhE,EAAG6gE,kBAAmBH,EAAkBO,wBACjCP,EAAkBO,iBAIrBP,EAAkBQ,kBAAoB,CAE1C,IAAM,IAAI3+G,EAAI,EAAGA,EAAIm+G,EAAkBQ,kBAAkBh/G,OAAQK,IAEhEy9C,EAAG+gE,mBAAoBL,EAAkBQ,kBAAmB3+G,WAItDm+G,EAAkBQ,iBAE1B,CAED,CAED,CAEA,cAAAp6C,CAAgB90C,GAEf,MAAM,GAAEguB,EAAE,QAAEwb,GAAYt9D,MAClB,WAAEohH,EAAU,aAAEjvE,GAAiBmrB,EAAQx8D,IAAKgzB,GAElD9zB,KAAKuiH,wBAAyBpwE,GAC9B2P,EAAGmhE,cAAe7B,GAElB9jD,EAAQttB,OAAQlc,EAEjB,CAEA,oBAAAwtE,CAAsBC,EAAYC,EAAYC,EAAY,KAAMC,EAAc,KAAMhuE,EAAQ,GAE3F,MAAM,GAAEouB,EAAE,QAAEwb,GAAYt9D,MAClB,MAAEiuB,GAAUjuB,KAAKs9D,SAEf8jD,WAAY8B,EAAa,cAAErH,EAAa,OAAES,EAAM,SAAED,GAAa/+C,EAAQx8D,IAAK0gG,GAEpF,IAAIr/F,EAAOC,EAAQ+gH,EAAMC,EACrBC,EAAMC,EAES,OAAd7hB,GAEJt/F,EAAQs/F,EAAUpwF,IAAIuY,EAAI63E,EAAUjgD,IAAI53B,EACxCxnB,EAASq/F,EAAUpwF,IAAIyY,EAAI23E,EAAUjgD,IAAI13B,EACzCq5F,EAAO1hB,EAAUjgD,IAAI53B,EACrBw5F,EAAO3hB,EAAUjgD,IAAI13B,IAIrB3nB,EAAQo/F,EAAWxtE,MAAM5xB,MACzBC,EAASm/F,EAAWxtE,MAAM3xB,OAC1B+gH,EAAO,EACPC,EAAO,GAIa,OAAhB1hB,GAEJ2hB,EAAO3hB,EAAY93E,EACnB05F,EAAO5hB,EAAY53E,IAInBu5F,EAAO,EACPC,EAAO,GAIRr1F,EAAMunF,YAAaqG,EAAeqH,GAIlCphE,EAAGg+D,YAAah+D,EAAGo+D,iBAAkB1e,EAAW2e,iBAChDr+D,EAAGg+D,YAAah+D,EAAGi+D,oBAAqBve,EAAWnsE,OACnDysB,EAAGg+D,YAAah+D,EAAGk+D,+BAAgCxe,EAAWye,kBAC9Dn+D,EAAGg+D,YAAah+D,EAAGo+D,iBAAkB1e,EAAW2e,iBAEhD,MAAMoD,EAAsBzhE,EAAGqtD,aAAcrtD,EAAG0hE,mBAC1CC,EAA2B3hE,EAAGqtD,aAAcrtD,EAAG4hE,qBAC/CC,EAA0B7hE,EAAGqtD,aAAcrtD,EAAG8hE,oBAC9CC,EAAwB/hE,EAAGqtD,aAAcrtD,EAAGgiE,kBAC5CC,EAA0BjiE,EAAGqtD,aAAcrtD,EAAGkiE,oBAE9CjwF,EAAQwtE,EAAWj4B,oBAAsBi4B,EAAWp4B,QAASz1C,GAAU6tE,EAAWxtE,MAOxF,GALA+tB,EAAGg+D,YAAah+D,EAAG0hE,kBAAmBzvF,EAAM5xB,OAC5C2/C,EAAGg+D,YAAah+D,EAAG4hE,oBAAqB3vF,EAAM3xB,QAC9C0/C,EAAGg+D,YAAah+D,EAAG8hE,mBAAoBT,GACvCrhE,EAAGg+D,YAAah+D,EAAGgiE,iBAAkBV,GAEhC7hB,EAAWjsE,uBAAyBisE,EAAW1sE,eAAiB,CAEpE,MAAMovF,EAAiB3mD,EAAQx8D,IAAKygG,GAC9B2iB,EAAiB5mD,EAAQx8D,IAAK0gG,GAE9B2iB,EAAuB7mD,EAAQx8D,IAAKmjH,EAAe9xE,cACnDiyE,EAAuB9mD,EAAQx8D,IAAKojH,EAAe/xE,cAEnDkyE,EAAiBF,EAAqBzB,aAAcuB,EAAe9qD,UACnEmrD,EAAiBF,EAAqB1B,aAAcwB,EAAe/qD,UAEzElrC,EAAM8mF,gBAAiBjzD,EAAGyiE,iBAAkBF,GAC5Cp2F,EAAM8mF,gBAAiBjzD,EAAGmzD,iBAAkBqP,GAE5C,IAAIlqC,EAAOt4B,EAAG0iE,iBAETjjB,EAAW1sE,iBAAiBulD,EAAOt4B,EAAG2iE,kBAE3C3iE,EAAG4iE,gBAAiBvB,EAAMC,EAAMjhH,EAAOC,EAAQihH,EAAMC,EAAMnhH,EAAOC,EAAQg4E,EAAMt4B,EAAGu5D,SAEnFptF,EAAM8mF,gBAAiBjzD,EAAGyiE,iBAAkB,MAC5Ct2F,EAAM8mF,gBAAiBjzD,EAAGmzD,iBAAkB,KAE7C,MAEM1T,EAAWxV,cAEfjqC,EAAG6/D,cAAe7/D,EAAGo6D,WAAYxoF,EAAO2vF,EAAMC,EAAMnhH,EAAOC,EAAQi6G,EAAUC,EAAQvoF,EAAMlzB,MAItF0gG,EAAWj4B,oBAEfxnB,EAAGqgE,wBAAyBrgE,EAAGo6D,WAAYxoF,EAAO2vF,EAAMC,EAAMvvF,EAAM5xB,MAAO4xB,EAAM3xB,OAAQi6G,EAAUtoF,EAAMlzB,MAIzGihD,EAAG6/D,cAAe7/D,EAAGo6D,WAAYxoF,EAAO2vF,EAAMC,EAAMnhH,EAAOC,EAAQi6G,EAAUC,EAAQvoF,GAQxF+tB,EAAGg+D,YAAah+D,EAAG0hE,kBAAmBD,GACtCzhE,EAAGg+D,YAAah+D,EAAG4hE,oBAAqBD,GACxC3hE,EAAGg+D,YAAah+D,EAAG8hE,mBAAoBD,GACvC7hE,EAAGg+D,YAAah+D,EAAGgiE,iBAAkBD,GACrC/hE,EAAGg+D,YAAah+D,EAAGkiE,mBAAoBD,GAGxB,IAAVrwF,GAAe8tE,EAAWluD,iBAAkBwO,EAAGwgE,eAAgBxgE,EAAGo6D,YAEvEjuF,EAAM4nF,eAEP,CAEA,wBAAApiE,CAA0B3f,EAAS8kC,EAAeyoC,GAEjD,MAAM,GAAEv/C,GAAO9hD,MACT,MAAEiuB,GAAUjuB,KAAKs9D,SAEjB,WAAE8jD,GAAephH,KAAKs9D,QAAQx8D,IAAKgzB,IAEnC,EAAElK,EAAC,EAAEE,EAAGmT,EAAG96B,EAAO+6B,EAAG96B,GAAWi/F,EAEhCsjB,GAAoD,IAA3B7wF,EAAQe,gBAA6B+jC,EAAczmB,cAAgBymB,EAAczmB,aAAaqH,QAAU,EAEjIorE,EAAYhsD,EAAczmB,aAAeymB,EAAczmB,aAAa/vC,OAASpC,KAAKs9D,QAAQ7qB,uBAAuB3oB,EAEvH,GAAK66F,EAAyB,CAE7B,MAAME,EAAkB,IAANj7F,GAAiB,IAANE,EAC7B,IAAIswD,EACA0qC,EAoBJ,IAlBgC,IAA3BhxF,EAAQe,gBAEZulD,EAAOt4B,EAAG2iE,iBACVK,EAAahjE,EAAGijE,iBAEXnsD,EAAcmO,UAElBqT,GAAQt4B,EAAGkjE,sBAMZ5qC,EAAOt4B,EAAG0iE,iBACVM,EAAahjE,EAAGszD,mBAIZyP,EAAU,CAEd,MAAMI,EAA0BjlH,KAAKs9D,QAAQx8D,IAAK83D,EAAczmB,cAE1D+yE,EAAKD,EAAwBvC,aAAc9pD,EAAc1yD,eACzD68G,EAAkBkC,EAAwBlC,gBAEhD90F,EAAM8mF,gBAAiBjzD,EAAGmzD,iBAAkBiQ,GAC5Cj3F,EAAM8mF,gBAAiBjzD,EAAGyiE,iBAAkBxB,GAE5C,MAAMoC,EAAWP,EAAY96F,EAAI1nB,EAEjC0/C,EAAG4iE,gBAAiB96F,EAAGu7F,EAAUv7F,EAAIznB,EAAOgjH,EAAW/iH,EAAQwnB,EAAGu7F,EAAUv7F,EAAIznB,EAAOgjH,EAAW/iH,EAAQg4E,EAAMt4B,EAAGu5D,SAEnHptF,EAAM8mF,gBAAiBjzD,EAAGyiE,iBAAkBW,GAE5Cj3F,EAAMunF,YAAa1zD,EAAGo6D,WAAYkF,GAElCt/D,EAAGsjE,kBAAmBtjE,EAAGo6D,WAAY,EAAG,EAAG,EAAGtyF,EAAGu7F,EAAUhjH,EAAOC,GAElE6rB,EAAM4nF,eAEP,KAAO,CAEN,MAAMqP,EAAKpjE,EAAGujE,oBAEdp3F,EAAM8mF,gBAAiBjzD,EAAGmzD,iBAAkBiQ,GAE5CpjE,EAAGwjE,qBAAsBxjE,EAAGmzD,iBAAkB6P,EAAYhjE,EAAGo6D,WAAYkF,EAAY,GACrFt/D,EAAG4iE,gBAAiB,EAAG,EAAGviH,EAAOC,EAAQ,EAAG,EAAGD,EAAOC,EAAQg4E,EAAMt4B,EAAGu5D,SAEvEv5D,EAAG6gE,kBAAmBuC,EAEvB,CAED,MAECj3F,EAAMunF,YAAa1zD,EAAGo6D,WAAYkF,GAClCt/D,EAAGsjE,kBAAmBtjE,EAAGo6D,WAAY,EAAG,EAAG,EAAGtyF,EAAGg7F,EAAYxiH,EAAS0nB,EAAG3nB,EAAOC,GAEhF6rB,EAAM4nF,gBAIF/hF,EAAQwf,iBAAkBtzC,KAAKszC,gBAAiBxf,GAErD9zB,KAAKs9D,QAAQioD,gBAAiB3sD,EAE/B,CAGA,wBAAA4sD,CAA0BC,EAAc7sD,GAEvC,MAAM,GAAE9W,GAAO9hD,KACTmyC,EAAeymB,EAAczmB,cAE7B,QAAEqH,EAAO,aAAE6tB,EAAY,YAAExuB,EAAW,cAAE+uB,EAAa,MAAEzlE,EAAK,OAAEC,GAAW+vC,EAI7E,GAFA2P,EAAG4jE,iBAAkB5jE,EAAG6jE,aAAcF,GAEjC5sE,IAAiB+uB,EAAgB,CAErC,IAAI05C,EAAmBx/D,EAAG8jE,kBAErBpsE,EAAU,GAET6tB,GAAgBA,EAAaxyC,gBAE5BwyC,EAAa9/D,OAASu6C,EAAG4pD,QAE7B4V,EAAmBx/D,EAAG69D,oBAMxB79D,EAAG+jE,+BAAgC/jE,EAAG6jE,aAAcnsE,EAAS8nE,EAAkBn/G,EAAOC,IAItF0/C,EAAGgkE,oBAAqBhkE,EAAG6jE,aAAcrE,EAAkBn/G,EAAOC,GAInE0/C,EAAGikE,wBAAyBjkE,EAAGozD,YAAapzD,EAAGijE,iBAAkBjjE,EAAG6jE,aAAcF,EAEnF,MAAY5sE,GAAe+uB,IAErBpuB,EAAU,EAEdsI,EAAG+jE,+BAAgC/jE,EAAG6jE,aAAcnsE,EAASsI,EAAG49D,iBAAkBv9G,EAAOC,GAIzF0/C,EAAGgkE,oBAAqBhkE,EAAG6jE,aAAc7jE,EAAG40D,cAAev0G,EAAOC,GAKnE0/C,EAAGikE,wBAAyBjkE,EAAGozD,YAAapzD,EAAGkkE,yBAA0BlkE,EAAG6jE,aAAcF,GAI5F,CAEA,yBAAM5jB,CAAqB/tE,EAASlK,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,GAExD,MAAM,QAAE3pB,EAAO,GAAExb,GAAO9hD,MAElB,WAAEohH,EAAU,SAAE/E,EAAQ,OAAEC,GAAWt8G,KAAKs9D,QAAQx8D,IAAKgzB,GAErDoxF,EAAKpjE,EAAGujE,oBAEdvjE,EAAGizD,gBAAiBjzD,EAAGyiE,iBAAkBW,GAEzC,MAAM9mG,EAAS0V,EAAQ6mB,cAAgBmH,EAAGsgE,4BAA8Bn7B,EAAYnlC,EAAGo6D,WAEvFp6D,EAAGwjE,qBAAsBxjE,EAAGyiE,iBAAkBziE,EAAGszD,kBAAmBh3F,EAAQgjG,EAAY,GAExF,MAAM6E,EAAiBjmH,KAAKkmH,mBAAoB5J,GAI1CxY,EADe3hG,EAAQC,EAFPpC,KAAKmmH,kBAAmB7J,EAAQD,GAKhD/zG,EAASw5C,EAAG8qD,eAElB9qD,EAAGuqD,WAAYvqD,EAAGskE,kBAAmB99G,GACrCw5C,EAAGvyB,WAAYuyB,EAAGskE,kBAAmBtiB,EAAYhiD,EAAGgrD,aACpDhrD,EAAGukE,WAAYz8F,EAAGE,EAAG3nB,EAAOC,EAAQi6G,EAAUC,EAAQ,GACtDx6D,EAAGuqD,WAAYvqD,EAAGskE,kBAAmB,YAE/B9oD,EAAQ0vC,MAAMC,mBAEpB,MAAMC,EAAY,IAAI+Y,EAAgBniB,EAAamiB,EAAeriB,mBAQlE,OANA9hD,EAAGuqD,WAAYvqD,EAAGskE,kBAAmB99G,GACrCw5C,EAAGqrD,iBAAkBrrD,EAAGskE,kBAAmB,EAAGlZ,GAC9CprD,EAAGuqD,WAAYvqD,EAAGskE,kBAAmB,MAErCtkE,EAAG6gE,kBAAmBuC,GAEfhY,CAER,CAEA,kBAAAgZ,CAAoB5J,GAEnB,MAAM,GAAEx6D,GAAO9hD,KAEf,GAAKs8G,IAAWx6D,EAAGoqD,cAAgB,OAAOpkG,WAE1C,GAAKw0G,IAAWx6D,EAAGm0D,uBAAyB,OAAOrsB,YACnD,GAAK0yB,IAAWx6D,EAAGo0D,uBAAyB,OAAOtsB,YACnD,GAAK0yB,IAAWx6D,EAAGw8D,qBAAuB,OAAO10B,YACjD,GAAK0yB,IAAWx6D,EAAG+pD,eAAiB,OAAOjiB,YAC3C,GAAK0yB,IAAWx6D,EAAGiqD,aAAe,OAAOzuE,YAEzC,GAAKg/E,IAAWx6D,EAAG8pD,WAAa,OAAOhiB,YACvC,GAAK0yB,IAAWx6D,EAAG4pD,MAAQ,OAAOvuE,aAElC,MAAM,IAAI9pB,MAAO,2BAA2BipG,IAE7C,CAEA,iBAAA6J,CAAmB7J,EAAQD,GAE1B,MAAM,GAAEv6D,GAAO9hD,KAEf,IAAIsmH,EAAoB,EAaxB,OAXKhK,IAAWx6D,EAAGoqD,gBAAgBoa,EAAoB,GAElDhK,IAAWx6D,EAAGm0D,wBAClBqG,IAAWx6D,EAAGo0D,wBACdoG,IAAWx6D,EAAGw8D,sBACdhC,IAAWx6D,EAAG+pD,gBACdyQ,IAAWx6D,EAAG8pD,aAAa0a,EAAoB,GAE3ChK,IAAWx6D,EAAGiqD,cAClBuQ,IAAWx6D,EAAG4pD,QAAQ4a,EAAoB,GAEtCjK,IAAav6D,EAAGw0D,KAAkC,EAApBgQ,EAC9BjK,IAAav6D,EAAGu0D,IAAiC,EAApBiQ,EAC7BjK,IAAav6D,EAAGs0D,MAAekQ,OAApC,CAED,EAID,MAAMC,GAEL,WAAAzmH,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EAEft9D,KAAK8hD,GAAK9hD,KAAKs9D,QAAQxb,GACvB9hD,KAAKwmH,oBAAsBxmH,KAAK8hD,GAAG2kE,yBAEnCzmH,KAAK2mG,WAAa,CAAC,CAEpB,CAEA,GAAA7lG,CAAK4B,GAEJ,IAAIszG,EAAYh2G,KAAK2mG,WAAYjkG,GAUjC,YARmB3B,IAAdi1G,IAEJA,EAAYh2G,KAAK8hD,GAAG4kE,aAAchkH,GAElC1C,KAAK2mG,WAAYjkG,GAASszG,GAIpBA,CAER,CAEA,GAAAr1G,CAAK+B,GAEJ,OAAO1C,KAAKwmH,oBAAoBrwG,SAAUzT,EAE3C,EAID,MAAMikH,GAEL,WAAA7mH,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EAEft9D,KAAK4mH,cAAgB,IAEtB,CAEA,gBAAA1nB,GAEC,GAA4B,OAAvBl/F,KAAK4mH,cAAyB,OAAO5mH,KAAK4mH,cAE/C,MAAM9kE,EAAK9hD,KAAKs9D,QAAQxb,GAClB6kD,EAAa3mG,KAAKs9D,QAAQqpC,WAEhC,IAA4D,IAAvDA,EAAWhmG,IAAK,kCAA8C,CAElE,MAAMq1G,EAAYrP,EAAW7lG,IAAK,kCAElCd,KAAK4mH,cAAgB9kE,EAAGqtD,aAAc6G,EAAU6Q,+BAEjD,MAEC7mH,KAAK4mH,cAAgB,EAItB,OAAO5mH,KAAK4mH,aAEb,EAID,MAAME,GAAgB,CAErB,iBAAoB,mBACpB,8BAAiC,2BACjC,6BAAgC,2BAChC,8BAAiC,2BACjC,+BAAkC,4BAClC,sCAAyC,4BACzC,8BAAiC,yBACjC,6BAAgC,2BAChC,gCAAmC,mBAIpC,MAAMC,GAEL,WAAAjnH,CAAaw9D,GAEZt9D,KAAK8hD,GAAKwb,EAAQxb,GAClB9hD,KAAK2mG,WAAarpC,EAAQqpC,WAC1B3mG,KAAK43D,KAAO0F,EAAQx6D,SAAS80D,KAC7B53D,KAAKgnH,KAAO,KACZhnH,KAAKsB,MAAQ,EACbtB,KAAKuH,KAAO,KACZvH,KAAKM,OAAS,IAEf,CAEA,MAAA4+D,CAAQz9D,EAAOC,GAEd,MAAM,GAAEogD,EAAE,KAAEklE,EAAI,OAAE1mH,EAAM,KAAEiH,EAAI,KAAEqwD,EAAI,MAAEt2D,GAAUtB,KAEjC,IAAVsB,EAEJwgD,EAAGmlE,aAAcD,EAAMtlH,EAAO6F,EAAM9F,GAIpCqgD,EAAGolE,WAAYF,EAAMvlH,EAAOC,GAI7Bk2D,EAAKrtD,OAAQjK,EAAQoB,EAAOslH,EAAM,EAEnC,CAEA,eAAAG,CAAiB1lH,EAAOC,EAAO0lH,GAE9B,MAAM,GAAEtlE,EAAE,KAAEklE,EAAI,KAAEz/G,EAAI,MAAEjG,EAAK,OAAEhB,EAAM,KAAEs3D,GAAS53D,KAE7B,IAAdonH,IAEU,IAAV9lH,EAEJwgD,EAAGulE,sBAAuBL,EAAMtlH,EAAO6F,EAAM9F,EAAO2lH,GAIpDtlE,EAAGwlE,oBAAqBN,EAAMvlH,EAAOC,EAAO0lH,GAI7CxvD,EAAKrtD,OAAQjK,EAAQoB,EAAOslH,EAAMI,GAEnC,CAEA,eAAAG,CAAiBC,EAAQC,EAAQC,GAEhC,MAAM,WAAE/gB,EAAU,KAAEqgB,EAAI,OAAE1mH,EAAM,KAAEs3D,GAAS53D,KAE3C,GAAmB,IAAd0nH,EAAkB,OAEvB,MAAM1R,EAAYrP,EAAW7lG,IAAK,oBAElC,GAAmB,OAAdk1G,EAEJ,IAAM,IAAI3xG,EAAI,EAAGA,EAAIqjH,EAAWrjH,IAE/BrE,KAAKk/D,OAAQsoD,EAAQnjH,GAAKojH,EAAQpjH,QAI7B,CAEc,IAAfrE,KAAKsB,MAET00G,EAAU2R,uBAAwBX,EAAMS,EAAQ,EAAGznH,KAAKuH,KAAMigH,EAAQ,EAAGE,GAIzE1R,EAAU4R,qBAAsBZ,EAAMQ,EAAQ,EAAGC,EAAQ,EAAGC,GAI7D,IAAIG,EAAe,EACnB,IAAM,IAAIxjH,EAAI,EAAGA,EAAIqjH,EAAWrjH,IAE/BwjH,GAAgBJ,EAAQpjH,GAIzBuzD,EAAKrtD,OAAQjK,EAAQunH,EAAcb,EAAM,EAE1C,CAED,CAEA,wBAAAc,CAA0BN,EAAQC,EAAQC,EAAWN,GAEpD,MAAM,WAAEzgB,EAAU,KAAEqgB,EAAI,OAAE1mH,EAAM,KAAEs3D,GAAS53D,KAE3C,GAAmB,IAAd0nH,EAAkB,OAEvB,MAAM1R,EAAYrP,EAAW7lG,IAAK,oBAElC,GAAmB,OAAdk1G,EAEJ,IAAM,IAAI3xG,EAAI,EAAGA,EAAIqjH,EAAWrjH,IAE/BrE,KAAKmnH,gBAAiBK,EAAQnjH,GAAKojH,EAAQpjH,GAAK+iH,EAAW/iH,QAItD,CAEc,IAAfrE,KAAKsB,MAET00G,EAAU+R,gCAAiCf,EAAMS,EAAQ,EAAGznH,KAAKuH,KAAMigH,EAAQ,EAAGJ,EAAW,EAAGM,GAIhG1R,EAAUgS,8BAA+BhB,EAAMQ,EAAQ,EAAGC,EAAQ,EAAGL,EAAW,EAAGM,GAIpF,IAAIG,EAAe,EACnB,IAAM,IAAIxjH,EAAI,EAAGA,EAAIqjH,EAAWrjH,IAE/BwjH,GAAgBJ,EAAQpjH,GAAM+iH,EAAW/iH,GAI1CuzD,EAAKrtD,OAAQjK,EAAQunH,EAAcb,EAAM,EAE1C,CAED,EAYD,MAAMiB,WAAqBtd,GAe1B,WAAA7qG,CAAa2e,EAAa,CAAC,GAE1B/U,MAAO+U,GASPze,KAAKitE,gBAAiB,EAStBjtE,KAAKkoH,eAAiB,KAStBloH,KAAK2mG,WAAa,KASlB3mG,KAAKmoH,aAAe,KASpBnoH,KAAKooH,aAAe,KASpBpoH,KAAKqoH,eAAiB,KAQtBroH,KAAK8hD,GAAK,KASV9hD,KAAKiuB,MAAQ,KASbjuB,KAAKgtG,MAAQ,KAObhtG,KAAKsoH,SAAW,CAAC,EAOjBtoH,KAAKuoH,uBAAyB,CAAC,EAS/BvoH,KAAKq2C,SAAU,EASfr2C,KAAKwoH,SAAW,KAShBxoH,KAAKyoH,SAAW,KAQhBzoH,KAAK0oH,gBAAiD,IAA9BjqG,EAAWiqG,eASnC1oH,KAAK2oH,gBAAkB,KAQvB3oH,KAAK4oH,eAAiB,IAAIC,OAE3B,CAOA,IAAA3jC,CAAMpiF,GAEL4G,MAAMw7E,KAAMpiF,GAIZ,MAAM2b,EAAaze,KAAKye,WAElBqqG,OAAqC/nH,IAAvB0d,EAAWpc,QAA0Boc,EAAWpc,QAAUS,EAASq2F,WAAW/tE,WAAY,UAE7G,SAAS29F,EAAevqE,GAExBA,EAAMwqE,iBAEN,MAAMC,EAAkB,CACvB7rB,IAAK,QACLC,QAAS7+C,EAAM0qE,eAAiB,iBAChC5rB,OAAQ,KACR6rB,cAAe3qE,GAGhB17C,EAASk4F,aAAciuB,EAExB,CAEAjpH,KAAKopH,eAAiBL,EAEtBjmH,EAASq2F,WAAWjpD,iBAAkB,mBAAoB64E,GAAe,GAEzE/oH,KAAK8hD,GAAKgnE,EAEV9oH,KAAK2mG,WAAa,IAAI4f,GAAiBvmH,MACvCA,KAAKmoH,aAAe,IAAIxB,GAAmB3mH,MAC3CA,KAAKkoH,eAAiB,IAAI3c,GAAqBvrG,MAC/CA,KAAKooH,aAAe,IAAIpN,GAAmBh7G,MAC3CA,KAAKqoH,eAAiB,IAAItB,GAAqB/mH,MAE/CA,KAAKiuB,MAAQ,IAAIs/E,GAAYvtG,MAC7BA,KAAKgtG,MAAQ,IAAI8I,GAAY91G,MAE7BA,KAAK2mG,WAAW7lG,IAAK,0BACrBd,KAAK2mG,WAAW7lG,IAAK,4BACrBd,KAAK2mG,WAAW7lG,IAAK,4BACrBd,KAAK2mG,WAAW7lG,IAAK,+BACrBd,KAAK2mG,WAAW7lG,IAAK,wCACrBd,KAAK2mG,WAAW7lG,IAAK,gCACrBd,KAAK2mG,WAAW7lG,IAAK,oBAErBd,KAAKwoH,SAAWxoH,KAAK2mG,WAAW7lG,IAAK,mCACrCd,KAAKyoH,SAAWzoH,KAAK2mG,WAAW7lG,IAAK,8BAEtC,CAQA,oBAAI4hB,GAEH,OAAO,KAER,CAUA,yBAAMy8E,CAAqBx8F,GAE1B,aAAa3C,KAAKkoH,eAAe/oB,oBAAqBx8F,EAEvD,CASA,gBAAMu6F,SAECl9F,KAAKgtG,MAAMC,kBAElB,CAOA,kBAAAoc,CAAoBzwD,GAEnB,IAAO54D,KAAKwoH,WAAcxoH,KAAK0oH,eAAiB,OAEhD,MAAMlG,EAAoBxiH,KAAKc,IAAK83D,GAEpC,GAAK54D,KAAKspH,aAIR,OAFO9G,EAAkB+G,aAAa/G,EAAkB+G,WAAa,SACrE/G,EAAkB+G,WAAWzjH,KAAM8yD,GAKhC4pD,EAAkBgH,cAErBxpH,KAAK8hD,GAAG2nE,SAAUzpH,KAAKwoH,SAASkB,kBAChClH,EAAkBgH,YAAc,MAIlChH,EAAkBgH,YAAcxpH,KAAK8hD,GAAG6nE,cAED,OAAlCnH,EAAkBgH,cAErBxpH,KAAK8hD,GAAG8nE,WAAY5pH,KAAKwoH,SAASkB,iBAAkBlH,EAAkBgH,aACtExpH,KAAKspH,cAAe,EAIvB,CASA,sBAAAO,CAAwBjxD,GAEvB,IAAO54D,KAAKwoH,WAAcxoH,KAAK0oH,eAAiB,OAEhD,MAAMlG,EAAoBxiH,KAAKc,IAAK83D,GAEpC,GAAK4pD,EAAkBgH,cAErBxpH,KAAK8hD,GAAG2nE,SAAUzpH,KAAKwoH,SAASkB,kBAEzBlH,EAAkBsH,aAAatH,EAAkBsH,WAAa,IACrEtH,EAAkBsH,WAAWhkH,KAAM,CAAEikH,MAAOvH,EAAkBgH,cAC9DhH,EAAkBgH,YAAc,KAChCxpH,KAAKspH,cAAe,EAEf9G,EAAkB+G,YAAc/G,EAAkB+G,WAAWvlH,OAAS,GAAI,CAE/E,MAAMgmH,EAAoBxH,EAAkB+G,WAAWz1G,QACvD9T,KAAKqpH,mBAAoBW,EAE1B,CAIF,CAUA,2BAAM/sB,CAAuBrkC,EAAerxD,EAAO,UAElD,IAAOvH,KAAKwoH,WAAcxoH,KAAK0oH,eAAiB,OAEhD,MAAMlG,EAAoBxiH,KAAKc,IAAK83D,GAE7B4pD,EAAkBsH,aAAatH,EAAkBsH,WAAa,IAErE,IAAM,IAAIzlH,EAAI,EAAGA,EAAIm+G,EAAkBsH,WAAW9lH,OAAQK,IAAO,CAE/D,MAAM4lH,EAAYzH,EAAkBsH,WAAYzlH,GAC1C6lH,EAAYlqH,KAAK8hD,GAAGqoE,kBAAmBF,EAAUF,MAAO/pH,KAAK8hD,GAAGsoE,wBAChE5B,EAAWxoH,KAAK8hD,GAAGqtD,aAAcnvG,KAAKwoH,SAAS6B,kBAErD,GAAKH,IAAe1B,EAAW,CAE/B,MAAM8B,EAAUtqH,KAAK8hD,GAAGqoE,kBAAmBF,EAAUF,MAAO/pH,KAAK8hD,GAAGyoE,cAC9DC,EAAWr8G,OAAQm8G,GAAY,IACrCtqH,KAAK8hD,GAAG2oE,YAAaR,EAAUF,OAC/BvH,EAAkBsH,WAAWtlB,OAAQngG,EAAG,GACxCA,IACArE,KAAK8C,SAAS80D,KAAKmI,gBAAiBx4D,EAAMijH,EAE3C,CAED,CAED,CAOA,UAAAp/F,GAEC,OAAOprB,KAAK8hD,EAEb,CAQA,WAAA+8C,CAAajmC,GAEZ,MAAM,GAAE9W,GAAO9hD,KACTwiH,EAAoBxiH,KAAKc,IAAK83D,GA0BpC,GApBA54D,KAAKqpH,mBAAoBzwD,GAEzB4pD,EAAkBr3F,gBAAkBnrB,KAAK2oH,gBACzC3oH,KAAK2oH,gBAAkB/vD,EAEvB54D,KAAKulH,gBAAiB3sD,GAEtB54D,KAAKs9E,MAAO1kB,EAAc+N,WAAY/N,EAAciO,WAAYjO,EAAcoO,aAAcpO,GAAe,GAGtGA,EAAcvmB,SAElBryC,KAAKgjG,eAAgBpqC,GAIrB9W,EAAGzP,SAAU,EAAG,EAAGyP,EAAG4oE,mBAAoB5oE,EAAG6oE,qBAIzC/xD,EAAcuO,QAAU,CAE5B,MAAM,EAAEv9C,EAAC,EAAEE,EAAC,MAAE3nB,EAAK,OAAEC,GAAWw2D,EAAcwO,aAE9CtlB,EAAGqlB,QAASv9C,EAAGgvC,EAAcx2D,OAASA,EAAS0nB,EAAG3nB,EAAOC,EAE1D,CAEA,MAAMqjE,EAAsB7M,EAAc6M,oBAErCA,EAAsB,IAI1B+8C,EAAkBoI,wBAA0BpI,EAAkBqI,iBAC9DrI,EAAkBsI,6BAA+BtI,EAAkBuI,sBAEnEvI,EAAkBwI,oBAAsB,KACxCxI,EAAkBqI,iBAAmB,IAAI9lH,MAAO0gE,GAChD+8C,EAAkBuI,sBAAwB,IAAIhmH,MAAO0gE,GACrD+8C,EAAkByI,oBAAsB,EAI1C,CAQA,YAAAlsB,CAAcnmC,GAEb,MAAM,GAAE9W,EAAE,MAAE7zB,GAAUjuB,KAChBwiH,EAAoBxiH,KAAKc,IAAK83D,GAC9BztC,EAAkBq3F,EAAkBr3F,gBAEpCs6C,EAAsB7M,EAAc6M,oBAErCA,EAAsB,IAErBA,EAAsB+8C,EAAkByI,qBAE5CnpE,EAAG2nE,SAAU3nE,EAAGopE,oBAIjBlrH,KAAKmrH,qBAAsBvyD,IAI5B,MAAMlqD,EAAWkqD,EAAclqD,SAE/B,GAAkB,OAAbA,EAEJ,IAAM,IAAIrK,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAE5C,MAAMyvB,EAAUplB,EAAUrK,GAErByvB,EAAQwf,iBAEZtzC,KAAKszC,gBAAiBxf,EAIxB,CAMD,GAFA9zB,KAAK2oH,gBAAkBx9F,EAES,OAA3BytC,EAAclqD,UAAqBkqD,EAAczmB,aAAe,CAEpE,MAAM8yE,EAA0BjlH,KAAKc,IAAK83D,EAAczmB,eAElD,QAAEqH,GAAYof,EAAczmB,aAElC,GAAKqH,EAAU,EAAI,CAElB,MAAM0rE,EAAKD,EAAwBvC,aAAc9pD,EAAc1yD,eAEzDk0E,EAAOt4B,EAAG0iE,iBAEVzB,EAAkBkC,EAAwBlC,gBAE1Cr0G,EAAWkqD,EAAclqD,SAE/Buf,EAAM8mF,gBAAiBjzD,EAAGyiE,iBAAkBxB,GAC5C90F,EAAM8mF,gBAAiBjzD,EAAGmzD,iBAAkBiQ,GAE5C,IAAM,IAAI7gH,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAIrC,GAAKu0D,EAAcuO,QAAU,CAE5B,MAAM,EAAEv9C,EAAC,EAAEE,EAAC,MAAE3nB,EAAK,OAAEC,GAAWw2D,EAAcwO,aAExCgkD,EAAQxyD,EAAcx2D,OAASA,EAAS0nB,EAE9Cg4B,EAAG4iE,gBAAiB96F,EAAGwhG,EAAOxhG,EAAIznB,EAAOipH,EAAQhpH,EAAQwnB,EAAGwhG,EAAOxhG,EAAIznB,EAAOipH,EAAQhpH,EAAQg4E,EAAMt4B,EAAGu5D,SACvGv5D,EAAGupE,yBAA0BvpE,EAAGyiE,iBAAkBU,EAAwBqG,kBAAmB1hG,EAAGwhG,EAAOjpH,EAAOC,EAE/G,MAEC0/C,EAAG4iE,gBAAiB,EAAG,EAAG9rD,EAAcz2D,MAAOy2D,EAAcx2D,OAAQ,EAAG,EAAGw2D,EAAcz2D,MAAOy2D,EAAcx2D,OAAQg4E,EAAMt4B,EAAGu5D,SAC/Hv5D,EAAGypE,sBAAuBzpE,EAAGyiE,iBAAkBU,EAAwBqG,kBAM1E,CAGD,CAEyB,OAApBngG,IAEJnrB,KAAKulH,gBAAiBp6F,GAEjBA,EAAgBknB,SAEpBryC,KAAKgjG,eAAgB73E,GAIrB22B,EAAGzP,SAAU,EAAG,EAAGyP,EAAG4oE,mBAAoB5oE,EAAG6oE,sBAM/C3qH,KAAK6pH,uBAAwBjxD,EAE9B,CASA,oBAAAuyD,CAAsBvyD,GAErB,MAAM4pD,EAAoBxiH,KAAKc,IAAK83D,IAI9B,wBAAEgyD,EAAuB,6BAAEE,GAAiCtI,EAElE,GAAKoI,GAA2BE,EAA+B,CAE9D,MAAMU,EAAW,IAAI3C,SACf,GAAE/mE,GAAO9hD,KAEfwiH,EAAkBsI,6BAA+B,KACjDtI,EAAkBoI,wBAA0B,KAE5C,MAAMa,EAAQ,KAEb,IAAIC,EAAY,EAGhB,IAAM,IAAIrnH,EAAI,EAAGA,EAAIumH,EAAwB5mH,OAAQK,IAAO,CAE3D,MAAM0lH,EAAQa,EAAyBvmH,GAExB,OAAV0lH,IAEAjoE,EAAGqoE,kBAAmBJ,EAAOjoE,EAAGsoE,0BAE/BtoE,EAAGqoE,kBAAmBJ,EAAOjoE,EAAGyoE,cAAiB,GAAIiB,EAASp3G,IAAK02G,EAA8BzmH,IAEtGumH,EAAyBvmH,GAAM,KAC/By9C,EAAG2oE,YAAaV,GAEhB2B,KAIF,CAEKA,EAAYd,EAAwB5mH,OAExCi0D,sBAAuBwzD,GAIvBjJ,EAAkBgJ,SAAWA,CAE9B,EAIDC,GAED,CAED,CAUA,UAAAtrB,CAAYvnC,EAAet4D,GAE1B,MAAMkiH,EAAoBxiH,KAAKc,IAAK83D,GAEpC,OAAO4pD,EAAkBgJ,UAAYhJ,EAAkBgJ,SAAS7qH,IAAKL,EAEtE,CAOA,cAAA0iG,CAAgBpqC,GAEf,MAAM9W,EAAK9hD,KAAK8hD,IACV,EAAEl4B,EAAC,EAAEE,EAAC,MAAE3nB,EAAK,OAAEC,GAAWw2D,EAAcsO,cAE9CplB,EAAGzP,SAAUzoB,EAAGgvC,EAAcx2D,OAASA,EAAS0nB,EAAG3nB,EAAOC,EAE3D,CAOA,cAAAqyE,CAAgBorB,GAEf,MAAM/9C,EAAK9hD,KAAK8hD,GAEX+9C,EAEJ/9C,EAAGwuD,OAAQxuD,EAAG6pE,cAId7pE,EAAGyuD,QAASzuD,EAAG6pE,aAIjB,CAWA,KAAAruC,CAAOnkE,EAAOme,EAAOyvC,EAAS3K,EAAa,KAAMwvD,GAAiB,GAEjE,MAAM,GAAE9pE,GAAO9hD,KAEf,GAAoB,OAAfo8D,EAAsB,CAE1B,MAAMuK,EAAa3mE,KAAK+zE,gBAIxBpN,EAAW7pC,GAAK6pC,EAAW9mD,EAC3B8mD,EAAW5pC,GAAK4pC,EAAW9mD,EAC3B8mD,EAAW7mD,GAAK6mD,EAAW9mD,EAE3Bu8C,EAAa,CACZ1tD,SAAU,KACVk4D,gBAAiBD,EAGnB,CAIA,IAAI2W,EAAQ,EAMZ,GAJKnkE,IAAQmkE,GAASx7B,EAAG0iE,kBACpBltF,IAAQgmD,GAASx7B,EAAG2iE,kBACpB19C,IAAUuW,GAASx7B,EAAGkjE,oBAEZ,IAAV1nC,EAAc,CAElB,IAAI3W,EAoBJ,GAlBKvK,EAAWwK,gBAEfD,EAAavK,EAAWwK,iBAIxBD,EAAa3mE,KAAK+zE,gBAIlBpN,EAAW7pC,GAAK6pC,EAAW9mD,EAC3B8mD,EAAW5pC,GAAK4pC,EAAW9mD,EAC3B8mD,EAAW7mD,GAAK6mD,EAAW9mD,GAIvByX,GAAQt3B,KAAKiuB,MAAMskF,cAAc,GAET,OAAxBn2C,EAAW1tD,SAEfozC,EAAG6kB,WAAYA,EAAW7pC,EAAG6pC,EAAW5pC,EAAG4pC,EAAW7mD,EAAG6mD,EAAW9mD,GACpEiiC,EAAGw7B,MAAOA,OAEJ,CAIN,GAFKsuC,GAAiB5rH,KAAKulH,gBAAiBnpD,GAEvCjjD,EAEJ,IAAM,IAAI9U,EAAI,EAAGA,EAAI+3D,EAAW1tD,SAAS1K,OAAQK,IAEhDy9C,EAAG+pE,cAAe/pE,EAAG9gB,MAAO38B,EAAG,CAAEsiE,EAAW7pC,EAAG6pC,EAAW5pC,EAAG4pC,EAAW7mD,EAAG6mD,EAAW9mD,IAMnFyX,GAASyvC,EAEbjlB,EAAGgqE,cAAehqE,EAAG40D,cAAe,EAAG,EAAG,GAE/Bp/E,EAEXwqB,EAAG+pE,cAAe/pE,EAAGzN,MAAO,EAAG,CAAE,IAEtB0yB,GAEXjlB,EAAGiqE,cAAejqE,EAAGkqE,QAAS,EAAG,CAAE,GAIrC,CAED,CAED,CAQA,YAAAprB,CAAcqrB,GAEb,MAAM,MAAEh+F,EAAK,GAAE6zB,GAAO9hD,KAEtBiuB,EAAM8mF,gBAAiBjzD,EAAGozD,YAAa,MACvCl1G,KAAKqpH,mBAAoB4C,EAE1B,CAUA,OAAA/6F,CAAS+6F,EAAcv7F,EAAaksC,EAAU7D,GAE7C,MAAM,MAAE9qC,EAAK,GAAE6zB,GAAO9hD,MAEA,IAAjBA,KAAKq2C,UAGTyL,EAAGwuD,OAAQxuD,EAAGoqE,oBACdlsH,KAAKq2C,SAAU,GAIhB,MAAM,WAAE81E,EAAU,iBAAEC,EAAgB,WAAEjrH,GAAenB,KAAKc,IAAKi4D,GAEzDszD,EAASrsH,KAAKssH,WAAY,KAAMnrH,GAEhCorH,EAASvsH,KAAKsoH,SAAU+D,QAEdtrH,IAAXwrH,EAEJvsH,KAAKwsH,WAAY,KAAMrrH,GAIvB2gD,EAAG2qE,gBAAiBF,GAIrBt+F,EAAM6mF,WAAYqX,GAElBnsH,KAAK0sH,cAAe9vD,GAEpB,MAAM+vD,EAAuB3sH,KAAK4sH,sBAAuBR,GAEzDtqE,EAAG+qE,sBAAuB/qE,EAAGgrE,mBAAoBH,GACjD7qE,EAAGirE,uBAAwBjrE,EAAGkrE,QAEzB7rH,EAAY,GAAI69D,kCAEpBld,EAAGwlE,oBAAqBxlE,EAAGkrE,OAAQ,EAAG,EAAGt8F,EAAYhvB,OAIrDogD,EAAGolE,WAAYplE,EAAGkrE,OAAQ,EAAGt8F,EAAYhvB,OAI1CogD,EAAGmrE,uBACHnrE,EAAG+qE,sBAAuB/qE,EAAGgrE,mBAAoB,MAIjD,IAAM,IAAIzoH,EAAI,EAAGA,EAAI+nH,EAAiBpoH,OAAQK,IAAO,CAEpD,MAAM6oH,EAAoBd,EAAkB/nH,GAEvC6oH,EAAkBlmB,KAEtBhnG,KAAKooH,aAAa3G,oBAAqByL,EAAkB7hB,gBAAiB6hB,EAAkBlmB,KAI7FkmB,EAAkB5hB,eAGnB,CAED,CAQA,aAAAtK,CAAeirB,GAEd,MAAMnqE,EAAK9hD,KAAK8hD,GAEhB9hD,KAAKq2C,SAAU,EAEfyL,EAAGyuD,QAASzuD,EAAGoqE,oBAEflsH,KAAK6pH,uBAAwBoC,GAExBjsH,KAAK2oH,iBAET3oH,KAAKulH,gBAAiBvlH,KAAK2oH,gBAI7B,CAQA,IAAAtlB,CAAM3iG,GAEL,MAAM,OAAEJ,EAAM,SAAEy4D,EAAQ,SAAE93D,EAAQ,QAAEoB,EAAO,uBAAE03D,GAA2Br5D,GAClE,WAAEyrH,GAAensH,KAAKc,IAAKi4D,IAE3B,GAAEjX,EAAE,MAAE7zB,GAAUjuB,KAEhBmtH,EAAcntH,KAAKc,IAAKuB,GAExB42D,EAAav4D,EAAaq6D,oBAEhC,GAAoB,OAAf9B,EAAsB,OAI3Bj5D,KAAK0sH,cAAehsH,EAAa05D,eAEjC,MAAM65C,EAAgB3zG,EAAOu/D,QAAUv/D,EAAOsB,YAAYwrH,cAAgB,EAE1En/F,EAAM+lF,YAAa/yG,EAAUgzG,EAAal6C,GAE1C9rC,EAAM6mF,WAAYqX,GAIlB,MAAM7oH,EAAmBtD,KAAKc,IAAKJ,GAEnC,IAAI6rH,EAASjpH,EAAiB+pH,UAE9B,QAAgBtsH,IAAXwrH,GAAwBjpH,EAAiBgqH,aAAe5sH,EAAaM,SAASoC,GAAK,CAEvF,MAAMipH,EAASrsH,KAAKssH,WAAY5rH,EAAa45D,WAAY55D,EAAag6D,iBAItE,GAFA6xD,EAASvsH,KAAKsoH,SAAU+D,QAERtrH,IAAXwrH,EAAuB,CAE3B,IAAIc,IAEAd,SAAQc,aAAcrtH,KAAKwsH,WAAY9rH,EAAa45D,WAAY55D,EAAag6D,kBAE5E2yD,IAEJ/pH,EAAiB+pH,UAAYd,EAC7BjpH,EAAiBgqH,WAAa5sH,EAAaM,SAASoC,GAItD,CAED,CAEA0+C,EAAG2qE,gBAAiBF,GAIpB,MAAMjrH,EAAQZ,EAAa45D,WAIrBizD,EAAaJ,EAAYnC,oBAE/B,GAAKuC,IAAejtH,QAAyBS,IAAfwsH,EAA2B,CAUxD,GARoB,OAAfA,IAAoD,IAA7BA,EAAW1nD,gBAEtC/jB,EAAG2nE,SAAU3nE,EAAGopE,oBAEhBiC,EAAYlC,wBAIiB,IAAzB3qH,EAAOulE,cAAyB,CAEpC,MAAMkkD,EAAQjoE,EAAG6nE,cAEjB7nE,EAAG8nE,WAAY9nE,EAAGopE,mBAAoBnB,GAEtCoD,EAAYtC,iBAAkBsC,EAAYlC,qBAAwBlB,EAClEoD,EAAYpC,sBAAuBoC,EAAYlC,qBAAwB3qH,CAExE,CAEA6sH,EAAYnC,oBAAsB1qH,CAEnC,CAGA,MAAMwC,EAAW9C,KAAKqoH,eAEjB/nH,EAAOk7D,SAAW14D,EAASkkH,KAAOllE,EAAGkrE,OAChC1sH,EAAOm7D,eAAiB34D,EAASkkH,KAAOllE,EAAG0rE,MAC3CltH,EAAOo7D,OAAS54D,EAASkkH,KAAOllE,EAAG2rE,WACnCntH,EAAOq7D,WAAa74D,EAASkkH,KAAOllE,EAAG4rE,WAGpB,IAAvBzsH,EAASs6D,WAEbttC,EAAMkjF,aAAclwG,EAAS0sH,mBAAqB3tH,KAAK8C,SAAS0vC,iBAChE1vC,EAASkkH,KAAOllE,EAAG0rE,OAInB1qH,EAASkkH,KAAOllE,EAAG8rE,UAQrB,MAAM,YAAE5yD,EAAW,cAAEE,GAAkBjC,EACvC,IAAI,YAAEgC,GAAgBhC,EAItB,GAFAn2D,EAASxC,OAASA,EAEH,OAAVgB,EAAiB,CAErB25D,GAAe35D,EAAMkE,MAAMo+F,kBAE3B,MAAMiqB,EAAY7tH,KAAKc,IAAKQ,GAE5BwB,EAASxB,MAAQA,EAAMI,MACvBoB,EAASyE,KAAOsmH,EAAUtmH,IAE3B,MAECzE,EAASxB,MAAQ,EAIbhB,EAAO25C,cAEyB,OAA/B35C,EAAOwtH,oBAEXhrH,EAASglH,yBAA0BxnH,EAAOytH,iBAAkBztH,EAAO0tH,iBAAkB1tH,EAAO2tH,gBAAiB3tH,EAAOwtH,qBAEvG9tH,KAAKkhG,WAAY,oBAM9Bp+F,EAASykH,gBAAiBjnH,EAAOytH,iBAAkBztH,EAAO0tH,iBAAkB1tH,EAAO2tH,kBAJnF,SAAU,wDAQA/yD,EAAgB,EAE3Bp4D,EAASqkH,gBAAiBlsD,EAAaD,EAAaE,GAIpDp4D,EAASo8D,OAAQjE,EAAaD,GAK/BlZ,EAAG2qE,gBAAiB,KAErB,CAQA,iBAAA/pD,GAEC,OAAO,CAER,CAQA,iBAAAF,GAEC,MAAO,EAER,CAUA,oBAAA4G,CAAsBt1C,GAErB9zB,KAAKooH,aAAah/C,qBAAsBt1C,EAEzC,CAQA,aAAAk1C,CAAel1C,EAASupB,GAEvBr9C,KAAKooH,aAAap/C,cAAel1C,EAASupB,EAE3C,CAQA,aAAA+lB,CAAetvC,EAASupB,GAEvBr9C,KAAKooH,aAAahlD,cAAetvC,EAASupB,EAE3C,CAOA,eAAA/J,CAAiBxf,GAEhB9zB,KAAKooH,aAAa90E,gBAAiBxf,EAEpC,CAOA,cAAA80C,CAAgB90C,GAEf9zB,KAAKooH,aAAax/C,eAAgB90C,EAEnC,CAaA,mBAAA+tE,CAAqB/tE,EAASlK,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,GAElD,OAAOjnF,KAAKooH,aAAavmB,oBAAqB/tE,EAASlK,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,EAE7E,CAOA,aAAAle,GAIA,CAOA,cAAAJ,GAA+B,CAW/B,iBAAAksB,CAAmBv0F,EAAQwC,GAE1B,OAAO,IAAI2jG,GAAiBnmG,EAAQwC,EAErC,CASA,aAAA4+D,CAAee,GAEd,MAAM3gB,EAAK9hD,KAAK8hD,IACV,MAAE+e,EAAK,KAAED,GAAS6B,EAElByrD,EAAmB,aAAVrtD,EAAuB/e,EAAGqsE,aAAcrsE,EAAGssE,iBAAoBtsE,EAAGqsE,aAAcrsE,EAAGusE,eAElGvsE,EAAGwsE,aAAcJ,EAAQttD,GACzB9e,EAAGysE,cAAeL,GAElBluH,KAAKwC,IAAKigE,EAAS,CAClB+rD,UAAWN,GAGb,CAOA,cAAAtjB,CAAgBnoC,GAEfziE,KAAKgwC,OAAQyyB,EAEd,CAQA,oBAAAF,CAAsB7hE,EAAcohE,GAEnC,MAAMhgB,EAAK9hD,KAAK8hD,GACViX,EAAWr4D,EAAaq4D,UAIxB,gBAAEuH,EAAe,cAAED,GAAkBtH,EAErCozD,EAAarqE,EAAG4f,gBAEhBS,EAAiBniE,KAAKc,IAAKw/D,GAAkBkuD,UAC7CvsD,EAAejiE,KAAKc,IAAKu/D,GAAgBmuD,UAY/C,GAVA1sE,EAAG2sE,aAActC,EAAYhqD,GAC7BrgB,EAAG2sE,aAActC,EAAYlqD,GAC7BngB,EAAG4sE,YAAavC,GAEhBnsH,KAAKwC,IAAKu2D,EAAU,CACnBozD,aACAhqD,iBACAF,iBAGiB,OAAbH,GAAqB9hE,KAAKyoH,SAA/B,CAEC,MAAM1S,EAAI,IAAIna,SAAWC,IAExB,MAAM4sB,EAAWzoH,KAAKyoH,SAChBkG,EAAc,KAEd7sE,EAAG8sE,oBAAqBzC,EAAY1D,EAASoG,wBAEjD7uH,KAAK8uH,iBAAkBpuH,EAAcq4D,GACrC8iC,KAIA5jC,sBAAuB02D,EAExB,EAIDA,GAAa,IAId7sD,EAASh8D,KAAMiwG,EAIhB,MAEA/1G,KAAK8uH,iBAAkBpuH,EAAcq4D,EAEtC,CAUA,aAAAg2D,CAAeC,EAAQC,GAEtB,MAAMxvD,EAAQuvD,EAAOx/G,MAAO,MACtB0/G,EAAS,GAET/mH,EAAOlD,KAAKoM,IAAK49G,EAAY,EAAG,GAChCE,EAAKlqH,KAAKu8C,IAAKytE,EAAY,EAAGxvD,EAAMz7D,QAE1C,IAAM,IAAIK,EAAI8D,EAAM9D,EAAI8qH,EAAI9qH,IAAO,CAElC,MAAM+qH,EAAO/qH,EAAI,EACjB6qH,EAAOppH,KAAM,GAAGspH,IAASH,EAAY,IAAM,OAAOG,MAAS3vD,EAAOp7D,KAEnE,CAEA,OAAO6qH,EAAOp+G,KAAM,KAErB,CAWA,gBAAAu+G,CAAkBvtE,EAAIosE,EAAQ3mH,GAE7B,MAAM+nH,EAASxtE,EAAGytE,mBAAoBrB,EAAQpsE,EAAG0tE,gBAC3CC,EAAS3tE,EAAG4tE,iBAAkBxB,GAAS56B,OAE7C,GAAKg8B,GAAqB,KAAXG,EAAgB,MAAO,GAEtC,MAAME,EAAe,iBAAiB3jC,KAAMyjC,GAC5C,GAAKE,EAAe,CAEnB,MAAMV,EAAYr7B,SAAU+7B,EAAc,IAC1C,OAAOpoH,EAAKqoH,cAAgB,OAASH,EAAS,OAASzvH,KAAK+uH,cAAejtE,EAAG+tE,gBAAiB3B,GAAUe,EAE1G,CAEC,OAAOQ,CAIT,CAUA,gBAAAK,CAAkB3D,EAAY4D,EAAkBC,GAE/C,GAAKhwH,KAAK8C,SAASw4F,MAAMC,kBAAoB,CAE5C,MAAMz5C,EAAK9hD,KAAK8hD,GAEVmuE,EAAanuE,EAAGouE,kBAAmB/D,GAAa74B,OAEtD,IAA8D,IAAzDxxC,EAAG8sE,oBAAqBzC,EAAYrqE,EAAGquE,aAG3C,GAAkD,mBAAtCnwH,KAAK8C,SAASw4F,MAAME,cAE/Bx7F,KAAK8C,SAASw4F,MAAME,cAAe15C,EAAIqqE,EAAY6D,EAAgBD,OAE7D,CAIN,MAAMK,EAAepwH,KAAKqvH,iBAAkBvtE,EAAIkuE,EAAgB,UAC1DK,EAAiBrwH,KAAKqvH,iBAAkBvtE,EAAIiuE,EAAkB,YAEpEtjH,QAAQkiB,MACP,oCAAsCmzB,EAAGwuE,WAAzC,sBACqBxuE,EAAG8sE,oBAAqBzC,EAAYrqE,EAAGyuE,iBAD5D,yBAEuBN,EAAa,KACpCG,EAAe,KACfC,EAGF,KAE0B,KAAfJ,GAEXxjH,QAAQC,KAAM,wCAAyCujH,EAIzD,CAED,CASA,gBAAAnB,CAAkBpuH,EAAcq4D,GAE/B,MAAM,MAAE9qC,EAAK,GAAE6zB,GAAO9hD,KAChBwwH,EAAexwH,KAAKc,IAAKi4D,IACzB,WAAEozD,EAAU,eAAEhqD,EAAc,aAAEF,GAAiBuuD,GAES,IAAzD1uE,EAAG8sE,oBAAqBzC,EAAYrqE,EAAGquE,cAE3CnwH,KAAK8vH,iBAAkB3D,EAAYhqD,EAAgBF,GAIpDh0C,EAAM6mF,WAAYqX,GAIlB,MAAMvvD,EAAWl8D,EAAa05D,cAE9Bp6D,KAAKywH,eAAgB7zD,EAAUuvD,GAI/BnsH,KAAKwC,IAAKu2D,EAAU,CACnBozD,cAGF,CAQA,qBAAA7pD,CAAuBy+B,EAAiBnkC,GAEvC,MAAM,MAAE3uC,EAAK,GAAE6zB,GAAO9hD,KAIhBsgE,EAAkB,CACvBO,MAAO,WACPD,KAAM,2DAGP5gE,KAAK0hE,cAAepB,GAEpB,MAAM,eAAEE,GAAmBugC,EAErBorB,EAAarqE,EAAG4f,gBAEhBS,EAAiBniE,KAAKc,IAAKw/D,GAAkBkuD,UAC7CvsD,EAAejiE,KAAKc,IAAK0/D,GAAiBguD,UAE1C1tD,EAAaN,EAAeM,WAE5B4vD,EAAwB,GACxBC,EAA0B,GAEhC,IAAM,IAAItsH,EAAI,EAAGA,EAAIy8D,EAAW98D,OAAQK,IAAO,CAE9C,MAAMwlG,EAAY/oC,EAAYz8D,GAE9BqsH,EAAsB5qH,KAAM+jG,EAAUH,aACtCinB,EAAwB7qH,KAAM+jG,EAAUF,cAEzC,CAEA7nD,EAAG2sE,aAActC,EAAYhqD,GAC7BrgB,EAAG2sE,aAActC,EAAYlqD,GAE7BngB,EAAG8uE,0BACFzE,EACAuE,EACA5uE,EAAG+uE,kBAGJ/uE,EAAG4sE,YAAavC,IAE8C,IAAzDrqE,EAAG8sE,oBAAqBzC,EAAYrqE,EAAGquE,cAE3CnwH,KAAK8vH,iBAAkB3D,EAAYhqD,EAAgBF,GAKpDh0C,EAAM6mF,WAAYqX,GAIlBnsH,KAAKywH,eAAgB7zD,EAAUuvD,GAE/B,MAAM2E,EAAiBtwD,EAAer/D,WAChCA,EAAa,GACbirH,EAAmB,GAEzB,IAAM,IAAI/nH,EAAI,EAAGA,EAAIysH,EAAe9sH,OAAQK,IAAO,CAElD,MAAM1B,EAAYmuH,EAAgBzsH,GAAI8B,KAAKxD,UAE3CxB,EAAW2E,KAAMnD,GAEV3C,KAAKW,IAAKgC,IAAc3C,KAAKkoH,eAAezqD,gBAAiB96D,EAAWm/C,EAAGivE,aAEnF,CAEA,IAAM,IAAI1sH,EAAI,EAAGA,EAAIssH,EAAwB3sH,OAAQK,IAAO,CAE3D,MAAM1B,EAAYguH,EAAyBtsH,GAAI1B,UAExC3C,KAAKW,IAAKgC,IAAc3C,KAAKkoH,eAAezqD,gBAAiB96D,EAAWm/C,EAAGivE,cAElF,MAAMxzD,EAAgBv9D,KAAKc,IAAK6B,GAEhCypH,EAAiBtmH,KAAMy3D,EAExB,CAIAv9D,KAAKwC,IAAKu+F,EAAiB,CAC1BorB,aACAC,mBACAjrH,cAGF,CAUA,cAAAk5D,CAAgBuI,EAAWhG,GAE1B,IAA6C,IAAxC58D,KAAK4oH,eAAejoH,IAAKi8D,GAAuB,CAEpD58D,KAAK4oH,eAAex0G,IAAKwoD,GAEzB,IAAIo0D,EAAiB,EACjBtiH,EAAW,EAEf,IAAM,MAAMk0D,KAAahG,EAAW,CAEnC58D,KAAKwC,IAAKogE,EAAW,CACpBl0D,SAAUA,EACVsiH,eAAgBA,IAGjB,IAAM,MAAM9tD,KAAWN,EAAUhG,SAE3BsG,EAAQU,iBAAkBotD,IAC1B9tD,EAAQC,kBAAmBz0D,GAIlC,CAED,CAEA1O,KAAK0kE,eAAgB9B,EAAWhG,EAEjC,CAUA,cAAA8H,CAAgB9B,GAEf,MAAM,GAAE9gB,GAAO9hD,KAETixH,EAAgBjxH,KAAKc,IAAK8hE,GAEhC,IAAIv+D,EAAI4sH,EAAcD,eAClBxnG,EAAIynG,EAAcviH,SAEtB,IAAM,MAAMw0D,KAAWN,EAAUhG,SAEhC,GAAKsG,EAAQkhC,iBAAmBlhC,EAAQU,gBAAkB,CAEzD,MAAM/iE,EAAOqiE,EAAQ56D,OACf4iG,EAAYppD,EAAG8qD,eAErB9qD,EAAGuqD,WAAYvqD,EAAGovE,eAAgBhmB,GAClCppD,EAAGvyB,WAAYuyB,EAAGovE,eAAgBrwH,EAAMihD,EAAGqvE,cAE3CnxH,KAAKwC,IAAK0gE,EAAS,CAClB5hE,MAAO+C,IACP6mG,aAGF,MAAO,GAAKhoC,EAAQC,iBAAmB,CAEtC,MAAM,WAAEi+C,EAAU,cAAEvF,GAAkB77G,KAAKc,IAAKoiE,EAAQpvC,SAExD9zB,KAAKwC,IAAK0gE,EAAS,CAClB5hE,MAAOkoB,IACP43F,aACAvF,iBAGF,CAIF,CAOA,aAAAh4C,CAAeX,GAEd,MAAMphB,EAAK9hD,KAAK8hD,GAEhB,GAAKohB,EAAQkhC,iBAAmBlhC,EAAQU,gBAAkB,CAEzD,MACMsnC,EADclrG,KAAKc,IAAKoiE,GACAgoC,UACxBrqG,EAAOqiE,EAAQ56D,OAErBw5C,EAAGuqD,WAAYvqD,EAAGovE,eAAgBhmB,GAClCppD,EAAGvyB,WAAYuyB,EAAGovE,eAAgBrwH,EAAMihD,EAAGqvE,aAE5C,CAED,CASA,oBAAAzzD,CAAsB/6D,GAErB,MAAMm/C,EAAK9hD,KAAK8hD,GAEhB9hD,KAAKkoH,eAAezqD,gBAAiB96D,EAAWm/C,EAAGsvE,qBAEpD,CAOA,eAAA3zD,CAAiB96D,GAEhB,GAAK3C,KAAKW,IAAKgC,GAAc,OAE7B,MAAMm/C,EAAK9hD,KAAK8hD,GAEhB9hD,KAAKkoH,eAAezqD,gBAAiB96D,EAAWm/C,EAAGivE,aAEpD,CAOA,sBAAApzD,CAAwBh7D,GAEvB,GAAK3C,KAAKW,IAAKgC,GAAc,OAE7B,MAAMm/C,EAAK9hD,KAAK8hD,GAEhB9hD,KAAKkoH,eAAezqD,gBAAiB96D,EAAWm/C,EAAGivE,aAEpD,CAOA,eAAAjzD,CAAiBn7D,GAEhB3C,KAAKkoH,eAAepqD,gBAAiBn7D,EAEtC,CAOA,gBAAA66D,CAAkB76D,GAEjB3C,KAAKkoH,eAAe1qD,iBAAkB76D,EAEvC,CAQA,UAAAu+F,CAAYx+F,GAEX,MAAM2uH,EAAextH,OAAOC,KAAMgjH,IAAgBwK,QAAQxiH,GAAOg4G,GAAeh4G,KAAUpM,IAEpFikG,EAAa3mG,KAAK2mG,WAExB,IAAM,IAAItiG,EAAI,EAAGA,EAAIgtH,EAAartH,OAAQK,IAEzC,GAAKsiG,EAAWhmG,IAAK0wH,EAAchtH,IAAQ,OAAO,EAInD,OAAO,CAER,CAOA,gBAAA66F,GAEC,OAAOl/F,KAAKmoH,aAAajpB,kBAE1B,CAWA,oBAAAoC,CAAsBC,EAAYC,EAAYC,EAAY,KAAMC,EAAc,KAAMhuE,EAAQ,GAE3F1zB,KAAKooH,aAAa9mB,qBAAsBC,EAAYC,EAAYC,EAAWC,EAAahuE,EAEzF,CASA,wBAAA+f,CAA0B3f,EAAS8kC,EAAeyoC,GAEjDrhG,KAAKooH,aAAa30E,yBAA0B3f,EAAS8kC,EAAeyoC,EAErE,CAQA,eAAAkkB,CAAiBnpD,GAEhB,MAAM,GAAEta,EAAE,MAAE7zB,GAAUjuB,KAEtB,IAAIuxH,EAAqB,KAEzB,GAA6B,OAAxBn1D,EAAW1tD,SAAoB,CAEnC,MAAMyjC,EAAeiqB,EAAWjqB,aAC1B8yE,EAA0BjlH,KAAKc,IAAKqxC,IACpC,QAAEqH,EAAO,YAAEX,EAAW,cAAE+uB,GAAkBz1B,EAE1Cq/E,GAAkD,IAAzCr/E,EAAas/E,wBACtBC,GAAqD,IAAlCv/E,EAAau/E,iBAChCC,GAA2D,IAArCx/E,EAAaw/E,oBAEzC,IAAIC,EAAS3M,EAAwBlC,gBACjCH,EAAoBqC,EAAwBrC,kBAEhD,MAAMzpD,EAAWjzD,GAAak2D,GAE9B,IAAI8oD,EAgBJ,GAdKsM,GAEJvM,EAAwB4M,mBAAsB5M,EAAwB4M,iBAAmB,CAAC,GAE1F3M,EAAKD,EAAwB4M,iBAAkB14D,KAI/C8rD,EAAwBvC,eAAkBuC,EAAwBvC,aAAe,CAAC,GAElFwC,EAAKD,EAAwBvC,aAAcvpD,SAIhCp4D,IAAPmkH,EAAmB,CAEvBA,EAAKpjE,EAAGujE,oBAERp3F,EAAM8mF,gBAAiBjzD,EAAGozD,YAAagQ,GAEvC,MAAMx2G,EAAW0tD,EAAW1tD,SAE5B,GAAK8iH,EAAS,CAEbvM,EAAwB4M,iBAAkB14D,GAAa+rD,EAEvD,MAAM,WAAE9D,GAAephH,KAAKc,IAAK4N,EAAU,IAErCojH,EAAW9xH,KAAK8C,SAAS03F,gBAE/B14C,EAAGwjE,qBAAsBxjE,EAAGozD,YAAapzD,EAAGszD,kBAAmBtzD,EAAGsgE,4BAA8B0P,EAAU1Q,EAAY,EAEvH,KAAO,CAEN6D,EAAwBvC,aAAcvpD,GAAa+rD,EAEnD,IAAM,IAAI7gH,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAE5C,MAAMyvB,EAAUplB,EAAUrK,GACpB6/D,EAAclkE,KAAKc,IAAKgzB,GAC9BowC,EAAY/xB,aAAeiqB,EAAWjqB,aACtC+xB,EAAY/K,SAAWA,EAEvB,MAAM2rD,EAAahjE,EAAGszD,kBAAoB/wG,EAE1C,GAAKqtH,GAAoBC,EAAsB,CAE9C,MAAMI,EAAQ/xH,KAAK8C,SAAS03F,gBAE5B14C,EAAGkwE,wBAAyBlwE,EAAGozD,YAAa4P,EAAY5gD,EAAYk9C,WAAY,EAAG2Q,EAEpF,MAECjwE,EAAGwjE,qBAAsBxjE,EAAGozD,YAAa4P,EAAYhjE,EAAGo6D,WAAYh4C,EAAYk9C,WAAY,EAM9F,CAEAnzF,EAAMknF,YAAa/4C,EAAY8oD,EAEhC,CAEA,GAAiC,OAA5B9oD,EAAWiL,aAAwB,CAEvC,MAAMnD,EAAclkE,KAAKc,IAAKs7D,EAAWiL,cACnC4qD,EAAarqD,EAAgB9lB,EAAGkkE,yBAA2BlkE,EAAGijE,iBACpE7gD,EAAY/xB,aAAeiqB,EAAWjqB,aACtC+xB,EAAY/K,SAAWA,EAEvBrX,EAAGwjE,qBAAsBxjE,EAAGozD,YAAa+c,EAAYnwE,EAAGo6D,WAAYh4C,EAAYk9C,WAAY,EAE7F,CAED,CAEA,GAAK5nE,EAAU,EAAI,CAElB,QAAgBz4C,IAAX6wH,EAAuB,CAE3B,MAAMtG,EAAoB,GAE1BsG,EAAS9vE,EAAGujE,oBAEZp3F,EAAM8mF,gBAAiBjzD,EAAGozD,YAAa0c,GAEvC,MAAM5O,EAAoB,GAEpBt0G,EAAW0tD,EAAW1tD,SAE5B,IAAM,IAAIrK,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAQ5C,GANA2+G,EAAmB3+G,GAAMy9C,EAAGowE,qBAE5BpwE,EAAG4jE,iBAAkB5jE,EAAG6jE,aAAc3C,EAAmB3+G,IAEzDinH,EAAkBxlH,KAAMg8C,EAAGszD,kBAAoB/wG,GAE1Cw0C,EAAc,CAElB,MAAMo5E,EAAarqD,EAAgB9lB,EAAGkkE,yBAA2BlkE,EAAGijE,iBACpEuG,EAAkBxlH,KAAMmsH,EAEzB,CAEA,MAAMn+F,EAAUsoC,EAAW1tD,SAAUrK,GAC/B6/D,EAAclkE,KAAKc,IAAKgzB,GAE9BguB,EAAG+jE,+BAAgC/jE,EAAG6jE,aAAcnsE,EAAS0qB,EAAYo9C,iBAAkBllD,EAAWj6D,MAAOi6D,EAAWh6D,QACxH0/C,EAAGikE,wBAAyBjkE,EAAGozD,YAAapzD,EAAGszD,kBAAoB/wG,EAAGy9C,EAAG6jE,aAAc3C,EAAmB3+G,GAG3G,CAKA,GAHA4gH,EAAwBlC,gBAAkB6O,EAC1C3M,EAAwBjC,kBAAoBA,OAEjBjiH,IAAtB6hH,EAAkC,CAEtCA,EAAoB9gE,EAAGowE,qBACvBlyH,KAAKooH,aAAa5C,yBAA0B5C,EAAmBxmD,GAE/D6oD,EAAwBrC,kBAAoBA,EAE5C,MAAMqP,EAAarqD,EAAgB9lB,EAAGkkE,yBAA2BlkE,EAAGijE,iBACpEuG,EAAkBxlH,KAAMmsH,EAEzB,CAEAhN,EAAwBqG,kBAAoBA,CAE7C,CAEAiG,EAAqBtM,EAAwBlC,eAE9C,MAECwO,EAAqBrM,CAIvB,CAEAj3F,EAAM8mF,gBAAiBjzD,EAAGozD,YAAaqc,EAExC,CAUA,UAAAjF,CAAYhrH,EAAOH,GAElB,IAAI2N,EAAM,GAEV,GAAe,OAAVxN,EAAiB,CAIrBwN,GAAO,IAFW9O,KAAKc,IAAKQ,GAEL8B,EAExB,CAEA,IAAM,IAAIiB,EAAI,EAAGA,EAAIlD,EAAW6C,OAAQK,IAAO,CAI9CyK,GAAO,IAFe9O,KAAKc,IAAKK,EAAYkD,IAEjBjB,EAE5B,CAEA,OAAO0L,CAER,CAUA,UAAA09G,CAAYlrH,EAAOH,GAElB,MAAM,GAAE2gD,GAAO9hD,KAETusH,EAASzqE,EAAGqwE,oBAClB,IAAIrjH,EAAM,GAENu+G,GAAY,EAIhB,GAFAvrE,EAAG2qE,gBAAiBF,GAEL,OAAVjrH,EAAiB,CAErB,MAAMusH,EAAY7tH,KAAKc,IAAKQ,GAE5BwgD,EAAGuqD,WAAYvqD,EAAGsvE,qBAAsBvD,EAAU3iB,WAElDp8F,GAAO,IAAM++G,EAAUzqH,EAExB,CAEA,IAAM,IAAIiB,EAAI,EAAGA,EAAIlD,EAAW6C,OAAQK,IAAO,CAE9C,MAAM1B,EAAYxB,EAAYkD,GACxBk5D,EAAgBv9D,KAAKc,IAAK6B,GAShC,IAAIktB,EAAQC,EAPZhhB,GAAO,IAAMyuD,EAAcn6D,GAE3B0+C,EAAGuqD,WAAYvqD,EAAGivE,aAAcxzD,EAAc2tC,WAC9CppD,EAAGswE,wBAAyB/tH,IAEvB1B,EAAUo8D,0BAA4Bp8D,EAAUq8D,qCAAoCquD,GAAY,IAIrD,IAA3C1qH,EAAUk4D,8BAEdhrC,EAASltB,EAAU9B,KAAKgvB,OAAS0tC,EAAcomC,gBAC/C7zE,EAASntB,EAAUmtB,OAASytC,EAAcomC,kBAI1C9zE,EAAS,EACTC,EAAS,GAILytC,EAAcnvD,UAElB0zC,EAAGuwE,qBAAsBhuH,EAAG1B,EAAUitB,SAAU2tC,EAAch2D,KAAMsoB,EAAQC,GAI5EgyB,EAAGwwE,oBAAqBjuH,EAAG1B,EAAUitB,SAAU2tC,EAAch2D,KAAM5E,EAAUq5D,WAAYnsC,EAAQC,GAI7FntB,EAAU2sB,6BAAgC3sB,EAAUk4D,6BAExD/Y,EAAGywE,oBAAqBluH,EAAG1B,EAAU6vH,kBAE1B7vH,EAAUk4D,8BAAgCl4D,EAAU9B,KAAK4xH,8BAEpE3wE,EAAGywE,oBAAqBluH,EAAG1B,EAAU9B,KAAK2xH,iBAI5C,CAMA,OAJA1wE,EAAGuqD,WAAYvqD,EAAGivE,aAAc,MAEhC/wH,KAAKsoH,SAAUx5G,GAAQy9G,EAEhB,CAAEA,SAAQc,YAElB,CASA,qBAAAT,CAAuBR,GAEtB,IAAIt9G,EAAM,GAEV,IAAM,IAAIzK,EAAI,EAAGA,EAAI+nH,EAAiBpoH,OAAQK,IAE7CyK,GAAO,IAAMs9G,EAAkB/nH,GAAIjB,GAIpC,IAAIupH,EAAuB3sH,KAAKuoH,uBAAwBz5G,GAExD,QAA8B/N,IAAzB4rH,EAEJ,OAAOA,EAIR,MAAM,GAAE7qE,GAAO9hD,KAEf2sH,EAAuB7qE,EAAG4wE,0BAE1B5wE,EAAG+qE,sBAAuB/qE,EAAGgrE,mBAAoBH,GAEjD,IAAM,IAAItoH,EAAI,EAAGA,EAAI+nH,EAAiBpoH,OAAQK,IAAO,CAEpD,MAAMk5D,EAAgB6uD,EAAkB/nH,GAExCy9C,EAAG8zD,eAAgB9zD,EAAG6wE,0BAA2BtuH,EAAGk5D,EAAc8tC,gBAEnE,CAMA,OAJAvpD,EAAG+qE,sBAAuB/qE,EAAGgrE,mBAAoB,MAEjD9sH,KAAKuoH,uBAAwBz5G,GAAQ69G,EAE9BA,CAER,CASA,cAAA8D,CAAgB7zD,EAAUuvD,GAEzB,MAAMrqE,EAAK9hD,KAAK8hD,GAEhB,IAAM,MAAM8gB,KAAahG,EAExB,IAAM,MAAMsG,KAAWN,EAAUhG,SAAW,CAE3C,MACMt7D,EADctB,KAAKc,IAAKoiE,GACJ5hE,MAE1B,GAAK4hE,EAAQkhC,iBAAmBlhC,EAAQU,gBAAkB,CAEzD,MAAM+kC,EAAW7mD,EAAG8wE,qBAAsBzG,EAAYjpD,EAAQxgE,MAC9Do/C,EAAG+wE,oBAAqB1G,EAAYxjB,EAAUrnG,EAE/C,MAAO,GAAK4hE,EAAQC,iBAAmB,CAEtC,MAAMwlC,EAAW7mD,EAAGgxE,mBAAoB3G,EAAYjpD,EAAQxgE,MAC5Do/C,EAAGixE,UAAWpqB,EAAUrnG,EAEzB,CAED,CAIF,CAQA,aAAAorH,CAAe9vD,GAEd,MAAM,GAAE9a,EAAE,MAAE7zB,GAAUjuB,KAEtB,IAAM,MAAM4iE,KAAahG,EAExB,IAAM,MAAMsG,KAAWN,EAAUhG,SAAW,CAE3C,MAAMo2D,EAAchzH,KAAKc,IAAKoiE,GACxB5hE,EAAQ0xH,EAAY1xH,MAErB4hE,EAAQkhC,iBAAmBlhC,EAAQU,gBAGvC31C,EAAM2nF,eAAgB9zD,EAAGovE,eAAgB5vH,EAAO0xH,EAAY9nB,WAEjDhoC,EAAQC,kBAEnBl1C,EAAMunF,YAAawd,EAAYnX,cAAemX,EAAY5R,WAAYt/D,EAAGyzD,SAAWj0G,EAItF,CAIF,CAKA,OAAA2J,GAECjL,KAAK8C,SAASq2F,WAAWlpD,oBAAqB,mBAAoBjwC,KAAKopH,eAExE,EAID,MAAM6J,GACM,aADNA,GAEK,YAFLA,GAGM,aAHNA,GAIS,gBAJTA,GAKU,iBAGVC,GACE,QADFA,GAEC,OAFDA,GAGE,QAHFA,GAIM,aAJNA,GAKI,UALJA,GAMK,YANLA,GAOS,gBAPTA,GAQG,SAGHC,GACE,QAIFC,GACC,OADDA,GAEE,QAGFC,GACA,MAIAC,GACC,OADDA,GAEE,QAFFA,GAGC,OAGDC,GACG,SADHA,GAEG,SAGHC,GAAmB,CAIxBC,QAAS,UACTC,QAAS,UACTC,OAAQ,SACRC,OAAQ,SAIRC,QAAS,UACTC,QAAS,UACTC,SAAU,WACVC,SAAU,WACVC,SAAU,WACVC,QAAS,UACTC,QAAS,UAITC,QAAS,UACTC,QAAS,UACTC,SAAU,WACVC,SAAU,WACVC,SAAU,WACVC,UAAW,YACXC,WAAY,aACZC,eAAgB,kBAChBC,WAAY,aACZC,UAAW,YACXC,UAAW,YACXC,WAAY,aACZC,eAAgB,kBAEhBC,aAAc,eACdC,aAAc,eACdC,cAAe,eAIfC,SAAU,WACVC,SAAU,WACVC,UAAW,YACXC,WAAY,aACZC,WAAY,aACZC,YAAa,cAIbC,WAAY,aACZC,WAAY,aACZC,YAAa,cAIbC,SAAU,WACVC,aAAc,eACdC,YAAa,cACbC,oBAAqB,uBACrBC,aAAc,eAIdC,qBAAsB,wBAKtBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,UAAW,cACXC,UAAW,cACXC,WAAY,eACZC,WAAY,eACZC,cAAe,kBACfC,aAAc,iBACdC,aAAc,iBACdC,iBAAkB,gBAKlBC,cAAe,iBACfC,kBAAmB,sBACnBC,gBAAiB,mBACjBC,oBAAqB,wBACrBC,eAAgB,kBAChBC,mBAAoB,uBACpBC,YAAa,eACbC,YAAa,eACbC,aAAc,gBACdC,aAAc,gBAKdC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,aAAc,iBACdC,iBAAkB,sBAClBC,cAAe,kBACfC,kBAAmB,uBACnBC,cAAe,kBACfC,kBAAmB,uBACnBC,cAAe,kBACfC,kBAAmB,uBACnBC,eAAgB,mBAChBC,mBAAoB,wBACpBC,eAAgB,mBAChBC,mBAAoB,wBACpBC,eAAgB,mBAChBC,mBAAoB,yBAIfC,GACQ,gBADRA,GAEG,SAFHA,GAGS,gBAGTC,GACG,SADHA,GAEI,UAGJC,GACC,OADDA,GAEA,MAFAA,GAGA,MAHAA,GAIQ,gBAJRA,GAKK,YALLA,GAMa,sBANbA,GAOA,MAPAA,GAQa,gBARbA,GASK,YATLA,GAUa,sBAVbA,GAWc,sBAXdA,GAYK,WAZLA,GAaa,qBAGbC,GACA,MADAA,GAEK,WAFLA,GAGY,mBAHZA,GAIA,MAJAA,GAKA,MAGAC,GACC,EADDA,GAMA,GAGAC,GACC,OADDA,GAEC,OAFDA,GAGI,UAHJA,GAIG,SAJHA,GAKW,kBALXA,GAMW,kBANXA,GAOU,iBAPVA,GAQU,iBAGVC,GAEI,UAFJA,GAGY,oBAGZC,GACM,aADNA,GAEK,YAFLA,GAGM,aAGNC,GACE,QADFA,GAEc,qBAFdA,GAGE,QAHFA,GAIC,OAJDA,GAKC,OAGDC,GAEC,KAFDA,GAGG,KAGHC,GAEC,KAFDA,GAGM,WAHNA,GAIC,OAJDA,GAMG,KAGHC,GACA,MAKAC,GACG,SADHA,GAEK,WAGLC,GAAiB,CACtBC,iBAAkB,qBAClBnE,qBAAsB,wBACtBoE,qBAAsB,yBACtBC,uBAAwB,2BACxBC,uBAAwB,2BACxBC,eAAgB,kBAChBC,sBAAuB,0BACvBC,UAAW,aACXC,cAAe,2BACfC,kBAAmB,qBACnBC,kBAAmB,qBACnBC,cAAe,iBACfC,mBAAoB,uBACpBC,UAAW,aASZ,MAAMC,WAAgB53B,GAQrB,WAAAxjG,CAAa4C,EAAMoxB,GAElBpqB,MAAOhH,GAOP1C,KAAK8zB,QAAUA,EAOf9zB,KAAKuB,QAAUuyB,EAAUA,EAAQvyB,QAAU,EAS3CvB,KAAK8jE,WAAY,CAElB,EAWD,MAAMq3D,WAAoBD,GASzB,WAAAp7H,CAAa4C,EAAM4wB,EAAarY,GAE/BvR,MAAOhH,EAAM4wB,EAAcA,EAAYpwB,MAAQ,MAO/ClD,KAAKszB,YAAcA,EAOnBtzB,KAAKib,UAAYA,CAElB,CAKA,MAAA1Q,GAECvK,KAAK8zB,QAAU9zB,KAAKszB,YAAYpwB,KAEjC,EAUD,MAAMk4H,WAAsB33B,GAQ3B,WAAA3jG,CAAa4C,EAAMC,GAElB+G,MAAOhH,EAAMC,EAAYA,EAAU6C,MAAQ,MAO3CxF,KAAK2C,UAAYA,EASjB3C,KAAKqjE,iBAAkB,CAExB,EAID,IAAIg4D,GAAM,EASV,MAAMC,WAA0BF,GAQ/B,WAAAt7H,CAAa6b,EAAaV,GAEzBvR,MAAO,iBAAmB2xH,KAAQ1/G,EAAcA,EAAYzY,MAAQ,MAOpElD,KAAK2b,YAAcA,EAOnB3b,KAAK4lG,OAASjqF,EAAcA,EAAYiqF,OAAS78F,EAAWG,WAO5DlJ,KAAKib,UAAYA,CAElB,CAOA,UAAI3S,GAEH,OAAOtI,KAAK2b,YAAYzY,KAEzB,EAID,MAAMq4H,WAA+Br+D,GAEpC,WAAAp9D,CAAa07H,GAEZ9xH,QAEA1J,KAAKw7H,OAASA,EAgEdx7H,KAAKy7H,cAAgBD,EAAOzyD,cAAe,CAAE11B,UAAWmmF,KACxDx5H,KAAK07H,aAAeF,EAAOzyD,cAAe,CAAE11B,UAAWmmF,KAGvDx5H,KAAK27H,kBAAoB,CAAC,EAC1B37H,KAAK47H,eAAiB,CAAC,EAEvB57H,KAAK67H,yBAA2BL,EAAOM,mBAAoB,CAC1D5gH,MAAO,eACP0lD,KAvE0B,6pBA0E3B5gE,KAAK+7H,2BAA6BP,EAAOM,mBAAoB,CAC5D5gH,MAAO,iBACP0lD,KA3C4B,sQA8C7B5gE,KAAKg8H,0BAA4BR,EAAOM,mBAAoB,CAC3D5gH,MAAO,gBACP0lD,KAjC2B,6RAoC7B,CAEA,mBAAAq7D,CAAqBtuH,GAEpB,IAAIorD,EAAW/4D,KAAK27H,kBAAmBhuH,GA0BvC,YAxBkB5M,IAAbg4D,IAEJA,EAAW/4D,KAAKw7H,OAAOj5D,qBAAsB,CAC5CrnD,MAAO,UAAWvN,IAClBksC,OAAQ,CACPqiF,OAAQl8H,KAAK67H,yBACbM,WAAY,QAEbj7D,SAAU,CACTg7D,OAAQl8H,KAAK+7H,2BACbI,WAAY,OACZC,QAAS,CAAE,CAAEzuH,YAEd0uH,UAAW,CACVC,SAAUrJ,GACVsJ,iBAAkBhJ,IAEnBz9G,OAAQ,SAGT9V,KAAK27H,kBAAmBhuH,GAAWorD,GAI7BA,CAER,CAEA,gBAAAyjE,CAAkB7uH,GAEjB,IAAIorD,EAAW/4D,KAAK47H,eAAgBjuH,GA0BpC,YAxBkB5M,IAAbg4D,IAEJA,EAAW/4D,KAAKw7H,OAAOj5D,qBAAsB,CAC5CrnD,MAAO,SAAUvN,IACjBksC,OAAQ,CACPqiF,OAAQl8H,KAAK67H,yBACbM,WAAY,QAEbj7D,SAAU,CACTg7D,OAAQl8H,KAAKg8H,0BACbG,WAAY,OACZC,QAAS,CAAE,CAAEzuH,YAEd0uH,UAAW,CACVC,SAAUrJ,GACVsJ,iBAAkBhJ,IAEnBz9G,OAAQ,SAGT9V,KAAK47H,eAAgBjuH,GAAWorD,GAI1BA,CAER,CAEA,KAAA1jC,CAAO+rF,EAAYqb,EAAsBC,EAAiB,GAEzD,MAAM/uH,EAAS8uH,EAAqB9uH,QAC9B,MAAExL,EAAK,OAAEC,GAAWq6H,EAAqBzrG,KAEzC2rG,EAAmB38H,KAAKi8H,oBAAqBtuH,GAC7CivH,EAAgB58H,KAAKw8H,iBAAkB7uH,GAEvCkvH,EAAc78H,KAAKw7H,OAAOxyD,cAAe,CAC9Ch4C,KAAM,CAAE7uB,QAAOC,SAAQ06H,mBAAoB,GAC3CnvH,SACAwhB,MAAO4tG,gBAAgBC,kBAAoBD,gBAAgBE,kBAGtDC,EAAU9b,EAAW+b,WAAY,CACtCC,aAAc,EACd/zD,cAAe,EACfg0D,UAAWpD,GACXyC,mBAGKY,EAAUT,EAAYM,WAAY,CACvCC,aAAc,EACd/zD,cAAe,EACfg0D,UAAWpD,GACXyC,eAAgB,IAGXa,EAAiBv9H,KAAKw7H,OAAOgC,qBAAsB,CAAC,GAEpDC,EAAO,CAAE1kE,EAAU2kE,EAAYC,KAEpC,MAAMC,EAAkB7kE,EAAS8kE,mBAAoB,GAE/Cj7D,EAAY5iE,KAAKw7H,OAAOsC,gBAAiB,CAC9ChoH,OAAQ8nH,EACRG,QAAS,CAAE,CACV76D,QAAS,EACT86D,SAAUh+H,KAAK07H,cACb,CACFx4D,QAAS,EACT86D,SAAUN,MAINO,EAAcV,EAAeW,gBAAiB,CACnDC,iBAAkB,CAAE,CACnBC,KAAMT,EACNU,OAAQjL,GACRkL,QAASnL,GACToL,WAAY,CAAE,EAAG,EAAG,EAAG,OAIzBN,EAAYO,YAAazlE,GACzBklE,EAAYQ,aAAc,EAAG77D,GAC7Bq7D,EAAY56B,KAAM,EAAG,EAAG,EAAG,GAC3B46B,EAAY3wF,KAAK,EAIlBmwF,EAAMd,EAAkBO,EAASI,GACjCG,EAAMb,EAAeU,EAASJ,GAE9Bl9H,KAAKw7H,OAAOkD,MAAMC,OAAQ,CAAEpB,EAAev+E,WAE3C69E,EAAY+B,SAEb,CAEA,eAAAtrF,CAAiB8tE,EAAYqb,EAAsBC,EAAiB,GAEnE,MAAMx4D,EAAclkE,KAAKc,IAAKsgH,QAEArgH,IAAzBmjE,EAAY26D,WAEhB36D,EAAY26D,SAAW,EACvB36D,EAAYiW,OAAS,IAItB,MAAM2kD,EAAS56D,EAAYiW,OAAQuiD,IAAoB18H,KAAK++H,qBAAsB3d,EAAYqb,EAAsBC,GAE9Ga,EAAiBv9H,KAAKw7H,OAAOgC,qBAAsB,CAAC,GAE1Dx9H,KAAKg/H,kBAAmBzB,EAAgBuB,GAExC9+H,KAAKw7H,OAAOkD,MAAMC,OAAQ,CAAEpB,EAAev+E,WAEb,IAAzBklB,EAAY26D,WAAiB36D,EAAYiW,OAAQuiD,GAAmBoC,GAEzE56D,EAAY26D,UAEb,CAEA,oBAAAE,CAAsB3d,EAAYqb,EAAsBC,GAEvD,MAAM3jE,EAAW/4D,KAAKi8H,oBAAqBQ,EAAqB9uH,QAE1DiwH,EAAkB7kE,EAAS8kE,mBAAoB,GAErD,IAAIX,EAAU9b,EAAW+b,WAAY,CACpCC,aAAc,EACd/zD,cAAe,EACfg0D,UAAWpD,GACXyC,mBAGD,MAAMoC,EAAS,GAEf,IAAM,IAAIz6H,EAAI,EAAGA,EAAIo4H,EAAqBpzD,cAAehlE,IAAO,CAE/D,MAAMu+D,EAAY5iE,KAAKw7H,OAAOsC,gBAAiB,CAC9ChoH,OAAQ8nH,EACRG,QAAS,CAAE,CACV76D,QAAS,EACT86D,SAAUh+H,KAAKy7H,eACb,CACFv4D,QAAS,EACT86D,SAAUd,MAINI,EAAUlc,EAAW+b,WAAY,CACtCC,aAAc/4H,EACdglE,cAAe,EACfg0D,UAAWpD,GACXyC,mBAGKuC,EAAiB,CACtBd,iBAAkB,CAAE,CACnBC,KAAMd,EACNe,OAAQjL,GACRkL,QAASnL,GACToL,WAAY,CAAE,EAAG,EAAG,EAAG,MAInBN,EAAcj+H,KAAKw7H,OAAO0D,0BAA2B,CAC1DC,aAAc,CAAE1C,EAAqB9uH,UAGtCswH,EAAYO,YAAazlE,GACzBklE,EAAYQ,aAAc,EAAG77D,GAC7Bq7D,EAAY56B,KAAM,EAAG,EAAG,EAAG,GAE3By7B,EAAOh5H,KAAM,CACZs5H,cAAe,CAAEnB,EAAYj/E,UAC7BigF,mBAGD/B,EAAUI,CAEX,CAEA,OAAOwB,CAER,CAEA,iBAAAE,CAAmBzB,EAAgBuB,GAElC,MAAMj2D,EAASi2D,EAAO96H,OAEtB,IAAM,IAAIK,EAAI,EAAGA,EAAIwkE,EAAQxkE,IAAO,CAEnC,MAAMo5H,EAAOqB,EAAQz6H,GAEf45H,EAAcV,EAAeW,gBAAiBT,EAAKwB,gBAEzDhB,EAAYoB,eAAgB5B,EAAK2B,eAEjCnB,EAAY3wF,KAEb,CAED,EAID,MAAMgyF,GAAmB,CACxB,CAAE,OAAgB,QAClB,CAAE,OAAe,OACjB,CAAE,OAAgB,QAClB,CAAE,OAAoB,aACtB,CAAE,OAAkB,UACpB,CAAE,OAAuB,gBACzB,CAAE,OAAiB,SACnB,CAAE,OAAmB,aAGhBC,GAAW,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,GAElC,MAAMC,GAEL,WAAA1/H,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EAEft9D,KAAKy/H,WAAa,KAElBz/H,KAAKk+C,eAAiB,CAAC,EACvBl+C,KAAK0/H,mBAAqB,CAAC,EAC3B1/H,KAAK2/H,kBAAoB,KAEzB3/H,KAAK4/H,YAAc,KAEnB5/H,KAAKqnE,aAAe,IAAI,MACxBrnE,KAAKqnE,aAAa3kE,KAAO,aAE1B,CAEA,aAAAqmE,CAAej1C,GAEd,MAAMwpC,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAEjBpa,EAAa9jD,EAAQx8D,IAAKgzB,GAE1B+rG,EAAuB,CAC5BC,aAAc9/H,KAAK+/H,oBAAqBjsG,EAAQysF,OAChDyf,aAAchgI,KAAK+/H,oBAAqBjsG,EAAQ2sF,OAChDwf,aAAcjgI,KAAK+/H,oBAAqBjsG,EAAQ6sF,OAChDjjE,UAAW19C,KAAKkgI,mBAAoBpsG,EAAQ4pB,WAC5CrK,UAAWrzC,KAAKkgI,mBAAoBpsG,EAAQuf,WAC5C8sF,aAAcngI,KAAKkgI,mBAAoBpsG,EAAQuf,WAC/CuzE,cAAe,GAKXiZ,EAAqBniF,YAAc87E,IAAwBqG,EAAqBxsF,YAAcmmF,IAAwBqG,EAAqBM,eAAiB3G,KAEhKqG,EAAqBjZ,cAAgB9yF,EAAQ3W,YAIzC2W,EAAQe,gBAA8C,OAA5Bf,EAAQmlD,kBAEtC4mD,EAAqB3oG,QAAUooG,GAAkBxrG,EAAQmlD,kBAI1DmoC,EAAW5sF,QAAUgnG,EAAOzyD,cAAe82D,EAE5C,CAEA,oBAAAz2D,CAAsBt1C,GAErB,IAAIstF,EAEJ,MAAMzzG,EAASyyH,GAAWtsG,GAErBA,EAAQ6mB,cAEZymE,EAAaphH,KAAKqgI,0BAA2B1yH,GAElCmmB,EAAQ4xE,eAEnB1lG,KAAKs9D,QAAQx8D,IAAKgzB,GAAUqwC,gBAAkBnkE,KAAKsgI,wBAInDlf,EAAaphH,KAAKugI,sBAAuB5yH,GAI1C3N,KAAKs9D,QAAQx8D,IAAKgzB,GAAUA,QAAUstF,CAEvC,CAEA,aAAAp4C,CAAel1C,EAASupB,EAAU,CAAC,GAElC,MAAMigB,EAAUt9D,KAAKs9D,QACf4G,EAAc5G,EAAQx8D,IAAKgzB,GAEjC,GAAKowC,EAAY/2D,YAEhB,MAAM,IAAIkG,MAAO,yDAIYtS,IAAzBs8C,EAAQonB,eAA6BpnB,EAAQonB,cAAe,QACzC1jE,IAAnBs8C,EAAQwrB,SAAuBxrB,EAAQwrB,OAAS,QAC9B9nE,IAAlBs8C,EAAQ/lB,QAAsB+lB,EAAQ/lB,MAAQ,GAEnD,MAAM,MAAEn1B,EAAK,OAAEC,EAAM,MAAEk1B,EAAK,OAAEuxC,GAAWxrB,EAEpCvpB,EAAQyB,uBAEP8nB,EAAQlL,aAEZkL,EAAQ1vC,OAAS3N,KAAKs9D,QAAQ0vC,MAAMwzB,sBAAuBnjF,EAAQlL,cAInEkL,EAAQ1vC,OAAS3N,KAAKs9D,QAAQ0vC,MAAMyzB,4BAMtC,MAAMpD,EAAYr9H,KAAK0gI,cAAe5sG,GAChCnmB,EAASmmB,EAAQ0oF,gBAAkBn/D,EAAQ1vC,QAAUyyH,GAAWtsG,EAASwpC,EAAQk+D,QAEvFt3D,EAAYv2D,OAASA,EAErB,MAAM,QAAE6rC,EAAO,eAAEmnF,EAAc,OAAEC,GAAWtjE,EAAQ0vC,MAAM6zB,qBAAsB/sG,GAEhF,IAAI3E,EAAQ4tG,gBAAgBE,gBAAkBF,gBAAgB+D,SAAW/D,gBAAgBgE,UAEvD,IAA7BjtG,EAAQwwC,mBAEZn1C,GAAS4tG,gBAAgBiE,kBAIW,IAAhCltG,EAAQw1C,sBAAqE,IAArCx1C,EAAQw0E,2BAEpDn5E,GAAS4tG,gBAAgBC,mBAI1B,MAAMiE,EAAuB,CAC5B/lH,MAAO4Y,EAAQpxB,KACfsuB,KAAM,CACL7uB,MAAOA,EACPC,OAAQA,EACR06H,mBAAoBxlG,GAErB+xC,cAAeR,EACftB,YAAao5D,EACbtD,UAAWA,EACX1vH,OAAQA,EACRwhB,MAAOA,GAKR,GAAK2E,EAAQ4xE,eAAiB,CAE7B,MAAMw7B,EAAQptG,EAAQzV,OAAOxd,KACvBsgI,EAAa,IAAIC,WAAYF,GAEnCD,EAAqBjwG,KAAK7uB,MAAQg/H,EAAWE,aAC7CJ,EAAqBjwG,KAAK5uB,OAAS++H,EAAWG,cAE9CH,EAAWI,QAEXr9D,EAAYC,gBAAkB+8D,CAE/B,KAAO,CAEN,QAAgBngI,IAAX4M,EAIJ,OAFAlB,QAAQC,KAAM,iDAEP1M,KAAKopE,qBAAsBt1C,GAInCowC,EAAYpwC,QAAUwpC,EAAQk+D,OAAOxyD,cAAei4D,EAErD,CAEA,GAAKL,EAAS,CAEb,MAAMY,EAA2B39H,OAAOsQ,OAAQ,CAAC,EAAG8sH,GAEpDO,EAAyBtmH,MAAQsmH,EAAyBtmH,MAAQ,QAClEsmH,EAAyBj6D,YAAc/tB,EAEvC0qB,EAAYu9D,YAAcnkE,EAAQk+D,OAAOxyD,cAAew4D,EAEzD,CAEAt9D,EAAY/2D,aAAc,EAE1B+2D,EAAY+8D,qBAAuBA,CAEpC,CAEA,cAAAr4D,CAAgB90C,GAEf,MAAMwpC,EAAUt9D,KAAKs9D,QACf4G,EAAc5G,EAAQx8D,IAAKgzB,QAEJ/yB,IAAxBmjE,EAAYpwC,SAAwBowC,EAAYpwC,QAAQ8qG,eAE5B79H,IAA5BmjE,EAAYu9D,aAA4Bv9D,EAAYu9D,YAAY7C,UAErEthE,EAAQttB,OAAQlc,EAEjB,CAEA,cAAA60C,CAAgB70C,UAEC9zB,KAAKs9D,QACOx8D,IAAKgzB,GAEdU,OAEpB,CAEA,eAAA8e,CAAiBxf,GAEhB,MAAMowC,EAAclkE,KAAKs9D,QAAQx8D,IAAKgzB,GAEtC,GAAKA,EAAQ6mB,cAEZ,IAAM,IAAIt2C,EAAI,EAAGA,EAAI,EAAGA,IAEvBrE,KAAK0hI,iBAAkBx9D,EAAYpwC,QAASowC,EAAY+8D,qBAAsB58H,OAIzE,CAEN,MAAMizB,EAAQxD,EAAQC,MAAMuD,OAAS,EAErC,IAAM,IAAIjzB,EAAI,EAAGA,EAAIizB,EAAOjzB,IAE3BrE,KAAK0hI,iBAAkBx9D,EAAYpwC,QAASowC,EAAY+8D,qBAAsB58H,EAIhF,CAED,CAEA,cAAAs9H,GAEM3hI,KAAK4/H,aAAc5/H,KAAK4/H,YAAYhB,UAEzC,MAAMthE,EAAUt9D,KAAKs9D,SACf,MAAEn7D,EAAK,OAAEC,GAAWk7D,EAAQ7qB,uBAclC,OAZAzyC,KAAK4/H,YAActiE,EAAQk+D,OAAOxyD,cAAe,CAChD9tD,MAAO,cACP8V,KAAM,CACL7uB,MAAOA,EACPC,OAAQA,EACR06H,mBAAoB,GAErBv1D,YAAajK,EAAQ0vC,MAAM40B,eAAgBtkE,EAAQx6D,SAAS02C,SAC5D7rC,OAAQ2vD,EAAQ0vC,MAAMyzB,2BACtBtxG,MAAO4tG,gBAAgBC,kBAAoBD,gBAAgBgE,WAGrD/gI,KAAK4/H,WAEb,CAEA,cAAAiC,CAAgBvqG,GAAQ,EAAMyvC,GAAU,GAEvC,MAAMzJ,EAAUt9D,KAAKs9D,SACf,MAAEn7D,EAAK,OAAEC,GAAWk7D,EAAQ7qB,uBAE5B40B,EAAernE,KAAKqnE,aACpBy6D,EAAkBxkE,EAAQx8D,IAAKumE,GAAevzC,QAEpD,IAAInmB,EAAQpG,EAcZ,GAZKw/D,GAEJp5D,EAAS,MACTpG,EAAO,OAEI+vB,IAEX3pB,EAAS,MACTpG,EAAO,YAIiBxG,IAApB+gI,EAAgC,CAEpC,GAAKz6D,EAAatzC,MAAM5xB,QAAUA,GAASklE,EAAatzC,MAAM3xB,SAAWA,GAAUilE,EAAa15D,SAAWA,GAAU05D,EAAa9/D,OAASA,EAE1I,OAAOu6H,EAIR9hI,KAAK4oE,eAAgBvB,EAEtB,CAUA,OARAA,EAAa3kE,KAAO,cACpB2kE,EAAa15D,OAASA,EACtB05D,EAAa9/D,KAAOA,EACpB8/D,EAAatzC,MAAM5xB,MAAQA,EAC3BklE,EAAatzC,MAAM3xB,OAASA,EAE5BpC,KAAKgpE,cAAe3B,EAAc,CAAEllE,QAAOC,WAEpCk7D,EAAQx8D,IAAKumE,GAAevzC,OAEpC,CAEA,aAAAsvC,CAAetvC,EAASupB,GAEvB,MAAM6mB,EAAclkE,KAAKs9D,QAAQx8D,IAAKgzB,IAEhC,qBAAEmtG,GAAyB/8D,EAEjC,IAAKpwC,EAAQwB,4BAAoDv0B,IAAzBkgI,EAAxC,CAKA,GAAKntG,EAAQi4D,cAEZ/rF,KAAK+hI,qBAAsB1kF,EAAQtpB,MAAOmwC,EAAYpwC,QAASmtG,EAAsB,EAAGntG,EAAQuB,YAE1F,GAAKvB,EAAQu0E,oBAAsBv0E,EAAQkoF,gBAEjD,IAAM,IAAI33G,EAAI,EAAGA,EAAIg5C,EAAQtpB,MAAMuD,MAAOjzB,IAEzCrE,KAAK+hI,qBAAsB1kF,EAAQtpB,MAAOmwC,EAAYpwC,QAASmtG,EAAsB58H,EAAGyvB,EAAQuB,MAAOhxB,QAIlG,GAAKyvB,EAAQw1C,qBAAuBx1C,EAAQw0E,yBAElDtoG,KAAKgiI,+BAAgCluG,EAAQq1C,QAASjF,EAAYpwC,QAASmtG,QAErE,GAAKntG,EAAQ6mB,cAEnB36C,KAAKiiI,sBAAuB5kF,EAAQ1uC,OAAQu1D,EAAYpwC,QAASmtG,EAAsBntG,EAAQuB,YAEzF,GAAKvB,EAAQ4xE,eAAiB,CAEpC,MAAMw7B,EAAQptG,EAAQzV,OAAOxd,KAE7BqjE,EAAYC,gBAAkB+8D,CAE/B,MAEClhI,KAAKkiI,oBAAqB7kF,EAAQtpB,MAAOmwC,EAAYpwC,QAASmtG,EAAsB,EAAGntG,EAAQuB,OAMhG6uC,EAAY3iE,QAAUuyB,EAAQvyB,QAEzBuyB,EAAQzpB,UAAWypB,EAAQzpB,SAAUypB,EAxCnC,CA0CR,CAEA,yBAAM+tE,CAAqB/tE,EAASlK,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,GAExD,MAAMu0C,EAASx7H,KAAKs9D,QAAQk+D,OAEtBt3D,EAAclkE,KAAKs9D,QAAQx8D,IAAKgzB,GAChCstF,EAAal9C,EAAYpwC,QACzBnmB,EAASu2D,EAAY+8D,qBAAqBtzH,OAC1Cw0H,EAAgBniI,KAAKmmH,kBAAmBx4G,GAE9C,IAAIy0H,EAAcjgI,EAAQggI,EAC1BC,EAA+C,IAAjCn9H,KAAKuhB,KAAM47G,EAAc,KAEvC,MAAMC,EAAa7G,EAAO5uB,aACzB,CACC57E,KAAM7uB,EAAQC,EAAS+/H,EACvBhzG,MAAOmzG,eAAexB,SAAWwB,eAAeC,WAI5CC,EAAUhH,EAAOgC,uBAEvBgF,EAAQ3gC,oBACP,CACC/tE,QAASstF,EACTqhB,OAAQ,CAAE74G,IAAGE,IAAGmT,EAAGgqD,IAEpB,CACC3+E,OAAQ+5H,EACRD,YAAaA,GAEd,CACCjgI,MAAOA,EACPC,OAAQA,IAKV,MAAM6jH,EAAiBjmH,KAAKkmH,mBAAoBv4G,GAEhD6tH,EAAOkD,MAAMC,OAAQ,CAAE6D,EAAQxjF,iBAEzBqjF,EAAWK,SAAUC,WAAWC,MAItC,OAAO,IAAI3c,EAFIoc,EAAWQ,iBAI3B,CAEA,qBAAAC,CAAuBhvG,GAEtB,MAAMlF,EAAUkF,EAAQlF,QAExB,OAASA,IAAY,OAAoCA,IAAY,OAAwCA,IAAY,OAAyBA,IAAY,KAE/J,CAEA,qBAAA2xG,CAAuB5yH,GAEtB,IAAIuwC,EAAiBl+C,KAAKk+C,eAAgBvwC,GAE1C,QAAwB5M,IAAnBm9C,EAA+B,CAEnC,MAAMpqB,EAAU,IAAI,MACpBA,EAAQuf,UAAY,MACpBvf,EAAQ4pB,UAAY,MAEpB19C,KAAKgpE,cAAel1C,EAAS,CAAE3xB,MAAO,EAAGC,OAAQ,EAAGuL,WAEpD3N,KAAKk+C,eAAgBvwC,GAAWuwC,EAAiBpqB,CAElD,CAEA,OAAO9zB,KAAKs9D,QAAQx8D,IAAKo9C,GAAiBpqB,OAE3C,CAEA,yBAAAusG,CAA2B1yH,GAE1B,IAAI+xH,EAAqB1/H,KAAKk+C,eAAgBvwC,GAE9C,QAA4B5M,IAAvB2+H,EAAmC,CAEvC,MAAM5rG,EAAU,IAAI,MACpBA,EAAQuf,UAAY,MACpBvf,EAAQ4pB,UAAY,MAEpB19C,KAAKgpE,cAAel1C,EAAS,CAAE3xB,MAAO,EAAGC,OAAQ,EAAGk1B,MAAO,IAE3Dt3B,KAAK0/H,mBAAoB/xH,GAAW+xH,EAAqB5rG,CAE1D,CAEA,OAAO9zB,KAAKs9D,QAAQx8D,IAAK4+H,GAAqB5rG,OAE/C,CAEA,qBAAAwsG,GAEC,IAAIX,EAAoB3/H,KAAK2/H,kBAE7B,GAA2B,OAAtBA,EAA6B,CAEjC,MAAMz6C,EAAO,CACZxlB,UAAW,EACXqjE,WAAY,EACZC,YAAa,EACbr1H,OAAQ,QAGT3N,KAAK2/H,kBAAoBA,EAAoB,IAAIyB,WAAY,IAAIt5H,WAAY,CAAE,EAAG,EAAG,EAAG,MAAUo9E,EAEnG,CAEA,OAAOy6C,CAER,CAEA,qBAAAsC,CAAuBtzH,EAAQyyG,EAAY6f,EAAsB5rG,GAEhE,IAAM,IAAIhxB,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAM0vB,EAAQplB,EAAQtK,GAEhB4+H,GAAsB,IAAV5tG,EAAiBkqG,GAAUl7H,GAAMA,EAE9C0vB,EAAMg4D,cAEV/rF,KAAK+hI,qBAAsBhuG,EAAMA,MAAOqtF,EAAY6f,EAAsBgC,EAAW5tG,GAIrFr1B,KAAKkiI,oBAAqBnuG,EAAOqtF,EAAY6f,EAAsBgC,EAAW5tG,EAIhF,CAED,CAEA,mBAAA6sG,CAAqBnuG,EAAOqtF,EAAY6f,EAAsBiC,EAAa7tG,GAE3Dr1B,KAAKs9D,QAAQk+D,OAErBkD,MAAMyE,2BACZ,CACC9kH,OAAQ0V,GACN,CACFD,QAASstF,EACTgiB,SAAU,EACVX,OAAQ,CAAE74G,EAAG,EAAGE,EAAG,EAAGmT,EAAGimG,IACvB,CACF/gI,MAAO4xB,EAAM5xB,MACbC,OAAQ2xB,EAAM3xB,OACd06H,mBAAoB,KAIP,IAAVznG,GAEJr1B,KAAKqjI,OAAQjiB,EAAY6f,EAAsBiC,EAIjD,CAEA,aAAAI,GAEC,IAAIC,EAAYvjI,KAAKy/H,WAQrB,OANmB,OAAd8D,IAEJvjI,KAAKy/H,WAAa8D,EAAY,IAAIhI,GAAwBv7H,KAAKs9D,QAAQk+D,SAIjE+H,CAER,CAEA,gBAAA7B,CAAkBtgB,EAAY6f,EAAsBvE,EAAiB,GAEpE18H,KAAKsjI,gBAAgBhwF,gBAAiB8tE,EAAY6f,EAAsBvE,EAEzE,CAEA,MAAA2G,CAAQjiB,EAAY6f,EAAsBiC,EAAc,GAEvDljI,KAAKsjI,gBAAgBjuG,MAAO+rF,EAAY6f,EAAsBiC,EAE/D,CAEA,oBAAAnB,CAAsBhuG,EAAOqtF,EAAY6f,EAAsBiC,EAAa7tG,EAAOiC,EAAQ,GAK1F,MAAMkkG,EAASx7H,KAAKs9D,QAAQk+D,OAEtB36H,EAAOkzB,EAAMlzB,KAEbshI,EAAgBniI,KAAKmmH,kBAAmB8a,EAAqBtzH,QAC7Dy0H,EAAcruG,EAAM5xB,MAAQggI,EAElC3G,EAAOkD,MAAM8E,aACZ,CACC1vG,QAASstF,EACTgiB,SAAU,EACVX,OAAQ,CAAE74G,EAAG,EAAGE,EAAG,EAAGmT,EAAGimG,IAE1BriI,EACA,CACCivB,OAAQiE,EAAM5xB,MAAQ4xB,EAAM3xB,OAAS+/H,EAAgB7qG,EACrD8qG,eAED,CACCjgI,MAAO4xB,EAAM5xB,MACbC,OAAQ2xB,EAAM3xB,OACd06H,mBAAoB,KAGP,IAAVznG,GAEJr1B,KAAKqjI,OAAQjiB,EAAY6f,EAAsBiC,EAIjD,CAEA,8BAAAlB,CAAgC74D,EAASi4C,EAAY6f,GAIpD,MAAMzF,EAASx7H,KAAKs9D,QAAQk+D,OAEtBiI,EAAYzjI,KAAK0jI,cAAezC,EAAqBtzH,QACrDg2H,EAAiB1C,EAAqBjwG,KAAK8rG,mBAAqB,EAEtE,IAAM,IAAIz4H,EAAI,EAAGA,EAAI8kE,EAAQnlE,OAAQK,IAAO,CAE3C,MAAM29G,EAAS74C,EAAS9kE,GAElBlC,EAAQ6/G,EAAO7/G,MACfC,EAAS4/G,EAAO5/G,OAChBk1B,EAAQqsG,EAAiB1C,EAAqBjwG,KAAK8rG,mBAAqB,EAExEsF,EAAcn9H,KAAKuhB,KAAMrkB,EAAQshI,EAAUthI,OAAUshI,EAAU3/B,WAC/D8/B,EAAgBxB,EAAcn9H,KAAKuhB,KAAMpkB,EAASqhI,EAAUrhI,QAElE,IAAM,IAAI+nC,EAAI,EAAGA,EAAI7S,EAAO6S,IAE3BqxF,EAAOkD,MAAM8E,aACZ,CACC1vG,QAASstF,EACTgiB,SAAU/+H,EACVo+H,OAAQ,CAAE74G,EAAG,EAAGE,EAAG,EAAGmT,EAAGkN,IAE1B63E,EAAOnhH,KACP,CACCivB,OAAQqa,EAAIy5F,EACZxB,cACAyB,aAAc5+H,KAAKuhB,KAAMpkB,EAASqhI,EAAUrhI,SAE7C,CACCD,MAAO8C,KAAKuhB,KAAMrkB,EAAQshI,EAAUthI,OAAUshI,EAAUthI,MACxDC,OAAQ6C,KAAKuhB,KAAMpkB,EAASqhI,EAAUrhI,QAAWqhI,EAAUrhI,OAC3D06H,mBAAoB,GAMxB,CAED,CAEA,aAAA4G,CAAe/1H,GAId,OAAKA,IAAW6lH,GAAiB2C,cAAgBxoH,IAAW6lH,GAAiB4C,iBAA0B,CAAEtyB,WAAY,EAAG3hG,MAAO,EAAGC,OAAQ,GACrIuL,IAAW6lH,GAAiB6C,cAAgB1oH,IAAW6lH,GAAiB8C,kBACxE3oH,IAAW6lH,GAAiB+C,cAAgB5oH,IAAW6lH,GAAiBgD,iBAD0B,CAAE1yB,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GAEtIuL,IAAW6lH,GAAiBiD,WAAa9oH,IAAW6lH,GAAiBsQ,UAAmB,CAAEhgC,WAAY,EAAG3hG,MAAO,EAAGC,OAAQ,GAC3HuL,IAAW6lH,GAAiBmD,YAAchpH,IAAW6lH,GAAiBoD,YACtEjpH,IAAW6lH,GAAiBqD,eAAiBlpH,IAAW6lH,GAAiBsD,cACzEnpH,IAAW6lH,GAAiBuD,cAAgBppH,IAAW6lH,GAAiBwD,iBAFkB,CAAElzB,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GAI9HuL,IAAW6lH,GAAiByD,eAAiBtpH,IAAW6lH,GAAiB0D,mBACzEvpH,IAAW6lH,GAAiB2D,iBAAmBxpH,IAAW6lH,GAAiB4D,oBADyB,CAAEtzB,WAAY,EAAG3hG,MAAO,EAAGC,OAAQ,GAEvIuL,IAAW6lH,GAAiB6D,gBAAkB1pH,IAAW6lH,GAAiB8D,mBAA4B,CAAExzB,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GAC1IuL,IAAW6lH,GAAiB+D,aAC5B5pH,IAAW6lH,GAAiBgE,YADqB,CAAE1zB,WAAY,EAAG3hG,MAAO,EAAGC,OAAQ,GAEpFuL,IAAW6lH,GAAiBiE,cAC5B9pH,IAAW6lH,GAAiBkE,cAE5B/pH,IAAW6lH,GAAiBmE,cAAgBhqH,IAAW6lH,GAAiBoE,iBAHtB,CAAE9zB,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GAItFuL,IAAW6lH,GAAiBqE,cAAgBlqH,IAAW6lH,GAAiBsE,iBAA0B,CAAEh0B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiBuE,cAAgBpqH,IAAW6lH,GAAiBwE,iBAA0B,CAAEl0B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiByE,cAAgBtqH,IAAW6lH,GAAiB0E,iBAA0B,CAAEp0B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiB2E,cAAgBxqH,IAAW6lH,GAAiB4E,iBAA0B,CAAEt0B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiB6E,cAAgB1qH,IAAW6lH,GAAiB8E,iBAA0B,CAAEx0B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiB+E,cAAgB5qH,IAAW6lH,GAAiBgF,iBAA0B,CAAE10B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiBiF,cAAgB9qH,IAAW6lH,GAAiBkF,iBAA0B,CAAE50B,WAAY,GAAI3hG,MAAO,EAAGC,OAAQ,GACtIuL,IAAW6lH,GAAiBmF,eAAiBhrH,IAAW6lH,GAAiBoF,kBAA2B,CAAE90B,WAAY,GAAI3hG,MAAO,GAAIC,OAAQ,GACzIuL,IAAW6lH,GAAiBqF,eAAiBlrH,IAAW6lH,GAAiBsF,kBAA2B,CAAEh1B,WAAY,GAAI3hG,MAAO,GAAIC,OAAQ,GACzIuL,IAAW6lH,GAAiBuF,eAAiBprH,IAAW6lH,GAAiBwF,kBAA2B,CAAEl1B,WAAY,GAAI3hG,MAAO,GAAIC,OAAQ,GACzIuL,IAAW6lH,GAAiByF,gBAAkBtrH,IAAW6lH,GAAiB0F,mBAA4B,CAAEp1B,WAAY,GAAI3hG,MAAO,GAAIC,OAAQ,IAC3IuL,IAAW6lH,GAAiB2F,gBAAkBxrH,IAAW6lH,GAAiB4F,mBAA4B,CAAEt1B,WAAY,GAAI3hG,MAAO,GAAIC,OAAQ,IAC3IuL,IAAW6lH,GAAiB6F,gBAAkB1rH,IAAW6lH,GAAiB8F,mBAA4B,CAAEx1B,WAAY,GAAI3hG,MAAO,GAAIC,OAAQ,SAAhJ,CAED,CAEA,mBAAA29H,CAAqB78H,GAEpB,IAAI6gI,EAAcxK,GAYlB,OAVKr2H,IAAU,MAEd6gI,EAAcxK,GAEHr2H,IAAU,QAErB6gI,EAAcxK,IAIRwK,CAER,CAEA,kBAAA7D,CAAoBh9H,GAEnB,IAAI8gI,EAAaxK,GAQjB,OANKt2H,IAAU,OAAiBA,IAAU,OAA8BA,IAAU,QAEjF8gI,EAAaxK,IAIPwK,CAER,CAEA,iBAAA7d,CAAmBx4G,GAGlB,OAAKA,IAAW6lH,GAAiBC,SAChC9lH,IAAW6lH,GAAiBE,SAC5B/lH,IAAW6lH,GAAiBG,QAC5BhmH,IAAW6lH,GAAiBI,OAAgB,EAGxCjmH,IAAW6lH,GAAiBK,SAChClmH,IAAW6lH,GAAiBM,SAC5BnmH,IAAW6lH,GAAiBO,UAC5BpmH,IAAW6lH,GAAiBQ,UAC5BrmH,IAAW6lH,GAAiBS,UAC5BtmH,IAAW6lH,GAAiBU,SAC5BvmH,IAAW6lH,GAAiBW,QAAiB,EAGzCxmH,IAAW6lH,GAAiBY,SAChCzmH,IAAW6lH,GAAiBa,SAC5B1mH,IAAW6lH,GAAiBc,UAC5B3mH,IAAW6lH,GAAiBe,UAC5B5mH,IAAW6lH,GAAiBgB,UAC5B7mH,IAAW6lH,GAAiBiB,WAC5B9mH,IAAW6lH,GAAiBkB,YAC5B/mH,IAAW6lH,GAAiBmB,gBAC5BhnH,IAAW6lH,GAAiBoB,YAC5BjnH,IAAW6lH,GAAiBqB,WAC5BlnH,IAAW6lH,GAAiBsB,WAC5BnnH,IAAW6lH,GAAiBuB,YAC5BpnH,IAAW6lH,GAAiBwB,gBAE5BrnH,IAAW6lH,GAAiByB,cAC5BtnH,IAAW6lH,GAAiB0B,cAC5BvnH,IAAW6lH,GAAiBoH,eAC5BjtH,IAAW6lH,GAAiByC,cAC5BtoH,IAAW6lH,GAAiBuC,aAC5BpoH,IAAW6lH,GAAiBwC,qBAC5BroH,IAAW6lH,GAAiB0C,qBAA8B,EAGtDvoH,IAAW6lH,GAAiB4B,UAChCznH,IAAW6lH,GAAiB6B,UAC5B1nH,IAAW6lH,GAAiB8B,WAC5B3nH,IAAW6lH,GAAiB+B,YAC5B5nH,IAAW6lH,GAAiBgC,YAC5B7nH,IAAW6lH,GAAiBiC,YAAqB,EAG7C9nH,IAAW6lH,GAAiBkC,YAChC/nH,IAAW6lH,GAAiBmC,YAC5BhoH,IAAW6lH,GAAiBoC,YAAqB,QAFlD,CAKD,CAEA,kBAAA1P,CAAoBv4G,GAEnB,OAAKA,IAAW6lH,GAAiBG,OAAgB7rH,WAC5C6F,IAAW6lH,GAAiBI,OAAgBlqC,UAC5C/7E,IAAW6lH,GAAiBC,QAAiB3rH,WAC7C6F,IAAW6lH,GAAiBE,QAAiBhqC,UAC7C/7E,IAAW6lH,GAAiBU,QAAiBpsH,WAC7C6F,IAAW6lH,GAAiBW,QAAiBzqC,UAC7C/7E,IAAW6lH,GAAiBQ,SAAkBlsH,WAC9C6F,IAAW6lH,GAAiBS,SAAkBvqC,UAC9C/7E,IAAW6lH,GAAiBqB,UAAmB/sH,WAC/C6F,IAAW6lH,GAAiBsB,UAAmBprC,UAC/C/7E,IAAW6lH,GAAiBkB,WAAoB5sH,WAChD6F,IAAW6lH,GAAiBoB,WAAoBlrC,UAGhD/7E,IAAW6lH,GAAiBK,QAAiBjqC,YAC7Cj8E,IAAW6lH,GAAiBM,QAAiBnqC,WAC7Ch8E,IAAW6lH,GAAiBe,SAAkB3qC,YAC9Cj8E,IAAW6lH,GAAiBgB,SAAkB7qC,WAC9Ch8E,IAAW6lH,GAAiB+B,WAAoB3rC,YAChDj8E,IAAW6lH,GAAiBgC,WAAoB7rC,WAChDh8E,IAAW6lH,GAAiBO,UAC5BpmH,IAAW6lH,GAAiBiB,WAC5B9mH,IAAW6lH,GAAiBiC,YAFkB7rC,YAK9Cj8E,IAAW6lH,GAAiBY,QAAiB92F,YAC7C3vB,IAAW6lH,GAAiBa,QAAiBh3F,WAC7C1vB,IAAW6lH,GAAiBc,SAAkBn3F,aAC9CxvB,IAAW6lH,GAAiB4B,SAAkB93F,YAC9C3vB,IAAW6lH,GAAiB6B,SAAkBh4F,WAC9C1vB,IAAW6lH,GAAiB8B,UAAmBn4F,aAC/CxvB,IAAW6lH,GAAiBkC,WAAoBp4F,YAChD3vB,IAAW6lH,GAAiBmC,WAAoBt4F,WAChD1vB,IAAW6lH,GAAiBoC,YAAqBz4F,aAEjDxvB,IAAW6lH,GAAiBuB,YAC5BpnH,IAAW6lH,GAAiBwB,eADoBltH,WAEhD6F,IAAW6lH,GAAiB0B,cAC5BvnH,IAAW6lH,GAAiByB,cAC5BtnH,IAAW6lH,GAAiBoH,cAFsBt9F,YAIlD3vB,IAAW6lH,GAAiByC,aAAsB94F,aAClDxvB,IAAW6lH,GAAiBuC,aAC5BpoH,IAAW6lH,GAAiBwC,oBADqB14F,YAEjD3vB,IAAW6lH,GAAiB0C,qBAA8B/4F,kBAA/D,CAED,CAEA,aAAAujG,CAAe5sG,GAEd,IAAIupG,EAYJ,OARCA,EAFIvpG,EAAQkoF,gBAEAge,GAIAA,GAINqD,CAER,EAID,SAAS+C,GAAWtsG,EAAS0nG,EAAS,MAErC,MAAM7tH,EAASmmB,EAAQnmB,OACjBpG,EAAOusB,EAAQvsB,KACfmlB,EAAaoH,EAAQpH,WAE3B,IAAIu3G,EAEJ,IAAqC,IAAhCnwG,EAAQw1C,sBAAqE,IAArCx1C,EAAQw0E,yBAEpD,OAAS36F,GAER,KAAK,MACJs2H,EAAcv3G,IAAe,MAAmB8mG,GAAiB4C,iBAAmB5C,GAAiB2C,aACrG,MAED,KAAK,MACJ8N,EAAcv3G,IAAe,MAAmB8mG,GAAiB8C,iBAAmB9C,GAAiB6C,aACrG,MAED,KAAK,MACJ4N,EAAcv3G,IAAe,MAAmB8mG,GAAiBgD,iBAAmBhD,GAAiB+C,aACrG,MAED,KAAK,MACJ0N,EAAcv3G,IAAe,MAAmB8mG,GAAiB0D,kBAAoB1D,GAAiByD,cACtG,MAED,KAAK,MACJgN,EAAcv3G,IAAe,MAAmB8mG,GAAiB8D,mBAAqB9D,GAAiB6D,eACvG,MAED,KAAK,MACJ4M,EAAcv3G,IAAe,MAAmB8mG,GAAiBoE,iBAAmBpE,GAAiBmE,aACrG,MAED,KAAK,MACJsM,EAAcv3G,IAAe,MAAmB8mG,GAAiBsE,iBAAmBtE,GAAiBqE,aACrG,MAED,KAAK,MACJoM,EAAcv3G,IAAe,MAAmB8mG,GAAiBwE,iBAAmBxE,GAAiBuE,aACrG,MAED,KAAK,MACJkM,EAAcv3G,IAAe,MAAmB8mG,GAAiB0E,iBAAmB1E,GAAiByE,aACrG,MAED,KAAK,MACJgM,EAAcv3G,IAAe,MAAmB8mG,GAAiB4E,iBAAmB5E,GAAiB2E,aACrG,MAED,KAAK,MACJ8L,EAAcv3G,IAAe,MAAmB8mG,GAAiB8E,iBAAmB9E,GAAiB6E,aACrG,MAED,KAAK,MACJ4L,EAAcv3G,IAAe,MAAmB8mG,GAAiBgF,iBAAmBhF,GAAiB+E,aACrG,MAED,KAAK,MACJ0L,EAAcv3G,IAAe,MAAmB8mG,GAAiBkF,iBAAmBlF,GAAiBiF,aACrG,MAED,KAAK,MACJwL,EAAcv3G,IAAe,MAAmB8mG,GAAiBoF,kBAAoBpF,GAAiBmF,cACtG,MAED,KAAK,MACJsL,EAAcv3G,IAAe,MAAmB8mG,GAAiBsF,kBAAoBtF,GAAiBqF,cACtG,MAED,KAAK,MACJoL,EAAcv3G,IAAe,MAAmB8mG,GAAiBwF,kBAAoBxF,GAAiBuF,cACtG,MAED,KAAK,MACJkL,EAAcv3G,IAAe,MAAmB8mG,GAAiB0F,mBAAqB1F,GAAiByF,eACvG,MAED,KAAK,MACJgL,EAAcv3G,IAAe,MAAmB8mG,GAAiB4F,mBAAqB5F,GAAiB2F,eACvG,MAED,KAAK,MACJ8K,EAAcv3G,IAAe,MAAmB8mG,GAAiB8F,mBAAqB9F,GAAiB6F,eACvG,MAED,KAAK,MACJ4K,EAAcv3G,IAAe,MAAmB8mG,GAAiBmB,eAAiBnB,GAAiBkB,WACnG,MAED,QACCjoH,QAAQkiB,MAAO,8CAA+ChhB,QAMhE,OAASA,GAER,KAAK,MAEJ,OAASpG,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBoB,WAC7B,MAED,KAAK,MACJqP,EAAYzQ,GAAiBgC,WAC7B,MAED,KAAK,MACJyO,EAAYzQ,GAAiB+B,WAC7B,MACD,KAAK,MACJ0O,EAAYzQ,GAAiBkC,WAC7B,MAED,KAAK,MACJuO,EAAYzQ,GAAiBmC,WAC7B,MAED,KAAK,MACJsO,EAAcv3G,IAAe,MAAmB8mG,GAAiBmB,eAAiBnB,GAAiBkB,WACnG,MAED,KAAK,MACJuP,EAAYzQ,GAAiBiC,YAC7B,MAED,KAAK,MACJwO,EAAYzQ,GAAiBoC,YAC7B,MAED,QACCnpH,QAAQkiB,MAAO,4DAA6DpnB,GAI9E,MAED,KAAK,MAEJ,GAASA,IAEH,MACJ08H,EAAYzQ,GAAiByB,kBAI7BxoH,QAAQkiB,MAAO,2DAA4DpnB,GAI7E,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBE,QAC7B,MAED,KAAK,MACJuQ,EAAYzQ,GAAiBM,QAC7B,MAED,KAAK,MACJmQ,EAAYzQ,GAAiBK,QAC7B,MAED,KAAK,MACJoQ,EAAYzQ,GAAiBY,QAC7B,MAED,KAAK,MACJ6P,EAAYzQ,GAAiBa,QAC7B,MAED,KAAK,MACJ4P,EAAYzQ,GAAiBC,QAC7B,MAED,KAAK,MACJwQ,EAAYzQ,GAAiBO,SAC7B,MAED,KAAK,MACJkQ,EAAYzQ,GAAiBc,SAC7B,MAED,QACC7nH,QAAQkiB,MAAO,2DAA4DpnB,GAI7E,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBS,SAC7B,MAED,KAAK,MACJgQ,EAAYzQ,GAAiBgB,SAC7B,MAED,KAAK,MACJyP,EAAYzQ,GAAiBe,SAC7B,MAED,KAAK,MACJ0P,EAAYzQ,GAAiB4B,SAC7B,MAED,KAAK,MACJ6O,EAAYzQ,GAAiB6B,SAC7B,MAED,KAAK,MACJ4O,EAAYzQ,GAAiBQ,SAC7B,MAED,KAAK,MACJiQ,EAAYzQ,GAAiBiB,UAC7B,MAED,KAAK,MACJwP,EAAYzQ,GAAiB8B,UAC7B,MAED,QACC7oH,QAAQkiB,MAAO,0DAA2DpnB,GAI5E,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBsC,aAC7B,MAED,KAAK,MACJmO,EAAYzQ,GAAiBuC,YAC7B,MAED,KAAK,MACJkO,EAAYzQ,GAAiByC,aAC7B,MAED,QACCxpH,QAAQkiB,MAAO,6DAA8DpnB,GAI/E,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBwC,oBAC7B,MAED,KAAK,MAECwF,IAAyE,IAA/DA,EAAO0I,SAASvjI,IAAKy5H,GAAelE,uBAElDzpH,QAAQkiB,MAAO,qIAIhBs1G,EAAYzQ,GAAiB0C,qBAE7B,MAED,QACCzpH,QAAQkiB,MAAO,oEAAqEpnB,GAItF,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBa,QAC7B,MAED,KAAK,MACJ4P,EAAYzQ,GAAiBY,QAC7B,MAED,QACC3nH,QAAQkiB,MAAO,kEAAmEpnB,GAIpF,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiB6B,SAC7B,MAED,KAAK,MACJ4O,EAAYzQ,GAAiB4B,SAC7B,MAED,QACC3oH,QAAQkiB,MAAO,iEAAkEpnB,GAInF,MAED,KAAK,MAEJ,OAASA,GAER,KAAK,MACJ08H,EAAYzQ,GAAiBmC,WAC7B,MAED,KAAK,MACJsO,EAAYzQ,GAAiBkC,WAC7B,MAED,QACCjpH,QAAQkiB,MAAO,mEAAoEpnB,GAIrF,MAED,QACCkF,QAAQkiB,MAAO,8CAA+ChhB,GAMjE,OAAOs2H,CAER,CAEA,MAAME,GAAoB,mFACpBC,GAAmB,mDAEnBC,GAAgB,CACrB,IAAO,QACP,IAAO,MACP,IAAO,OACP,KAAQ,OAER,YAAa,OACZ,YAAa,QACb,YAAa,QACb,aAAc,QAEf,MAAS,OACT,MAAS,QACT,MAAS,QACT,MAAS,QAET,YAAa,OACb,YAAa,QACb,YAAa,QACb,aAAc,QAEd,MAAS,OACT,MAAS,QACT,MAAS,QACT,MAAS,QAET,YAAa,OACb,YAAa,QACb,YAAa,QACb,aAAc,QAEd,MAAS,OACT,MAAS,QACT,MAAS,QACT,MAAS,QAET,cAAe,OACf,QAAW,OAEX,cAAe,OACf,QAAW,OAEX,cAAe,OACf,QAAW,OAEX,QAAW,UAEX,WAAc,UAEd,WAAc,UACd,iBAAoB,UACpB,wBAA2B,cAE3B,iBAAoB,eACpB,8BAAiC,eAEjC,WAAc,YAEd,aAAgB,cAChB,mBAAsB,cAEtB,mBAAsB,iBACtB,mBAAsB,iBACtB,yBAA4B,iBAC5B,mBAAsB,kBA8EvB,MAAMC,WAAyB1xC,GAO9B,WAAA9yF,CAAaue,GAEZ,MAAM,KAAE9W,EAAI,OAAEsM,EAAM,KAAEnR,EAAI,WAAEwwF,EAAU,UAAEC,EAAS,WAAE3uD,GAnFvC,CAAEnmB,IAIf,MAAMm1E,GAFNn1E,EAASA,EAAOi1E,QAEWG,MAAO0wC,IAElC,GAAqB,OAAhB3wC,GAA+C,IAAvBA,EAAYxvF,OAAe,CAEvD,MAAMkvF,EAAaM,EAAa,GAC1BE,EAAe,GACrB,IAAID,EAAQ,KAEZ,KAA4D,QAAlDA,EAAQ2wC,GAAiBp4C,KAAMkH,KAExCQ,EAAa5tF,KAAM,CAAEpD,KAAM+wF,EAAO,GAAKlsF,KAAMksF,EAAO,KAKrD,MAAM5/E,EAAS,GACf,IAAM,IAAIxP,EAAI,EAAGA,EAAIqvF,EAAa1vF,OAAQK,IAAO,CAEhD,MAAM,KAAE3B,EAAI,KAAE6E,GAASmsF,EAAcrvF,GAErC,IAAIkgI,EAAeh9H,EAEdg9H,EAAal+H,WAAY,OAE7Bk+H,EAAe,WAIVA,EAAal+H,WAAY,aAE7Bk+H,EAAeh9H,EAAKiI,MAAO,KAAO,IAInC+0H,EAAeF,GAAeE,IAI/B1wH,EAAO/N,KAAM,IAAIsqF,GAAmBm0C,EAAc7hI,GAEnD,CAEA,MAAMywF,EAAY90E,EAAOy1E,UAAWN,EAAa,GAAIxvF,QAC/CwgC,EAAagvD,EAAa,IAAO,OAEjC9wF,OAA4B3B,IAArByyF,EAAa,GAAoBA,EAAa,GAAM,GAGjE,MAAO,CACNjsF,KAHY88H,GAAe7/F,IAAgBA,EAI3C3wB,SACAnR,OACAwwF,aACAC,YACA3uD,aAGF,CAEC,MAAM,IAAInxB,MAAO,6CAElB,EAkBmEmxH,CAAOnmH,GAEzE3U,MAAOnC,EAAMsM,EAAQnR,GAErB1C,KAAKkzF,WAAaA,EAClBlzF,KAAKmzF,UAAYA,EACjBnzF,KAAKwkC,WAAaA,CAEnB,CAQA,OAAAsrC,CAASptE,EAAO1C,KAAK0C,MAEpB,MAAM8hC,EAAiC,SAApBxkC,KAAKwkC,WAAwB,MAAQxkC,KAAKwkC,WAAa,GAE1E,MAAO,MAAO9hC,OAAY1C,KAAKkzF,WAAWI,YAAc9uD,IAAgBxkC,KAAKmzF,SAE9E,EASD,MAAMsxC,WAAuB9xC,GAQ5B,aAAA9iB,CAAexxD,GAEd,OAAO,IAAIimH,GAAkBjmH,EAE9B,EAKD,MAAMqmH,GAAmC,oBAAT55H,KAAyBA,KAAK45H,eAAiB,CAAEl8H,OAAQ,EAAGC,SAAU,EAAGk8H,QAAS,GAE5GC,GAAc,CACnB,CAAE77H,EAAWC,WAAa,OAC1B,CAAED,EAAWE,YAAc,QAC3B,CAAEF,EAAWG,YAAc,cAGtB27H,GAAY,CACjB,CAAE,OAAkB,SACpB,CAAE,OAAuB,QACzB,CAAE,OAA0B,UAGvBC,GAAoB,CACzB,OAAUJ,GAAiBA,GAAel8H,OAAS,EACnD,SAAYk8H,GAAiBA,GAAej8H,SAAW,EACvD,QAAWi8H,GAAiBA,GAAeC,QAAU,GAGhDI,GAAW,CAChBC,UAAU,EACV1+B,eAAe,EACfC,eAAe,GAGV0+B,GAAc,CACnB,KAAM,WAGDC,GAAc,CACnBxtH,MAAO,MACPF,IAAK,MACLJ,KAAM,MACNF,KAAM,OACNiC,MAAO,YAEPC,KAAM,YACNC,MAAO,YACPC,MAAO,YACPC,MAAO,aAEPC,KAAM,YACNC,MAAO,YACPC,MAAO,YACPC,MAAO,aAEPC,KAAM,YACNC,MAAO,YACPC,MAAO,YACPC,MAAO,aAEPC,KAAM,cACNC,KAAM,cACNC,KAAM,eAGDirH,GAAgB,CAAC,EAEjBC,GAAe,CACpBC,QAAS,IAAIp2D,GAAU,kFACvBq2D,UAAW,IAAIr2D,GAAU,kFACzBs2D,SAAU,IAAIt2D,GAAU,uFACxBu2D,SAAU,IAAIv2D,GAAU,uFACxBw2D,SAAU,IAAIx2D,GAAU,uFACxBy2D,YAAa,IAAIz2D,GAAU,uEAC3B02D,aAAc,IAAI12D,GAAU,8GAC5B22D,aAAc,IAAI32D,GAAU,0HAC5B42D,aAAc,IAAI52D,GAAU,sIAC5B62D,qBAAsB,IAAI72D,GAAU,+EACpC82D,qBAAsB,IAAI92D,GAAU,uIACpC+2D,oBAAqB,IAAI/2D,GAAU,wFACnCg3D,mBAAoB,IAAIh3D,GAAoB,kvBAyBvCi3D,GAAc,CACnB/+G,KAAM,OACNC,KAAM,SACNk+G,UAAW,gBACXC,SAAU,eACVC,SAAU,eACVC,SAAU,eACVC,YAAa,kBACbC,aAAc,mBACdC,aAAc,mBACdC,aAAc,mBACdM,YAAa,cACbC,QAAS,gBAKgB,oBAAdC,WAA6B,WAAW/xH,KAAM+xH,UAAUC,aAEnElB,GAAamB,UAAY,IAAIt3D,GAAU,yGACvCm2D,GAAaoB,SAAW,IAAIv3D,GAAU,6HAA8H,CAAEm2D,GAAamB,YACnLnB,GAAaqB,SAAW,IAAIx3D,GAAU,wJAAyJ,CAAEm2D,GAAamB,YAC9MnB,GAAasB,SAAW,IAAIz3D,GAAU,mLAAoL,CAAEm2D,GAAamB,YAEzOL,GAAYK,UAAY,gBACxBL,GAAYM,SAAW,eACvBN,GAAYO,SAAW,eACvBP,GAAYQ,SAAW,gBAMxB,IAAIC,GAAc,IAE2E,KAAjE,oBAAdN,WAA6B,gBAAgB/xH,KAAM+xH,UAAUC,cAE1EK,IAAe,+CAMhB,MAAMC,WAAwB/8C,GAE7B,WAAA/pF,CAAaQ,EAAQwC,GAEpB4G,MAAOpJ,EAAQwC,EAAU,IAAI2hI,IAE7BzkI,KAAK0mG,cAAgB,CAAC,EAEtB1mG,KAAK4mG,SAAW,CAAC,EAEjB5mG,KAAK6mI,WAAa,CAAC,EAEnB7mI,KAAK8mI,aAAe,IAAIpgI,GAEzB,CAEA,wBAAAiwB,CAA0B7C,GAEzB,OAAkC,IAA3BA,EAAQ4xE,gBAA2B5xE,EAAQpH,aAAe,KAElE,CAEA,sBAAAq6G,CAAwBjzG,EAASL,EAAiBqC,EAAWG,EAAcpa,EAAc7b,KAAK6b,aAE7F,MAAqB,aAAhBA,EAECoa,EAEG,kBAAmBxC,MAAsBA,cAA8BqC,MAAgBG,MAIvF,kBAAmBxC,MAAsBA,cAA8BqC,MAIpE91B,KAAK2rF,kBAAmB73D,GAE5B9zB,KAAKgnI,wBAAyBlzG,EAASL,EAAiBqC,GAIxD91B,KAAK6rF,mBAAoB/3D,EAASL,EAAiBqC,EAAWG,EAAc,IAIrF,CAEA,oBAAAgxG,CAAsBxzG,EAAiBqC,EAAWja,EAAc7b,KAAK6b,aAEpE,GAAqB,aAAhBA,EAEJ,MAAO,iCAAkC4X,MAAsBA,yBAAyCqC,cAAwBA,UAIhIrpB,QAAQkiB,MAAO,uDAAwD9S,YAIzE,CAEA,2BAAAqrH,CAA6BpzG,EAASL,EAAiBqC,EAAWC,EAAcE,EAAcpa,EAAc7b,KAAK6b,aAEhH,MAAuB,aAAhBA,GAA8C,YAAhBA,IAAkE,IAAnC7b,KAAKmnI,eAAgBrzG,GAI7E9zB,KAAK2rF,kBAAmB73D,GAE5B9zB,KAAKgnI,wBAAyBlzG,EAASL,EAAiBqC,EAAWC,GAInE/1B,KAAK6rF,mBAAoB/3D,EAASL,EAAiBqC,EAAWG,EAAcF,GAR5E,uBAAwBtC,MAAsBA,cAA8BqC,MAAgBC,KAYrG,CAEA,oBAAAqxG,CAAsBtzG,GAErB,MAAMuzG,EAAe,aAAcxC,GAAW/wG,EAAQysF,WAAcskB,GAAW/wG,EAAQ2sF,UAAY3sF,EAAQkoF,gBAAkB,KAAO,QAEpI,IAAIzsC,EAAW41D,GAAekC,GAE9B,QAAkBtmI,IAAbwuE,EAAyB,CAE7B,MAAMp5D,EAAW,GAGXmxH,EAAYxzG,EAAQkoF,gBAAkB,QAAU,QACtD,IAAIp7C,EAAO,MAAMymE,cAAyBC,UAAkBA,mBAA2BA,OAEvF,MAAMC,EAAiB,CAAEC,EAAMj3E,KAEzBi3E,IAAS,OAEbrxH,EAASrQ,KAAMs/H,GAAaU,sBAE5BllE,GAAQ,uCAAwCrQ,OAErCi3E,IAAS,OAEpBrxH,EAASrQ,KAAMs/H,GAAaY,qBAE5BplE,GAAQ,sCAAuCrQ,OAEpCi3E,IAAS,OAEpBrxH,EAASrQ,KAAMs/H,GAAaW,sBAE5BnlE,GAAQ,uCAAwCrQ,QAIhDqQ,GAAQ,aAAcrQ,IAEtB9jD,QAAQC,KAAM,kDAAmD86H,yBAElE,EAIDD,EAAgBzzG,EAAQysF,MAAO,KAE/B3/C,GAAQ,MAER2mE,EAAgBzzG,EAAQ2sF,MAAO,KAE1B3sF,EAAQkoF,kBAEZp7C,GAAQ,MACR2mE,EAAgBzzG,EAAQ6sF,MAAO,MAIhC//C,GAAQ,gBAERukE,GAAekC,GAAiB93D,EAAW,IAAIN,GAAUrO,EAAMzqD,EAEhE,CAIA,OAFAo5D,EAASljE,MAAOrM,MAETqnI,CAER,CAEA,wBAAAI,CAA0B3zG,EAASL,EAAiBsC,GAEnD,MAAMmuC,EAAclkE,KAAKsN,gBAAiBwmB,EAAS9zB,KAAK6b,YAAa7b,KAAKwvB,kBAEnCzuB,IAAlCmjE,EAAYwjE,oBAAkCxjE,EAAYwjE,kBAAoB,CAAC,GAEpF,IAAIC,EAAuBzjE,EAAYwjE,kBAAmB3xG,GAE1D,QAAuDh1B,IAAlDmjE,EAAYwjE,kBAAmB3xG,GAA+B,CAElE,IAAI6xG,EACAC,EAEJ,MAAM,eAAElH,GAAmB3gI,KAAK8C,SAASw6D,QAAQ0vC,MAAM6zB,qBAAsB/sG,GACvEg0G,EAAiBnH,EAAiB,EAIvCkH,EAFI/zG,EAAQkoF,gBAEI,YAKA,YAOhB4rB,EAFIE,GAAkBh0G,EAAQ4xE,gBAAkB5xE,EAAQwwC,iBAE9B7wC,EAIA,GAAGA,IAAkBsC,EAAe,UAAWA,MAAoB,KAI9F4xG,EAAuB,IAAIr8G,GAAS,IAAIgH,GAAgB,sBAAuBs1G,MAA8BC,IAE7G3jE,EAAYwjE,kBAAmB3xG,GAAiB4xG,GAE3C7zG,EAAQu0E,oBAAsBv0E,EAAQkoF,mBAE1C93C,EAAY6jE,gBAAkB,IAAIz8G,GACjC,IAAIgH,GACH,oBAAoBmB,KACpB,SAOEK,EAAQk0G,gBAEZ9jE,EAAY+jE,cAAgB,IAAI38G,GAC/B,IAAIgH,GAAgB,KAAM,QAK7B,CAEA,OAAOq1G,EAAqBt7H,MAAOrM,KAEpC,CAEA,uBAAAgnI,CAAyBlzG,EAASL,EAAiBqC,EAAWC,EAAe,MAE5E/1B,KAAKkoI,SAAU,sBAKf,MAAO,2BAA4Bz0G,MAHdzzB,KAAKonI,qBAAsBtzG,OAG4BgC,QAFnD91B,KAAKynI,yBAA0B3zG,EAASL,EAAiBsC,YAEwCA,OAE3H,CAEA,kBAAA81D,CAAoB/3D,EAASL,EAAiBqC,EAAWG,EAAcF,EAAe,MAErF,MAAMoyG,EAAenoI,KAAKonI,qBAAsBtzG,GAC1Cs0G,EAAmBpoI,KAAKynI,yBAA0B3zG,EAASL,EAAiBsC,GAE5Eq2D,EAAUt4D,EAAQkoF,gBAAkB,OAAS,OAC7CqsB,EAAe,GAAGj8C,UAAgB+7C,KAAgBryG,QAAgBs2D,UAAgBg8C,MAExF,OAAOpoI,KAAKw2B,oBAAqB1C,EAASL,EAAiB40G,EAAcpyG,EAAcF,EAExF,CAEA,mBAAAS,CAAqB1C,EAASL,EAAiBw0E,EAAgBhyE,EAAcF,EAAe,MAE3F,OAAgC,IAA3BjC,EAAQ4xE,iBAAwD,IAA7B5xE,EAAQwwC,iBAExC,gBAAiB7wC,MAAsBw0E,MAEnChyE,EAEJ,gBAAiBxC,MAAsBw0E,MAAqBhyE,WAAwBF,QAIpF,gBAAiBtC,MAAsBw0E,WAA0BlyE,OAI1E,CAEA,oBAAAuyG,CAAsBx0G,EAASL,EAAiBw0E,EAAgBsgC,GAE/D,MAAO,iBAAkB90G,MAAsBw0E,MAAqBsgC,KAErE,CAEA,eAAAC,CAAiB10G,GAEhB,OAAkC,IAA3BA,EAAQe,gBAAuD,OAA5Bf,EAAQmlD,eAEnD,CAEA,cAAAkuD,CAAgBrzG,GAEf,MAAuD,UAAhD9zB,KAAK8rF,4BAA6Bh4D,KACpC9zB,KAAKke,YAAa,uBAAmD,IAA1B4V,EAAQi4D,eAA0Bj4D,EAAQvsB,OAAS,QAC5D,IAApCvH,KAAKwoI,gBAAiB10G,IAAuBA,EAAQuf,YAAc,OAAiBvf,EAAQ4pB,YAAc,OAC5G19C,KAAK8C,SAASw6D,QAAQ0vC,MAAM6zB,qBAAsB/sG,GAAU6sG,eAAiB,CAE/E,CAEA,eAAAlqG,CAAiB3C,EAASL,EAAiBqC,EAAWG,EAAcpa,EAAc7b,KAAK6b,aAEtF,IAAItO,EAAU,KAgBd,OAZCA,GAF+B,IAA3BumB,EAAQ4xE,eAEF1lG,KAAKinI,qBAAsBxzG,EAAiBqC,EAAWja,GAEtD7b,KAAKmnI,eAAgBrzG,GAEtB9zB,KAAK6rF,mBAAoB/3D,EAASL,EAAiBqC,EAAWG,EAAc,IAAKpa,GAIjF7b,KAAK+mI,uBAAwBjzG,EAASL,EAAiBqC,EAAWG,EAAcpa,GAIpFtO,CAER,CAEA,mBAAA+oB,CAAqBxC,EAASL,EAAiBqC,EAAWK,EAAaF,EAAcpa,EAAc7b,KAAK6b,aAEvG,GAAqB,aAAhBA,EAGJ,MAAO,sBAAuB4X,MAAsBA,cAA8BqC,OAAiBK,EAAa,OAAUA,EAAa,OAIvI1pB,QAAQkiB,MAAO,iEAAkE9S,YAInF,CAEA,sBAAA0a,CAAwBzC,EAASL,EAAiBqC,EAAWI,EAAgBD,EAAcpa,EAAc7b,KAAK6b,aAE7G,GAAqB,aAAhBA,EAEJ,MAAO,yBAA0B4X,MAAsBA,cAA8BqC,MAAgBI,MAIrGzpB,QAAQkiB,MAAO,yEAA0E9S,YAI3F,CAEA,oBAAAua,CAAsBtC,EAASL,EAAiBqC,EAAWC,EAAcE,EAAcpa,EAAc7b,KAAK6b,aAEzG,IAAItO,EAAU,KAYd,OARCA,GAF+B,IAA3BumB,EAAQ4xE,eAEF1lG,KAAKinI,qBAAsBxzG,EAAiBqC,EAAWja,GAIvD7b,KAAKknI,4BAA6BpzG,EAASL,EAAiBqC,EAAWC,EAAcE,EAAcpa,GAIvGtO,CAER,CAEA,mBAAA8oB,CAAqBvC,EAASL,EAAiBqC,EAAWE,EAAaC,EAAcpa,EAAc7b,KAAK6b,aAEvG,GAAqB,aAAhBA,EAEJ,MAAO,sBAAuB4X,MAAsBA,cAA8BqC,MAAgBE,MAIlGvpB,QAAQkiB,MAAO,+DAAgE9S,YAIjF,CAEA,eAAA3L,CAAiB/J,EAAM0V,EAAc7b,KAAK6b,aAEzC,IAA4B,IAAvB1V,EAAK06E,gBAAsD,IAA5B16E,EAAKkW,oBAExC,GAAqB,WAAhBR,EAEJ,MAAO,YAAa1V,EAAKzD,YAIpB,IAA4B,IAAvByD,EAAKs6E,cAAyB,CAEzC,MAAM/9E,EAAOyD,EAAKzD,KACZ6E,EAAOpB,EAAKoB,KAElB,MAAc,YAATA,GAA+B,gBAATA,GAAmC,mBAATA,GAAsC,cAATA,EAE1E7E,EAEa,WAAT6E,GAA8B,kBAATA,GAAqC,0BAATA,EAErD,cAAepB,EAAK/C,MAAOV,IAI3ByD,EAAK8U,UAAUvY,KAAO,IAAMA,CAIrC,CAEA,OAAOgH,MAAMwG,gBAAiB/J,EAE/B,CAEA,mBAAA0gG,GAEC,MAAO,QAER,CAEA,qBAAA4hC,CAAuB5sH,GAEtB,OAAOhY,OAAOC,KAAM9D,KAAKqxE,SAAUx1D,IAAgB7X,MAEpD,CAEA,mBAAAic,CAAqBhB,GAEpB,MAAMypH,EAAOzD,GAAahmH,GAE1B,YAAcle,IAAT2nI,GAEJ1oI,KAAKkoI,SAAUQ,GAERA,GAID,IAER,CAEA,aAAAC,CAAexiI,EAAM0V,GAEpB,MAAqB,YAAhBA,EACG9S,EAAWC,UAEZ7C,EAAKy/F,MAEb,CAEA,gBAAAgjC,CAAkBziI,EAAM0V,GAEvB,OAAO+oH,GAAa5kI,KAAK2oI,cAAexiI,EAAM0V,GAE/C,CAEA,kBAAAD,CAAoBzV,EAAMoB,EAAMsU,EAAanZ,EAAO,MAEnD,MAAMo2B,EAAcpvB,MAAMkS,mBAAoBzV,EAAMoB,EAAMsU,EAAanZ,GACjE2K,EAAWrN,KAAKsN,gBAAiBnH,EAAM0V,EAAa7b,KAAKwvB,aAE/D,QAA6BzuB,IAAxBsM,EAASi9F,WAA2B,CAExC,IAAIA,EAEJ,MAAMlvF,EAAQjV,EAAK8U,UACbgwE,EAAY7vE,EAAM1Y,KAElBk6D,EAAW58D,KAAKorF,kBAAmBH,EAAWpvE,GAEpD,GAAc,YAATtU,GAA+B,gBAATA,GAAmC,mBAATA,GAAsC,cAATA,EAAuB,CAExG,IAAIusB,EAAU,KAEd,MAAM8xE,EAAS5lG,KAAK2oI,cAAexiI,EAAM0V,GAmBzC,GAjBc,YAATtU,GAA+B,mBAATA,EAE1BusB,EAAU,IAAI6xE,GAAoB7sE,EAAYp2B,KAAMo2B,EAAY3yB,KAAMiV,EAAOwqF,GAEzD,gBAATr+F,EAEXusB,EAAU,IAAI+xE,GAAwB/sE,EAAYp2B,KAAMo2B,EAAY3yB,KAAMiV,EAAOwqF,GAE7D,cAATr+F,IAEXusB,EAAU,IAAIiyE,GAAsBjtE,EAAYp2B,KAAMo2B,EAAY3yB,KAAMiV,EAAOwqF,IAIhF9xE,EAAQywC,OAAsC,IAA9Bp+D,EAAK0iI,qBACrB/0G,EAAQ0vE,cAAeshC,GAAmBjpH,IAEnB,aAAhBA,GAA8C,YAAhBA,IAAqE,IAAtC7b,KAAKmnI,eAAgBhhI,EAAKjD,SAAuC,IAAlB4wB,EAAQywC,MAW1H3H,EAAS92D,KAAMguB,GAEfw2E,EAAa,CAAEx2E,OAb6H,CAE5I,MAAMU,EAAU,IAAI2mG,GAAa,GAAGriG,EAAYp2B,eAAgBo2B,EAAY3yB,KAAMiV,GAClFoZ,EAAQgvE,cAAeshC,GAAmBjpH,IAE1C+gD,EAAS92D,KAAM0uB,EAASV,GAExBw2E,EAAa,CAAE91E,EAASV,EAEzB,CAQD,MAAO,GAAc,WAATvsB,GAA8B,kBAATA,GAAqC,0BAATA,EAAmC,CAE/F,MAEMe,EAAS,IAFc,WAATf,EAAoB28F,GAAoBo3B,IAE5Bn1H,EAAMiV,GACtC9S,EAAOk7F,cAAeshC,GAAmBjpH,IAEzC+gD,EAAS92D,KAAMwC,GAEfgiG,EAAahiG,CAEd,KAAO,CAEN,MAAMiiG,EAAgBvqG,KAAK0mG,cAAe7qF,KAAmB7b,KAAK0mG,cAAe7qF,GAAgB,CAAC,GAElG,IAAI2uF,EAAgBD,EAAetf,QAEZlqF,IAAlBypG,IAEJA,EAAgB,IAAIjF,GAAmBta,EAAW7vE,GAClDovF,EAAchH,cAAeshC,GAAmBjpH,IAEhD0uF,EAAetf,GAAcuf,EAE7B5tC,EAAS92D,KAAM0kG,IAIhBF,EAAatqG,KAAK4uF,eAAgB91D,EAAavxB,GAE/CijG,EAAclG,WAAYgG,EAE3B,CAEAj9F,EAASi9F,WAAaA,CAEvB,CAEA,OAAOxxE,CAER,CAEA,UAAAgwG,CAAYpmI,EAAME,EAAU2E,EAAMsU,EAAc7b,KAAK6b,aAEpD,MAAMvE,EAAMtX,KAAK4mG,SAAU/qF,KAAmB7b,KAAK4mG,SAAU/qF,GAAgB,IAAInV,KAYjF,OAVyB,IAApB4Q,EAAI3W,IAAK+B,IAEb4U,EAAI9U,IAAKE,EAAM,CACdA,OACAE,WACA2E,SAKK3E,CAER,CAEA,UAAAmmI,CAAYrmI,EAAMmZ,EAAc7b,KAAK6b,aAEpC,YAA0C9a,IAAjCf,KAAK4mG,SAAU/qF,IAA+B7b,KAAK4mG,SAAU/qF,GAAclb,IAAK+B,EAE1F,CAEA,cAAAulC,GAEC,MAA0B,WAArBjoC,KAAK6b,YAEF7b,KAAK8oI,WAAY,eAAgB,cAAe,MAAO,aAIxD,aAER,CAEA,iBAAAx7C,CAAmB53E,GAElB,MAAMI,EAASJ,EAAWI,OACpBq3E,EAAWntF,KAAKutF,eAAgB73E,GAEhC+I,EAAa,GAEnB,IAAM,MAAM/N,KAASoF,EAAOjC,OAE3B4K,EAAW3Y,KAAM4K,EAAMhO,KAAO,MAAQ1C,KAAK6Q,QAASH,EAAMnJ,OAM3D,IAAIq5D,EAAO,MAAO9qD,EAAOpT,SAAW+b,EAAW3N,KAAM,cAAiB9Q,KAAK6Q,QAASiF,EAAOvO,YAC1F4lF,EAAS3C,SACT2C,EAASvsB,SAaV,OAVKusB,EAASpgF,SAEb6zD,GAAQ,YAAausB,EAASpgF,aAI/B6zD,GAAQ,QAIDA,CAER,CAEA,gBAAAz4B,GAEC,MAA0B,WAArBnoC,KAAK6b,YAEF7b,KAAK8oI,WAAY,iBAAkB,gBAAiB,MAAO,aAI5D,eAER,CAEA,uBAAAvgG,GAEC,OAAOvoC,KAAK8oI,WAAY,yBAA0B,uBAAwB,MAAO,YAElF,CAEA,eAAAE,GAIC,OAFAhpI,KAAKipI,kBAEEjpI,KAAK8oI,WAAY,gBAAiB,eAAgB,MAAO,YAEjE,CAEA,0BAAArgG,GAIC,OAFAzoC,KAAKipI,kBAEEjpI,KAAK8oI,WAAY,yBAA0B,0BAA2B,MAAO,YAErF,CAEA,gBAAAngG,GAIC,OAFA3oC,KAAKipI,kBAEEjpI,KAAK8oI,WAAY,cAAe,gBAAiB,MAAO,YAEhE,CAEA,YAAAzgG,GAEC,OAAO,IAER,CAEA,cAAAjO,GAEC,OAAOp6B,KAAK8oI,WAAY,eAAgB,UAAW,OAEpD,CAEA,YAAAh2F,GAEC,OAAO9yC,KAAK8oI,WAAY,WAAY,YAAa,aAAgB,KAElE,CAEA,YAAA30F,GAEC,MAAO,UAAYn0C,KAAK8oI,WAAY,aAAc,QAAS,MAAO,SAEnE,CAEA,eAAAryF,GAEC,MAAO,4BAER,CAEA,OAAAthB,GAEC,OAAO,CAER,CAEA,eAAA+zG,CAAiBxmI,EAAMmZ,EAAc7b,KAAK6b,cAE3B7b,KAAK6mI,WAAYhrH,KAAmB7b,KAAK6mI,WAAYhrH,GAAgB,IAAI++C,MACjFxmD,IAAK1R,EAEZ,CAEA,aAAAymI,CAAettH,GAEd,MAAMqsF,EAAW,GACX2+B,EAAa7mI,KAAK6mI,WAAYhrH,GAEpC,QAAoB9a,IAAf8lI,EAEJ,IAAM,MAAMuC,KAAavC,EAExB3+B,EAASpiG,KAAM,UAAUsjI,MAM3B,OAAOlhC,EAASp3F,KAAM,KAEvB,CAEA,eAAAm4H,GAECjpI,KAAKkpI,gBAAiB,YAEvB,CAEA,kBAAAG,GAECrpI,KAAKkpI,gBAAiB,gBAEvB,CAEA,mBAAAI,GAECtpI,KAAKkpI,gBAAiB,iBAEvB,CAEA,eAAAK,GAECvpI,KAAKkpI,gBAAiB,MAEvB,CAEA,wBAAAM,GAECxpI,KAAKkpI,gBAAiB,uBAEvB,CAEA,sBAAA3yF,CAAwBizD,GAEvBxpG,KAAKspI,sBACLtpI,KAAK8oI,WAAY,iBAAkB,oBAAqB,cAAet/B,MAAiB,SAEzF,CAEA,WAAAigC,CAAa5tH,GAEZ,MAAMqsF,EAAW,GACXtB,EAAW5mG,KAAK4mG,SAAU/qF,GAEhC,QAAkB9a,IAAb6lG,EAEJ,IAAM,MAAM,KAAElkG,EAAI,SAAEE,EAAQ,KAAE2E,KAAUq/F,EAAS/gG,SAEhDqiG,EAASpiG,KAAM,aAAapD,OAAUE,OAAc2E,KAMtD,OAAO2gG,EAASp3F,KAAM,QAEvB,CAEA,cAAA44H,CAAgBhnI,EAAMyS,EAAO4Z,EAAYqN,GAaxC,OAXuC,IAAlCp8B,KAAK8mI,aAAanmI,IAAK+B,IAE3B1C,KAAK8mI,aAAatkI,IAAKE,EAAM,CAC5BA,OACAyS,QACA4Z,aACAqN,gBAKK15B,CAER,CAEA,eAAAinI,CAAiB9tH,GAEhB,GAAqB,YAAhBA,EAEJ,OAID,MAAMqsF,EAAW,GAEjB,IAAM,MAAM,KAAExlG,EAAI,MAAEyS,EAAK,WAAE4Z,EAAU,YAAEqN,KAAiBp8B,KAAK8mI,aAAajhI,SAAW,CAEpF,MAAM0B,EAAOvH,KAAK6Q,QAASke,GAE3Bm5E,EAASpiG,KAAM,OAAOqP,MAAUzS,aAAgB6E,MAAS60B,OAE1D,CAEA,OAAO8rE,EAASp3F,KAAM,KAEvB,CAEA,aAAA4pD,CAAe7+C,GAEd,MAAMqsF,EAAW,GAkBjB,GAhBqB,YAAhBrsF,IAEJ7b,KAAK8oI,WAAY,uBAAwB,KAAM,YAAa,aAC5D9oI,KAAK8oI,WAAY,eAAgB,cAAe,YAAa,aAC7D9oI,KAAK8oI,WAAY,sBAAuB,UAAW,YAAa,aAChE9oI,KAAK8oI,WAAY,iBAAkB,gBAAiB,YAAa,aAE5D9oI,KAAK8C,SAASo+F,WAAY,eAE9BlhG,KAAKkpI,gBAAiB,YAAartH,GACnC7b,KAAK8oI,WAAY,gBAAiB,eAAgB,MAAO,eAMtC,WAAhBjtH,GAA4C,YAAhBA,EAA4B,CAE5D,MAAM+qF,EAAW5mG,KAAKypI,YAAa,aAE9B7iC,GAAWsB,EAASpiG,KAAM8gG,GAE/B,MAAMzlG,EAAanB,KAAKouF,qBAExB,IAAM,IAAI9sF,EAAQ,EAAG0C,EAAS7C,EAAW6C,OAAQ1C,EAAQ0C,EAAQ1C,IAAW,CAE3E,MAAMqB,EAAYxB,EAAYG,GACxBoB,EAAOC,EAAUD,KACjB6E,EAAOvH,KAAK6Q,QAASlO,EAAU4E,MAErC2gG,EAASpiG,KAAM,cAAcxE,OAAYoB,OAAY6E,IAEtD,CAED,CAEA,OAAO2gG,EAASp3F,KAAM,QAEvB,CAEA,gBAAA83F,CAAkBC,GAEjB,MAAMX,EAAW,GACXY,EAAUD,EAAOznB,iBAEvB,IAAM,IAAI/8E,EAAI,EAAGA,EAAIykG,EAAQ9kG,OAAQK,IAAO,CAE3C,MAAM0kG,EAASD,EAASzkG,GACxB6jG,EAASpiG,KAAM,gBAAgBzB,QAAQA,OAAQ0kG,SAEhD,CAEA,MAAMnC,EAAW5mG,KAAKypI,YAAa,UAInC,OAFK7iC,GAAWsB,EAASpiG,KAAM,KAAO8gG,GAE/BsB,EAASp3F,KAAM,MAEvB,CAEA,UAAAk4F,CAAYntF,GAEX,MAAMqsF,EAAW,GACXhe,EAAUlqF,KAAKkqF,QAASruE,GAE9B,IAAM,IAAIva,EAAQ,EAAG0C,EAASkmF,EAAQlmF,OAAQ1C,EAAQ0C,EAAQ1C,IAAW,CAExE,MAAMunG,EAAS3e,EAAS5oF,GAClBoB,EAAOmmG,EAAOnmG,KAEpB,IAAI6K,EAAU,UAAY7K,QAC1B6K,GAAWvN,KAAK4oG,iBAAkBC,GAClCt7F,GAAW,MAGX26F,EAASpiG,KAAMyH,GAEf26F,EAASpiG,KAAM,2BAA4BpD,SAE5C,CAEA,OAAOwlG,EAASp3F,KAAM,OAEvB,CAEA,MAAAg9B,CAAQvmC,EAAM7E,GAEb,MAAO,OAAQA,OAAY1C,KAAK6Q,QAAStJ,IAE1C,CAEA,OAAA0mF,CAASpyE,GAER,MAAMqsF,EAAW,GACX1d,EAAOxqF,KAAKwqF,KAAM3uE,GAExB,QAAc9a,IAATypF,EAEJ,IAAM,MAAMkC,KAAYlC,EAEvB0d,EAASpiG,KAAM,KAAM9F,KAAK8tC,OAAQ4+C,EAASnlF,KAAMmlF,EAAShqF,UAM5D,MAAO,KAAMwlG,EAASp3F,KAAM,SAE7B,CAEA,WAAAw9E,CAAazyE,GAEZ,MAAMqsF,EAAW,GAQjB,GANqB,WAAhBrsF,GAEJ7b,KAAK8oI,WAAY,WAAY,SAAU,YAAa,UAIhC,WAAhBjtH,GAA4C,aAAhBA,EAA6B,CAE7D,MAAMyuE,EAAWtqF,KAAKsqF,SAChBE,EAAOxqF,KAAKwqF,KAAM3uE,GAExB,IAAM,IAAIva,EAAQ,EAAGA,EAAQgpF,EAAStmF,OAAQ1C,IAAW,CAExD,MAAM4a,EAAUouE,EAAUhpF,GAE1B,GAAK4a,EAAQG,mBAAqB,CAEjC,IAAIutH,EAAoB,cAActoI,MAEjC,wBAAwBgT,KAAM4H,EAAQ3U,QAE1CqiI,GAAqB,yBAKtB1hC,EAASpiG,KAAM,GAAI8jI,KAAuB1tH,EAAQxZ,UAAY1C,KAAK6Q,QAASqL,EAAQ3U,QAErF,KAA4B,WAAhBsU,IAAyD,IAA7B2uE,EAAKr0E,SAAU+F,IAEtDsuE,EAAK1kF,KAAMoW,EAIb,CAED,CAEA,MAAM0qF,EAAW5mG,KAAKypI,YAAa5tH,GAE9B+qF,GAAWsB,EAASpiG,KAAM8gG,GAE/B,MAAMhmC,EAAOsnC,EAASp3F,KAAM,SAE5B,MAAuB,WAAhB+K,EAA2B7b,KAAK6pI,eAAgB,iBAAkB,KAAOjpE,GAASA,CAE1F,CAEA,WAAA2tB,CAAa1yE,GAEZ,MAAMw1D,EAAWrxE,KAAKqxE,SAAUx1D,GAE1BssF,EAAkB,GAClB2hC,EAAiB,GACjBC,EAAiB,GACjBrjC,EAAgB,CAAC,EAEvB,IAAM,MAAM5qF,KAAWu1D,EAAW,CAEjC,MAAM4Z,EAAYnvE,EAAQb,UAAUvY,KAC9BsnI,EAAiBhqI,KAAKmqF,gBAAiBc,GAE7C,GAAsB,YAAjBnvE,EAAQvU,MAAuC,gBAAjBuU,EAAQvU,MAA2C,mBAAjBuU,EAAQvU,MAA8C,cAAjBuU,EAAQvU,KAAuB,CAExI,MAAMusB,EAAUhY,EAAQ3V,KAAKjD,MAgB7B,IAAI28G,EAdmB,aAAhBhkG,GAA8C,YAAhBA,IAAkE,IAAnC7b,KAAKmnI,eAAgBrzG,KAA6D,IAAtChY,EAAQ3V,KAAK0iI,uBAEvH7oI,KAAKwoI,gBAAiB10G,GAE1Bq0E,EAAgBriG,KAAM,aAAckkI,EAAe9mE,uBAA0B8mE,EAAe5uH,eAAiBU,EAAQpZ,sCAIrHylG,EAAgBriG,KAAM,aAAckkI,EAAe9mE,uBAA0B8mE,EAAe5uH,eAAiBU,EAAQpZ,4BAQvH,IAAIunI,EAAe,GAEnB,MAAM,eAAEtJ,GAAmB3gI,KAAK8C,SAASw6D,QAAQ0vC,MAAM6zB,qBAAsB/sG,GAQ7E,GANK6sG,EAAiB,IAErBsJ,EAAe,kBAIe,IAA1Bn2G,EAAQ6mB,cAEZklE,EAAc,yBAER,IAAoC,IAA/B/rF,EAAQu0E,qBAAoE,IAArCv0E,EAAQw0E,yBAE1DuX,EAAc,6BAER,IAAgC,IAA3B/rF,EAAQe,eAEnBgrF,EAAc,gBAAgBoqB,YAExB,IAAgC,IAA3Bn2G,EAAQ4xE,eAEnBma,EAAc,wBAER,IAAiC,IAA5B/rF,EAAQkoF,gBAEnB6D,EAAc,uBAER,IAA2C,IAAtC/jG,EAAQ3V,KAAK0iI,qBAAgC,CAKxDhpB,EAAc,sBAHCugB,GAAWtsG,OACX9zB,KAAK4oI,iBAAkB9sH,EAAQ3V,KAAM0V,KAIrD,KAAO,CAINgkG,EAAc,UAAUoqB,QAFAjqI,KAAK8rF,4BAA6Bh4D,GAAU8I,OAAQ,OAI7E,CAEAurE,EAAgBriG,KAAM,aAAckkI,EAAe9mE,uBAA0B8mE,EAAe5uH,eAAiBU,EAAQpZ,UAAYm9G,KAElI,MAAO,GAAsB,WAAjB/jG,EAAQvU,MAAsC,kBAAjBuU,EAAQvU,MAA6C,0BAAjBuU,EAAQvU,KAAmC,CAEvH,MAAMipB,EAAa1U,EAAQ3V,KACrB4oB,EAAa/uB,KAAK6Q,QAAS2f,EAAWzB,YACtCqN,EAAc5L,EAAW4L,YAEzBmsE,EAAqBnsE,EAAc,GAAsB,WAAjBtgB,EAAQvU,KAAoB,KAAO60B,EAAc,GACzF8tG,EAAoB15G,EAAW25G,SAAW,UAAUp7G,KAAgB,GAAGA,IACvEq7G,EAAgB,KAAMtuH,EAAQpZ,iBAAmBwnI,IAAsB3hC,QACvE8hC,EAAmB75G,EAAW85G,oBAAsB,YAAatqI,KAAK4oI,iBAAkBp4G,EAAY3U,KAAmB,UAE7HiuH,EAAehkI,KAAM9F,KAAKuqI,sBAAuB,cAAgB/5G,EAAWptB,GAAIgnI,EAAeC,EAAkBL,EAAe9mE,UAAY8mE,EAAe5uH,OAE5J,KAAO,CAEN,MAAMovH,EAAaxqI,KAAK6Q,QAAS7Q,KAAK8P,cAAegM,EAAQvU,OACvD0jF,EAAYnvE,EAAQb,UAAUvY,MAEtBgkG,EAAezb,KAAiByb,EAAezb,GAAc,CAC1E3pF,MAAO0oI,EAAe9mE,UACtB9/D,GAAI4mI,EAAe5uH,MACnB8sF,SAAU,MAGLA,SAASpiG,KAAM,KAAMgW,EAAQpZ,UAAY8nI,IAEhD,CAED,CAEA,IAAM,MAAM9nI,KAAQgkG,EAAgB,CAEnC,MAAMtrF,EAAQsrF,EAAehkG,GAE7BqnI,EAAejkI,KAAM9F,KAAKuqI,sBAAuB7nI,EAAM0Y,EAAM8sF,SAASp3F,KAAM,OAAS,UAAWsK,EAAM9Z,MAAO8Z,EAAMhY,IAEpH,CAEA,IAAIw9D,EAAOunC,EAAgBr3F,KAAM,MAIjC,OAHA8vD,GAAQkpE,EAAeh5H,KAAM,MAC7B8vD,GAAQmpE,EAAej5H,KAAM,MAEtB8vD,CAER,CAEA,SAAA8tB,GAEC,MAAMub,EAAgC,OAAlBjqG,KAAKiB,SAAoB,CAAEigE,SAAU,CAAC,EAAGrnB,OAAQ,CAAC,GAAM,CAAE3oB,QAAS,CAAC,GAExFlxB,KAAKurF,oBAEL,IAAM,MAAM1vE,KAAeouF,EAAc,CAExC,MAAMI,EAAYJ,EAAapuF,GAC/BwuF,EAAUh5B,SAAWrxE,KAAKuuF,YAAa1yE,GACvCwuF,EAAUlpG,WAAanB,KAAK06D,cAAe7+C,GAC3CwuF,EAAU/f,SAAWtqF,KAAKsuF,YAAazyE,GACvCwuF,EAAUngB,QAAUlqF,KAAKgpG,WAAYntF,GACrCwuF,EAAU7f,KAAOxqF,KAAKiuF,QAASpyE,GAC/BwuF,EAAU9f,MAAQvqF,KAAKwuF,SAAU3yE,GACjCwuF,EAAUw8B,WAAa7mI,KAAKmpI,cAAettH,GAC3CwuF,EAAUy8B,aAAe9mI,KAAK2pI,gBAAiB9tH,GAI/C,IAAI4uE,EAAO,cACXA,GAAQzqF,KAAKiqF,SAAUpuE,GAEvB,MAAMmuE,EAAYhqF,KAAKgqF,UAAWnuE,GAC5BquF,EAAWlgB,EAAWA,EAAUhmF,OAAS,GAEzC8H,EAAao+F,EAASp+F,WACtB2+H,OAAkC1pI,IAAf+K,IAA8D,IAAlCA,EAAWwtC,mBAEhE,IAAM,MAAMnzC,KAAQ6jF,EAAY,CAE/B,MAAMmgB,EAAenqG,KAAKitF,YAAa9mF,GACjCikG,EAAWjkG,EAAKzD,KAYtB,GAVK0nG,IAEC3f,EAAKzmF,OAAS,IAAIymF,GAAQ,MAE/BA,GAAQ,gBAAiB2f,SAI1B3f,GAAQ,GAAI0f,EAAavpC,WAEpBz6D,IAAS+jG,GAA4B,YAAhBruF,EAIzB,GAFA4uE,GAAQ,kBAEa,WAAhB5uE,EAEJ4uE,GAAQ,qBAAsB0f,EAAap9F,eAErC,GAAqB,aAAhB8O,EAEX,GAAK4uH,EAEJpgC,EAAUqgC,WAAa5+H,EAAWrC,SAElCghF,GAAQ,UAAW0f,EAAap9F,cAE1B,CAEN,IAAI49H,EAAgB,kCAEpB,MAAM/jC,EAAW5mG,KAAKypI,YAAa,UAE9B7iC,IAAW+jC,GAAiB,QAAU/jC,GAE3CyD,EAAUqgC,WAAa,eACvBrgC,EAAUngB,SAAWlqF,KAAK6pI,eAAgB,eAAgBc,GAC1DtgC,EAAUngB,SAAW,4CAErBO,GAAQ,kBAAmB0f,EAAap9F,6BAEzC,CAMH,CAEAs9F,EAAU5f,KAAOA,CAGlB,CAEuB,OAAlBzqF,KAAKiB,UAETjB,KAAKiiE,aAAejiE,KAAK4qI,mBAAoB3gC,EAAYpwD,QACzD75C,KAAKmiE,eAAiBniE,KAAK6qI,qBAAsB5gC,EAAY/oC,WAI7DlhE,KAAKwhE,cAAgBxhE,KAAK8qI,oBAAqB7gC,EAAY/4E,SAAWlxB,KAAKM,OAAOqwB,eAAiB,CAAE,KAAO7f,KAAM,MAIpH,CAEA,SAAAqP,CAAWuB,EAAQnV,EAAS,MAE3B,IAAIw+H,EAcJ,OAZgB,OAAXx+H,IAEJw+H,EAAa/qI,KAAKgrI,eAAgBtpH,EAAS,IAAMnV,SAI9BxL,IAAfgqI,IAEJA,EAAa/qI,KAAKgrI,eAAgBtpH,IAI5BqpH,GAAcrpH,CAEtB,CAEA,OAAA7Q,CAAStJ,GAER,OAAO29H,GAAa39H,IAAUA,CAE/B,CAEA,WAAA2W,CAAaxb,GAEZ,IAAIqK,EAASg4H,GAAUriI,GAkBvB,YAhBgB3B,IAAXgM,IAEU,sBAATrK,EAEJqK,EAAS/M,KAAK8C,SAASo+F,WAAY,sBAEf,iBAATx+F,IAEXqK,EAAS/M,KAAK8C,SAASo+F,WAAY,mBAIpC6jC,GAAUriI,GAASqK,GAIbA,CAER,CAEA,cAAAi+H,CAAgBtpH,GAQf,YANgC3gB,IAA3BqkI,GAAc1jH,IAElB1hB,KAAKkoI,SAAUxmH,GAITwkH,GAAaxkH,EAErB,CAEA,QAAAwmH,CAAUxlI,GAET,MAAMuoI,EAAW7F,GAAc1iI,GAS/B,OARAuoI,EAAS5+H,MAAOrM,MAEkB,OAA7BA,KAAKkW,qBAETlW,KAAKkW,oBAAoBC,SAASrQ,KAAMmlI,GAIlCA,CAER,CAEA,kBAAAL,CAAoB7gC,GAEnB,MAAO,GAAI/pG,KAAKivF,kCAEhB8a,EAAW88B,8BAGX98B,EAAW14B,4BAGX04B,EAAWzf,kEAIXyf,EAAWxf,8BAGFwf,EAAW5oG,oDAGnB4oG,EAAWvf,wBAGXuf,EAAWtf,mCAOb,CAEA,oBAAAogD,CAAsB9gC,GAErB,MAAO,GAAI/pG,KAAKivF,8BAEf03C,sBAGD58B,EAAW14B,2BAGX04B,EAAW7f,wBAGX6f,EAAWxf,gCAGFwf,EAAWzf,iBAAiByf,EAAW2gC,gCAG/C3gC,EAAWvf,wBAGXuf,EAAWtf,aAKb,CAEA,mBAAAqgD,CAAqB/gC,EAAYp5E,GAEhC,MAAO,GAAI3wB,KAAKivF,kCAEhB8a,EAAW88B,4EAMX98B,EAAW+8B,gCAGX/8B,EAAW14B,yBAGX04B,EAAWxf,sCAEe55D,iBACjBo5E,EAAW5oG,wFAGiCwvB,uDAAmEA,uBAGvHo5E,EAAWvf,wBAGXuf,EAAWtf,aAKb,CAEA,cAAAo/C,CAAgBnnI,EAAM8nF,GAErB,MAAO,YACA9nF,QACP8nF,OAGD,CAEA,qBAAA+/C,CAAuB7nI,EAAM8nF,EAAMob,EAAQ1iC,EAAU,EAAG9nD,EAAQ,GAE/D,MAAM8vH,EAAaxoI,EAAO,SAG1B,MAAO,GAFe1C,KAAK6pI,eAAgBqB,EAAY1gD,iBAG7CtnB,eAAqB9nD,YAC3BwqF,MAAWljG,OAAUwoI,IAE1B,EAID,MAAMC,GAEL,WAAArrI,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,CAEhB,CAEA,4BAAA8tE,CAA8BxyE,GAE7B,IAAIjrD,EAgBJ,OAdoC,OAA/BirD,EAAcyO,aAElB15D,EAAS3N,KAAKqrI,oBAAqBzyE,EAAcyO,cAEtCzO,EAActhC,OAASshC,EAAcmO,QAEhDp5D,EAAS6lH,GAAiBwC,oBAEfp9D,EAActhC,QAEzB3pB,EAAS6lH,GAAiBuC,aAIpBpoH,CAER,CAEA,mBAAA09H,CAAqBv3G,GAEpB,OAAO9zB,KAAKs9D,QAAQx8D,IAAKgzB,GAAUnmB,MAEpC,CAEA,oBAAAkzH,CAAsB/sG,GAErB,IAAI0lB,EAEJ,GAAK1lB,EAAQyB,qBAEZikB,EAAU,OAEJ,GAAK1lB,EAAQe,iBAAoBf,EAAQqe,aAAe,CAE9D,MAAMrvC,EAAW9C,KAAKs9D,QAAQx6D,SACxBqvC,EAAervC,EAASsvC,kBAE9BoH,EAAUrH,EAAeA,EAAaqH,QAAU12C,EAAS02C,OAE1D,MAAY1lB,EAAQqe,eAEnBqH,EAAU1lB,EAAQqe,aAAaqH,SAIhCA,EAAUA,GAAW,EAErB,MAAMonF,EAASpnF,EAAU,GAA8B,OAAzB1lB,EAAQqe,eAAsD,IAA3Bre,EAAQe,iBAA4D,IAAjCf,EAAQyB,qBAG5G,MAAO,CAAEikB,UAASmnF,eAFKC,EAAS,EAAIpnF,EAEFonF,SAEnC,CAEA,qBAAAJ,CAAuB5nE,GAEtB,IAAIjrD,EAYJ,OARCA,EAF+B,OAA3BirD,EAAclqD,SAET1O,KAAKqrI,oBAAqBzyE,EAAclqD,SAAU,IAIlD1O,KAAKygI,2BAIR9yH,CAER,CAEA,oBAAA29H,CAAsB1yE,GAErB,OAAgC,OAA3BA,EAAclqD,SAEXkqD,EAAclqD,SAAU,GAAIge,WAI7B1sB,KAAKs9D,QAAQx6D,SAAS8pB,gBAE9B,CAEA,oBAAA2+G,CAAsBjrI,EAAQW,GAE7B,OAAKX,EAAOk7D,SAAkBy3D,GACpB3yH,EAAOm7D,gBAAoBn7D,EAAOu/D,SAAiC,IAAvB5+D,EAASs6D,UAA8B03D,GACnF3yH,EAAOo7D,OAAgBu3D,GACvB3yH,EAAOu/D,OAAgBozD,QAA5B,CAEN,CAEA,cAAA2O,CAAgBr6D,GAEf,IAAI7lE,EAAQ,EAeZ,OAbK6lE,EAAc,IAGlB7lE,EAAQuD,KAAKkjB,IAAK,EAAGljB,KAAKshB,MAAOthB,KAAKmhB,KAAMmhD,KAE7B,IAAV7lE,IAEJA,EAAQ,IAMHA,CAER,CAEA,2BAAA8pI,CAA6B5yE,GAE5B,OAAgC,OAA3BA,EAAclqD,SAEX1O,KAAK4hI,eAAgBhpE,EAAc2O,aAIpCvnE,KAAK4hI,eAAgB5hI,KAAKs9D,QAAQx6D,SAAS02C,QAEnD,CAEA,wBAAAinF,GAKC,OAAK4F,UAAUC,UAAUnwH,SAAU,SAE3Bq9G,GAAiBuB,WAIjBsR,UAAUoF,IAAIhL,0BAIvB,EAID,MAAMiL,GAAkC,IAAIhlI,IAAK,CAChD,CAAEgjF,UAAW,CAAE,QAAS,WACxB,CAAE5hF,WAAY,CAAE,QAAS,WACzB,CAAE6hF,WAAY,CAAE,SAAU,YAC1B,CAAEC,YAAa,CAAE,SAAU,YAC3B,CAAEvsD,WAAY,CAAE,SAAU,YAC1B,CAAEC,YAAa,CAAE,SAAU,YAC3B,CAAEH,aAAc,CAAE,cAGbwuG,GAAqC,IAAIjlI,IAAK,CACnD,CAAE,MAAwB,CAAE,cAGvBklI,GAA6C,IAAIllI,IAAK,CAC3D,CAAE22B,WAAY,UACd,CAAEssD,WAAY,UACd,CAAErsD,YAAa,UACf,CAAEssD,YAAa,UACf,CAAEzsD,aAAc,aAGjB,MAAM0uG,GAEL,WAAA/rI,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,CAEhB,CAEA,eAAAG,CAAiB96D,EAAWwsB,GAE3B,MAAMa,EAAkBhwB,KAAK69D,oBAAqBl7D,GAE5C26D,EAAUt9D,KAAKs9D,QACf/tC,EAAa+tC,EAAQx8D,IAAKkvB,GAEhC,IAAI1nB,EAASinB,EAAWjnB,OAExB,QAAgBvH,IAAXuH,EAAuB,CAE3B,MAAMkzH,EAASl+D,EAAQk+D,OAEvB,IAAIh2H,EAAQwqB,EAAgBxqB,MAG5B,IAA8B,IAAzB7C,EAAUq5D,aAA0Bx2D,EAAM1F,cAAgB6pF,YAAcnkF,EAAM1F,cAAgB8pF,aAAgB,CAElH,MAAMkiD,EAAY,IAAIxuG,YAAa93B,EAAMxB,QACzC,IAAM,IAAIK,EAAI,EAAGA,EAAImB,EAAMxB,OAAQK,IAElCynI,EAAWznI,GAAMmB,EAAOnB,GAIzBmB,EAAQsmI,CAET,CAIA,GAFA97G,EAAgBxqB,MAAQA,GAEjBwqB,EAAgB+uC,0BAA4B/uC,EAAgBgvC,oCAAoE,IAA7BhvC,EAAgBJ,SAAiB,CAE1IpqB,EAAQ,IAAIA,EAAM1F,YAAqC,EAAxBkwB,EAAgBtuB,OAE/C,IAAM,IAAI2C,EAAI,EAAGA,EAAI2rB,EAAgBtuB,MAAO2C,IAE3CmB,EAAMhD,IAAKwtB,EAAgBxqB,MAAMumI,SAAc,EAAJ1nI,EAAW,EAAJA,EAAQ,GAAS,EAAJA,GAKhE2rB,EAAgBJ,SAAW,EAC3BI,EAAgBxqB,MAAQA,CAEzB,CAEA,MAAMwrB,EAAOxrB,EAAMs+F,YAAiB,EAAMt+F,EAAMs+F,WAAa,GAAQ,EAErEx7F,EAASkzH,EAAO5uB,aAAc,CAC7B1xF,MAAO8U,EAAgBttB,KACvBsuB,KAAMA,EACN7B,MAAOA,EACP68G,kBAAkB,IAGnB,IAAIxmI,EAAM1F,YAAawI,EAAOu6H,kBAAmBrgI,IAAKgD,GAEtD8C,EAAO2jI,QAEP18G,EAAWjnB,OAASA,CAErB,CAED,CAEA,eAAAw1D,CAAiBn7D,GAEhB,MAAMqtB,EAAkBhwB,KAAK69D,oBAAqBl7D,GAE5C26D,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAEjBlzH,EAASg1D,EAAQx8D,IAAKkvB,GAAkB1nB,OAExC9C,EAAQwqB,EAAgBxqB,MACxB0mI,EAAelsI,KAAKmsI,cAAe3mI,GACnC4mG,EAAep8E,EAAgBo8E,aAErC,GAA6B,IAAxBA,EAAapoG,OAIjBw3H,EAAOkD,MAAM/xB,YACZrkG,EACA,EACA9C,EACA,OAGK,CAEN,MAAM4mI,EAAmBF,EAAe,EAAI1mI,EAAMo+F,kBAElD,IAAM,IAAIv/F,EAAI,EAAG+oC,EAAIg/D,EAAapoG,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAEvD,MAAMkoG,EAAQH,EAAc/nG,GAEtBgoI,EAAa9/B,EAAM9qG,MAAQ2qI,EAC3Bp7G,EAAOu7E,EAAM7qG,MAAQ0qI,EAE3B5Q,EAAOkD,MAAM/xB,YACZrkG,EACA,EACA9C,EACA6mI,EACAr7G,EAGF,CAEAhB,EAAgBw8E,mBAEjB,CAED,CAEA,yBAAA8/B,CAA2B5rI,GAE1B,MAAMS,EAAaT,EAAag6D,gBAC1B1B,EAAgB,IAAItyD,IAE1B,IAAM,IAAI6lI,EAAO,EAAGA,EAAOprI,EAAW6C,OAAQuoI,IAAU,CAEvD,MAAM1tE,EAAoB19D,EAAYorI,GAChC5oC,EAAkB9kC,EAAkBr5D,MAAMo+F,kBAC1C5zE,EAAkBhwB,KAAK69D,oBAAqBgB,GAElD,IAAI2tE,EAAqBxzE,EAAcl4D,IAAKkvB,GAE5C,QAA4BjvB,IAAvByrI,EAAmC,CAEvC,IAAIC,EAAaC,GAEuC,IAAnD7tE,EAAkBhE,8BAEtB4xE,EAAc5tE,EAAkBh+D,KAAKgvB,OAAS8zE,EAC9C+oC,EAAW7tE,EAAkBh+D,KAAK4xH,6BAA+B0H,GAA4BA,KAI7FsS,EAAc5tE,EAAkBjvC,SAAW+zE,EAC3C+oC,EAAW7tE,EAAkBvvC,2BAA6B6qG,GAA4BA,KAKjD,IAAjCt7D,EAAkB7C,YAA0B6C,EAAkBr5D,MAAM1F,cAAgB6pF,YAAc9qB,EAAkBr5D,MAAM1F,cAAgB8pF,cAE9I6iD,EAAc,GAIfD,EAAqB,CACpBC,cACAtrI,WAAY,GACZurI,YAGD1zE,EAAcx2D,IAAKwtB,EAAiBw8G,EAErC,CAEA,MAAM7+H,EAAS3N,KAAK2sI,iBAAkB9tE,GAChC/uC,GAA8D,IAAnD+uC,EAAkBhE,6BAA0CgE,EAAkB/uC,OAAS6zE,EAAkB,EAE1H6oC,EAAmBrrI,WAAW2E,KAAM,CACnC8mI,eAAgBL,EAChBz8G,SACAniB,UAGF,CAEA,OAAO5I,MAAMoD,KAAM6wD,EAAcnzD,SAElC,CAEA,gBAAA23D,CAAkB76D,GAEjB,MAAM26D,EAAUt9D,KAAKs9D,QACRA,EAAQx8D,IAAKd,KAAK69D,oBAAqBl7D,IAE/C2F,OAAOs2H,UAEZthE,EAAQttB,OAAQrtC,EAEjB,CAEA,yBAAMw8F,CAAqBx8F,GAE1B,MAAM26D,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAGjBtwB,EADO5tC,EAAQx8D,IAAKd,KAAK69D,oBAAqBl7D,IAC7B2F,OACjB0oB,EAAOk6E,EAAUl6E,KAEjB67G,EAAgBrR,EAAO5uB,aAAc,CAC1C1xF,MAAO,GAAIvY,EAAUD,gBACrBsuB,OACA7B,MAAOmzG,eAAexB,SAAWwB,eAAeC,WAG3CuK,EAAatR,EAAOgC,qBAAsB,CAC/CtiH,MAAO,oBAAqBvY,EAAUD,SAGvCoqI,EAAWC,mBACV7hC,EACA,EACA2hC,EACA,EACA77G,GAGD,MAAMg8G,EAAcF,EAAW9tF,SAC/Bw8E,EAAOkD,MAAMC,OAAQ,CAAEqO,UAEjBH,EAAcnK,SAAUC,WAAWC,MAEzC,MAAMh7H,EAAcilI,EAAchK,iBAE5B31B,EAAY,IAAIvqG,EAAU6C,MAAM1F,YAAa8H,EAAY5F,MAAO,IAItE,OAFA6qI,EAAcZ,QAEP/+B,EAAU5kG,MAElB,CAEA,gBAAAqkI,CAAkB9tE,GAEjB,MAAM,SAAEjvC,EAAQ,WAAEosC,GAAe6C,EAC3BouE,EAAYpuE,EAAkBr5D,MAAM1F,YACpCq9D,EAAgB0B,EAAkB/+D,YAExC,IAAI6N,EAEJ,GAAkB,IAAbiiB,EAEJjiB,EAASi+H,GAA2C9qI,IAAKmsI,OAEnD,CAEN,MACMjlC,GADgB2jC,GAAmC7qI,IAAKq8D,IAAmBuuE,GAAgC5qI,IAAKmsI,IACxFjxE,EAAa,EAAI,GAE/C,GAAKgsC,EAAS,CAEb,MAAMklC,EAAeD,EAAUrpC,kBAAoBh0E,EAE7Cu9G,EAD8D,EAAzCloI,KAAKshB,OAAS2mH,EAAe,GAAM,GAClBD,EAAUrpC,kBAEtD,GAAKupC,EAAiB,EAErB,MAAM,IAAI95H,MAAO,4DAIlB1F,EAAS,GAAGq6F,KAAUmlC,GAEvB,CAED,CAQA,OANOx/H,GAENlB,QAAQkiB,MAAO,gEAIThhB,CAER,CAEA,aAAAw+H,CAAe3mI,GAEd,OAAO6B,YAAY+lI,OAAQ5nI,MAAeA,aAAiB6nI,SAE5D,CAEA,mBAAAxvE,CAAqBl7D,GAIpB,OAFKA,EAAUk4D,+BAA+Bl4D,EAAYA,EAAU9B,MAE7D8B,CAER,EAID,MAAM2qI,GAEL,WAAAxtI,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,EACft9D,KAAKutI,qBAAuB,IAAIrtI,OAEjC,CAEA,oBAAAstI,CAAsB5qE,GAErB,MAAMtF,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAEjBuC,EAAU,GAEhB,IAAIz8H,EAAQ,EAEZ,IAAM,MAAM4hE,KAAWN,EAAUhG,SAAW,CAE3C,MAAM6wE,EAAa,CAClBvqE,QAAS5hE,IACTiiG,WAAYrgC,EAAQqgC,YAGrB,GAAKrgC,EAAQU,iBAAmBV,EAAQG,gBAAkB,CAEzD,MAAM/6D,EAAS,CAAC,EAEX46D,EAAQG,kBAEc,EAArBH,EAAQqgC,aAIPrgC,EAAQ0iC,SAAW78F,EAAWG,YAAcg6D,EAAQ0iC,SAAW78F,EAAWE,YAE9EX,EAAOf,KAAOsyH,GAUfvxH,EAAOf,KAAOsyH,IAMhB4T,EAAWnlI,OAASA,CAErB,MAAO,GAAK46D,EAAQY,UAAY,CAE/B,MAAMtvC,EAAU,CAAC,EAEZ0uC,EAAQpvC,QAAQe,gBAEqB,OAApCquC,EAAQpvC,QAAQmlD,kBAEpBzkD,EAAQjtB,KAAO,cAMjBkmI,EAAWj5G,QAAUA,CAEtB,MAAO,GAAK0uC,EAAQC,kBAAoBD,EAAQpvC,QAAQ4xE,eAEvD+nC,EAAWtpE,gBAAkB,CAAC,OAExB,GAAKjB,EAAQC,kBAAoBD,EAAQqB,MAAQ,CAEvD,MAAMmpE,EAAiB,CAAC,EACxBA,EAAe//H,OAAS3N,KAAKs9D,QAAQx8D,IAAKoiE,EAAQpvC,SAAUA,QAAQnmB,OAEpE,MAAMi4F,EAAS1iC,EAAQ0iC,OAItB8nC,EAAe9nC,OAFXA,IAAW78F,EAAWG,WAEF4wH,GAEbl0B,IAAW78F,EAAWE,WAET6wH,GAIAA,GAIzB2T,EAAWC,eAAiBA,CAE7B,MAAO,GAAKxqE,EAAQC,iBAAmB,CAEtC,MAAMrvC,EAAU,CAAC,GAEX,eAAE6sG,GAAmBrjE,EAAQ0vC,MAAM6zB,qBAAsB39D,EAAQpvC,SAcvE,GAZK6sG,EAAiB,IAErB7sG,EAAQm2G,cAAe,EAEhB/mE,EAAQpvC,QAAQe,iBAEtBf,EAAQ65G,WAAa5T,KAMlB72D,EAAQpvC,QAAQe,eAEpBf,EAAQ65G,WAAa5T,QAEf,GAAK72D,EAAQpvC,QAAQi4D,eAAiB7oB,EAAQpvC,QAAQu0E,oBAAsBnlC,EAAQpvC,QAAQkoF,gBAAkB,CAEpH,MAAMz0G,EAAO27D,EAAQpvC,QAAQvsB,KAExBA,IAAS,MAEbusB,EAAQ65G,WAAa5T,GAEVxyH,IAAS,MAEpBusB,EAAQ65G,WAAa5T,GAEVxyH,IAAS,QAEfvH,KAAKs9D,QAAQ4jC,WAAY,sBAE7BptE,EAAQ65G,WAAa5T,GAIrBjmG,EAAQ65G,WAAa5T,GAMxB,CAEK72D,EAAQ4iC,qBAEZhyE,EAAQ85G,cAAgB3T,GAEb/2D,EAAQpvC,QAAQu0E,oBAAsBnlC,EAAQpvC,QAAQw0E,yBAEjEx0E,EAAQ85G,cAAgB3T,GAEb/2D,EAAQ8iC,qBAEnBlyE,EAAQ85G,cAAgB3T,IAIzBwT,EAAW35G,QAAUA,CAEtB,MAECrnB,QAAQkiB,MAAO,4CAA6Cu0C,OAI7D66D,EAAQj4H,KAAM2nI,EAEf,CAEA,OAAOjS,EAAOqS,sBAAuB,CAAE9P,WAExC,CAEA,cAAA1jE,CAAgBuI,EAAWhG,EAAU6G,EAAYliE,EAAU,GAE1D,MAAM,QAAE+7D,EAAO,qBAAEiwE,GAAyBvtI,KACpC8tI,EAAexwE,EAAQx8D,IAAK8hE,GAIlC,IASImrE,EATAC,EAAgBT,EAAqBzsI,IAAK8hE,EAAUkd,wBAEjC/+E,IAAlBitI,IAEJA,EAAgBhuI,KAAKwtI,qBAAsB5qE,GAC3C2qE,EAAqB/qI,IAAKogE,EAAUkd,kBAAmBkuD,IAMnDvqE,EAAa,SAEY1iE,IAAxB+sI,EAAaxiD,SAEjBwiD,EAAaxiD,OAAS,GACtBwiD,EAAaG,SAAW,IAIpBH,EAAaG,SAAUxqE,KAAiBliE,IAE5CwsI,EAAeD,EAAaxiD,OAAQ7nB,UAMhB1iE,IAAjBgtI,IAEJA,EAAe/tI,KAAK89H,gBAAiBl7D,EAAWorE,GAE3CvqE,EAAa,IAEjBqqE,EAAaxiD,OAAQ7nB,GAAesqE,EACpCD,EAAaG,SAAUxqE,GAAeliE,IAMxCusI,EAAa1yH,MAAQ2yH,EACrBD,EAAah4H,OAASk4H,CAEvB,CAEA,aAAAnqE,CAAeX,GAEd,MAAM5F,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAEjBlzH,EAAS46D,EAAQ56D,OACjB4iG,EAAY5tC,EAAQx8D,IAAKoiE,GAAU56D,OAEzCkzH,EAAOkD,MAAM/xB,YAAazB,EAAW,EAAG5iG,EAAQ,EAEjD,CAEA,eAAAw1H,CAAiBl7D,EAAWsrE,GAE3B,MAAM5wE,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAEvB,IAAI2S,EAAe,EACnB,MAAMC,EAAa,GAEnB,IAAM,MAAMlrE,KAAWN,EAAUhG,SAAW,CAE3C,GAAKsG,EAAQU,gBAAkB,CAE9B,MAAMovD,EAAc11D,EAAQx8D,IAAKoiE,GAEjC,QAA4BniE,IAAvBiyH,EAAY1qH,OAAuB,CAEvC,MAAMw7F,EAAa5gC,EAAQ4gC,WAErB30E,EAAQmzG,eAAe+L,QAAU/L,eAAexB,SAEhD51B,EAAYswB,EAAO5uB,aAAc,CACtC1xF,MAAO,iBAAmBgoD,EAAQxgE,KAClCsuB,KAAM8yE,EACN30E,MAAOA,IAGR6jG,EAAY1qH,OAAS4iG,CAEtB,CAEAkjC,EAAWtoI,KAAM,CAAEo9D,QAASirE,EAAcnQ,SAAU,CAAE11H,OAAQ0qH,EAAY1qH,SAE3E,MAAO,GAAK46D,EAAQG,gBAAkB,CAErC,MAAM2vD,EAAc11D,EAAQx8D,IAAKoiE,GAEjC,QAA4BniE,IAAvBiyH,EAAY1qH,OAAuB,CAEvC,MAAM3F,EAAYugE,EAAQvgE,UAK1BqwH,EAAY1qH,OAASg1D,EAAQx8D,IAAK6B,GAAY2F,MAE/C,CAEA8lI,EAAWtoI,KAAM,CAAEo9D,QAASirE,EAAcnQ,SAAU,CAAE11H,OAAQ0qH,EAAY1qH,SAE3E,MAAO,GAAK46D,EAAQY,UAAY,CAE/B,MAAMs9C,EAAa9jD,EAAQx8D,IAAKoiE,EAAQpvC,SAExCs6G,EAAWtoI,KAAM,CAAEo9D,QAASirE,EAAcnQ,SAAU5c,EAAW5sF,SAEhE,MAAO,GAAK0uC,EAAQC,iBAAmB,CAEtC,MAAMe,EAAc5G,EAAQx8D,IAAKoiE,EAAQpvC,SAEzC,IAAIw6G,EAEJ,QAAqCvtI,IAAhCmjE,EAAYC,gBAEhBmqE,EAAc9S,EAAO+S,sBAAuB,CAAElwH,OAAQ6lD,EAAYC,sBAE5D,CAEN,MAAMkF,EAAgBnG,EAAQqB,MAAQ,EAAIL,EAAYpwC,QAAQu1C,cACxDt5D,EAAe,QAASm0D,EAAYpwC,QAAQ3xB,SAAW+hE,EAAYpwC,QAAQ1xB,UAAYinE,IAI7F,GAFAilE,EAAcpqE,EAAan0D,QAENhP,IAAhButI,EAA4B,CAEhC,MAAME,EAAYtU,GAElB,IAAIuU,EAIHA,EAFIvrE,EAAQ4iC,qBAEOm0B,GAER/2D,EAAQ8iC,mBAEAi0B,GAER/2D,EAAQpvC,QAAQu0E,oBAAsBnlC,EAAQpvC,QAAQw0E,yBAE9C2xB,GAIAA,GAIpBqU,EAAcpqE,EAAan0D,GAAiBm0D,EAAYpwC,QAAQqpG,WAAY,CAAEuR,OAAQF,EAAWnR,UAAWoR,EAAkBplE,iBAE/H,CAED,CAEA+kE,EAAWtoI,KAAM,CAAEo9D,QAASirE,EAAcnQ,SAAUsQ,GAErD,CAEAH,GAED,CAEA,OAAO3S,EAAOsC,gBAAiB,CAC9B5iH,MAAO,aAAe0nD,EAAUlgE,KAChCoT,OAAQo4H,EACRnQ,QAASqQ,GAGX,EAID,MAAMO,GAEL,WAAA7uI,CAAaw9D,GAEZt9D,KAAKs9D,QAAUA,CAEhB,CAEA,eAAAsxE,CAAiBC,GAEhB,OAAO7uI,KAAKs9D,QAAQ0vC,MAAMw+B,4BAA6BqD,EAExD,CAEA,oBAAAtsE,CAAsB7hE,EAAcohE,GAEnC,MAAM,OAAExhE,EAAM,SAAEW,EAAQ,SAAED,EAAQ,SAAE+3D,GAAar4D,GAC3C,cAAE2/D,EAAa,gBAAEC,GAAoBvH,EAErCuE,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OACjBxuB,EAAQ1vC,EAAQ0vC,MAEhBwjB,EAAelzD,EAAQx8D,IAAKi4D,GAI5B+1E,EAAmB,GAEzB,IAAM,MAAMlsE,KAAaliE,EAAa05D,cAAgB,CAErD,MAAM0zE,EAAexwE,EAAQx8D,IAAK8hE,GAElCksE,EAAiBhpI,KAAMgoI,EAAah4H,OAErC,CAIA,MAAMkjD,EAAgBsE,EAAQ4qD,eAAeokB,0BAA2B5rI,GAIxE,IAAI65C,GAE0B,IAAzBt5C,EAASq5C,aAAwBr5C,EAASs5C,WAAa,QAE3DA,EAAWv6C,KAAK+uI,aAAc9tI,IAM/B,IAAI+tI,EAAe,CAAC,GAEW,IAA1B/tI,EAASkzG,eAEb66B,EAAe,CACd93G,QAASl3B,KAAKivI,mBAAoBhuI,GAClCiuI,OAAQlvI,KAAKmvI,qBAAsBluI,EAAS2yG,aAC5Cw7B,YAAapvI,KAAKmvI,qBAAsBluI,EAAS4yG,cACjDw7B,OAAQrvI,KAAKmvI,qBAAsBluI,EAAS6yG,gBAK9C,MAAMw7B,EAAiBtvI,KAAKuvI,mBAAoBtuI,GAE1Cm7H,EAAU,GAEhB,GAAuC,OAAlC17H,EAAa2B,QAAQqM,SAAoB,CAE7C,MAAMA,EAAWhO,EAAa2B,QAAQqM,SAEtC,IAAM,IAAIrK,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAE5C,MAAMmrI,EAAcxiC,EAAMq+B,oBAAqB38H,EAAUrK,IAEzD+3H,EAAQt2H,KAAM,CACb6H,OAAQ6hI,EACRC,MAAOl1F,EACPm1F,UAAWJ,GAGb,CAED,KAAO,CAEN,MAAME,EAAcxiC,EAAMwzB,sBAAuB9/H,EAAa2B,SAE9D+5H,EAAQt2H,KAAM,CACb6H,OAAQ6hI,EACRC,MAAOl1F,EACPm1F,UAAWJ,GAGb,CAEA,MAAMK,EAAeryE,EAAQx8D,IAAKu/D,GAAgB67D,OAC5C0T,EAAiBtyE,EAAQx8D,IAAKw/D,GAAkB47D,OAEhD2T,EAAiB7vI,KAAK8vI,mBAAoBxvI,EAAQU,EAAUC,GAC5D40E,EAAe71E,KAAK+vI,iBAAkB9uI,GACtC+uI,EAAqBhjC,EAAMo+B,6BAA8B1qI,EAAa2B,SAEtEklE,EAAcvnE,KAAK4uI,gBAAiBluI,EAAa2B,SAEjD4tI,EAAqB,CAC1B/0H,MAAO,kBAAmBja,EAASyB,MAAQzB,EAASsG,QAAUtG,EAASmC,KACvEy2C,OAAQh2C,OAAOsQ,OAAQ,CAAC,EAAGw7H,EAAc,CAAE1kC,QAASjyC,IACpDkI,SAAUr9D,OAAOsQ,OAAQ,CAAC,EAAGy7H,EAAgB,CAAExT,YAC/CC,UAAWwT,EACXK,YAAa,CACZxuI,MAAO6lE,EACP4oE,uBAAwBlvI,EAASw4C,iBAAmB8tB,EAAc,GAEnEzxD,OAAQ0lH,EAAO4U,qBAAsB,CACpCtB,sBAKIuB,EAAe,CAAC,EAChBC,EAAc5vI,EAAa2B,QAAQi1B,MACnCi5G,EAAgB7vI,EAAa2B,QAAQ0kE,QA0B3C,IAxBqB,IAAhBupE,IAA0C,IAAlBC,KAEP,IAAhBD,IAEJD,EAAa1iI,OAASqiI,EACtBK,EAAaG,kBAAoBvvI,EAAS03C,WAC1C03F,EAAax6D,aAAeA,IAIN,IAAlB06D,IAEJF,EAAarB,aAAeA,EAC5BqB,EAAaI,YAAc,CAAC,EAC5BJ,EAAaK,gBAAkBzvI,EAASozG,gBACxCg8B,EAAaj8B,iBAAmBnzG,EAASmzG,kBAI1C67B,EAAmBI,aAAeA,GAKjB,OAAbvuE,EAEJ0uD,EAAaz3D,SAAWyiE,EAAOj5D,qBAAsB0tE,OAE/C,CAEN,MAAMl6B,EAAI,IAAIna,SAAWC,IAExB2/B,EAAOmV,0BAA2BV,GAAqBW,MAAM73E,IAE5Dy3D,EAAaz3D,SAAWA,EACxB8iC,GAAS,GAEP,IAIJ/5B,EAASh8D,KAAMiwG,EAEhB,CAED,CAEA,mBAAA86B,CAAqBj4E,GAEpB,MAAM0E,EAAUt9D,KAAKs9D,SACf,MAAE0vC,EAAK,OAAEwuB,GAAWl+D,EAEpB0yE,EAAqBhjC,EAAMo+B,6BAA8BxyE,GAIzDwD,EAAa,CAClBlhD,MAAO,sBACPikH,aAAc,CALKnyB,EAAMwzB,sBAAuB5nE,IAMhDo3E,qBACAzoE,YANmBvnE,KAAK4uI,gBAAiBh2E,IAS1C,OAAO4iE,EAAO0D,0BAA2B9iE,EAE1C,CAEA,qBAAAkG,CAAuBvJ,EAAU6D,GAEhC,MAAMU,EAAUt9D,KAAKs9D,QACfk+D,EAASl+D,EAAQk+D,OAEjBh7D,EAAiBlD,EAAQx8D,IAAKi4D,EAASyH,gBAAiB07D,OAExD4U,EAAcxzE,EAAQx8D,IAAKi4D,GAI3B+1E,EAAmB,GAEzB,IAAM,MAAM1uD,KAAiBxjB,EAAW,CAEvC,MAAMkxE,EAAexwE,EAAQx8D,IAAKs/E,GAElC0uD,EAAiBhpI,KAAMgoI,EAAah4H,OAErC,CAEAg7H,EAAY/3E,SAAWyiE,EAAOl5D,sBAAuB,CACpDpxC,QAASsvC,EACT1qD,OAAQ0lH,EAAO4U,qBAAsB,CACpCtB,sBAIH,CAEA,YAAAC,CAAc9tI,GAEb,IAAIkY,EAAO69B,EAEX,MAAMuD,EAAWt5C,EAASs5C,SACpBg3D,EAAWtwG,EAASswG,SACpBC,EAAWvwG,EAASuwG,SACpBF,EAAgBrwG,EAASqwG,cAG/B,GAAK/2D,IAAa,MAAiB,CAElC,MAAMm3D,EAA2C,OAA3BzwG,EAASywG,cAAyBzwG,EAASywG,cAAgBH,EAC3EI,EAA2C,OAA3B1wG,EAAS0wG,cAAyB1wG,EAAS0wG,cAAgBH,EAC3EC,EAAqD,OAAhCxwG,EAASwwG,mBAA8BxwG,EAASwwG,mBAAqBH,EAEhGn4F,EAAQ,CACP43H,UAAW/wI,KAAKgxI,gBAAiBz/B,GACjC0/B,UAAWjxI,KAAKgxI,gBAAiBx/B,GACjC0/B,UAAWlxI,KAAKmxI,mBAAoB7/B,IAGrCt6D,EAAQ,CACP+5F,UAAW/wI,KAAKgxI,gBAAiBt/B,GACjCu/B,UAAWjxI,KAAKgxI,gBAAiBr/B,GACjCu/B,UAAWlxI,KAAKmxI,mBAAoB1/B,GAGtC,KAAO,CAEN,MAEM2/B,EAAW,CAAEC,EAAQC,EAAQC,EAAUC,KAE5Cr4H,EAAQ,CACP43H,UAAWM,EACXJ,UAAWK,EACXJ,UAAWxX,IAGZ1iF,EAAQ,CACP+5F,UAAWQ,EACXN,UAAWO,EACXN,UAAWxX,GACX,EAIF,GAlB2Bz4H,EAAS2wG,mBAoBnC,OAASr3D,GAER,KAAK,MACJ62F,EAAU3X,GAAoBA,GAAiCA,GAAoBA,IACnF,MAED,KAAK,MACJ2X,EAAU3X,GAAoBA,GAAoBA,GAAoBA,IACtE,MAED,KAAK,MACJ2X,EAAU3X,GAAqBA,GAA4BA,GAAqBA,IAChF,MAED,KAAK,MACJ2X,EAAU3X,GAAqBA,GAAoBA,GAAqBA,SAO1E,OAASl/E,GAER,KAAK,MACJ62F,EAAU3X,GAAyBA,GAAiCA,GAAoBA,IACxF,MAED,KAAK,MACJ2X,EAAU3X,GAAyBA,GAAoBA,GAAyBA,IAChF,MAED,KAAK,MACJ2X,EAAU3X,GAAqBA,GAA4BA,GAAqBA,IAChF,MAED,KAAK,MACJ2X,EAAU3X,GAAqBA,GAAoBA,GAAqBA,IAO5E,CAEA,QAAe14H,IAAVoY,QAAiCpY,IAAVi2C,EAE3B,MAAO,CAAE79B,QAAO69B,SAIhBvqC,QAAQkiB,MAAO,2CAA4C4rB,EAI7D,CAEA,eAAAy2F,CAAiBvB,GAEhB,IAAIgC,EAEJ,OAAShC,GAER,KAAK,MACJgC,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KAAK,MACJgY,EAAchY,GACd,MAED,KA3goCsB,IA4goCrBgY,EAAchY,GACd,MAED,KA9goC8B,IA+goC7BgY,EAAchY,GACd,MAED,QACChtH,QAAQkiB,MAAO,oDAAqD8gH,GAItE,OAAOgC,CAER,CAEA,kBAAAxC,CAAoBhuI,GAEnB,IAAIywI,EAEJ,MAAMj+B,EAAcxyG,EAASwyG,YAE7B,OAASA,GAER,KAAK,MACJi+B,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,KAAK,MACJwe,EAAiBxe,GACjB,MAED,QACCzmH,QAAQkiB,MAAO,kDAAmD8kF,GAIpE,OAAOi+B,CAER,CAEA,oBAAAvC,CAAsBlwH,GAErB,IAAI0yH,EAEJ,OAAS1yH,GAER,KAAK,MACJ0yH,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,KAAK,MACJ+X,EAAmB/X,GACnB,MAED,QACCntH,QAAQkiB,MAAO,mDAAoDgjH,GAIrE,OAAOA,CAER,CAEA,kBAAAR,CAAoB7/B,GAEnB,IAAIsgC,EAEJ,OAAStgC,GAER,KAAK,MACJsgC,EAAiBlY,GACjB,MAED,KAAK,MACJkY,EAAiBlY,GACjB,MAED,KAAK,MACJkY,EAAiBlY,GACjB,MAED,KAAK,MACJkY,EAAiBlY,GACjB,MAED,KAAK,MACJkY,EAAiBlY,GACjB,MAED,QACCjtH,QAAQkiB,MAAO,2DAA4D2iF,GAI7E,OAAOsgC,CAER,CAEA,kBAAA9B,CAAoBxvI,EAAQU,EAAUC,GAErC,MAAMm7D,EAAa,CAAC,EACd4wC,EAAQhtG,KAAKs9D,QAAQ0vC,MAU3B,OARA5wC,EAAWkgE,SAAWtvB,EAAMu+B,qBAAsBjrI,EAAQW,GAElC,OAAnBD,EAASM,QAAoC,IAAlBhB,EAAOo7D,SAA6C,IAA1Bp7D,EAAOm7D,iBAEhEW,EAAWmgE,iBAAqBv7H,EAASM,MAAMkE,iBAAiBokF,YAAgB2pC,GAAwBA,IAIhGtyH,EAASk5B,MAEjB,KAAK,MACJiiC,EAAWs0C,UAAY2iB,GACvBj3D,EAAWy1E,SAAWve,GACtB,MAED,KAAK,MACJl3D,EAAWs0C,UAAY2iB,GACvBj3D,EAAWy1E,SAAWve,GACtB,MAED,KAAK,MACJl3D,EAAWs0C,UAAY2iB,GACvBj3D,EAAWy1E,SAAWve,GACtB,MAED,QACC7mH,QAAQkiB,MAAO,0DAA2D1tB,EAASk5B,MAKrF,OAAOiiC,CAER,CAEA,kBAAAmzE,CAAoBtuI,GAEnB,OAAiC,IAAxBA,EAASizG,WAAwBylB,GAAyBA,EAEpE,CAEA,gBAAAoW,CAAkB9uI,GAEjB,IAAI40E,EAEJ,IAA4B,IAAvB50E,EAAS23C,UAEbi9B,EAAeq9C,OAET,CAEN,MAAMxgB,EAAYzxG,EAASyxG,UAE3B,OAASA,GAER,KAAK,MACJ78B,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,KAAK,MACJr9C,EAAeq9C,GACf,MAED,QACCzmH,QAAQkiB,MAAO,qDAAsD+jF,GAIxE,CAEA,OAAO78B,CAER,EAgBD,MAAMi8D,WAAsBnnC,GAkB3B,WAAA7qG,CAAa2e,EAAa,CAAC,GAE1B/U,MAAO+U,GASPze,KAAKqkE,iBAAkB,EAGvBrkE,KAAKye,WAAWu4B,WAA+Bj2C,IAArB0d,EAAWu4B,OAA+Bv4B,EAAWu4B,MAE/Eh3C,KAAKye,WAAWszH,oBAAiDhxI,IAA9B0d,EAAWszH,eAAiC,CAAC,EAAItzH,EAAWszH,eAQ/F/xI,KAAK0oH,gBAAiD,IAA9BjqG,EAAWiqG,eAQnC1oH,KAAKw7H,OAAS,KAQdx7H,KAAKqC,QAAU,KAQfrC,KAAK4/H,YAAc,KAQnB5/H,KAAKgyI,4BAA8B,KAOnChyI,KAAKgtG,MAAQ,IAAIm+B,GAAanrI,MAQ9BA,KAAKkoH,eAAiB,IAAI2jB,GAAsB7rI,MAQhDA,KAAKiyI,aAAe,IAAI3E,GAAoBttI,MAQ5CA,KAAKkyI,cAAgB,IAAIvD,GAAqB3uI,MAQ9CA,KAAKooH,aAAe,IAAIoX,GAAoBx/H,MAO5CA,KAAKmyI,qBAAuB,IAAIzrI,GAEjC,CASA,UAAMw+E,CAAMpiF,SAEL4G,MAAMw7E,KAAMpiF,GAIlB,MAAM2b,EAAaze,KAAKye,WAIxB,IAAI+8G,EAEJ,QAA2Bz6H,IAAtB0d,EAAW+8G,OAAuB,CAEtC,MAAM4W,EAAiB,CACtBC,gBAAiB5zH,EAAW4zH,iBAGvBC,EAAiC,oBAAdjM,gBAAoCA,UAAUoF,IAAI8G,eAAgBH,GAAmB,KAE9G,GAAiB,OAAZE,EAEJ,MAAM,IAAIj/H,MAAO,mDAMlB,MAAM6wH,EAAWrgI,OAAOgC,OAAQu0H,IAE1BoY,EAAoB,GAE1B,IAAM,MAAM9vI,KAAQwhI,EAEdoO,EAAQpO,SAASvjI,IAAK+B,IAE1B8vI,EAAkB1sI,KAAMpD,GAM1B,MAAM+vI,EAAmB,CACxBC,iBAAkBF,EAClBT,eAAgBtzH,EAAWszH,gBAG5BvW,QAAe8W,EAAQK,cAAeF,EAEvC,MAECjX,EAAS/8G,EAAW+8G,OAIrBA,EAAOoX,KAAKhC,MAAQh5E,IAEnB,MAAMi7E,EAAiB,CACtBz1C,IAAK,SACLC,QAASzlC,EAAKylC,SAAW,iBACzBC,OAAQ1lC,EAAK0lC,QAAU,KACvB6rB,cAAevxD,GAGhB90D,EAASk4F,aAAc63C,EAAgB,IAIxC,MAAMxwI,OAAmCtB,IAAvB0d,EAAWpc,QAA0Boc,EAAWpc,QAAUS,EAASq2F,WAAW/tE,WAAY,UAE5GprB,KAAKw7H,OAASA,EACdx7H,KAAKqC,QAAUA,EAEf,MAAMywI,EAAYr0H,EAAWu4B,MAAQ,gBAAkB,SAEvDh3C,KAAK0oH,eAAiB1oH,KAAK0oH,gBAAkB1oH,KAAKkhG,WAAYk5B,GAAeK,gBAE7Ez6H,KAAKqC,QAAQ0wI,UAAW,CACvBvX,OAAQx7H,KAAKw7H,OACb7tH,OAAQ3N,KAAKgtG,MAAMyzB,2BACnBtxG,MAAO4tG,gBAAgBC,kBAAoBD,gBAAgBgE,SAC3D+R,UAAWA,IAGZ9yI,KAAKs/F,YAEN,CAQA,oBAAI58E,GAEH,OAAO,KAER,CAUA,yBAAMy8E,CAAqBx8F,GAE1B,aAAa3C,KAAKkoH,eAAe/oB,oBAAqBx8F,EAEvD,CAOA,UAAAyoB,GAEC,OAAOprB,KAAKqC,OAEb,CAYA,+BAAA2wI,GAEC,IAAI52E,EAAap8D,KAAKgyI,4BAEtB,GAAoB,OAAf51E,EAAsB,CAE1B,MAAMt5D,EAAW9C,KAAK8C,SAEtBs5D,EAAa,CACZ+hE,iBAAkB,CAAE,CACnBC,KAAM,SAIqB,IAAxBp+H,KAAK8C,SAASw0B,QAA4C,IAA1Bt3B,KAAK8C,SAASikE,UAElD3K,EAAW62E,uBAAyB,CACnC7U,KAAMp+H,KAAKooH,aAAayZ,eAAgB/+H,EAASw0B,MAAOx0B,EAASikE,SAAUo2D,eAK7E,MAAM+V,EAAkB92E,EAAW+hE,iBAAkB,GAEhDn+H,KAAK8C,SAAS02C,QAAU,EAE5B05F,EAAgB9U,KAAOp+H,KAAK4/H,YAAYzC,aAIxC+V,EAAgBC,mBAAgBpyI,EAIjCf,KAAKgyI,4BAA8B51E,CAEpC,CAEA,MAAM82E,EAAkB92E,EAAW+hE,iBAAkB,GAYrD,OAVKn+H,KAAK8C,SAAS02C,QAAU,EAE5B05F,EAAgBC,cAAgBnzI,KAAKqC,QAAQ+wI,oBAAoBjW,aAIjE+V,EAAgB9U,KAAOp+H,KAAKqC,QAAQ+wI,oBAAoBjW,aAIlD/gE,CAER,CAUA,wBAAAi3E,CAA0Bz6E,EAAe06E,EAAyB,CAAC,GAElE,MAAMnhG,EAAeymB,EAAczmB,aAC7B+1B,EAAmBloE,KAAKc,IAAKqxC,GAEnC,IAAIuJ,EAAcwsB,EAAiBxsB,YAEnC,QAAqB36C,IAAhB26C,GACJwsB,EAAiB/lE,QAAUgwC,EAAahwC,OACxC+lE,EAAiB9lE,SAAW+vC,EAAa/vC,QACzC8lE,EAAiBqrE,aAAephG,EAAaohG,YAC7CrrE,EAAiBD,oBAAsB91B,EAAa81B,mBACpDC,EAAiBZ,iBAAmB1O,EAAc0O,gBAClDY,EAAiB1uB,UAAYrH,EAAaqH,SAC1C0uB,EAAiBm2D,SAAWiV,EAAuBjV,OAClD,CAED3iF,EAAc,CAAC,EAEfwsB,EAAiBxsB,YAAcA,EAI/B,MAAMge,EAAY,KAEjBvnB,EAAalC,oBAAqB,UAAWypB,GAE7C15D,KAAKgwC,OAAQmC,EAAc,EAI5BA,EAAajC,iBAAkB,UAAWwpB,EAE3C,CAEA,MAAMP,EAAWP,EAAc1yD,cAE/B,IAAIk2D,EAAa1gB,EAAayd,GAE9B,QAAoBp4D,IAAfq7D,EAA2B,CAE/B,MAAM1tD,EAAWkqD,EAAclqD,SACzByvH,EAAmB,GAEzB,IAAIqV,EAEJ,IAAM,IAAInvI,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAE5C,MAAM6/D,EAAclkE,KAAKc,IAAK4N,EAAUrK,IAElCovI,EAAiB,CACtBv4H,MAAO,mBAAoB7W,IAC3B+4H,aAAcxkE,EAAcqP,kBAC5BoB,cAAe,EACfqzD,eAAgB9jE,EAAc0O,eAC9BygE,gBAAiB,EACjB1K,UAAWpD,IAGP9nF,EAAau/E,kBAEjB8hB,EAAa56E,EAAc0O,eAE3BmsE,EAAe/W,eAAiB,EAChC+W,EAAepW,UAAYpD,GAC3BwZ,EAAe3W,mBAAqBpuH,EAAUrK,GAAI0vB,MAAMuD,OAE7C6a,EAAaw/E,sBAExB8hB,EAAepW,UAAYpD,GAC3BwZ,EAAe3W,mBAAqBpuH,EAAUrK,GAAI0vB,MAAMuD,OAIzD,MAAMo8G,EAAcxvE,EAAYpwC,QAAQqpG,WAAYsW,GAEpD,IAAIrV,EAAM+U,OAEuBpyI,IAA5BmjE,EAAYu9D,aAEhBrD,EAAOl6D,EAAYu9D,YAAYtE,aAC/BgW,EAAgBO,IAIhBtV,EAAOsV,EACPP,OAAgBpyI,GAIjBo9H,EAAiBr4H,KAAM,CACtBs4H,OACAuV,WAAYH,EACZL,gBACA9U,OAAQjL,GACRkL,QAASnL,MACNmgB,GAGL,CAOA,GAJAl3E,EAAa,CACZ+hE,oBAGIvlE,EAActhC,MAAQ,CAE1B,MAEM27G,EAAyB,CAC9B7U,KAHwBp+H,KAAKc,IAAK83D,EAAcyO,cAGzBvzC,QAAQqpG,cAEhC/gE,EAAW62E,uBAAyBA,CAErC,CAEAv3F,EAAayd,GAAaiD,EAE1B8L,EAAiB/lE,MAAQgwC,EAAahwC,MACtC+lE,EAAiB9lE,OAAS+vC,EAAa/vC,OACvC8lE,EAAiB1uB,QAAUrH,EAAaqH,QACxC0uB,EAAiBD,kBAAoBrP,EAAcqP,kBACnDC,EAAiBZ,eAAiB1O,EAAc0O,eAChDY,EAAiBqrE,WAAaphG,EAAaohG,WAC3CrrE,EAAiByrE,WAAaH,EAC9BtrE,EAAiBm2D,OAASF,EAAkB,GAAIE,MAEjD,CAEA,OAAOjiE,CAER,CAQA,WAAAyiC,CAAajmC,GAEZ,MAAM4pD,EAAoBxiH,KAAKc,IAAK83D,GAE9B4iE,EAASx7H,KAAKw7H,OACd/1D,EAAsB7M,EAAc6M,oBAE1C,IAAImuE,EAyBAx3E,EAvBCqJ,EAAsB,IAErB+8C,EAAkBqxB,0BAA2BrxB,EAAkBqxB,yBAAyBjV,UACxFpc,EAAkBsxB,6BAA8BtxB,EAAkBsxB,4BAA4BlV,UAInGpc,EAAkBqxB,yBAA2BrxB,EAAkBoxB,kBAC/DpxB,EAAkBsxB,4BAA8BtxB,EAAkBuxB,qBAClEvxB,EAAkBsI,6BAA+BtI,EAAkBuI,sBAInE6oB,EAAoBpY,EAAOwY,eAAgB,CAAEzsI,KAAM,YAAa7F,MAAO+jE,EAAqBvqD,MAAO,qBAAsB09C,EAAcx1D,OAEvIo/G,EAAkBoxB,kBAAoBA,EACtCpxB,EAAkByI,oBAAsB,EACxCzI,EAAkBuI,sBAAwB,IAAIhmH,MAAO0gE,GAErD+8C,EAAkBwI,oBAAsB,MAQxC5uD,EAF+B,OAA3BxD,EAAclqD,SAEL1O,KAAKgzI,kCAILhzI,KAAKqzI,yBAA0Bz6E,EAAe,CAAEylE,OAAQjL,KAItEpzH,KAAKqpH,mBAAoBzwD,EAAewD,GAExCA,EAAWw3E,kBAAoBA,EAE/B,MAAMX,EAAyB72E,EAAW62E,uBAE1C,GAAgC,OAA3Br6E,EAAclqD,SAAoB,CAEtC,MAAMyvH,EAAmB/hE,EAAW+hE,iBAEpC,IAAM,IAAI95H,EAAI,EAAGA,EAAI85H,EAAiBn6H,OAAQK,IAAO,CAEpD,MAAM6uI,EAAkB/U,EAAkB95H,GAErCu0D,EAAc+N,YAElBusE,EAAgB3U,WAAmB,IAANl6H,EAAUu0D,EAAcgO,gBAAkB,CAAE9pC,EAAG,EAAGC,EAAG,EAAGjd,EAAG,EAAGD,EAAG,GAC9FqzH,EAAgB7U,OAASjL,GACzB8f,EAAgB5U,QAAUnL,KAI1B+f,EAAgB7U,OAASjL,GACzB8f,EAAgB5U,QAAUnL,GAI5B,CAED,KAAO,CAEN,MAAM+f,EAAkB92E,EAAW+hE,iBAAkB,GAEhDvlE,EAAc+N,YAElBusE,EAAgB3U,WAAa3lE,EAAcgO,gBAC3CssE,EAAgB7U,OAASjL,GACzB8f,EAAgB5U,QAAUnL,KAI1B+f,EAAgB7U,OAASjL,GACzB8f,EAAgB5U,QAAUnL,GAI5B,CAIKv6D,EAActhC,QAEbshC,EAAciO,YAElBosE,EAAuB5zD,gBAAkBzmB,EAAckO,gBACvDmsE,EAAuBgB,YAAc7gB,GACrC6f,EAAuBiB,aAAe/gB,KAItC8f,EAAuBgB,YAAc7gB,GACrC6f,EAAuBiB,aAAe/gB,KAMnCv6D,EAAcmO,UAEbnO,EAAcoO,cAElBisE,EAAuB1zD,kBAAoB3mB,EAAcqO,kBACzDgsE,EAAuBkB,cAAgB/gB,GACvC6f,EAAuBmB,eAAiBjhB,KAIxC8f,EAAuBkB,cAAgB/gB,GACvC6f,EAAuBmB,eAAiBjhB,KAQ1C,MAAMqP,EAAUhH,EAAOgC,qBAAsB,CAAEtiH,MAAO,iBAAmB09C,EAAcx1D,KACjFixI,EAAc7R,EAAQtE,gBAAiB9hE,GAkB7C,GAdAomD,EAAkBpmD,WAAaA,EAC/BomD,EAAkBggB,QAAUA,EAC5BhgB,EAAkB6xB,YAAcA,EAChC7xB,EAAkB8xB,YAAc,CAAEnzI,WAAY,CAAC,EAAGozI,cAAe,GAAIx7E,SAAU,KAAMz3D,MAAO,MAC5FkhH,EAAkB4c,cAAgB,GAI7BxmE,EAAcvmB,UAElBryC,KAAKgjG,eAAgBpqC,GAIjBA,EAAcuO,QAAU,CAE5B,MAAM,EAAEv9C,EAAC,EAAEE,EAAC,MAAE3nB,EAAK,OAAEC,GAAWw2D,EAAcwO,aAE9CitE,EAAYG,eAAgB5qH,EAAGE,EAAG3nB,EAAOC,EAE1C,CAED,CAQA,YAAA28F,CAAcnmC,GAEb,MAAM4pD,EAAoBxiH,KAAKc,IAAK83D,GAC9B6M,EAAsB7M,EAAc6M,oBAgB1C,GAdK+8C,EAAkB4c,cAAcp7H,OAAS,GAE7Cw+G,EAAkB6xB,YAAYhV,eAAgB7c,EAAkB4c,eAI5D35D,EAAsB+8C,EAAkByI,qBAE5CzI,EAAkB6xB,YAAYI,oBAI/BjyB,EAAkB6xB,YAAY/mG,MAEzBm4B,EAAsB,EAAI,CAE9B,MAAMivE,EAAmC,EAAtBjvE,EAInB,IAAIkvE,EAAqB30I,KAAKmyI,qBAAqBrxI,IAAK4zI,QAE5B3zI,IAAvB4zI,IAEJA,EAAqB30I,KAAKw7H,OAAO5uB,aAChC,CACC57E,KAAM0jH,EACNvlH,MAAOmzG,eAAesS,cAAgBtS,eAAevB,WAIvD/gI,KAAKmyI,qBAAqB3vI,IAAKkyI,EAAYC,IAM5C,MAAMtS,EAAariI,KAAKw7H,OAAO5uB,aAC9B,CACC57E,KAAM0jH,EACNvlH,MAAOmzG,eAAexB,SAAWwB,eAAeC,WAKlD/f,EAAkBggB,QAAQqS,gBAAiBryB,EAAkBoxB,kBAAmB,EAAGnuE,EAAqBkvE,EAAoB,GAC5HnyB,EAAkBggB,QAAQuK,mBAAoB4H,EAAoB,EAAGtS,EAAY,EAAGqS,GAEpFlyB,EAAkBuxB,qBAAuB1R,EAIzCriI,KAAKmrH,qBAAsBvyD,EAE5B,CASA,GAPA54D,KAAK6pH,uBAAwBjxD,EAAe4pD,EAAkBggB,SAE9DxiI,KAAKw7H,OAAOkD,MAAMC,OAAQ,CAAEnc,EAAkBggB,QAAQxjF,WAKtB,OAA3B4Z,EAAclqD,SAAoB,CAEtC,MAAMA,EAAWkqD,EAAclqD,SAE/B,IAAM,IAAIrK,EAAI,EAAGA,EAAIqK,EAAS1K,OAAQK,IAAO,CAE5C,MAAMyvB,EAAUplB,EAAUrK,IAEO,IAA5ByvB,EAAQwf,iBAEZtzC,KAAKooH,aAAa90E,gBAAiBxf,EAIrC,CAED,CAED,CAUA,UAAAqsE,CAAYvnC,EAAet4D,GAE1B,MAAMkiH,EAAoBxiH,KAAKc,IAAK83D,GAEpC,OAAO4pD,EAAkBgJ,UAAYhJ,EAAkBgJ,SAAS7qH,IAAKL,EAEtE,CASA,0BAAM6qH,CAAsBvyD,GAE3B,MAAM4pD,EAAoBxiH,KAAKc,IAAK83D,IAI9B,4BAAEk7E,EAA2B,6BAAEhpB,GAAiCtI,EAEtE,GAAKsxB,GAA+BhpB,EAA+B,CAElE,MAAMU,EAAW,IAAI3C,QAErBrG,EAAkBsI,6BAA+B,KACjDtI,EAAkBsxB,4BAA8B,WAE1CA,EAA4BpR,SAAUC,WAAWC,MAEvD,MAAMt6H,EAASwrI,EAA4BjR,iBACrCiS,EAAU,IAAIC,eAAgBzsI,GAEpC,IAAM,IAAIjE,EAAI,EAAGA,EAAIymH,EAA6B9mH,OAAQK,IAEpDywI,EAASzwI,KAAQ2wI,OAAQ,IAE7BxpB,EAASp3G,IAAK02G,EAA8BzmH,IAM9CyvI,EAA4BlV,UAE5Bpc,EAAkBgJ,SAAWA,CAE9B,CAED,CAOA,cAAAxoB,CAAgBpqC,GAEf,MAAM,YAAEy7E,GAAgBr0I,KAAKc,IAAK83D,IAC5B,EAAEhvC,EAAC,EAAEE,EAAC,MAAE3nB,EAAK,OAAEC,EAAM,SAAEq8F,EAAQ,SAAEC,GAAa9lC,EAAcsO,cAElEmtE,EAAYh1C,YAAaz1E,EAAGE,EAAG3nB,EAAOC,EAAQq8F,EAAUC,EAEzD,CAUA,KAAAphB,CAAOnkE,EAAOme,EAAOyvC,EAASkuE,EAAsB,MAEnD,MAAMzZ,EAASx7H,KAAKw7H,OACd14H,EAAW9C,KAAK8C,SAEtB,IAEImwI,EACA1U,EAEA2W,EACAC,EANAhX,EAAmB,GAQvB,GAAKhlH,EAAQ,CAEZ,MAAMwtD,EAAa3mE,KAAK+zE,gBAExB,IAA6B,IAAxB/zE,KAAK8C,SAASk0C,MAAiB,CAInC,MAAMn3B,EAAI8mD,EAAW9mD,EAErB0+G,EAAa,CAAEzhG,EAAG6pC,EAAW7pC,EAAIjd,EAAGkd,EAAG4pC,EAAW5pC,EAAIld,EAAGC,EAAG6mD,EAAW7mD,EAAID,EAAGA,EAAGA,EAElF,MAEC0+G,EAAa,CAAEzhG,EAAG6pC,EAAW7pC,EAAGC,EAAG4pC,EAAW5pC,EAAGjd,EAAG6mD,EAAW7mD,EAAGD,EAAG8mD,EAAW9mD,EAIlF,CAEA,GAA6B,OAAxBo1H,EAA+B,CAEnCC,EAAgBpyI,EAASw0B,MACzB69G,EAAkBryI,EAASikE,QAE3B,MAAM3K,EAAap8D,KAAKgzI,kCAExB,GAAK75H,EAAQ,CAEZglH,EAAmB/hE,EAAW+hE,iBAE9B,MAAM+U,EAAkB/U,EAAkB,GAE1C+U,EAAgB3U,WAAaA,EAC7B2U,EAAgB7U,OAASjL,GACzB8f,EAAgB5U,QAAUnL,EAE3B,EAEK+hB,GAAiBC,KAErBlC,EAAyB72E,EAAW62E,uBAItC,KAAO,CAKN,GAHAiC,EAAgBD,EAAoB39G,MACpC69G,EAAkBF,EAAoBluE,QAEjC5tD,EAAQ,CAIZglH,EAFmBn+H,KAAKqzI,yBAA0B4B,EAAqB,CAAE5W,OAAQjL,KAEnD+K,gBAE/B,CAEA,GAAK+W,GAAiBC,EAAkB,CAIvClC,EAAyB,CACxB7U,KAHwBp+H,KAAKc,IAAKm0I,EAAoB5tE,cAG/BvzC,QAAQqpG,aAGjC,CAED,CAIK+X,IAEC59G,GAEJ27G,EAAuBgB,YAAc7gB,GACrC6f,EAAuB5zD,gBAAkBv8E,EAASi9F,gBAClDkzC,EAAuBiB,aAAe/gB,KAItC8f,EAAuBgB,YAAc7gB,GACrC6f,EAAuBiB,aAAe/gB,KAQnCgiB,IAECpuE,GAEJksE,EAAuBkB,cAAgB/gB,GACvC6f,EAAuB1zD,kBAAoBz8E,EAASm9F,kBACpDgzC,EAAuBmB,eAAiBjhB,KAIxC8f,EAAuBkB,cAAgB/gB,GACvC6f,EAAuBmB,eAAiBjhB,KAQ1C,MAAMqP,EAAUhH,EAAOgC,qBAAsB,CAAC,GAC1BgF,EAAQtE,gBAAiB,CAC5CC,mBACA8U,2BAGW3lG,MAEZkuF,EAAOkD,MAAMC,OAAQ,CAAE6D,EAAQxjF,UAEhC,CAUA,YAAA4hD,CAAcqrB,GAEb,MAAMmpB,EAAWp1I,KAAKc,IAAKmrH,GAGrB7vD,EAAa,CAAC,EAEpBp8D,KAAKqpH,mBAAoB4C,EAAc7vD,GAEvCg5E,EAASC,cAAgBr1I,KAAKw7H,OAAOgC,uBAErC4X,EAASE,eAAiBF,EAASC,cAAcE,iBAAkBn5E,EAEpE,CAUA,OAAAlrC,CAAS+6F,EAAcv7F,EAAaksC,EAAU7D,GAE7C,MAAM,eAAEu8E,GAAmBt1I,KAAKc,IAAKmrH,GAI/B6kB,EAAc9wI,KAAKc,IAAKi4D,GAAWA,SACzCu8E,EAAe9W,YAAasS,GAI5B,IAAM,IAAIzsI,EAAI,EAAG+oC,EAAIwvB,EAAS54D,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAEnD,MAAMu+D,EAAYhG,EAAUv4D,GACtBypI,EAAe9tI,KAAKc,IAAK8hE,GAE/B0yE,EAAe7W,aAAcp6H,EAAGypI,EAAa1yH,MAE9C,CAEA,MAAMo6H,EAAmCx1I,KAAKw7H,OAAOia,OAAOD,iCAEtDE,EAAkB11I,KAAKc,IAAK4vB,QAEI3vB,IAAjC20I,EAAgBC,eAA6BD,EAAgBC,aAAe,CAAE/rH,EAAG,EAAGE,EAAG,EAAGmT,EAAG,IAElG,MAAM,aAAE04G,GAAiBD,EAEpBhlH,EAAYG,cAAgB2kH,GAEhCG,EAAa/rH,EAAI3kB,KAAKu8C,IAAK9wB,EAAYG,cAAe2kH,GACtDG,EAAa7rH,EAAI7kB,KAAKuhB,KAAMkK,EAAYG,cAAgB2kH,IAIxDG,EAAa/rH,EAAI8G,EAAYG,cAI9BykH,EAAeM,mBACdD,EAAa/rH,EACb+rH,EAAa7rH,EACb6rH,EAAa14G,EAGf,CAQA,aAAA+jE,CAAeirB,GAEd,MAAMppD,EAAY7iE,KAAKc,IAAKmrH,GAE5BppD,EAAUyyE,eAAehoG,MAEzBttC,KAAK6pH,uBAAwBoC,EAAcppD,EAAUwyE,eAErDr1I,KAAKw7H,OAAOkD,MAAMC,OAAQ,CAAE97D,EAAUwyE,cAAcr2F,UAErD,CASA,gBAAMk+C,SAECl9F,KAAKw7H,OAAOkD,MAAMmX,qBAEzB,CAUA,IAAAxyC,CAAM3iG,EAAck3D,GAEnB,MAAM,OAAEt3D,EAAM,QAAE+B,EAAO,SAAE02D,GAAar4D,EAChCk8D,EAAWl8D,EAAa05D,cACxBooD,EAAoBxiH,KAAKc,IAAKuB,GAC9ByuI,EAAc9wI,KAAKc,IAAKi4D,GAAWA,SACnCu7E,EAAc9xB,EAAkB8xB,YAChCgB,EAAiB9yB,EAAkB6xB,YAEnCp7E,EAAav4D,EAAaq6D,oBAEhC,GAAoB,OAAf9B,EAAsB,OAItBq7E,EAAYv7E,WAAa+3E,IAE7BwE,EAAe9W,YAAasS,GAE5BwD,EAAYv7E,SAAW+3E,GAMxB,MAAMgF,EAAuBxB,EAAYC,cAEzC,IAAM,IAAIlwI,EAAI,EAAG+oC,EAAIwvB,EAAS54D,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAEnD,MAAMu+D,EAAYhG,EAAUv4D,GACtBypI,EAAe9tI,KAAKc,IAAK8hE,GAE1BkzE,EAAsBlzE,EAAUthE,SAAYshE,EAAUx/D,KAE1DkyI,EAAe7W,aAAc77D,EAAUthE,MAAOwsI,EAAa1yH,OAC3D06H,EAAsBlzE,EAAUthE,OAAUshE,EAAUx/D,GAItD,CAIA,MAAM9B,EAAQZ,EAAa45D,WAErBc,EAAuB,OAAV95D,EAInB,IAAkB,IAAb85D,GAECk5E,EAAYhzI,QAAUA,EAAQ,CAElC,MAAMgH,EAAStI,KAAKc,IAAKQ,GAAQgH,OAC3BytI,EAAgBz0I,EAAMkE,iBAAiBokF,YAAgB2pC,GAAwBA,GAErF+hB,EAAeU,eAAgB1tI,EAAQytI,GAEvCzB,EAAYhzI,MAAQA,CAErB,CAMD,MAAM03D,EAAgBt4D,EAAao6D,mBAEnC,IAAM,IAAIz2D,EAAI,EAAG+oC,EAAI4rB,EAAch1D,OAAQK,EAAI+oC,EAAG/oC,IAAO,CAExD,MAAM4xI,EAAej9E,EAAe30D,GAEpC,GAAKiwI,EAAYnzI,WAAYkD,KAAQ4xI,EAAe,CAEnD,MAAM3tI,EAAStI,KAAKc,IAAKm1I,GAAe3tI,OACxCgtI,EAAeY,gBAAiB7xI,EAAGiE,GAEnCgsI,EAAYnzI,WAAYkD,GAAM4xI,CAE/B,CAED,CAIA,QAA6Cl1I,IAAxCyhH,EAAkBoxB,kBAAkC,CAExD,MAAMrmB,EAAa/K,EAAkBwI,oBAEhCuC,IAAejtH,IAEC,OAAfitH,IAAoD,IAA7BA,EAAW1nD,gBAEtCyvE,EAAeb,oBACfjyB,EAAkByI,wBAIW,IAAzB3qH,EAAOulE,gBAEXyvE,EAAea,oBAAqB3zB,EAAkByI,qBACtDzI,EAAkBuI,sBAAuBvI,EAAkByI,qBAAwB3qH,GAIpFkiH,EAAkBwI,oBAAsB1qH,EAI1C,CAIA,IAA8B,IAAzBA,EAAO25C,cAAyB,CAEpC,MAAMutE,EAASlnH,EAAOytH,iBAChBtG,EAASnnH,EAAO0tH,iBAChBtG,EAAYpnH,EAAO2tH,gBACnBmoB,EAAgB91I,EAAOwtH,oBAE7B,IAAM,IAAIzpH,EAAI,EAAGA,EAAIqjH,EAAWrjH,IAAO,CAEtC,MAAM3C,EAAQ00I,EAAgBA,EAAe/xI,GAAM,EAC7C82D,EAAgBz5D,EAAQ,EAAI,EAAI2C,GAEpB,IAAb+2D,EAEJk6E,EAAee,YAAa5uB,EAAQpjH,GAAK3C,EAAO8lH,EAAQnjH,GAAM/C,EAAMkE,MAAMo+F,kBAAmB,EAAGzoC,GAIhGm6E,EAAejyC,KAAMokB,EAAQpjH,GAAK3C,EAAO8lH,EAAQnjH,GAAK82D,EAIxD,CAED,MAAO,IAAkB,IAAbC,EAAoB,CAE/B,MAAQJ,YAAas7E,EAAU,cAAEp7E,EAAeD,YAAas7E,GAAet9E,EAEtE9Z,EAAWz+C,EAAa65D,cAE9B,GAAkB,OAAbpb,EAAoB,CAExB,MAAM72C,EAAStI,KAAKc,IAAKq+C,GAAW72C,OAEpCgtI,EAAekB,oBAAqBluI,EAAQ,EAE7C,MAECgtI,EAAee,YAAaC,EAAYp7E,EAAeq7E,EAAY,EAAG,GAIvE3+E,EAAKrtD,OAAQjK,EAAQg2I,EAAYp7E,EAElC,KAAO,CAEN,MAAM,YAAEF,EAAW,cAAEE,EAAa,YAAED,GAAgBhC,EAE9C9Z,EAAWz+C,EAAa65D,cAE9B,GAAkB,OAAbpb,EAAoB,CAExB,MAAM72C,EAAStI,KAAKc,IAAKq+C,GAAW72C,OAEpCgtI,EAAemB,aAAcnuI,EAAQ,EAEtC,MAECgtI,EAAejyC,KAAMroC,EAAaE,EAAeD,EAAa,GAI/DrD,EAAKrtD,OAAQjK,EAAQ06D,EAAaE,EAEnC,CAED,CAUA,iBAAAwH,CAAmBhiE,GAElB,MAAMG,EAAOb,KAAKc,IAAKJ,IAEjB,OAAEJ,EAAM,SAAEW,GAAaP,EAEvBssG,EAAQhtG,KAAKgtG,MAEbzlC,EAAcylC,EAAMw+B,4BAA6B9qI,EAAa2B,SAC9DqqB,EAAasgF,EAAMs+B,qBAAsB5qI,EAAa2B,SACtDmtI,EAAcxiC,EAAMwzB,sBAAuB9/H,EAAa2B,SACxD2tI,EAAqBhjC,EAAMo+B,6BAA8B1qI,EAAa2B,SACtEq0I,EAAoB1pC,EAAMu+B,qBAAsBjrI,EAAQW,GAE9D,IAAImJ,GAAc,EAsClB,OApCKvJ,EAAKI,WAAaA,GAAYJ,EAAK81I,kBAAoB11I,EAASM,SACpEV,EAAKy5C,cAAgBr5C,EAASq5C,aAAez5C,EAAK05C,WAAat5C,EAASs5C,UAAY15C,EAAK+wG,qBAAuB3wG,EAAS2wG,oBACzH/wG,EAAK0wG,WAAatwG,EAASswG,UAAY1wG,EAAK2wG,WAAavwG,EAASuwG,UAAY3wG,EAAKywG,gBAAkBrwG,EAASqwG,eAC9GzwG,EAAK6wG,gBAAkBzwG,EAASywG,eAAiB7wG,EAAK8wG,gBAAkB1wG,EAAS0wG,eAAiB9wG,EAAK4wG,qBAAuBxwG,EAASwwG,oBACvI5wG,EAAKqzG,aAAejzG,EAASizG,YAAcrzG,EAAK83C,aAAe13C,EAAS03C,YAAc93C,EAAK+3C,YAAc33C,EAAS23C,WAAa/3C,EAAK6xG,YAAczxG,EAASyxG,WAC3J7xG,EAAKszG,eAAiBlzG,EAASkzG,cAAgBtzG,EAAK4yG,cAAgBxyG,EAASwyG,aAC7E5yG,EAAK+yG,cAAgB3yG,EAAS2yG,aAAe/yG,EAAKgzG,eAAiB5yG,EAAS4yG,cAAgBhzG,EAAKizG,eAAiB7yG,EAAS6yG,cAC3HjzG,EAAKwzG,kBAAoBpzG,EAASozG,iBAAmBxzG,EAAKuzG,mBAAqBnzG,EAASmzG,kBACxFvzG,EAAKs5B,OAASl5B,EAASk5B,MAAQt5B,EAAK44C,kBAAoBx4C,EAASw4C,iBACjE54C,EAAK0mE,cAAgBA,GAAe1mE,EAAK6rB,aAAeA,GACxD7rB,EAAK2uI,cAAgBA,GAAe3uI,EAAKmvI,qBAAuBA,GAChEnvI,EAAK61I,oBAAsBA,GAC3B71I,EAAKq4D,0BAA4Bx4D,EAAaw4D,0BAG9Cr4D,EAAKI,SAAWA,EAAUJ,EAAK81I,gBAAkB11I,EAASM,QAC1DV,EAAKy5C,YAAcr5C,EAASq5C,YAAaz5C,EAAK05C,SAAWt5C,EAASs5C,SAAU15C,EAAK+wG,mBAAqB3wG,EAAS2wG,mBAC/G/wG,EAAK0wG,SAAWtwG,EAASswG,SAAU1wG,EAAK2wG,SAAWvwG,EAASuwG,SAAU3wG,EAAKywG,cAAgBrwG,EAASqwG,cACpGzwG,EAAK6wG,cAAgBzwG,EAASywG,cAAe7wG,EAAK8wG,cAAgB1wG,EAAS0wG,cAAe9wG,EAAK4wG,mBAAqBxwG,EAASwwG,mBAC7H5wG,EAAKqzG,WAAajzG,EAASizG,WAC3BrzG,EAAK83C,WAAa13C,EAAS03C,WAAY93C,EAAK+3C,UAAY33C,EAAS23C,UAAW/3C,EAAK6xG,UAAYzxG,EAASyxG,UACtG7xG,EAAKszG,aAAelzG,EAASkzG,aAActzG,EAAK4yG,YAAcxyG,EAASwyG,YACvE5yG,EAAK+yG,YAAc3yG,EAAS2yG,YAAa/yG,EAAKgzG,aAAe5yG,EAAS4yG,aAAchzG,EAAKizG,aAAe7yG,EAAS6yG,aACjHjzG,EAAKwzG,gBAAkBpzG,EAASozG,gBAAiBxzG,EAAKuzG,iBAAmBnzG,EAASmzG,iBAClFvzG,EAAKs5B,KAAOl5B,EAASk5B,KAAMt5B,EAAK44C,gBAAkBx4C,EAASw4C,gBAC3D54C,EAAK0mE,YAAcA,EACnB1mE,EAAK6rB,WAAaA,EAClB7rB,EAAK2uI,YAAcA,EACnB3uI,EAAKmvI,mBAAqBA,EAC1BnvI,EAAK61I,kBAAoBA,EACzB71I,EAAKq4D,wBAA0Bx4D,EAAaw4D,wBAE5C9uD,GAAc,GAIRA,CAER,CAQA,iBAAAo4D,CAAmB9hE,GAElB,MAAM,OAAEJ,EAAM,SAAEW,GAAaP,EAEvBssG,EAAQhtG,KAAKgtG,MACbp0C,EAAgBl4D,EAAa2B,QAEnC,MAAO,CACNpB,EAASq5C,YAAar5C,EAASs5C,SAAUt5C,EAAS2wG,mBAClD3wG,EAASswG,SAAUtwG,EAASuwG,SAAUvwG,EAASqwG,cAC/CrwG,EAASywG,cAAezwG,EAAS0wG,cAAe1wG,EAASwwG,mBACzDxwG,EAASizG,WACTjzG,EAAS03C,WAAY13C,EAAS23C,UAAW33C,EAASyxG,UAClDzxG,EAASkzG,aAAclzG,EAASwyG,YAChCxyG,EAAS2yG,YAAa3yG,EAAS4yG,aAAc5yG,EAAS6yG,aACtD7yG,EAASozG,gBAAiBpzG,EAASmzG,iBACnCnzG,EAASk5B,KACT6yE,EAAMw+B,4BAA6B5yE,GACnCo0C,EAAMs+B,qBAAsB1yE,GAAiBo0C,EAAMwzB,sBAAuB5nE,GAAiBo0C,EAAMo+B,6BAA8BxyE,GAC/Ho0C,EAAMu+B,qBAAsBjrI,EAAQW,GACpCP,EAAaq7D,sBACbr7D,EAAaw4D,yBACZpoD,MAEH,CASA,aAAAi4D,CAAej1C,GAEd9zB,KAAKooH,aAAar/C,cAAej1C,EAElC,CAOA,cAAA60C,CAAgB70C,GAEf9zB,KAAKooH,aAAaz/C,eAAgB70C,EAEnC,CAQA,oBAAAs1C,CAAsBt1C,GAErB9zB,KAAKooH,aAAah/C,qBAAsBt1C,EAEzC,CAQA,aAAAk1C,CAAel1C,EAASupB,GAEvBr9C,KAAKooH,aAAap/C,cAAel1C,EAASupB,EAE3C,CAQA,aAAA+lB,CAAetvC,EAASupB,GAEvBr9C,KAAKooH,aAAahlD,cAAetvC,EAASupB,EAE3C,CAOA,eAAA/J,CAAiBxf,GAEhB9zB,KAAKooH,aAAa90E,gBAAiBxf,EAEpC,CAOA,cAAA80C,CAAgB90C,GAEf9zB,KAAKooH,aAAax/C,eAAgB90C,EAEnC,CAaA,mBAAA+tE,CAAqB/tE,EAASlK,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,GAElD,OAAOjnF,KAAKooH,aAAavmB,oBAAqB/tE,EAASlK,EAAGE,EAAG3nB,EAAOC,EAAQ6kF,EAE7E,CAQA,kBAAAoiC,CAAoBzwD,EAAewD,GAElC,IAAOp8D,KAAK0oH,eAAiB,OAE7B,MAAMlG,EAAoBxiH,KAAKc,IAAK83D,GAEpC,IAAO4pD,EAAkBo0B,kBAAoB,CAG5C,MAAMrvI,EAAOqxD,EAAchoC,cAAgB,UAAY,SACjDgmH,EAAoB52I,KAAKw7H,OAAOwY,eAAgB,CAAEzsI,KAAM,YAAa7F,MAAO,EAAGwZ,MAAO,aAAa3T,KAAQqxD,EAAcx1D,OAEzHyzI,EAAkB,CACvBC,SAAUF,EACVG,0BAA2B,EAC3BC,oBAAqB,GAGtBnzI,OAAOsQ,OAAQioD,EAAY,CAAEy6E,oBAE7Br0B,EAAkBo0B,kBAAoBA,CAEvC,CAED,CAQA,sBAAA/sB,CAAwBjxD,EAAe4pE,GAEtC,IAAOxiI,KAAK0oH,eAAiB,OAE7B,MAAMlG,EAAoBxiH,KAAKc,IAAK83D,GAG9B5nC,EAAO,EAAIimH,cAAcrzC,uBAEyB7iG,IAAnDyhH,EAAkB00B,+BAEtB10B,EAAkB00B,6BAA+B,CAChDC,cAAen3I,KAAKw7H,OAAO5uB,aAAc,CACxC1xF,MAAO,2BACP8V,KAAMA,EACN7B,MAAOmzG,eAAesS,cAAgBtS,eAAevB,WAEtDqW,aAAcp3I,KAAKw7H,OAAO5uB,aAAc,CACvC1xF,MAAO,0BACP8V,KAAMA,EACN7B,MAAOmzG,eAAexB,SAAWwB,eAAeC,aAMnD,MAAM,cAAE4U,EAAa,aAAEC,GAAiB50B,EAAkB00B,6BAG1D1U,EAAQqS,gBAAiBryB,EAAkBo0B,kBAAmB,EAAG,EAAGO,EAAe,GAEpD,aAA1BC,EAAaC,UAEjB7U,EAAQuK,mBAAoBoK,EAAe,EAAGC,EAAc,EAAGpmH,EAIjE,CAUA,2BAAMisE,CAAuBrkC,EAAerxD,EAAO,UAElD,IAAOvH,KAAK0oH,eAAiB,OAE7B,MAAMlG,EAAoBxiH,KAAKc,IAAK83D,GAEpC,QAAwD73D,IAAnDyhH,EAAkB00B,6BAA6C,OAEpE,MAAM,aAAEE,GAAiB50B,EAAkB00B,6BAEZ,aAA1BE,EAAaC,UAEjBD,EAAa1U,SAAUC,WAAWC,MAAOgO,MAAM,KAE9C,MAAM0G,EAAQ,IAAIvC,eAAgBqC,EAAavU,kBACzCrY,EAAWr8G,OAAQmpI,EAAO,GAAMA,EAAO,IAAQ,IAGrDt3I,KAAK8C,SAAS80D,KAAKmI,gBAAiBx4D,EAAMijH,GAE1C4sB,EAAanL,OAAO,GAOvB,CAWA,iBAAAp3C,CAAmBv0F,EAAQwC,GAE1B,OAAO,IAAI8jI,GAAiBtmI,EAAQwC,EAErC,CASA,aAAA4+D,CAAee,GAEKziE,KAAKc,IAAK2hE,GAElBy5D,OAAS,CACnBA,OAAQl8H,KAAKw7H,OAAOM,mBAAoB,CAAEl7D,KAAM6B,EAAQ7B,KAAM1lD,MAAOunD,EAAQ5B,OAA2B,KAAjB4B,EAAQ//D,KAAc,IAAK+/D,EAAQ//D,OAAU,MACpIy5H,WAAY,OAGd,CAOA,cAAAvxB,CAAgBnoC,GAEfziE,KAAKgwC,OAAQyyB,EAEd,CAUA,oBAAAF,CAAsB7hE,EAAcohE,GAEnC9hE,KAAKkyI,cAAc3vE,qBAAsB7hE,EAAcohE,EAExD,CAQA,qBAAAQ,CAAuBy+B,EAAiBnkC,GAEvC58D,KAAKkyI,cAAc5vE,sBAAuBy+B,EAAiBnkC,EAE5D,CAOA,WAAAghC,CAAahlC,GAEZ,MAAM4pD,EAAoBxiH,KAAKc,IAAK83D,GAEpC4pD,EAAkB+0B,aAAe/0B,EAAkB6xB,YACnD7xB,EAAkBg1B,aAAeh1B,EAAkB8xB,YAEnD9xB,EAAkB8xB,YAAc,CAAEnzI,WAAY,CAAC,EAAGozI,cAAe,GAAIx7E,SAAU,KAAMz3D,MAAO,MAC5FkhH,EAAkB6xB,YAAcr0I,KAAKkyI,cAAcrB,oBAAqBj4E,EAEzE,CAQA,YAAAilC,CAAcjlC,EAAe32D,GAE5B,MAAMugH,EAAoBxiH,KAAKc,IAAK83D,GAG9B6+E,EADgBj1B,EAAkB6xB,YACRr1F,SAEhCh/C,KAAKc,IAAKmB,GAASw1I,UAAYA,EAI/Bj1B,EAAkB8xB,YAAc9xB,EAAkBg1B,aAClDh1B,EAAkB6xB,YAAc7xB,EAAkB+0B,YAEnD,CAQA,SAAAz5C,CAAWllC,EAAe32D,GAECjC,KAAKc,IAAK83D,GAElBwmE,cAAct5H,KAAM9F,KAAKc,IAAKmB,GAASw1I,UAE1D,CAYA,cAAAp9E,CAAgBuI,EAAWhG,EAAU6G,EAAYliE,GAEhDvB,KAAKiyI,aAAa53E,eAAgBuI,EAAWhG,EAAU6G,EAAYliE,EAEpE,CAUA,cAAAmjE,CAAgB9B,EAAWhG,EAAU6G,EAAYliE,GAEhDvB,KAAKiyI,aAAa53E,eAAgBuI,EAAWhG,EAAU6G,EAAYliE,EAEpE,CAOA,aAAAsiE,CAAeX,GAEdljE,KAAKiyI,aAAapuE,cAAeX,EAElC,CASA,oBAAAxF,CAAsB/6D,GAErB3C,KAAKkoH,eAAezqD,gBAAiB96D,EAAW2/H,eAAeoV,MAAQpV,eAAevB,SAAWuB,eAAexB,SAEjH,CAOA,eAAArjE,CAAiB96D,GAEhB3C,KAAKkoH,eAAezqD,gBAAiB96D,EAAW2/H,eAAe95H,OAAS85H,eAAevB,SAAWuB,eAAexB,SAElH,CAOA,sBAAAnjE,CAAwBh7D,GAEvB3C,KAAKkoH,eAAezqD,gBAAiB96D,EAAW2/H,eAAeqV,QAAUrV,eAAe95H,OAAS85H,eAAevB,SAAWuB,eAAexB,SAE3I,CAOA,8BAAAljE,CAAgCj7D,GAE/B3C,KAAKkoH,eAAezqD,gBAAiB96D,EAAW2/H,eAAeqV,QAAUrV,eAAesV,SAAWtV,eAAevB,SAAWuB,eAAexB,SAE7I,CAOA,eAAAhjE,CAAiBn7D,GAEhB3C,KAAKkoH,eAAepqD,gBAAiBn7D,EAEtC,CAOA,gBAAA66D,CAAkB76D,GAEjB3C,KAAKkoH,eAAe1qD,iBAAkB76D,EAEvC,CAOA,UAAA28F,GAECt/F,KAAK4/H,YAAc5/H,KAAKooH,aAAauZ,iBACrC3hI,KAAKgyI,4BAA8B,IAEpC,CASA,gBAAA9yC,GAEC,OAAO,EAER,CAQA,UAAAgC,CAAYx+F,GAEX,OAAO1C,KAAKw7H,OAAO0I,SAASvjI,IAAK+B,EAElC,CAWA,oBAAA4+F,CAAsBC,EAAYC,EAAYC,EAAY,KAAMC,EAAc,KAAMhuE,EAAQ,GAE3F,IAAI2vF,EAAO,EACPC,EAAO,EACPu0B,EAAW,EAEXC,EAAO,EACPC,EAAO,EACPC,EAAW,EAEXC,EAAW12C,EAAWxtE,MAAM5xB,MAC5ByiH,EAAYrjB,EAAWxtE,MAAM3xB,OAEd,OAAdq/F,IAEJq2C,EAAOr2C,EAAU73E,EACjBmuH,EAAOt2C,EAAU33E,EACjBkuH,EAAWv2C,EAAUxkE,GAAK,EAC1Bg7G,EAAWx2C,EAAUt/F,MACrByiH,EAAYnjB,EAAUr/F,QAIF,OAAhBs/F,IAEJ2hB,EAAO3hB,EAAY93E,EACnB05F,EAAO5hB,EAAY53E,EACnB+tH,EAAWn2C,EAAYzkE,GAAK,GAI7B,MAAMulG,EAAUxiI,KAAKw7H,OAAOgC,qBAAsB,CAAEtiH,MAAO,wBAA0BqmF,EAAWn+F,GAAK,IAAMo+F,EAAWp+F,KAEhH80I,EAAYl4I,KAAKc,IAAKygG,GAAaztE,QACnCqkH,EAAiBn4I,KAAKc,IAAK0gG,GAAa1tE,QAE9C0uG,EAAQlhC,qBACP,CACCxtE,QAASokH,EACT9U,SAAU1vG,EACV+uG,OAAQ,CAAE74G,EAAGkuH,EAAMhuH,EAAGiuH,EAAM96G,EAAG+6G,IAEhC,CACClkH,QAASqkH,EACT/U,SAAU1vG,EACV+uG,OAAQ,CAAE74G,EAAGy5F,EAAMv5F,EAAGw5F,EAAMrmF,EAAG46G,IAEhC,CACCI,EACArzB,EACA,IAIF5kH,KAAKw7H,OAAOkD,MAAMC,OAAQ,CAAE6D,EAAQxjF,UAErC,CASA,wBAAAvL,CAA0B3f,EAAS8kC,EAAeyoC,GAEjD,MAAMmhB,EAAoBxiH,KAAKc,IAAK83D,GAEpC,IAAIs/E,EAAY,KAMdA,EAJGt/E,EAAczmB,aAEbre,EAAQe,eAEA70B,KAAKc,IAAK83D,EAAcyO,cAAevzC,QAIvC9zB,KAAKc,IAAK83D,EAAclqD,SAAU,IAAMolB,QAMhDA,EAAQe,eAEA70B,KAAKooH,aAAayZ,eAAgBjpE,EAActhC,MAAOshC,EAAcmO,SAIrE/mE,KAAKqC,QAAQ+wI,oBAM3B,MAAM+E,EAAiBn4I,KAAKc,IAAKgzB,GAAUA,QAE3C,GAAKokH,EAAUvqI,SAAWwqI,EAAexqI,OAIxC,YAFAlB,QAAQkiB,MAAO,wFAAyFupH,EAAUvqI,OAAQwqI,EAAexqI,QAM1I,IAAI60H,EA8BJ,GA5BKhgB,EAAkB6xB,aAEtB7xB,EAAkB6xB,YAAY/mG,MAE9Bk1F,EAAUhgB,EAAkBggB,SAI5BA,EAAUxiI,KAAKw7H,OAAOgC,qBAAsB,CAAEtiH,MAAO,4BAA8B4Y,EAAQ1wB,KAI5Fo/H,EAAQlhC,qBACP,CACCxtE,QAASokH,EACTzV,OAAQ,CAAEphC,EAAUz3E,EAAGy3E,EAAUv3E,EAAG,IAErC,CACCgK,QAASqkH,GAEV,CACC92C,EAAUpkE,EACVokE,EAAUnkE,IAIPpJ,EAAQwf,iBAAkBtzC,KAAKooH,aAAa90E,gBAAiBxf,GAE7D0uF,EAAkB6xB,YAAc,CAEpC,MAAM,WAAEj4E,GAAeomD,EAEvB,IAAM,IAAIn+G,EAAI,EAAGA,EAAI+3D,EAAW+hE,iBAAiBn6H,OAAQK,IAExD+3D,EAAW+hE,iBAAkB95H,GAAIg6H,OAASjL,GAgB3C,GAZKx6D,EAActhC,QAAQ8kC,EAAW62E,uBAAuBgB,YAAc7gB,IACtEx6D,EAAcmO,UAAU3K,EAAW62E,uBAAuBkB,cAAgB/gB,IAE/E5Q,EAAkB6xB,YAAc7R,EAAQtE,gBAAiB9hE,GACzDomD,EAAkB8xB,YAAc,CAAEnzI,WAAY,CAAC,EAAGozI,cAAe,GAAIx7E,SAAU,KAAMz3D,MAAO,MAEvFs3D,EAAcvmB,UAElBryC,KAAKgjG,eAAgBpqC,GAIjBA,EAAcuO,QAAU,CAE5B,MAAM,EAAEv9C,EAAC,EAAEE,EAAC,MAAE3nB,EAAK,OAAEC,GAAWw2D,EAAcwO,aAE9Co7C,EAAkB6xB,YAAYG,eAAgB5qH,EAAGE,EAAG3nB,EAAOC,EAE5D,CAED,MAECpC,KAAKw7H,OAAOkD,MAAMC,OAAQ,CAAE6D,EAAQxjF,UAItC,EAID,MAAMo5F,WAAqB,MAE1B,WAAAt4I,CAAaqZ,EAAOy5C,EAAW7qC,EAAUwpE,EAAOC,EAAUxT,GAEzDt0E,MAAOyP,EAAOy5C,EAAW7qC,EAAUwpE,EAAOC,EAAUxT,GAEpDh+E,KAAK+xF,OAAS,IAEf,CAEA,IAAAxuF,CAAM8a,EAAQg6H,GAMb,OAJA3uI,MAAMnG,KAAM8a,EAAQg6H,GAEpBr4I,KAAK+xF,OAAS1zE,EAAO0zE,OAEd/xF,IAER,EAYD,MAAMs4I,WAA4BhhD,GAKjC,WAAAx3F,GAEC4J,QAEA1J,KAAK+3F,YAAah3C,GAAuB,qBACzC/gD,KAAK+3F,YAAatkC,GAA0B,wBAC5CzzD,KAAK+3F,YAAajkC,GAA0B,wBAC5C9zD,KAAK+3F,YAAa3iC,GAAsB,oBACxCp1D,KAAK+3F,YAAav4C,GAAuB,qBACzCx/C,KAAK+3F,YAAan3C,GAAyB,uBAC3C5gD,KAAK+3F,YAAal7C,GAAwB,sBAC1C78C,KAAK+3F,YAAatiC,GAAwB,sBAC1Cz1D,KAAK+3F,YAAah8C,GAAuB,qBACzC/7C,KAAK+3F,YAAa57C,GAAwB,sBAC1Cn8C,KAAK+3F,YAAajiC,GAAoB,kBACtC91D,KAAK+3F,YAAarhC,GAAoB,kBACtC12D,KAAK+3F,YAAaxgC,GAAoB,kBAEtCv3D,KAAKk4F,SAAUra,GAAgB,OAC/B79E,KAAKk4F,SAAU3H,GAAsB,OACrCvwF,KAAKk4F,SAAUvH,GAAmB,OAClC3wF,KAAKk4F,SAAU9G,GAAe,OAC9BpxF,KAAKk4F,SAAUlG,GAAkB,OACjChyF,KAAKk4F,SAAUjG,GAAqB,OACpCjyF,KAAKk4F,SAAU3F,GAAgB,OAC/BvyF,KAAKk4F,SAAUpG,GAAkBsmD,IAEjCp4I,KAAK23F,eAAgBlqB,GAAmB,OACxCztE,KAAK23F,eAAgBjqB,GAAqB,OAC1C1tE,KAAK23F,eAAgBhqB,GAAmB,OACxC3tE,KAAK23F,eAAgB9pB,GAAuB,MAC5C7tE,KAAK23F,eAAgBtpB,GAAgB,OACrCruE,KAAK23F,eAAgBhpB,GAAoB,MAE1C,EA0BD,MAAM4pE,WAAuBx/C,GAgB5B,WAAAj5F,CAAa2e,EAAa,CAAC,GAE1B,IAAI+5H,EAEC/5H,EAAWg6H,WAEfD,EAAevwB,IAIfuwB,EAAe1G,GAEfrzH,EAAWy6E,YAAc,KAExBzsF,QAAQC,KAAM,gFAEP,IAAIu7G,GAAcxpG,KAS3B/U,MAHgB,IAAI8uI,EAAc/5H,GAGlBA,GAQhBze,KAAKyuB,QAAU,IAAI6pH,GASnBt4I,KAAK04I,kBAAmB,CAEzB,EAgByB,MAyOG,MAsFJ,MAuLQ,MA0GF,MAuJH","sources":["webpack://gatsby-starter-blog-github-theme/./node_modules/three/build/three.webgpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, WebGLCoordinateSystem, WebGPUCoordinateSystem, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, BackSide, CubeReflectionMapping, CubeRefractionMapping, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RenderTarget3D, RenderTargetArray, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';\n\nconst refreshUniforms = [\n\t'alphaMap',\n\t'alphaTest',\n\t'anisotropy',\n\t'anisotropyMap',\n\t'anisotropyRotation',\n\t'aoMap',\n\t'attenuationColor',\n\t'attenuationDistance',\n\t'bumpMap',\n\t'clearcoat',\n\t'clearcoatMap',\n\t'clearcoatNormalMap',\n\t'clearcoatNormalScale',\n\t'clearcoatRoughness',\n\t'color',\n\t'dispersion',\n\t'displacementMap',\n\t'emissive',\n\t'emissiveMap',\n\t'envMap',\n\t'gradientMap',\n\t'ior',\n\t'iridescence',\n\t'iridescenceIOR',\n\t'iridescenceMap',\n\t'iridescenceThicknessMap',\n\t'lightMap',\n\t'map',\n\t'matcap',\n\t'metalness',\n\t'metalnessMap',\n\t'normalMap',\n\t'normalScale',\n\t'opacity',\n\t'roughness',\n\t'roughnessMap',\n\t'sheen',\n\t'sheenColor',\n\t'sheenColorMap',\n\t'sheenRoughnessMap',\n\t'shininess',\n\t'specular',\n\t'specularColor',\n\t'specularColorMap',\n\t'specularIntensity',\n\t'specularIntensityMap',\n\t'specularMap',\n\t'thickness',\n\t'transmission',\n\t'transmissionMap'\n];\n\n/**\n * This class is used by {@link WebGPURenderer} as management component.\n * It's primary purpose is to determine whether render objects require a\n * refresh right before they are going to be rendered or not.\n */\nclass NodeMaterialObserver {\n\n\t/**\n\t * Constructs a new node material observer.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t */\n\tconstructor( builder ) {\n\n\t\t/**\n\t\t * A node material can be used by more than one render object so the\n\t\t * monitor must maintain a list of render objects.\n\t\t *\n\t\t * @type {WeakMap<RenderObject,Object>}\n\t\t */\n\t\tthis.renderObjects = new WeakMap();\n\n\t\t/**\n\t\t * Whether the material uses node objects or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.hasNode = this.containsNode( builder );\n\n\t\t/**\n\t\t * Whether the node builder's 3D object is animated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.hasAnimation = builder.object.isSkinnedMesh === true;\n\n\t\t/**\n\t\t * A list of all possible material uniforms\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.refreshUniforms = refreshUniforms;\n\n\t\t/**\n\t\t * Holds the current render ID from the node frame.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object is verified for the first time of this observer.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the given render object is verified for the first time of this observer.\n\t */\n\tfirstInitialization( renderObject ) {\n\n\t\tconst hasInitialized = this.renderObjects.has( renderObject );\n\n\t\tif ( hasInitialized === false ) {\n\n\t\t\tthis.getRenderObjectData( renderObject );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns monitoring data for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Object} The monitoring data.\n\t */\n\tgetRenderObjectData( renderObject ) {\n\n\t\tlet data = this.renderObjects.get( renderObject );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconst { geometry, material, object } = renderObject;\n\n\t\t\tdata = {\n\t\t\t\tmaterial: this.getMaterialData( material ),\n\t\t\t\tgeometry: {\n\t\t\t\t\tattributes: this.getAttributesData( geometry.attributes ),\n\t\t\t\t\tindexVersion: geometry.index ? geometry.index.version : null,\n\t\t\t\t\tdrawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }\n\t\t\t\t},\n\t\t\t\tworldMatrix: object.matrixWorld.clone()\n\t\t\t};\n\n\t\t\tif ( object.center ) {\n\n\t\t\t\tdata.center = object.center.clone();\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tdata.morphTargetInfluences = object.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\t\tdata.version = renderObject.bundle.version;\n\n\t\t\t}\n\n\t\t\tif ( data.material.transmission > 0 ) {\n\n\t\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\t\tdata.bufferWidth = width;\n\t\t\t\tdata.bufferHeight = height;\n\n\t\t\t}\n\n\t\t\tthis.renderObjects.set( renderObject, data );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns an attribute data structure holding the attributes versions for\n\t * monitoring.\n\t *\n\t * @param {Object} attributes - The geometry attributes.\n\t * @return {Object} An object for monitoring the versions of attributes.\n\t */\n\tgetAttributesData( attributes ) {\n\n\t\tconst attributesData = {};\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tattributesData[ name ] = {\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\treturn attributesData;\n\n\t}\n\n\t/**\n\t * Returns `true` if the node builder's material uses\n\t * node properties.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether the node builder's material uses node properties or not.\n\t */\n\tcontainsNode( builder ) {\n\n\t\tconst material = builder.material;\n\n\t\tfor ( const property in material ) {\n\n\t\t\tif ( material[ property ] && material[ property ].isNode )\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\tif ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns a material data structure holding the material property values for\n\t * monitoring.\n\t *\n\t * @param {Material} material - The material.\n\t * @return {Object} An object for monitoring material properties.\n\t */\n\tgetMaterialData( material ) {\n\n\t\tconst data = {};\n\n\t\tfor ( const property of this.refreshUniforms ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( value === null || value === undefined ) continue;\n\n\t\t\tif ( typeof value === 'object' && value.clone !== undefined ) {\n\n\t\t\t\tif ( value.isTexture === true ) {\n\n\t\t\t\t\tdata[ property ] = { id: value.id, version: value.version };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[ property ] = value.clone();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata[ property ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has not changed its state.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the given render object has changed its state or not.\n\t */\n\tequals( renderObject ) {\n\n\t\tconst { object, material, geometry } = renderObject;\n\n\t\tconst renderObjectData = this.getRenderObjectData( renderObject );\n\n\t\t// world matrix\n\n\t\tif ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {\n\n\t\t\trenderObjectData.worldMatrix.copy( object.matrixWorld );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// material\n\n\t\tconst materialData = renderObjectData.material;\n\n\t\tfor ( const property in materialData ) {\n\n\t\t\tconst value = materialData[ property ];\n\t\t\tconst mtlValue = material[ property ];\n\n\t\t\tif ( value.equals !== undefined ) {\n\n\t\t\t\tif ( value.equals( mtlValue ) === false ) {\n\n\t\t\t\t\tvalue.copy( mtlValue );\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( mtlValue.isTexture === true ) {\n\n\t\t\t\tif ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {\n\n\t\t\t\t\tvalue.id = mtlValue.id;\n\t\t\t\t\tvalue.version = mtlValue.version;\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( value !== mtlValue ) {\n\n\t\t\t\tmaterialData[ property ] = mtlValue;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialData.transmission > 0 ) {\n\n\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\tif ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {\n\n\t\t\t\trenderObjectData.bufferWidth = width;\n\t\t\t\trenderObjectData.bufferHeight = height;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tconst storedGeometryData = renderObjectData.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst storedAttributes = storedGeometryData.attributes;\n\n\t\tconst storedAttributeNames = Object.keys( storedAttributes );\n\t\tconst currentAttributeNames = Object.keys( attributes );\n\n\t\tif ( storedAttributeNames.length !== currentAttributeNames.length ) {\n\n\t\t\trenderObjectData.geometry.attributes = this.getAttributesData( attributes );\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compare each attribute\n\n\t\tfor ( const name of storedAttributeNames ) {\n\n\t\t\tconst storedAttributeData = storedAttributes[ name ];\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t// attribute was removed\n\t\t\t\tdelete storedAttributes[ name ];\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( storedAttributeData.version !== attribute.version ) {\n\n\t\t\t\tstoredAttributeData.version = attribute.version;\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check index\n\n\t\tconst index = geometry.index;\n\t\tconst storedIndexVersion = storedGeometryData.indexVersion;\n\t\tconst currentIndexVersion = index ? index.version : null;\n\n\t\tif ( storedIndexVersion !== currentIndexVersion ) {\n\n\t\t\tstoredGeometryData.indexVersion = currentIndexVersion;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check drawRange\n\n\t\tif ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {\n\n\t\t\tstoredGeometryData.drawRange.start = geometry.drawRange.start;\n\t\t\tstoredGeometryData.drawRange.count = geometry.drawRange.count;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tif ( renderObjectData.morphTargetInfluences ) {\n\n\t\t\tlet morphChanged = false;\n\n\t\t\tfor ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {\n\n\t\t\t\t\tmorphChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( morphChanged ) return true;\n\n\t\t}\n\n\t\t// center\n\n\t\tif ( renderObjectData.center ) {\n\n\t\t\tif ( renderObjectData.center.equals( object.center ) === false ) {\n\n\t\t\t\trenderObjectData.center.copy( object.center );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// bundle\n\n\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\trenderObjectData.version = renderObject.bundle.version;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Checks if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {NodeFrame} nodeFrame - The current node frame.\n\t * @return {Boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject, nodeFrame ) {\n\n\t\tif ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )\n\t\t\treturn true;\n\n\t\tconst { renderId } = nodeFrame;\n\n\t\tif ( this.renderId !== renderId ) {\n\n\t\t\tthis.renderId = renderId;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst isStatic = renderObject.object.static === true;\n\t\tconst isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;\n\n\t\tif ( isStatic || isBundle )\n\t\t\treturn false;\n\n\t\tconst notEqual = this.equals( renderObject ) !== true;\n\n\t\treturn notEqual;\n\n\t}\n\n}\n\n/** @module NodeUtils **/\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53( value, seed = 0 ) {\n\n\tlet h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n\n\tif ( value instanceof Array ) {\n\n\t\tfor ( let i = 0, val; i < value.length; i ++ ) {\n\n\t\t\tval = value[ i ];\n\t\t\th1 = Math.imul( h1 ^ val, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ val, 1597334677 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, ch; i < value.length; i ++ ) {\n\n\t\t\tch = value.charCodeAt( i );\n\t\t\th1 = Math.imul( h1 ^ ch, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ ch, 1597334677 );\n\n\t\t}\n\n\t}\n\n\th1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );\n\th1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );\n\th2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );\n\th2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );\n\n\treturn 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );\n\n}\n\n/**\n * Computes a hash for the given string.\n *\n * @method\n * @param {String} str - The string to be hashed.\n * @return {Number} The hash.\n */\nconst hashString = ( str ) => cyrb53( str );\n\n/**\n * Computes a hash for the given array.\n *\n * @method\n * @param {Array<Number>} array - The array to be hashed.\n * @return {Number} The hash.\n */\nconst hashArray = ( array ) => cyrb53( array );\n\n/**\n * Computes a hash for the given list of parameters.\n *\n * @method\n * @param {...Number} params - A list of parameters.\n * @return {Number} The hash.\n */\nconst hash$1 = ( ...params ) => cyrb53( params );\n\n/**\n * Computes a cache key for the given node.\n *\n * @method\n * @param {Object} object - The object to be hashed.\n * @param {Boolean} [force=false] - Whether to force a cache key computation or not.\n * @return {Number} The hash.\n */\nfunction getCacheKey$1( object, force = false ) {\n\n\tconst values = [];\n\n\tif ( object.isNode === true ) {\n\n\t\tvalues.push( object.id );\n\t\tobject = object.getSelf();\n\n\t}\n\n\tfor ( const { property, childNode } of getNodeChildren( object ) ) {\n\n\t\tvalues.push( values, cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );\n\n\t}\n\n\treturn cyrb53( values );\n\n}\n\n/**\n * This generator function can be used to iterate over the node children\n * of the given object.\n *\n * @generator\n * @param {Object} node - The object to be hashed.\n * @param {Boolean} [toJSON=false] - Whether to return JSON or not.\n * @yields {Object} A result node holding the property, index (if available) and the child node.\n */\nfunction* getNodeChildren( node, toJSON = false ) {\n\n\tfor ( const property in node ) {\n\n\t\t// Ignore private properties.\n\t\tif ( property.startsWith( '_' ) === true ) continue;\n\n\t\tconst object = node[ property ];\n\n\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\tfor ( let i = 0; i < object.length; i ++ ) {\n\n\t\t\t\tconst child = object[ i ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: i, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object && object.isNode === true ) {\n\n\t\t\tyield { property, childNode: object };\n\n\t\t} else if ( typeof object === 'object' ) {\n\n\t\t\tfor ( const subProperty in object ) {\n\n\t\t\t\tconst child = object[ subProperty ];\n\n\t\t\t\tif ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {\n\n\t\t\t\t\tyield { property, index: subProperty, childNode: child };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst typeFromLength = /*@__PURE__*/ new Map( [\n\t[ 1, 'float' ],\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst dataFromObject = /*@__PURE__*/ new WeakMap();\n\n/**\n * Returns the data type for the given the length.\n *\n * @method\n * @param {Number} length - The length.\n * @return {String} The data type.\n */\nfunction getTypeFromLength( length ) {\n\n\treturn typeFromLength.get( length );\n\n}\n\n/**\n * Returns the typed array for the given data type.\n *\n * @method\n * @param {String} type - The data type.\n * @return {TypedArray} The typed array.\n */\nfunction getTypedArrayFromType( type ) {\n\n\t// Handle component type for vectors and matrices\n\tif ( /[iu]?vec\\d/.test( type ) ) {\n\n\t\t// Handle int vectors\n\t\tif ( type.startsWith( 'ivec' ) ) return Int32Array;\n\t\t// Handle uint vectors\n\t\tif ( type.startsWith( 'uvec' ) ) return Uint32Array;\n\t\t// Default to float vectors\n\t\treturn Float32Array;\n\n\t}\n\n\t// Handle matrices (always float)\n\tif ( /mat\\d/.test( type ) ) return Float32Array;\n\n\t// Basic types\n\tif ( /float/.test( type ) ) return Float32Array;\n\tif ( /uint/.test( type ) ) return Uint32Array;\n\tif ( /int/.test( type ) ) return Int32Array;\n\n\tthrow new Error( `THREE.NodeUtils: Unsupported type: ${type}` );\n\n}\n\n/**\n * Returns the length for the given data type.\n *\n * @method\n * @param {String} type - The data type.\n * @return {Number} The length.\n */\nfunction getLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 9;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\tconsole.error( 'THREE.TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the data type for the given value.\n *\n * @method\n * @param {Any} value - The value.\n * @return {String?} The data type.\n */\nfunction getValueType( value ) {\n\n\tif ( value === undefined || value === null ) return null;\n\n\tconst typeOf = typeof value;\n\n\tif ( value.isNode === true ) {\n\n\t\treturn 'node';\n\n\t} else if ( typeOf === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeOf === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( typeOf === 'string' ) {\n\n\t\treturn 'string';\n\n\t} else if ( typeOf === 'function' ) {\n\n\t\treturn 'shader';\n\n\t} else if ( value.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value.isColor === true ) {\n\n\t\treturn 'color';\n\n\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\treturn 'ArrayBuffer';\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Returns the value/object for the given data type and parameters.\n *\n * @method\n * @param {String} type - The given type.\n * @param {...Any} params - A parameter list.\n * @return {Any} The value/object.\n */\nfunction getValueFromType( type, ...params ) {\n\n\tconst last4 = type ? type.slice( - 4 ) : undefined;\n\n\tif ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()\n\n\t\tif ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];\n\n\t}\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn params[ 0 ] || false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn params[ 0 ] || 0;\n\n\t} else if ( type === 'string' ) {\n\n\t\treturn params[ 0 ] || '';\n\n\t} else if ( type === 'ArrayBuffer' ) {\n\n\t\treturn base64ToArrayBuffer( params[ 0 ] );\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Gets the object data that can be shared between different rendering steps.\n *\n * @param {Object} object - The object to get the data for.\n * @return {Object} The object data.\n */\nfunction getDataFromObject( object ) {\n\n\tlet data = dataFromObject.get( object );\n\n\tif ( data === undefined ) {\n\n\t\tdata = {};\n\t\tdataFromObject.set( object, data );\n\n\t}\n\n\treturn data;\n\n}\n\n/**\n * Converts the given array buffer to a Base64 string.\n *\n * @method\n * @param {ArrayBuffer} arrayBuffer - The array buffer.\n * @return {String} The Base64 string.\n */\nfunction arrayBufferToBase64( arrayBuffer ) {\n\n\tlet chars = '';\n\n\tconst array = new Uint8Array( arrayBuffer );\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\tchars += String.fromCharCode( array[ i ] );\n\n\t}\n\n\treturn btoa( chars );\n\n}\n\n/**\n * Converts the given Base64 string to an array buffer.\n *\n * @method\n * @param {String} base64 - The Base64 string.\n * @return {ArrayBuffer} The array buffer.\n */\nfunction base64ToArrayBuffer( base64 ) {\n\n\treturn Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;\n\n}\n\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tarrayBufferToBase64: arrayBufferToBase64,\n\tbase64ToArrayBuffer: base64ToArrayBuffer,\n\tgetCacheKey: getCacheKey$1,\n\tgetDataFromObject: getDataFromObject,\n\tgetLengthFromType: getLengthFromType,\n\tgetNodeChildren: getNodeChildren,\n\tgetTypeFromLength: getTypeFromLength,\n\tgetTypedArrayFromType: getTypedArrayFromType,\n\tgetValueFromType: getValueFromType,\n\tgetValueType: getValueType,\n\thash: hash$1,\n\thashArray: hashArray,\n\thashString: hashString\n});\n\n/** @module NodeConstants **/\n\n/**\n * Possible shader stages.\n *\n * @property {string} VERTEX The vertex shader stage.\n * @property {string} FRAGMENT The fragment shader stage.\n */\nconst NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\n/**\n * Update types of a node.\n *\n * @property {string} NONE The update method is not executed.\n * @property {string} FRAME The update method is executed per frame.\n * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.\n * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.\n */\nconst NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tRENDER: 'render',\n\tOBJECT: 'object'\n};\n\n/**\n * Data types of a node.\n *\n * @property {string} BOOLEAN Boolean type.\n * @property {string} INTEGER Integer type.\n * @property {string} FLOAT Float type.\n * @property {string} VECTOR2 Two-dimensional vector type.\n * @property {string} VECTOR3 Three-dimensional vector type.\n * @property {string} VECTOR4 Four-dimensional vector type.\n * @property {string} MATRIX2 2x2 matrix type.\n * @property {string} MATRIX3 3x3 matrix type.\n * @property {string} MATRIX4 4x4 matrix type.\n */\nconst NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX2: 'mat2',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n\n/**\n * Access types of a node. These are relevant for compute and storage usage.\n *\n * @property {string} READ_ONLY Read-only access\n * @property {string} WRITE_ONLY Write-only access.\n * @property {string} READ_WRITE Read and write access.\n */\nconst NodeAccess = {\n\tREAD_ONLY: 'readOnly',\n\tWRITE_ONLY: 'writeOnly',\n\tREAD_WRITE: 'readWrite',\n};\n\nconst defaultShaderStages = [ 'fragment', 'vertex' ];\nconst defaultBuildStages = [ 'setup', 'analyze', 'generate' ];\nconst shaderStages = [ ...defaultShaderStages, 'compute' ];\nconst vectorComponents = [ 'x', 'y', 'z', 'w' ];\n\nlet _nodeId = 0;\n\n/**\n * Base class for all nodes.\n *\n * @augments EventDispatcher\n */\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\t/**\n\t * Constructs a new node.\n\t *\n\t * @param {String?} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node type. This represents the result type of the node (e.g. `float` or `vec3`).\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.nodeType = nodeType;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The UUID of the node.\n\t\t *\n\t\t * @type {String}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t/**\n\t\t * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether this node is global or not. This property is relevant for the internal\n\t\t * node caching system. All nodes which should be declared just once should\n\t\t * set this flag to `true` (a typical example is {@link AttributeNode}).\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.global = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNode = true;\n\n\t\t// private\n\n\t\t/**\n\t\t * The cache key of this node.\n\t\t *\n\t\t * @private\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._cacheKey = null;\n\n\t\t/**\n\t\t * The cache key 's version.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the node should be regenerated.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The type of the class. The value is usually the constructor name.\n\t *\n\t * @type {String}\n \t * @readonly\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @param {String} updateType - The update type.\n\t * @return {Node} A reference to this node.\n\t */\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `FRAME`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `RENDER`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `OBJECT`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#updateReference}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this.getSelf() );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The `this` reference might point to a Proxy so this method can be used\n\t * to get the reference to the actual node instance.\n\t *\n\t * @return {Node} A reference to the node.\n\t */\n\tgetSelf() {\n\n\t\t// Returns non-node object.\n\n\t\treturn this.self || this;\n\n\t}\n\n\t/**\n\t * Nodes might refer to other objects like materials. This method allows to dynamically update the reference\n\t * to such objects based on a given state (e.g. the current node frame or builder).\n\t *\n\t * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {Any} The updated reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * By default this method returns the value of the {@link Node#global} flag. This method\n\t * can be overwritten in derived classes if an analytical way is required to determine the\n\t * global status.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t/**\n\t * Generator function that can be used to iterate over the child nodes.\n\t *\n\t * @generator\n\t * @yields {Node} A child node.\n\t */\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of getNodeChildren( this ) ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method dispatches the `dispose` event. This event can be used\n\t * to register event listeners for clean up tasks.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Callback for {@link Node#traverse}.\n\t *\n\t * @callback traverseCallback\n\t * @param {Node} node - The current node.\n\t */\n\n\t/**\n\t * Can be used to traverse through the node's hierarchy.\n\t *\n\t * @param {traverseCallback} callback - A callback that is executed per node.\n\t */\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the cache key for this node.\n\t *\n\t * @param {Boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.\n\t * @return {Number} The cache key of the node.\n\t */\n\tgetCacheKey( force = false ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tthis._cacheKey = hash$1( getCacheKey$1( this, force ), this.customCacheKey() );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\t/**\n\t * Generate a custom cache key for this node.\n\t *\n\t * @return {Number} The cache key of the node.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the references to this node which is by default `this`.\n\t *\n\t * @return {Node} A reference to this node.\n\t */\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the hash of the node which is used to identify the node. By default it's\n\t * the {@link Node#uuid} however derived node classes might have to overwrite this method\n\t * depending on their implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#update}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateBefore}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateAfter}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\t/**\n\t * Certain types are composed of multiple elements. For example a `vec3`\n\t * is composed of three `float` values. This method returns the type of\n\t * these elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * This method is used during the build process of a node and ensures\n\t * equal nodes are not built multiple times but just once. For example if\n\t * `attribute( 'uv' )` is used multiple times by the user, the build\n\t * process makes sure to process just the first node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The shared node if possible. Otherwise `this` is returned.\n\t */\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\t/**\n\t * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.\n\t * This method is often overwritten in derived modules to prepare the node which is used as the output/result.\n\t * The output node must be returned in the `return` statement.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node?} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\t/**\n\t * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.\n\t * This stage analyzes the node hierarchy and ensures descendent nodes are built.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tanalyze( builder ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.\n\t * This state builds the output node and returns the resulting shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String?} output - Can be used to define the output type.\n\t * @return {String?} The generated shader string.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state before it is used to render an object.\n\t * The {@link Node#updateBeforeType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateBefore( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state after it was used to render an object.\n\t * The {@link Node#updateAfterType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateAfter( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state when it is used to render an object.\n\t * The {@link Node#updateType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * This method performs the build of a node. The behavior of this method as well as its return value depend\n\t * on the current build stage (setup, analyze or generate).\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String?} output - Can be used to define the output type.\n\t * @return {String?} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.\n\t */\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\t//const stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\n\t\t\t\tconst outputNode = this.setup( builder ); // return a node or null\n\t\t\t\tconst isNodeOutput = outputNode && outputNode.isNode === true;\n\n\t\t\t\t/*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {\n\n\t\t\t\t\t// !! no outputNode !!\n\t\t\t\t\t//outputNode = builder.stack;\n\n\t\t\t\t}*/\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( isNodeOutput ) {\n\n\t\t\t\t\toutputNode.build( builder );\n\n\t\t\t\t}\n\n\t\t\t\tproperties.outputNode = outputNode;\n\n\t\t\t}\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the child nodes as a JSON object.\n\t *\n\t * @return {Object} The serialized child objects as JSON.\n\t */\n\tgetSerializeChildren() {\n\n\t\treturn getNodeChildren( this );\n\n\t}\n\n\t/**\n\t * Serializes the node to JSON.\n\t *\n\t * @param {Object} json - The output JSON object.\n\t */\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deserializes the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON object.\n\t */\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the node into the three.js JSON Object/Scene format.\n\t *\n\t * @param {Object?} meta - An optional JSON object that already holds serialized data from other scene objects.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.6,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Base class for representing element access on an array-like\n * node data structures.\n *\n * @augments Node\n */\nclass ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute\n\n\tstatic get type() {\n\n\t\treturn 'ArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs an array element node.\n\t *\n\t * @param {Node} node - The array-like node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The array-like node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The index node that defines the element access.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.indexNode = indexNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the array-like node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'uint' );\n\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a convert operation during the shader generation process\n * meaning it converts the data type of a node to a target data type.\n *\n * @augments Node\n */\nclass ConvertNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConvertNode';\n\n\t}\n\n\t/**\n\t * Constructs a new convert node.\n\t *\n\t * @param {Node} node - The node which type should be converted.\n\t * @param {String} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t */\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which type should be converted.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the implementation tries to infer the best\n\t * matching type from the {@link ConvertNode#convertTo} property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.convertTo = this.convertTo;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.convertTo = data.convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\n/**\n * This module uses cache management to create temporary variables\n * if the node is used more than once to prevent duplicate calculations.\n *\n * The class acts as a base class for many other nodes types.\n *\n * @augments Node\n */\nclass TempNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TempNode';\n\n\t}\n\n\t/**\n\t * Constructs a temp node.\n\t *\n\t * @param {String?} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTempNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes.\n\t */\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).usageCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a join operation during the shader generation process.\n * For example in can compose/join two single floats into a `vec2` type.\n *\n * @augments TempNode\n */\nclass JoinNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'JoinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new join node.\n\t *\n\t * @param {Array<Node>} nodes - An array of nodes that should be joined.\n\t * @param {String?} [nodeType=null] - The node type.\n\t */\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * An array of nodes that should be joined.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type must be inferred from the\n\t * joined data length if not explicitly defined.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst primitiveType = builder.getComponentType( type );\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tlet inputSnippet = input.build( builder );\n\n\t\t\tconst inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );\n\n\t\t\tif ( inputPrimitiveType !== primitiveType ) {\n\n\t\t\t\tinputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );\n\n\t\t\t}\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nconst _stringVectorComponents = vectorComponents.join( '' );\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SplitNode` represents a property access operation which means it is\n * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.\n * For example:\n * ```js\n * const redValue = color.r;\n * ```\n *\n * @augments Node\n */\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\t/**\n\t * Constructs a new split node.\n\t *\n\t * @param {Node} node - The node that should be accessed.\n\t * @param {String} [components='x'] - The components that should be accessed.\n\t */\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be accessed.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The components that should be accessed.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the requested components.\n\t *\n\t * @return {Number} The vector length.\n\t */\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\t/**\n\t * Returns the component type of the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The component type.\n\t */\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from requested components.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SetNode` represents a set operation which means it is used to implement any\n * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.\n * For example:\n * ```js\n * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );\n * ```\n *\n * @augments TempNode\n */\nclass SetNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SetNode';\n\n\t}\n\n\t/**\n\t * Constructs a new set node.\n\t *\n\t * @param {Node} sourceNode - The node that should be updated.\n\t * @param {String} components - The components that should be updated.\n\t * @param {Node} targetNode - The value node.\n\t */\n\tconstructor( sourceNode, components, targetNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be updated.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be updated.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * The value node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { sourceNode, components, targetNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\n\t\tconst componentType = builder.getComponentType( targetNode.getNodeType( builder ) );\n\t\tconst targetType = builder.getTypeFromLength( components.length, componentType );\n\n\t\tconst targetSnippet = targetNode.build( builder, targetType );\n\t\tconst sourceSnippet = sourceNode.build( builder, sourceType );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ 0 ] ) {\n\n\t\t\t\tsnippetValues.push( targetSnippet );\n\n\t\t\t\ti += components.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceSnippet + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a flip operation during the shader generation process\n * meaning it flips normalized values with the following formula:\n * ```\n * x = 1 - x;\n * ```\n * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and\n * `flipSTPQ()` method invocations on node objects. For example:\n * ```js\n * uvNode = uvNode.flipY();\n * ```\n *\n * @augments TempNode\n */\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\t/**\n\t * Constructs a new flip node.\n\t *\n\t * @param {Node} sourceNode - The node which component(s) should be flipped.\n\t * @param {String} components - The components that should be flipped e.g. `'x'` or `'xy'`.\n\t */\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which component(s) should be flipped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be flipped e.g. `'x'` or `'xy'`.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.components = components;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the source node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\n/**\n * Base class for representing data input nodes.\n *\n * @augments Node\n */\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {Any} value - The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInputNode = true;\n\n\t\t/**\n\t\t * The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t\t *\n\t\t * @type {Any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * The precision of the value in the shader.\n\t\t *\n\t\t * @type {('low'|'medium'|'high')?}\n\t\t * @default null\n\t\t */\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the input type of the node which is by default the node type. Derived modules\n\t * might overwrite this method and use a fixed type or compute one analytically.\n\t *\n\t * A typical example for different input and node types are textures. The input type of a\n\t * normal RGBA texture is `texture` whereas its node type is `vec4`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Sets the precision to the given value. The method can be\n\t * overwritten in derived classes if the final precision must be computed\n\t * analytically.\n\t *\n\t * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.\n\t * @return {InputNode} A reference to this node.\n\t */\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\n/**\n * Class for representing a constant value in the shader.\n *\n * @augments InputNode\n */\nclass ConstNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'ConstNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).\n\t * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isConstNode = true;\n\n\t}\n\n\t/**\n\t * Generates the shader string of the value with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateConst( builder ) {\n\n\t\treturn builder.generateConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\n//\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\nfunction addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\tconsole.warn( `Redefinition of method chaining ${ name }` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( node.isStackNode !== true && prop === 'assign' ) {\n\n\t\t\t\treturn ( ...params ) => {\n\n\t\t\t\t\tcurrentStack.assign( nodeObj, ...params );\n\n\t\t\t\t\treturn nodeObj;\n\n\t\t\t\t};\n\n\t\t\t} else if ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( nodeObj, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, value ) );\n\n\t\t\t} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\t\t\t\tprop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );\n\n\t\t\t\treturn () => nodeObject( new FlipNode( nodeObject( node ), prop ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.get( node, prop, nodeObj );\n\n\t},\n\n\tset( node, prop, value, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\t// setting properties\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\tnodeObj[ prop ].assign( value );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Reflect.set( node, prop, value, nodeObj );\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\t\tif ( properties.onceOutput ) return properties.onceOutput;\n\n\t\t//\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tif ( builder.currentFunctionNode !== null ) {\n\n\t\t\t\tbuilder.currentFunctionNode.includes.push( functionNode );\n\n\t\t\t}\n\n\t\t\tresult = nodeObject( functionNode.call( inputNodes ) );\n\n\t\t} else {\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties.onceOutput = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode === null ) {\n\n\t\t\tproperties.outputNode = this.setupOutput( builder );\n\n\t\t}\n\n\t\treturn properties.outputNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\treturn this.getOutputNode( builder );\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\treturn outputNode.build( builder, output );\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\tnodeObjects( inputs );\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst safeGetNodeType = ( node ) => {\n\n\ttry {\n\n\t\treturn node.getNodeType();\n\n\t} catch ( _ ) {\n\n\t\treturn undefined;\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nconst defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nfunction ShaderNode( jsFunc, nodeType ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );\n\n}\n\nconst nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nconst nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nconst nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nconst nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );\nconst nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );\n\nconst Fn = ( jsFunc, nodeType ) => {\n\n\tconst shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\tconst fn = ( ...params ) => {\n\n\t\tlet inputs;\n\n\t\tnodeObjects( params );\n\n\t\tif ( params[ 0 ] && params[ 0 ].isNode ) {\n\n\t\t\tinputs = [ ...params ];\n\n\t\t} else {\n\n\t\t\tinputs = params[ 0 ];\n\n\t\t}\n\n\t\treturn shaderNode.call( inputs );\n\n\t};\n\n\tfn.shaderNode = shaderNode;\n\n\tfn.setLayout = ( layout ) => {\n\n\t\tshaderNode.setLayout( layout );\n\n\t\treturn fn;\n\n\t};\n\n\tfn.once = () => {\n\n\t\tshaderNode.once = true;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\nconst tslFn = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );\n\treturn Fn( ...params );\n\n};\n\n//\n\naddMethodChaining( 'toGlobal', ( node ) => {\n\n\tnode.global = true;\n\n\treturn node;\n\n} );\n\n//\n\nconst setCurrentStack = ( stack ) => {\n\n\tcurrentStack = stack;\n\n};\n\nconst getCurrentStack = () => currentStack;\n\nconst If = ( ...params ) => currentStack.If( ...params );\n\nfunction append( node ) {\n\n\tif ( currentStack ) currentStack.add( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'append', append );\n\n// types\n\nconst color = new ConvertType( 'color' );\n\nconst float = new ConvertType( 'float', cacheMaps.float );\nconst int = new ConvertType( 'int', cacheMaps.ints );\nconst uint = new ConvertType( 'uint', cacheMaps.uint );\nconst bool = new ConvertType( 'bool', cacheMaps.bool );\n\nconst vec2 = new ConvertType( 'vec2' );\nconst ivec2 = new ConvertType( 'ivec2' );\nconst uvec2 = new ConvertType( 'uvec2' );\nconst bvec2 = new ConvertType( 'bvec2' );\n\nconst vec3 = new ConvertType( 'vec3' );\nconst ivec3 = new ConvertType( 'ivec3' );\nconst uvec3 = new ConvertType( 'uvec3' );\nconst bvec3 = new ConvertType( 'bvec3' );\n\nconst vec4 = new ConvertType( 'vec4' );\nconst ivec4 = new ConvertType( 'ivec4' );\nconst uvec4 = new ConvertType( 'uvec4' );\nconst bvec4 = new ConvertType( 'bvec4' );\n\nconst mat2 = new ConvertType( 'mat2' );\nconst mat3 = new ConvertType( 'mat3' );\nconst mat4 = new ConvertType( 'mat4' );\n\nconst string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nconst arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nconst element = /*@__PURE__*/ nodeProxy( ArrayElementNode );\nconst convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nconst split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\n/** @module UniformGroupNode **/\n\n/**\n * This node can be used to group single instances of {@link UniformNode}\n * and manage them as a uniform buffer.\n *\n * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`\n * will be used when defining the {@link UniformNode#groupNode} property.\n *\n * - `objectGroup`: Uniform buffer per object.\n * - `renderGroup`: Shared uniform buffer, updated once per render call.\n * - `frameGroup`: Shared uniform buffer, updated once per frame.\n *\n * @augments Node\n */\nclass UniformGroupNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'UniformGroupNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform group node.\n\t *\n\t * @param {String} name - The name of the uniform group node.\n\t * @param {Boolean} [shared=false] - Whether this uniform group node is shared or not.\n\t * @param {Number} [order=1] - Influences the internal sorting.\n\t */\n\tconstructor( name, shared = false, order = 1 ) {\n\n\t\tsuper( 'string' );\n\n\t\t/**\n\t\t * The name of the uniform group node.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this uniform group node is shared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shared = shared;\n\n\t\t/**\n\t\t * Influences the internal sorting.\n\t\t * TODO: Add details when this property should be changed.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.order = order;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformGroup = true;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.name = this.name;\n\t\tdata.version = this.version;\n\t\tdata.shared = this.shared;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.name = data.name;\n\t\tthis.version = data.version;\n\t\tthis.shared = data.shared;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a uniform group node with the given name.\n *\n * @function\n * @param {String} name - The name of the uniform group node.\n * @returns {UniformGroupNode}\n */\nconst uniformGroup = ( name ) => new UniformGroupNode( name );\n\n/**\n * TSL function for creating a shared uniform group node with the given name and order.\n *\n * @function\n * @param {String} name - The name of the uniform group node.\n * @param {Number} [order=0] - Influences the internal sorting.\n * @returns {UniformGroupNode}\n */\nconst sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per frame.\n *\n * @type {UniformGroupNode}\n */\nconst frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per render.\n *\n * @type {UniformGroupNode}\n */\nconst renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );\n\n/**\n * TSL object that represents a uniform group node which is updated once per object.\n *\n * @type {UniformGroupNode}\n */\nconst objectGroup = /*@__PURE__*/ uniformGroup( 'object' );\n\n/** @module UniformNode **/\n\n/**\n * Class for representing a uniform.\n *\n * @augments InputNode\n */\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform node.\n\t *\n\t * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n\t * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformNode = true;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The uniform group of this uniform. By default, uniforms are\n\t\t * managed per object but they might belong to a shared group\n\t\t * which is updated per frame or render call.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @param {String} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#groupNode} property.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the {@link UniformNode#groupNode}.\n\t *\n\t * @return {UniformGroupNode} The uniform group.\n\t */\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\t/**\n\t * By default, this method returns the result of {@link Node#getHash} but derived\n\t * classes might overwrite this method with a different implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The uniform hash.\n\t */\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tconst self = this.getSelf();\n\n\t\tcallback = callback.bind( self );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, self );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.label !== undefined ) delete builder.context.label;\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a uniform node.\n *\n * @function\n * @param {Any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n * @param {String?} arg2 - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n * @returns {UniformNode}\n */\nconst uniform = ( arg1, arg2 ) => {\n\n\tconst nodeType = getConstNodeType( arg2 || arg1 );\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tconst value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\n/** @module PropertyNode **/\n\n/**\n * This class represents a shader property. It can be used\n * to explicitly define a property and assign a value to it.\n *\n * ```js\n * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );\n *```\n * `PropertyNode` is used by the engine to predefined common material properties\n * for TSL code.\n *\n * @augments Node\n */\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\t/**\n\t * Constructs a new property node.\n\t *\n\t * @param {String} nodeType - The type of the node.\n\t * @param {String?} [name=null] - The name of the property in the shader.\n\t * @param {Boolean} [varying=false] - Whether this property is a varying or not.\n\t */\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The name of the property in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this property is a varying or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.varying = varying;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPropertyNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a property node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} [name=null] - The name of the property in the shader.\n * @returns {PropertyNode}\n */\nconst property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\n\n/**\n * TSL function for creating a varying property node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} [name=null] - The name of the varying in the shader.\n * @returns {PropertyNode}\n */\nconst varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\n/**\n * TSL object that represents the shader variable `DiffuseColor`.\n *\n * @type {PropertyNode<vec4>}\n */\nconst diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\n\n/**\n * TSL object that represents the shader variable `EmissiveColor`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\n\n/**\n * TSL object that represents the shader variable `Roughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\n\n/**\n * TSL object that represents the shader variable `Metalness`.\n *\n * @type {PropertyNode<float>}\n */\nconst metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\n\n/**\n * TSL object that represents the shader variable `Clearcoat`.\n *\n * @type {PropertyNode<float>}\n */\nconst clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\n\n/**\n * TSL object that represents the shader variable `ClearcoatRoughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\n\n/**\n * TSL object that represents the shader variable `Sheen`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\n\n/**\n * TSL object that represents the shader variable `SheenRoughness`.\n *\n * @type {PropertyNode<float>}\n */\nconst sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\n\n/**\n * TSL object that represents the shader variable `Iridescence`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\n\n/**\n * TSL object that represents the shader variable `IridescenceIOR`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\n\n/**\n * TSL object that represents the shader variable `IridescenceThickness`.\n *\n * @type {PropertyNode<float>}\n */\nconst iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\n\n/**\n * TSL object that represents the shader variable `AlphaT`.\n *\n * @type {PropertyNode<float>}\n */\nconst alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\n\n/**\n * TSL object that represents the shader variable `Anisotropy`.\n *\n * @type {PropertyNode<float>}\n */\nconst anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyT`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyB`.\n *\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\n\n/**\n * TSL object that represents the shader variable `SpecularColor`.\n *\n * @type {PropertyNode<color>}\n */\nconst specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\n\n/**\n * TSL object that represents the shader variable `SpecularF90`.\n *\n * @type {PropertyNode<float>}\n */\nconst specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\n\n/**\n * TSL object that represents the shader variable `Shininess`.\n *\n * @type {PropertyNode<float>}\n */\nconst shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\n\n/**\n * TSL object that represents the shader variable `Output`.\n *\n * @type {PropertyNode<vec4>}\n */\nconst output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\n\n/**\n * TSL object that represents the shader variable `dashSize`.\n *\n * @type {PropertyNode<float>}\n */\nconst dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\n\n/**\n * TSL object that represents the shader variable `gapSize`.\n *\n * @type {PropertyNode<float>}\n */\nconst gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\n\n/**\n * TSL object that represents the shader variable `pointWidth`.\n *\n * @type {PropertyNode<float>}\n */\nconst pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\n\n/**\n * TSL object that represents the shader variable `IOR`.\n *\n * @type {PropertyNode<float>}\n */\nconst ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\n\n/**\n * TSL object that represents the shader variable `Transmission`.\n *\n * @type {PropertyNode<float>}\n */\nconst transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\n\n/**\n * TSL object that represents the shader variable `Thickness`.\n *\n * @type {PropertyNode<float>}\n */\nconst thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\n\n/**\n * TSL object that represents the shader variable `AttenuationDistance`.\n *\n * @type {PropertyNode<float>}\n */\nconst attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\n\n/**\n * TSL object that represents the shader variable `AttenuationColor`.\n *\n * @type {PropertyNode<color>}\n */\nconst attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\n\n/**\n * TSL object that represents the shader variable `Dispersion`.\n *\n * @type {PropertyNode<float>}\n */\nconst dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n\n/** @module AssignNode **/\n\n/**\n * These node represents an assign operation. Meaning a node is assigned\n * to another node.\n *\n * @augments TempNode\n */\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\t/**\n\t * Constructs a new assign node.\n\t *\n\t * @param {Node} targetNode - The target node.\n\t * @param {Node} sourceNode - The source type.\n\t */\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The target node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t\t/**\n\t\t * The source node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes. This method\n\t * is overwritten since it always returns `false` (assigns are unique).\n\t *\n\t * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.\n\t */\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\t/**\n\t * Whether a split is required when assigning source to target. This can happen when the component length of\n\t * target and source data type does not match.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether a split is required when assigning source to target.\n\t */\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDifferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst target = targetNode.context( { assign: true } ).build( builder );\n\t\tconst source = sourceNode.build( builder, targetType );\n\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst targetRoot = targetNode.node.context( { assign: true } ).build( builder );\n\n\t\t\tfor ( let i = 0; i < targetNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = targetNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an assign node.\n *\n * @function\n * @param {Node} targetNode - The target node.\n * @param {Node} sourceNode - The source type.\n * @returns {AssignNode}\n */\nconst assign = /*@__PURE__*/ nodeProxy( AssignNode );\n\naddMethodChaining( 'assign', assign );\n\n/**\n * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted\n * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate\n * this logic.\n *\n * @augments TempNode\n */\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function call node.\n\t *\n\t * @param {FunctionNode?} functionNode - The function node.\n\t * @param {Object<String, Node>} [parameters={}] - The parameters for the function call.\n\t */\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The function node.\n\t\t *\n\t\t * @type {FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.functionNode = functionNode;\n\n\t\t/**\n\t\t * The parameters of the function call.\n\t\t *\n\t\t * @type {Object<String, Node>}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t}\n\n\t/**\n\t * Sets the parameters of the function call node.\n\t *\n\t * @param {Object<String, Node>} parameters - The parameters to set.\n\t * @return {FunctionCallNode} A reference to this node.\n\t */\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the parameters of the function call node.\n\t *\n\t * @return {Object<String, Node>} The parameters of this node.\n\t */\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${functionName}( ${params.join( ', ' )} )`;\n\n\t}\n\n}\n\nconst call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn nodeObject( new FunctionCallNode( nodeObject( func ), params ) );\n\n};\n\naddMethodChaining( 'call', call );\n\n/** @module OperatorNode **/\n\n/**\n * This node represents basic mathematical and logical operations like addition,\n * subtraction or comparisons (e.g. `equal()`).\n *\n * @augments TempNode\n */\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new operator node.\n\t *\n\t * @param {String} op - The operator.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node} bNode - The second input.\n\t * @param {...Node} params - Additional input parameters.\n\t */\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\t/**\n\t\t * The operator.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.op = op;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the operator\n\t * and the input node types.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output string.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\treturn typeB;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '<' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } < ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } <= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } > ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>=' && outputLength > 1 ) {\n\n\t\t\t\tif ( builder.useComparisonMethod ) {\n\n\t\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `( ${ a } >= ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\n/**\n * Returns the addition of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );\n\n/**\n * Returns the subtraction of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );\n\n/**\n * Returns the multiplication of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );\n\n/**\n * Returns the division of two or more value.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );\n\n/**\n * Computes the remainder of dividing the first node by the second, for integer values.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );\n\n/**\n * Checks if two nodes are equal.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );\n\n/**\n * Checks if two nodes are not equal.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );\n\n/**\n * Checks if the first node is less than the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );\n\n/**\n * Checks if the first node is greater than the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );\n\n/**\n * Checks if the first node is less than or equal to the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );\n\n/**\n * Checks if the first node is greater than or equal to the second.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );\n\n/**\n * Performs logical AND on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );\n\n/**\n * Performs logical OR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );\n\n/**\n * Performs logical NOT on a node.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );\n\n/**\n * Performs logical XOR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );\n\n/**\n * Performs bitwise AND on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );\n\n/**\n * Performs bitwise NOT on a node.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );\n\n/**\n * Performs bitwise OR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );\n\n/**\n * Performs bitwise XOR on two nodes.\n *\n * @function\n * @param {Node} aNode - The first input.\n * @param {Node} bNode - The second input.\n * @returns {OperatorNode}\n */\nconst bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );\n\n/**\n * Shifts a node to the left.\n *\n * @function\n * @param {Node} aNode - The node to shift.\n * @param {Node} bNode - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );\n\n/**\n * Shifts a node to the right.\n *\n * @function\n * @param {Node} aNode - The node to shift.\n * @param {Node} bNode - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'modInt', modInt );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\n\nconst remainder = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );\n\treturn modInt( ...params );\n\n};\n\naddMethodChaining( 'remainder', remainder );\n\n/** @module MathNode **/\n\n/**\n * This node represents a variety of mathematical methods available in shaders.\n * They are divided into three categories:\n *\n * - Methods with one input like `sin`, `cos` or `normalize`.\n * - Methods with two inputs like `dot`, `cross` or `pow`.\n * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.\n *\n * @augments TempNode\n */\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\t/**\n\t * Constructs a new math node.\n\t *\n\t * @param {String} method - The method name.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node?} [bNode=null] - The second input.\n\t * @param {Node?} [cNode=null] - The third input.\n\t */\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The method name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * The third input.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.cNode = cNode;\n\n\t}\n\n\t/**\n\t * The input type is inferred from the node types of the input nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\t/**\n\t * The selected method as well as the input type determine the node type of this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else if ( method === MathNode.MOD ) {\n\n\t\t\treturn this.aNode.getNodeType( builder );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst coordinateSystem = builder.renderer.coordinateSystem;\n\n\t\tif ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\treturn normalize( mulNode ).build( builder, output );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.ONE_MINUS ) {\n\n\t\t\treturn sub( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\treturn div( 1.0, a ).build( builder, output );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\treturn abs( sub( a, b ) ).build( builder, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( coordinateSystem === WebGLCoordinateSystem && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null ) {\n\n\t\t\t\t\tmethod = 'atan2';\n\n\t\t\t\t}\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.TRANSPOSE = 'transpose';\n\n// 2 inputs\n\nMathNode.BITCAST = 'bitcast';\nMathNode.EQUALS = 'equals';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.MOD = 'mod';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\n// 1 inputs\n\n/**\n * A small value used to handle floating-point precision errors.\n *\n * @type {Node<float>}\n */\nconst EPSILON = /*@__PURE__*/ float( 1e-6 );\n\n/**\n * Represents infinity.\n *\n * @type {Node<float>}\n */\nconst INFINITY = /*@__PURE__*/ float( 1e6 );\n\n/**\n * Represents PI.\n *\n * @type {Node<float>}\n */\nconst PI = /*@__PURE__*/ float( Math.PI );\n\n/**\n * Represents PI * 2.\n *\n * @type {Node<float>}\n */\nconst PI2 = /*@__PURE__*/ float( Math.PI * 2 );\n\n/**\n * Returns `true` if all components of `x` are `true`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );\n\n/**\n * Returns `true` if any components of `x` are `true`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );\n\n/**\n * Converts a quantity in degrees to radians.\n *\n * @function\n * @param {Node | Number} x - The input in degrees.\n * @returns {Node}\n */\nconst radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );\n\n/**\n * Convert a quantity in radians to degrees.\n *\n * @function\n * @param {Node | Number} x - The input in radians.\n * @returns {Node}\n */\nconst degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );\n\n/**\n * Returns the natural exponentiation of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );\n\n/**\n * Returns 2 raised to the power of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );\n\n/**\n * Returns the natural logarithm of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );\n\n/**\n * Returns the base 2 logarithm of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );\n\n/**\n * Returns the square root of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );\n\n/**\n * Returns the inverse of the square root of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );\n\n/**\n * Finds the nearest integer less than or equal to the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );\n\n/**\n * Finds the nearest integer that is greater than or equal to the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );\n\n/**\n * Calculates the unit vector in the same direction as the original vector.\n *\n * @function\n * @param {Node} x - The input vector.\n * @returns {Node}\n */\nconst normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );\n\n/**\n * Computes the fractional part of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );\n\n/**\n * Returns the sine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );\n\n/**\n * Returns the cosine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );\n\n/**\n * Returns the tangent of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );\n\n/**\n * Returns the arcsine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );\n\n/**\n * Returns the arccosine of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );\n\n/**\n * Returns the arc-tangent of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );\n\n/**\n * Returns the absolute value of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );\n\n/**\n * Extracts the sign of the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );\n\n/**\n * Calculates the length of a vector.\n *\n * @function\n * @param {Node} x - The parameter.\n * @returns {Node<float>}\n */\nconst length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );\n\n/**\n * Negates the value of the parameter (-x).\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );\n\n/**\n * Return `1` minus the parameter.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );\n\n/**\n * Returns the partial derivative of the parameter with respect to x.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );\n\n/**\n * Returns the partial derivative of the parameter with respect to y.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );\n\n/**\n * Rounds the parameter to the nearest integer.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );\n\n/**\n * Returns the reciprocal of the parameter `(1/x)`.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );\n\n/**\n * Truncates the parameter, removing the fractional part.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );\n\n/**\n * Returns the sum of the absolute derivatives in x and y.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @returns {Node}\n */\nconst fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );\n\n/**\n * Returns the transpose of a matrix.\n *\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node}\n */\nconst transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );\n\n// 2 inputs\n\n/**\n * Reinterpret the bit representation of a value in one type as a value in another type.\n *\n * @function\n * @param {Node | Number} x - The parameter.\n * @param {String} y - The new type.\n * @returns {Node}\n */\nconst bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );\n\n/**\n * Returns `true` if `x` equals `y`.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node<bool>}\n */\nconst equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );\n\n/**\n * Returns the lesser of two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );\n\n/**\n * Returns the greater of two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );\n\n/**\n * Computes the remainder of dividing the first node by the second one.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );\n\n/**\n * Generate a step function by comparing two values.\n *\n * @function\n * @param {Node | Number} x - The y parameter.\n * @param {Node | Number} y - The x parameter.\n * @returns {Node}\n */\nconst step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );\n\n/**\n * Calculates the reflection direction for an incident vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );\n\n/**\n * Calculates the distance between two points.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first point.\n * @param {Node<vec2|vec3|vec4>} y - The second point.\n * @returns {Node<float>}\n */\nconst distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );\n\n/**\n * Calculates the absolute difference between two values.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node}\n */\nconst difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );\n\n/**\n * Calculates the dot product of two vectors.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<float>}\n */\nconst dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );\n\n/**\n * Calculates the cross product of two vectors.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );\n\n/**\n * Return the value of the first parameter raised to the power of the second one.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @param {Node | Number} y - The second parameter.\n * @returns {Node}\n */\nconst pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );\n\n/**\n * Returns the square of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );\n\n/**\n * Returns the cube of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );\n\n/**\n * Returns the fourth power of the parameter.\n *\n * @function\n * @param {Node | Number} x - The first parameter.\n * @returns {Node}\n */\nconst pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );\n\n/**\n * Transforms the direction of a vector by a matrix and then normalizes the result.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} direction - The direction vector.\n * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.\n * @returns {Node}\n */\nconst transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );\n\n/**\n * Returns the cube root of a number.\n *\n * @function\n * @param {Node | Number} a - The first parameter.\n * @returns {Node}\n */\nconst cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\n\n/**\n * Calculate the squared length of a vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} a - The vector.\n * @returns {Node<float>}\n */\nconst lengthSq = ( a ) => dot( a, a );\n\n/**\n * Linearly interpolates between two values.\n *\n * @function\n * @param {Node | Number} a - The first parameter.\n * @param {Node | Number} b - The second parameter.\n * @param {Node | Number} t - The interpolation value.\n * @returns {Node}\n */\nconst mix = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );\n\n/**\n * Constrains a value to lie between two further values.\n *\n * @function\n * @param {Node | Number} value - The value to constrain.\n * @param {Node | Number} [low=0] - The lower bound.\n * @param {Node | Number} [high=1] - The upper bound.\n * @returns {Node}\n */\nconst clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\n\n/**\n * Constrains a value between `0` and `1`.\n *\n * @function\n * @param {Node | Number} value - The value to constrain.\n * @returns {Node}\n */\nconst saturate = ( value ) => clamp( value );\n\n/**\n * Calculates the refraction direction for an incident vector.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @param {Node<float>} eta - The the ratio of indices of refraction.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );\n\n/**\n * Performs a Hermite interpolation between two values.\n *\n * @function\n * @param {Node | Number} low - The value of the lower edge of the Hermite function.\n * @param {Node | Number} high - The value of the upper edge of the Hermite function.\n * @param {Node | Number} x - The source value for interpolation.\n * @returns {Node}\n */\nconst smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );\n\n/**\n * Returns a vector pointing in the same direction as another.\n *\n * @function\n * @param {Node<vec2|vec3|vec4>} N - The vector to orient.\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );\n\n/**\n * Returns a random value for the given uv.\n *\n * @function\n * @param {Node<vec2>} uv - The uv node.\n * @returns {Node<float>}\n */\nconst rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\n/**\n * Alias for `mix()` with a different parameter order.\n *\n * @function\n * @param {Node | Number} t - The interpolation value.\n * @param {Node | Number} e1 - The first parameter.\n * @param {Node | Number} e2 - The second parameter.\n * @returns {Node}\n */\nconst mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\n\n/**\n * Alias for `smoothstep()` with a different parameter order.\n *\n * @function\n * @param {Node | Number} x - The source value for interpolation.\n * @param {Node | Number} low - The value of the lower edge of the Hermite function.\n * @param {Node | Number} high - The value of the upper edge of the Hermite function.\n * @returns {Node}\n */\nconst smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\n/**\n * Returns the arc-tangent of the quotient of its parameters.\n *\n * @function\n * @param {Node | Number} y - The y parameter.\n * @param {Node | Number} x - The x parameter.\n * @returns {Node}\n */\nconst atan2 = ( y, x ) => { // @deprecated, r172\n\n\tconsole.warn( 'THREE.TSL: \"atan2\" is overloaded. Use \"atan\" instead.' );\n\treturn atan( y, x );\n\n};\n\n// GLSL alias function\n\nconst faceforward = faceForward;\nconst inversesqrt = inverseSqrt;\n\n// Method chaining\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min$1 );\naddMethodChaining( 'max', max$1 );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'step', step );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'rand', rand );\n\n/** @module ConditionalNode **/\n\n/**\n * Represents a logical `if/else` statement. Can be used as an alternative\n * to the `If()`/`Else()` syntax.\n *\n * The corresponding TSL `select()` looks like so:\n * ```js\n * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );\n * ```\n * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`\n * determine the outcome of the entire statement.\n *\n * @augments Node\n */\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional node.\n\t *\n\t * @param {Node} condNode - The node that defines the condition.\n\t * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n\t * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n\t */\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that defines the condition.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.condNode = condNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `true`.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.ifNode = ifNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `false`.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the if/else\n\t * nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tif ( ifNode === undefined ) {\n\n\t\t\t// fallback setup\n\n\t\t\tthis.setup( builder );\n\n\t\t\treturn this.getNodeType( builder );\n\n\t\t}\n\n\t\tconst ifType = ifNode.getNodeType( builder );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tconst elseType = elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode.cache();\n\t\tconst ifNode = this.ifNode.cache();\n\t\tconst elseNode = this.elseNode ? this.elseNode.cache() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a conditional node.\n *\n * @function\n * @param {Node} condNode - The node that defines the condition.\n * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n * @returns {ConditionalNode}\n */\nconst select = /*@__PURE__*/ nodeProxy( ConditionalNode );\n\naddMethodChaining( 'select', select );\n\n//\n\nconst cond = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );\n\treturn select( ...params );\n\n};\n\naddMethodChaining( 'cond', cond );\n\n/** @module ContextNode **/\n\n/**\n * This node can be used as a context management component for another node.\n * {@link NodeBuilder} performs its node building process in a specific context and\n * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:\n *\n * ```js\n *node.context( { getUV: () => customCoord } );\n *```\n * @augments Node\n */\nclass ContextNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new context node.\n\t *\n\t * @param {Node} node - The node whose context should be modified.\n\t * @param {Object} [value={}] - The modified context data.\n\t */\n\tconstructor( node, value = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isContextNode = true;\n\n\t\t/**\n\t\t * The node whose context should be modified.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The modified context data.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the reference to {@link module:ContextNode~ContextNode#node}.\n\t *\n\t * @return {Node} A reference to {@link module:ContextNode~ContextNode#node}.\n\t */\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the type of {@link module:ContextNode~ContextNode#node}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.node.build( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst node = this.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn node;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( { ...builder.context, ...this.value } );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a context node.\n *\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {Object} [value={}] - The modified context data.\n * @returns {ContextNode}\n */\nconst context = /*@__PURE__*/ nodeProxy( ContextNode );\n\n/**\n * TSL function for defining a label context value for a given node.\n *\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {String} name - The name/label to set.\n * @returns {ContextNode}\n */\nconst label = ( node, name ) => context( node, { label: name } );\n\naddMethodChaining( 'context', context );\naddMethodChaining( 'label', label );\n\n/** @module VarNode **/\n\n/**\n * Class for representing shader variables as nodes. Variables are created from\n * existing nodes like the following:\n *\n * ```js\n * const depth = sampleDepth( uvNode ).toVar( 'depth' );\n * ```\n *\n * @augments Node\n */\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\t/**\n\t * Constructs a new variable node.\n\t *\n\t * @param {Node} node - The node for which a variable should be created.\n\t * @param {String?} name - The name of the variable in the shader.\n\t */\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a variable should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the variable in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * `VarNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVarNode = true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name } = this;\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tconst snippet = node.build( builder, nodeVar.type );\n\n\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a var node.\n *\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {String?} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\naddMethodChaining( 'toVar', ( ...params ) => createVar( ...params ).append() );\n\n// Deprecated\n\nconst temp = ( node ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: \"temp\" is deprecated. Use \".toVar()\" instead.' );\n\n\treturn createVar( node );\n\n};\n\naddMethodChaining( 'temp', temp );\n\n/** @module VaryingNode **/\n\n/**\n * Class for representing shader varyings as nodes. Varyings are create from\n * existing nodes like the following:\n *\n * ```js\n * const positionLocal = positionGeometry.varying( 'vPositionLocal' );\n * ```\n *\n * @augments Node\n */\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new varying node.\n\t *\n\t * @param {Node} node - The node for which a varying should be created.\n\t * @param {String?} name - The name of the varying in the shader.\n\t */\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a varying should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the varying in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVaryingNode = true;\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method performs the setup of a varying node with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeVarying} The node varying from the node builder.\n\t */\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type );\n\t\t\tproperties.node = this.node;\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\treturn this.node.analyze( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tconst needsReassign = builder.shaderStage === 'fragment' && properties.reassignPosition === true && builder.context.needsPositionReassign;\n\n\t\tif ( properties.propertyName === undefined || needsReassign ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );\n\n\t\t\tproperties.propertyName = propertyName;\n\n\t\t\tif ( needsReassign ) {\n\n\t\t\t\t// once reassign varying in fragment stage\n\t\t\t\tproperties.reassignPosition = false;\n\n\t\t\t} else if ( properties.reassignPosition === undefined && builder.context.isPositionNodeInput ) {\n\n\t\t\t\tproperties.reassignPosition = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a varying node.\n *\n * @function\n * @param {Node} node - The node for which a varying should be created.\n * @param {String?} name - The name of the varying in the shader.\n * @returns {VaryingNode}\n */\nconst varying = /*@__PURE__*/ nodeProxy( VaryingNode );\n\n/**\n * Computes a node in the vertex stage.\n *\n * @function\n * @param {Node} node - The node which should be executed in the vertex stage.\n * @returns {VaryingNode}\n */\nconst vertexStage = ( node ) => varying( node );\n\naddMethodChaining( 'varying', varying );\naddMethodChaining( 'vertexStage', vertexStage );\n\n/** @module ColorSpaceFunctions **/\n\n/**\n * Converts the given color value from sRGB to linear-sRGB color space.\n *\n * @method\n * @param {Node<vec3>} color - The sRGB color.\n * @return {Node<vec3>} The linear-sRGB color.\n */\nconst sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = color.mul( 0.0773993808 );\n\tconst factor = color.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferEOTF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\n/**\n * Converts the given color value from linear-sRGB to sRGB color space.\n *\n * @method\n * @param {Node<vec3>} color - The linear-sRGB color.\n * @return {Node<vec3>} The sRGB color.\n */\nconst sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = color.mul( 12.92 );\n\tconst factor = color.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferOETF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\n/** @module ColorSpaceNode **/\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\n/**\n * This node represents a color space conversion. Meaning it converts\n * a color value from a source to a target color space.\n *\n * @augments TempNode\n */\nclass ColorSpaceNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ColorSpaceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new color space node.\n\t *\n\t * @param {Node} colorNode - Represents the color to convert.\n\t * @param {String} source - The source color space.\n\t * @param {String} target - The target color space.\n\t */\n\tconstructor( colorNode, source, target ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * Represents the color to convert.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The source color space.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.source = source;\n\n\t\t/**\n\t\t * The target color space.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.target = target;\n\n\t}\n\n\t/**\n\t * This method resolves the constants `WORKING_COLOR_SPACE` and\n\t * `OUTPUT_COLOR_SPACE` based on the current configuration of the\n\t * color management and renderer.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} colorSpace - The color space to resolve.\n\t * @return {String} The resolved color space.\n\t */\n\tresolveColorSpace( builder, colorSpace ) {\n\n\t\tif ( colorSpace === WORKING_COLOR_SPACE ) {\n\n\t\t\treturn ColorManagement.workingColorSpace;\n\n\t\t} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {\n\n\t\t\treturn builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode } = this;\n\n\t\tconst source = this.resolveColorSpace( builder, this.source );\n\t\tconst target = this.resolveColorSpace( builder, this.target );\n\n\t\tlet outputNode = colorNode;\n\n\t\tif ( ColorManagement.enabled === false || source === target || ! source || ! target ) {\n\n\t\t\treturn outputNode;\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\tif ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {\n\n\t\t\toutputNode = vec4(\n\t\t\t\tmat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),\n\t\t\t\toutputNode.a\n\t\t\t);\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for converting a given color node to the current output color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @returns {ColorSpaceNode}\n */\nconst toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node to the current working color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @returns {ColorSpaceNode}\n */\nconst toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node from the current working color space to the given color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} colorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );\n\n/**\n * TSL function for converting a given color node from the given color space to the current working color space.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} colorSpace - The source color space.\n * @returns {ColorSpaceNode}\n */\nconst colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node from one color space to another one.\n *\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {String} sourceColorSpace - The source color space.\n * @param {String} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );\n\naddMethodChaining( 'toOutputColorSpace', toOutputColorSpace );\naddMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );\n\naddMethodChaining( 'workingToColorSpace', workingToColorSpace );\naddMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/** @module ReferenceBaseNode **/\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {Node?} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link module:ReferenceBaseNode~ReferenceBaseNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n};\n\n/**\n * Base class for nodes which establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference base node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {Object?} [object=null] - The object the property belongs to.\n\t * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceBaseNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {String} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType ).getSelf();\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {Any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link module:ReferenceBaseNode~ReferenceBaseNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference base node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nconst reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\n/** @module RendererReferenceNode **/\n\n/**\n * This node is a special type of reference node which is intended\n * for linking renderer properties with node values.\n * ```js\n * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );\n * ```\n * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will\n * automatically be updated.\n *\n * @augments ReferenceBaseNode\n */\nclass RendererReferenceNode extends ReferenceBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'RendererReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new renderer reference node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} inputType - The uniform type that should be used to represent the property value.\n\t * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n\t * the node refers to the renderer of the current state.\n\t */\n\tconstructor( property, inputType, renderer = null ) {\n\n\t\tsuper( property, inputType, renderer );\n\n\t\t/**\n\t\t * The renderer the property belongs to. When no renderer is set,\n\t\t * the node refers to the renderer of the current state.\n\t\t *\n\t\t * @type {Renderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis.setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link module:RendererReferenceNode~RendererReferenceNode#renderer} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.renderer !== null ? this.renderer : state.renderer;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a renderer reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n * the node refers to the renderer of the current state.\n * @returns {RendererReferenceNode}\n */\nconst rendererReference = ( name, type, renderer = null ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );\n\n/** @module ToneMappingNode **/\n\n/**\n * This node represents a tone mapping operation.\n *\n * @augments TempNode\n */\nclass ToneMappingNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToneMappingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new tone mapping node.\n\t *\n\t * @param {Number} toneMapping - The tone mapping type.\n\t * @param {Node} exposureNode - The tone mapping exposure.\n\t * @param {Node} [colorNode=null] - The color node to process.\n\t */\n\tconstructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The tone mapping exposure.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.exposureNode = exposureNode;\n\n\t\t/**\n\t\t * Represents the color to process.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\t/**\n\t * Overwrites the default `customCacheKey()` implementation by including the tone\n\t * mapping type into the cache key.\n\t *\n\t * @return {Number} The hash.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn hash$1( this.toneMapping );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\t\tconst toneMapping = this.toneMapping;\n\n\t\tif ( toneMapping === NoToneMapping ) return colorNode;\n\n\t\tlet outputNode = null;\n\n\t\tconst toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );\n\n\t\tif ( toneMappingFn !== null ) {\n\n\t\t\toutputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a tone mapping node.\n *\n * @function\n * @param {Number} mapping - The tone mapping type.\n * @param {Node<float> | Number} exposure - The tone mapping exposure.\n * @param {Node<vec3> | Color} color - The color node to process.\n * @returns {ToneMappingNode<vec3>}\n */\nconst toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\n\n/**\n * TSL object that represents the global tone mapping exposure of the renderer.\n *\n * @type {RendererReferenceNode<vec3>}\n */\nconst toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );\n\naddMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );\n\n/** @module BufferAttributeNode **/\n\n/**\n * In earlier `three.js` versions it was only possible to define attribute data\n * on geometry level. With `BufferAttributeNode`, it is also possible to do this\n * on the node level.\n * ```js\n * const geometry = new THREE.PlaneGeometry();\n * const positionAttribute = geometry.getAttribute( 'position' );\n *\n * const colors = [];\n * for ( let i = 0; i < position.count; i ++ ) {\n * \tcolors.push( 1, 0, 0 );\n * }\n *\n * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );\n * ```\n * This new approach is especially interesting when geometry data are generated via\n * compute shaders. The below line converts a storage buffer into an attribute node.\n * ```js\n * material.positionNode = positionBuffer.toAttribute();\n * ```\n * @augments InputNode\n */\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer attribute node.\n\t *\n\t * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.\n\t * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {Number} [bufferStride=0] - The buffer stride.\n\t * @param {Number} [bufferOffset=0] - The buffer offset.\n\t */\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The buffer type (e.g. `'vec3'`).\n\t\t *\n\t\t * @type {String}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer stride.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferStride = bufferStride;\n\n\t\t/**\n\t\t * The buffer offset.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\t/**\n\t\t * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,\n\t\t * if you are planning to update the attribute data per frame.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * Whether the attribute is instanced or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.instanced = false;\n\n\t\t/**\n\t\t * A reference to the buffer attribute.\n\t\t *\n\t\t * @type {BufferAttribute?}\n\t\t * @default null\n\t\t */\n\t\tthis.attribute = null;\n\n\t\t/**\n\t\t * `BufferAttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the attribute data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the buffer attribute.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\t/**\n\t * Depending on which value was passed to the node, `setup()` behaves\n\t * differently. If no instance of `BufferAttribute` was passed, the method\n\t * creates an internal attribute and configures it respectively.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the buffer attribute node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\t/**\n\t * Sets the `usage` property to the given value.\n\t *\n\t * @param {Number} value - The usage to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the `instanced` property to the given value.\n\t *\n\t * @param {Number} value - The value to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a buffer attribute node.\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst bufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage.\n * Use this function if attribute data are updated per frame.\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst dynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\n/**\n * TSL function for creating a buffer attribute node but with enabled instancing\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing\n *\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [stride=0] - The buffer stride.\n * @param {Number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedDynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n\n/** @module ComputeNode **/\n\n/**\n * TODO\n *\n * @augments Node\n */\nclass ComputeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute node.\n\t *\n\t * @param {Node} computeNode - TODO\n\t * @param {Number} count - TODO.\n\t * @param {Array<Number>} [workgroupSize=[64]] - TODO.\n\t */\n\tconstructor( computeNode, count, workgroupSize = [ 64 ] ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputeNode = true;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.computeNode = computeNode;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Array<Number>}\n\t\t * @default [64]\n\t\t */\n\t\tthis.workgroupSize = workgroupSize;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.dispatchCount = 0;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = 1;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}\n\t\t * is executed once per object by default.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.onInitFunction = null;\n\n\t\tthis.updateDispatchCount();\n\n\t}\n\n\t/**\n\t * Executes the `dispose` event for this node.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Sets the {@link ComputeNode#name} property.\n\t *\n\t * @param {String} name - The name of the uniform.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * TODO\n\t */\n\tupdateDispatchCount() {\n\n\t\tconst { count, workgroupSize } = this;\n\n\t\tlet size = workgroupSize[ 0 ];\n\n\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\tsize *= workgroupSize[ i ];\n\n\t\tthis.dispatchCount = Math.ceil( count / size );\n\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * @param {Function} callback - TODO.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tonInit( callback ) {\n\n\t\tthis.onInitFunction = callback;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The method execute the compute for this node.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a compute node.\n *\n * @function\n * @param {Node} node - TODO\n * @param {Number} count - TODO.\n * @param {Array<Number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nconst compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );\n\naddMethodChaining( 'compute', compute );\n\n/** @module CacheNode **/\n\n/**\n * This node can be used as a cache management component for another node.\n * Caching is in general used by default in {@link NodeBuilder} but this node\n * allows the usage of a shared parent cache during the build process.\n *\n * @augments Node\n */\nclass CacheNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CacheNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cache node.\n\t *\n\t * @param {Node} node - The node that should be cached.\n\t * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t */\n\tconstructor( node, parent = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be cached.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Whether this node refers to a shared parent cache or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCacheNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst nodeType = this.node.getNodeType( builder );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn nodeType;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cache node.\n *\n * @function\n * @param {Node} node - The node that should be cached.\n * @param {Boolean} parent - Whether this node refers to a shared parent cache or not.\n * @returns {CacheNode}\n */\nconst cache = ( node, parent ) => nodeObject( new CacheNode( nodeObject( node ), parent ) );\n\naddMethodChaining( 'cache', cache );\n\n/** @module BypassNode **/\n\n/**\n * The class generates the code of a given node but returns another node in the output.\n * This can be used to call a method or node that does not return a value, i.e.\n * type `void` on an input where returning a value is required. Example:\n *\n * ```js\n * material.colorNode = myColor.bypass( runVoidFn() )\n *```\n *\n * @augments Node\n */\nclass BypassNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BypassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bypass node.\n\t *\n\t * @param {Node} outputNode - The output node.\n\t * @param {Node} callNode - The call node.\n\t */\n\tconstructor( outputNode, callNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBypassNode = true;\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * The call node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bypass node.\n *\n * @function\n * @param {Node} outputNode - The output node.\n * @param {Node} callNode - The call node.\n * @returns {BypassNode}\n */\nconst bypass = /*@__PURE__*/ nodeProxy( BypassNode );\n\naddMethodChaining( 'bypass', bypass );\n\n/** @module RemapNode **/\n\n/**\n * This node allows to remap a node value from one range into another. E.g a value of\n * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.\n * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.\n *\n * @augments Node\n */\nclass RemapNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RemapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new remap node.\n\t *\n\t * @param {Node} node - The node that should be remapped.\n\t * @param {Node} inLowNode - The source or current lower bound of the range.\n\t * @param {Node} inHighNode - The source or current upper bound of the range.\n\t * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n\t * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n\t */\n\tconstructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be remapped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The source or current lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inLowNode = inLowNode;\n\n\t\t/**\n\t\t * The source or current upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inHighNode = inHighNode;\n\n\t\t/**\n\t\t * The target lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(0)\n\t\t */\n\t\tthis.outLowNode = outLowNode;\n\n\t\t/**\n\t\t * The target upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(1)\n\t\t */\n\t\tthis.outHighNode = outHighNode;\n\n\t\t/**\n\t\t * Whether the node value should be clamped before\n\t\t * remapping it to the target range.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.doClamp = true;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );\n\n\t\tif ( doClamp === true ) t = t.clamp();\n\n\t\treturn t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a remap node.\n *\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );\n\n/**\n * TSL function for creating a remap node, but with enabled clamping.\n *\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );\n\naddMethodChaining( 'remap', remap );\naddMethodChaining( 'remapClamp', remapClamp );\n\n/** @module ExpressionNode **/\n\n/**\n * This class can be used to implement basic expressions in shader code.\n * Basic examples for that are `return`, `continue` or `discard` statements.\n *\n * @augments Node\n */\nclass ExpressionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ExpressionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new expression node.\n\t *\n\t * @param {String} [snippet=''] - The native code snippet.\n\t * @param {String} [nodeType='void'] - The node type.\n\t */\n\tconstructor( snippet = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The native code snippet.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.snippet = snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snippet = this.snippet;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t} else {\n\n\t\t\treturn builder.format( `( ${ snippet } )`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an expression node.\n *\n * @function\n * @param {String} [snippet=''] - The native code snippet.\n * @param {String} [nodeType='void'] - The node type.\n * @returns {ExpressionNode}\n */\nconst expression = /*@__PURE__*/ nodeProxy( ExpressionNode );\n\n/** @module Discard **/\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {ConditionalNode?} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.\n * @return {Node} The `discard` expression.\n */\nconst Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();\n\n/**\n * Represents a `return` shader operation in TSL.\n *\n * @method\n * @return {ExpressionNode} The `return` expression.\n */\nconst Return = () => expression( 'return' ).append();\n\naddMethodChaining( 'discard', Discard );\n\n/** @module RenderOutputNode **/\n\n/**\n * Normally, tone mapping and color conversion happens automatically\n * before outputting pixel too the default (screen) framebuffer. In certain\n * post processing setups this happens to late because certain effects\n * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used\n * to apply tone mapping and color space conversion at an arbitrary point\n * in the effect chain.\n *\n * When applying tone mapping and color space conversion manually with this node,\n * you have to set {@link PostProcessing#outputColorTransform} to `false`.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n * postProcessing.outputColorTransform = false;\n *\n * const scenePass = pass( scene, camera );\n * const outputPass = renderOutput( scenePass );\n *\n * postProcessing.outputNode = outputPass;\n * ```\n *\n * @augments TempNode\n */\nclass RenderOutputNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RenderOutputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new render output node.\n\t *\n\t * @param {Node} colorNode - The color node to process.\n\t * @param {Number} toneMapping - The tone mapping type.\n\t * @param {String} outputColorSpace - The output color space.\n\t */\n\tconstructor( colorNode, toneMapping, outputColorSpace ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The color node to process.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @type {Number?}\n\t\t */\n\t\tthis.toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The output color space.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.outputColorSpace = outputColorSpace;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderOutputNode = true;\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tlet outputNode = this.colorNode || context.color;\n\n\t\t// tone mapping\n\n\t\tconst toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;\n\t\tconst outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;\n\n\t\tif ( toneMapping !== NoToneMapping ) {\n\n\t\t\toutputNode = outputNode.toneMapping( toneMapping );\n\n\t\t}\n\n\t\t// working to output color space\n\n\t\tif ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {\n\n\t\t\toutputNode = outputNode.workingToColorSpace( outputColorSpace );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @function\n * @param {Node} color - The color node to process.\n * @param {Number?} [toneMapping=null] - The tone mapping type.\n * @param {String?} [outputColorSpace=null] - The output color space.\n * @returns {RenderOutputNode}\n */\nconst renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );\n\naddMethodChaining( 'renderOutput', renderOutput );\n\n// Non-PURE exports list, side-effects are required here.\n// TSL Base Syntax\n\n\nfunction addNodeElement( name/*, nodeElement*/ ) {\n\n\tconsole.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );\n\n}\n\n/** @module AttributeNode **/\n\n/**\n * Base class for representing shader attributes as nodes.\n *\n * @augments Node\n */\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new attribute node.\n\t *\n\t * @param {String} attributeName - The name of the attribute.\n\t * @param {String?} nodeType - The node type.\n\t */\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * `AttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Sets the attribute name to the given value. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {String} attributeName - The name of the attribute.\n\t * @return {AttributeNode} A reference to this node.\n\t */\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the attribute name of this node. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an attribute node.\n *\n * @function\n * @param {String} name - The name of the attribute.\n * @param {String?} nodeType - The node type.\n * @returns {AttributeNode}\n */\nconst attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );\n\n/** @module UV **/\n\n/**\n * TSL function for creating an uv attribute node with the given index.\n *\n * @function\n * @param {Number} [index=0] - The uv index.\n * @return {AttributeNode<vec2>} The uv attribute node.\n */\nconst uv = ( index = 0 ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );\n\n/** @module TextureSizeNode **/\n\n/**\n * A node that represents the dimensions of a texture. The texture size is\n * retrieved in the shader via built-in shader functions like `textureDimensions()`\n * or `textureSize()`.\n *\n * @augments Node\n */\nclass TextureSizeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TextureSizeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture size node.\n\t *\n\t * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n\t * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.\n\t */\n\tconstructor( textureNode, levelNode = null ) {\n\n\t\tsuper( 'uvec2' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureSizeNode = true;\n\n\t\t/**\n\t\t * A texture node which size should be retrieved.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * A level node which defines the requested mip.\n\t\t *\n\t\t * @type {Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst textureProperty = this.textureNode.build( builder, 'property' );\n\t\tconst level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );\n\n\t\treturn builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a texture size node.\n *\n * @function\n * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.\n * @returns {TextureSizeNode}\n */\nconst textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );\n\n/** @module MatcapUVNode **/\n\n/**\n * A special type of uniform node that computes the\n * maximum mipmap level for a given texture node.\n *\n * ```js\n * const level = maxMipLevel( textureNode );\n * ```\n *\n * @augments module:UniformNode~UniformNode\n */\nclass MaxMipLevelNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaxMipLevelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new max mip level node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 0 );\n\n\t\t/**\n\t\t * The texture node to compute the max mip level for.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * the texture once per frame in its {@link MaxMipLevelNode#update} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * The texture node to compute the max mip level for.\n\t *\n\t * @readonly\n\t * @type {TextureNode}\n\t */\n\tget textureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * The texture.\n\t *\n\t * @readonly\n\t * @type {Texture}\n\t */\n\tget texture() {\n\n\t\treturn this._textureNode.value;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.texture;\n\t\tconst images = texture.images;\n\t\tconst image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;\n\n\t\tif ( image && image.width !== undefined ) {\n\n\t\t\tconst { width, height } = image;\n\n\t\t\tthis.value = Math.log2( Math.max( width, height ) );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a max mip level node.\n *\n * @function\n * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n * @returns {MaxMipLevelNode}\n */\nconst maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );\n\n/** @module TextureNode **/\n\n/**\n * This type of uniform node represents a 2D texture.\n *\n * @augments module:UniformNode~UniformNode\n */\nclass TextureNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'TextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture node.\n\t *\n\t * @param {Texture} value - The texture.\n\t * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n\t * @param {Node<int>?} [levelNode=null] - The level node.\n\t * @param {Node<float>?} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureNode = true;\n\n\t\t/**\n\t\t * Represents the texture coordinates.\n\t\t *\n\t\t * @type {Node<vec2|vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * Represents the mip level that should be selected.\n\t\t *\n\t\t * @type {Node<int>?}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Represents the bias to be applied during level-of-detail computation.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.biasNode = biasNode;\n\n\t\t/**\n\t\t * Represents a reference value a texture sample is compared to.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.compareNode = null;\n\n\t\t/**\n\t\t * When using texture arrays, the depth node defines the layer to select.\n\t\t *\n\t\t * @type {Node<int>?}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * When defined, a texture is sampled using explicit gradients.\n\t\t *\n\t\t * @type {Array<Node<vec2>>?}\n\t\t * @default null\n\t\t */\n\t\tthis.gradNode = null;\n\n\t\t/**\n\t\t * Whether texture values should be sampled or fetched.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sampler = true;\n\n\t\t/**\n\t\t * Whether the uv transformation matrix should be\n\t\t * automatically updated or not. Use `setUpdateMatrix()`\n\t\t * if you want to change the value of the property.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.updateMatrix = false;\n\n\t\t/**\n\t\t * By default the `update()` method is not executed. `setUpdateMatrix()`\n\t\t * sets the value to `frame` when the uv transformation matrix should\n\t\t * automatically be updated.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The reference node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = null;\n\n\t\t/**\n\t\t * The texture value is stored in a private property.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * The uniform node that represents the uv transformation matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<mat3>?}\n\t\t */\n\t\tthis._matrixUniform = null;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\t/**\n\t * Overwritten since the uniform hash is defined by the texture's UUID.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The uniform hash.\n\t */\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the texture type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\tif ( this.value.type === UnsignedIntType ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else if ( this.value.type === IntType ) {\n\n\t\t\treturn 'ivec4';\n\n\t\t}\n\n\t\treturn 'vec4';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the current texture's channel.\n\t *\n\t * @return {AttributeNode<vec2>} The default uvs.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn uv( this.value.channel );\n\n\t}\n\n\t/**\n\t * Overwritten to always return the texture reference of the node.\n\t *\n\t * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {Texture} The texture reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\t/**\n\t * Transforms the given uv node with the texture transformation matrix.\n\t *\n\t * @param {Node} uvNode - The uv node to transform.\n\t * @return {Node} The transformed uv node.\n\t */\n\tgetTransformedUV( uvNode ) {\n\n\t\tif ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );\n\n\t\treturn this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\t/**\n\t * Defines whether the uv transformation matrix should automatically be updated or not.\n\t *\n\t * @param {Boolean} value - The update toggle.\n\t * @return {TextureNode} A reference to this node.\n\t */\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\t\tthis.updateType = value ? NodeUpdateType.RENDER : NodeUpdateType.NONE;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Setups texture node by preparing the internal nodes for code generation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.referenceNode = this.referenceNode;\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().' );\n\n\t\t}\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\tif ( this.updateMatrix === true ) {\n\n\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t}\n\n\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.biasNode = this.biasNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\t/**\n\t * Generates the snippet for the texture sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} textureProperty - The texture property.\n\t * @param {String} uvSnippet - The uv snippet.\n\t * @param {String} levelSnippet - The level snippet.\n\t * @param {String} biasSnippet - The bias snippet.\n\t * @param {String} depthSnippet - The depth snippet.\n\t * @param {String} compareSnippet - The compare snippet.\n\t * @param {String} gradSnippet - The grad snippet.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );\n\n\t\t} else if ( biasSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsToWorkingColorSpace( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the sampler value.\n\t *\n\t * @param {Boolean} value - The sampler value to set.\n\t * @return {TextureNode} A reference to this texture node.\n\t */\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the sampler value.\n\t *\n\t * @return {Boolean} The sampler value.\n\t */\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\tuv( uvNode ) { // @deprecated, r172\n\n\t\tconsole.warn( 'THREE.TextureNode: .uv() has been renamed. Use .sample() instead.' );\n\n\t\treturn this.sample( uvNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given uv node.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tsample( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = nodeObject( uvNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples a blurred version of the texture by defining an internal bias.\n\t *\n\t * @param {Node<float>} amountNode - How blurred the texture should be.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tblur( amountNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples a specific mip of the texture.\n\t *\n\t * @param {Node<int>} levelNode - The mip level to sample.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = nodeObject( levelNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Returns the texture size of the requested level.\n\t *\n\t * @param {Node<int>} levelNode - The level to compute the size for.\n\t * @return {TextureSizeNode} The texture size.\n\t */\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given bias.\n\t *\n\t * @param {Node<float>} biasNode - The bias node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tbias( biasNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( biasNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by executing a compare operation.\n\t *\n\t * @param {Node<float>} compareNode - The node that defines the compare value.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture using an explicit gradient.\n\t *\n\t * @param {Node<vec2>} gradNodeX - The gradX node.\n\t * @param {Node<vec2>} gradNodeY - The gradY node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by defining a depth node.\n\t *\n\t * @param {Node<int>} depthNode - The depth node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this.getSelf();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\t\tdata.sampler = this.sampler;\n\t\tdata.updateMatrix = this.updateMatrix;\n\t\tdata.updateType = this.updateType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\t\tthis.sampler = data.sampler;\n\t\tthis.updateMatrix = data.updateMatrix;\n\t\tthis.updateType = data.updateType;\n\n\t}\n\n\t/**\n\t * The update is used to implement the update of the uv transformation matrix.\n\t */\n\tupdate() {\n\n\t\tconst texture = this.value;\n\t\tconst matrixUniform = this._matrixUniform;\n\n\t\tif ( matrixUniform !== null ) matrixUniform.value = texture.matrix;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Clones the texture node.\n\t *\n\t * @return {TextureNode} The cloned texture node.\n\t */\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );\n\t\tnewNode.sampler = this.sampler;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a texture node.\n *\n * @function\n * @param {Texture} value - The texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst texture = /*@__PURE__*/ nodeProxy( TextureNode );\n\n/**\n * TSL function for creating a texture node that fetches/loads texels without interpolation.\n *\n * @function\n * @param {Texture} value - The texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\n//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\n/**\n * Converts a texture or texture node to a sampler.\n *\n * @function\n * @param {TextureNode|Texture} aTexture - The texture or texture node to convert.\n * @returns {Node}\n */\nconst sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );\n\n/** @module Camera **/\n\n/**\n * TSL object that represents the `near` value of the camera used for the current render.\n *\n * @type {UniformNode<float>}\n */\nconst cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\n\n/**\n * TSL object that represents the `far` value of the camera used for the current render.\n *\n * @type {UniformNode<float>}\n */\nconst cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\n\n/**\n * TSL object that represents the projection matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\n\n/**\n * TSL object that represents the inverse projection matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrixInverse = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\n\n/**\n * TSL object that represents the view matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraViewMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\n\n/**\n * TSL object that represents the world matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat4>}\n */\nconst cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\n\n/**\n * TSL object that represents the normal matrix of the camera used for the current render.\n *\n * @type {UniformNode<mat3>}\n */\nconst cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\n\n/**\n * TSL object that represents the position in world space of the camera used for the current render.\n *\n * @type {UniformNode<vec3>}\n */\nconst cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n\n/** @module Object3DNode **/\n\n/**\n * This node can be used to access transformation related metrics of 3D objects.\n * Depending on the selected scope, a different metric is represented as a uniform\n * in the shader. The following scopes are supported:\n *\n * - `POSITION`: The object's position in world space.\n * - `VIEW_POSITION`: The object's position in view/camera space.\n * - `DIRECTION`: The object's direction in world space.\n * - `SCALE`: The object's scale in world space.\n * - `WORLD_MATRIX`: The object's matrix in world space.\n *\n * @augments Node\n */\nclass Object3DNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'Object3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object 3D node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t * @param {Object3D?} [object3d=null] - The 3D object.\n\t */\n\tconstructor( scope, object3d = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node reports a different type of transformation depending on the scope.\n\t\t *\n\t\t * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D?}\n\t\t * @default null\n\t\t */\n\t\tthis.object3d = object3d;\n\n\t\t/**\n\t\t * Overwritten since this type of node is updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Holds the value of the node as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.SCALE ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixScale( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.DIRECTION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tobject.getWorldDirection( uniformNode.value );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the uniform node. The node type of the uniform\n\t * node also depends on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\n\n/**\n * TSL function for creating an object 3D node that represents the object's direction in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );\n\n/**\n * TSL function for creating an object 3D node that represents the object's world matrix.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<mat4>}\n */\nconst objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );\n\n/**\n * TSL function for creating an object 3D node that represents the object's scale in world space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in view/camera space.\n *\n * @function\n * @param {Object3D?} [object3d=null] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );\n\n/** @module ModelNode **/\n\n/**\n * This type of node is a specialized version of `Object3DNode`\n * with larger set of model related metrics. Unlike `Object3DNode`,\n * `ModelNode` extracts the reference to the 3D object from the\n * current node frame state.\n *\n * @augments module:Object3DNode~Object3DNode\n */\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object model node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\t/**\n\t * Extracts the model reference from the frame state and then\n\t * updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\n/**\n * TSL object that represents the object's direction in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\n\n/**\n * TSL object that represents the object's world matrix.\n *\n * @type {ModelNode<mat4>}\n */\nconst modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\n\n/**\n * TSL object that represents the object's position in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\n\n/**\n * TSL object that represents the object's scale in world space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\n\n/**\n * TSL object that represents the object's position in view/camera space.\n *\n * @type {ModelNode<vec3>}\n */\nconst modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\n\n/**\n * TSL object that represents the object's normal matrix.\n *\n * @type {UniformNode<mat3>}\n */\nconst modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\n\n/**\n * TSL object that represents the object's inverse world matrix.\n *\n * @type {UniformNode<mat4>}\n */\nconst modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\n\n/**\n * TSL object that represents the object's model view matrix.\n *\n * @type {Node<mat4>}\n */\nconst modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.renderer.nodes.modelViewMatrix || mediumpModelViewMatrix;\n\n} ).once() )().toVar( 'modelViewMatrix' );\n\n// GPU Precision\n\n/**\n * TSL object that represents the object's model view in `mediump` precision.\n *\n * @type {Node<mat4>}\n */\nconst mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );\n\n// CPU Precision\n\n/**\n * TSL object that represents the object's model view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @type {Node<mat4>}\n */\nconst highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelViewMatrix' );\n\n/**\n * TSL object that represents the object's model normal view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @type {Node<mat3>}\n */\nconst highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelNormalViewMatrix' );\n\n/** @module Position **/\n\n/**\n * TSL object that represents the position attribute of the current rendered object.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );\n\n/**\n * TSL object that represents the vertex position in local space of the current rendered object.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionLocal = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );\n\n/**\n * TSL object that represents the previous vertex position in local space of the current rendered object.\n * Used in context of {@link module:VelocityNode~VelocityNode} for rendering motion vectors.\n *\n * @type {AttributeNode<vec3>}\n */\nconst positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );\n\n/**\n * TSL object that represents the vertex position in world space of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.varying( 'v_positionWorld' ).context( { needsPositionReassign: true } );\n\n/**\n * TSL object that represents the position world direction of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' ).context( { needsPositionReassign: true } );\n\n/**\n * TSL object that represents the vertex position in view space of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupPositionView();\n\n}, 'vec3' ).once() )().varying( 'v_positionView' ).context( { needsPositionReassign: true } );\n\n/**\n * TSL object that represents the position view direction of the current rendered object.\n *\n * @type {VaryingNode<vec3>}\n */\nconst positionViewDirection = /*@__PURE__*/ positionView.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );\n\n/** @module FrontFacingNode **/\n\n/**\n * This node can be used to evaluate whether a primitive is front or back facing.\n *\n * @augments Node\n */\nclass FrontFacingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FrontFacingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new front facing node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { renderer, material } = builder;\n\n\t\tif ( renderer.coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\treturn 'false';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\n/**\n * TSL object that represents whether a primitive is front or back facing\n *\n * @type {FrontFacingNode<bool>}\n */\nconst frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );\n\n/**\n * TSL object that represents the front facing status as a number instead of a bool.\n * `1` means front facing, `-1` means back facing.\n *\n * @type {Node<float>}\n */\nconst faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );\n\n/** @module Normal **/\n\n/**\n * TSL object that represents the normal attribute of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );\n\n/**\n * TSL object that represents the vertex normal in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\tconsole.warn( 'TSL.NormalNode: Vertex attribute \"normal\" not found on geometry.' );\n\n\t\treturn vec3( 0, 1, 0 );\n\n\t}\n\n\treturn normalGeometry;\n\n}, 'vec3' ).once() )().toVar( 'normalLocal' );\n\n/**\n * TSL object that represents the flat vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );\n\n/**\n * TSL object that represents the vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet node;\n\n\tif ( builder.material.flatShading === true ) {\n\n\t\tnode = normalFlat;\n\n\t} else {\n\n\t\tnode = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once() )().toVar( 'normalView' );\n\n/**\n * TSL object that represents the vertex normal in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );\n\n/**\n * TSL object that represents the transformed vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupNormal();\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );\n\n/**\n * TSL object that represents the transformed vertex normal in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );\n\n/**\n * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupClearcoatNormal();\n\n}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );\n\n/**\n * Transforms the normal with the given matrix.\n *\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {\n\n\tconst m = mat3( matrix );\n\n\tconst transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );\n\n\treturn m.mul( transformedNormal ).xyz;\n\n} );\n\n/**\n * Transforms the given normal from local to view space.\n *\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {\n\n\tconst modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;\n\n\tif ( modelNormalViewMatrix !== null ) {\n\n\t\treturn modelNormalViewMatrix.transformDirection( normal );\n\n\t}\n\n\t//\n\n\tconst transformedNormal = modelNormalMatrix.mul( normal );\n\n\treturn cameraViewMatrix.transformDirection( transformedNormal );\n\n} );\n\n/** @module MaterialProperties **/\n\n/**\n * TSL object that represents the refraction ratio of the material used for rendering the current object.\n *\n * @type {UniformNode<float>}\n */\nconst materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );\n\n/** @module ReflectVector **/\n\n/**\n * The reflect vector in view space.\n *\n * @type {Node<vec3>}\n */\nconst reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );\n\n/**\n * The refract vector in view space.\n *\n * @type {Node<vec3>}\n */\nconst refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );\n\n/**\n * Used for sampling cube maps when using cube reflection mapping.\n *\n * @type {Node<vec3>}\n */\nconst reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\n/**\n * Used for sampling cube maps when using cube refraction mapping.\n *\n * @type {Node<vec3>}\n */\nconst refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\n/** @module CubeTextureNode **/\n\n/**\n * This type of uniform node represents a cube texture.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass CubeTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube texture node.\n\t *\n\t * @param {CubeTexture} value - The cube texture.\n\t * @param {Node<vec3>?} [uvNode=null] - The uv node.\n\t * @param {Node<int>?} [levelNode=null] - The level node.\n\t * @param {Node<float>?} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode, biasNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'cubeTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the mapping type of the cube texture.\n\t *\n\t * @return {Node<vec3>} The default uv attribute.\n\t */\n\tgetDefaultUV() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.mapping === CubeReflectionMapping ) {\n\n\t\t\treturn reflectVector;\n\n\t\t} else if ( texture.mapping === CubeRefractionMapping ) {\n\n\t\t\treturn refractVector;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping );\n\n\t\t\treturn vec3( 0, 0, 0 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n\t * for cube textures. The uv transformation matrix is not applied to cube textures.\n\t *\n\t * @param {Boolean} value - The update toggle.\n\t */\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {\n\n\t\t\treturn vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t} else {\n\n\t\t\treturn uvNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} cubeUV - The uv node to generate code for.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateUV( builder, cubeUV ) {\n\n\t\treturn cubeUV.build( builder, 'vec3' );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube texture node.\n *\n * @function\n * @param {CubeTexture} value - The cube texture.\n * @param {Node<vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @param {Node<float>?} [biasNode=null] - The bias node.\n * @returns {CubeTextureNode}\n */\nconst cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );\n\n/** @module BufferNode **/\n\n/**\n * A special type of uniform node which represents array-like data\n * as uniform buffers. The access usually happens via `element()`\n * which returns an instance of {@link ArrayElementNode}. For example:\n *\n * ```js\n * const bufferNode = buffer( array, 'mat4', count );\n * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer\n * ```\n * In general, it is recommended to use the more managed {@link UniformArrayNode}\n * since it handles more input types and automatically cares about buffer paddings.\n *\n * @augments module:UniformNode~UniformNode\n */\nclass BufferNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {Array<Number>} value - Array-like buffer data.\n\t * @param {String} bufferType - The data type of the buffer.\n\t * @param {Number} [bufferCount=0] - The count of buffer elements.\n\t */\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The data type of the buffer.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\t/**\n\t * The data type of the buffer elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The element type.\n\t */\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'buffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\n/**\n * TSL function for creating a buffer node.\n *\n * @function\n * @param {Array} value - Array-like buffer data.\n * @param {String} type - The data type of a buffer element.\n * @param {Number} count - The count of buffer elements.\n * @returns {BufferNode}\n */\nconst buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );\n\n/** @module UniformArrayNode **/\n\n/**\n * Represents the element access on uniform array nodes.\n *\n * @augments ArrayElementNode\n */\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.\n\t * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.\n\t */\n\tconstructor( uniformArrayNode, indexNode ) {\n\n\t\tsuper( uniformArrayNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\t\tconst paddedType = this.node.getPaddedType();\n\n\t\treturn builder.format( snippet, paddedType, type );\n\n\t}\n\n}\n\n/**\n * Similar to {@link module:BufferNode~BufferNode} this module represents array-like data as\n * uniform buffers. Unlike {@link module:BufferNode~BufferNode}, it can handle more common\n * data types in the array (e.g `three.js` primitives) and automatically\n * manage buffer padding. It should be the first choice when working with\n * uniforms buffers.\n * ```js\n * const tintColors = uniformArray( [\n * \tnew Color( 1, 0, 0 ),\n * \tnew Color( 0, 1, 0 ),\n * \tnew Color( 0, 0, 1 )\n * ], 'color' );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments module:BufferNode~BufferNode\n */\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform array node.\n\t *\n\t * @param {Array<Any>} value - Array holding the buffer data.\n\t * @param {String?} [elementType=null] - The data type of a buffer element.\n\t */\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null );\n\n\t\t/**\n\t\t * Array holding the buffer data. Unlike {@link module:BufferNode~BufferNode}, the array can\n\t\t * hold number primitives as well as three.js objects like vectors, matrices\n\t\t * or colors.\n\t\t *\n\t\t * @type {Array<Any>}\n\t\t */\n\t\tthis.array = value;\n\n\t\t/**\n\t\t * The data type of an array element.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;\n\n\t\t/**\n\t\t * The padded type. Uniform buffers must conform to a certain buffer layout\n\t\t * so a separate type is computed to ensure correct buffer size.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.paddedType = this.getPaddedType();\n\n\t\t/**\n\t\t * Overwritten since uniform array nodes are updated per render.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the\n\t * {@link module:UniformArrayNode~UniformArrayNode#paddedType}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.paddedType;\n\n\t}\n\n\t/**\n\t * The data type of the array elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Returns the padded type based on the element type.\n\t *\n\t * @return {String} The padded type.\n\t */\n\tgetPaddedType() {\n\n\t\tconst elementType = this.elementType;\n\n\t\tlet paddedType = 'vec4';\n\n\t\tif ( elementType === 'mat2' ) {\n\n\t\t\tpaddedType = 'mat2';\n\n\t\t} else if ( /mat/.test( elementType ) === true ) {\n\n\t\t\tpaddedType = 'mat4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'i' ) {\n\n\t\t\tpaddedType = 'ivec4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'u' ) {\n\n\t\t\tpaddedType = 'uvec4';\n\n\t\t}\n\n\t\treturn paddedType;\n\n\t}\n\n\t/**\n\t * The update makes sure to correctly transfer the data from the (complex) objects\n\t * in the array to the internal, correctly padded value buffer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementType = this.elementType;\n\n\t\tif ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat2' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\t\t\t\tvalue[ index + 3 ] = matrix.elements[ 3 ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat3' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\n\t\t\t\tvalue[ index + 4 ] = matrix.elements[ 3 ];\n\t\t\t\tvalue[ index + 5 ] = matrix.elements[ 4 ];\n\t\t\t\tvalue[ index + 6 ] = matrix.elements[ 5 ];\n\n\t\t\t\tvalue[ index + 8 ] = matrix.elements[ 6 ];\n\t\t\t\tvalue[ index + 9 ] = matrix.elements[ 7 ];\n\t\t\t\tvalue[ index + 10 ] = matrix.elements[ 8 ];\n\n\t\t\t\tvalue[ index + 15 ] = 1;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat4' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tfor ( let i = 0; i < matrix.elements.length; i ++ ) {\n\n\t\t\t\t\tvalue[ index + i ] = matrix.elements[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implement the value buffer creation based on the array data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {null}\n\t */\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\t\tconst elementType = this.elementType;\n\n\t\tlet arrayType = Float32Array;\n\n\t\tconst paddedType = this.paddedType;\n\t\tconst paddedElementLength = builder.getTypeLength( paddedType );\n\n\t\tif ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\tif ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * paddedElementLength );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = paddedType;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default `element()` method to provide element access\n\t * based on {@link module:UniformArrayNode~UniformArrayNode}.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {UniformArrayElementNode}\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an uniform array node.\n *\n * @function\n * @param {Array<Any>} values - Array-like data.\n * @param {String} nodeType - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nconst uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n\n//\n\nconst uniforms = ( values, nodeType ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );\n\treturn nodeObject( new UniformArrayNode( values, nodeType ) );\n\n};\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/** @module ReferenceNode **/\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {Node?} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link module:ReferenceNode~ReferenceNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n/**\n * This type of node establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {Object?} [object=null] - The object the property belongs to.\n\t * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An optional label of the internal uniform node.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.name = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the label for the internal uniform.\n\t *\n\t * @param {String} name - The label to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {String} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.count !== null ) {\n\n\t\t\tnode = buffer( null, uniformType, this.count );\n\n\t\t} else if ( Array.isArray( this.getValueFromReference() ) ) {\n\n\t\t\tnode = uniformArray( null, uniformType );\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tnode = texture( null );\n\n\t\t} else if ( uniformType === 'cubeTexture' ) {\n\n\t\t\tnode = cubeTexture( null );\n\n\t\t} else {\n\n\t\t\tnode = uniform( null, uniformType );\n\n\t\t}\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tif ( this.name !== null ) node.label( this.name );\n\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {Any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link module:ReferenceNode~ReferenceNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );\n\n/**\n * TSL function for creating a reference node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Number} count - The number of value inside the array-like object.\n * @param {Object} object - An array-like object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );\n\n/** @module MaterialReferenceNode **/\n\n/**\n * This node is a special type of reference node which is intended\n * for linking material properties with node values.\n * ```js\n * const opacityNode = materialReference( 'opacity', 'float', material );\n * ```\n * When changing `material.opacity`, the node value of `opacityNode` will\n * automatically be updated.\n *\n * @augments module:ReferenceNode~ReferenceNode\n */\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material reference node.\n\t *\n\t * @param {String} property - The name of the property the node refers to.\n\t * @param {String} inputType - The uniform type that should be used to represent the property value.\n\t * @param {Material?} [material=null] - The material the property belongs to. When no material is set,\n\t * the node refers to the material of the current rendered object.\n\t */\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\t/**\n\t\t * The material the property belongs to. When no material is set,\n\t\t * the node refers to the material of the current rendered object.\n\t\t *\n\t\t * @type {Material?}\n\t\t * @default null\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMaterialReferenceNode = true;\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link module:MaterialReferenceNode~MaterialReferenceNode#material} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.material !== null ? this.material : state.material;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a material reference node.\n *\n * @function\n * @param {String} name - The name of the property the node refers to.\n * @param {String} type - The uniform type that should be used to represent the property value.\n * @param {Material?} [material=null] - The material the property belongs to.\n * When no material is set, the node refers to the material of the current rendered object.\n * @returns {MaterialReferenceNode}\n */\nconst materialReference = ( name, type, material = null ) => nodeObject( new MaterialReferenceNode( name, type, material ) );\n\n/** @module Tangent **/\n\n/**\n * TSL object that represents the tangent attribute of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'tangent' ) === false ) {\n\n\t\tbuilder.geometry.computeTangents();\n\n\t}\n\n\treturn attribute( 'tangent', 'vec4' );\n\n} )();\n\n/**\n * TSL object that represents the vertex tangent in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );\n\n/**\n * TSL object that represents the vertex tangent in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );\n\n/**\n * TSL object that represents the vertex tangent in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).varying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );\n\n/**\n * TSL object that represents the transformed vertex tangent in view space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );\n\n/**\n * TSL object that represents the transformed vertex tangent in world space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );\n\n/** @module Bitangent **/\n\nconst getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;\n\n/**\n * TSL object that represents the bitangent attribute of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );\n\n/**\n * TSL object that represents the vertex bitangent in local space of the current rendered object.\n *\n * @type {Node<vec3>}\n */\nconst bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );\n\n/**\n * TSL object that represents the vertex bitangent in view space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );\n\n/**\n * TSL object that represents the vertex bitangent in world space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );\n\n/**\n * TSL object that represents the transformed vertex bitangent in view space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );\n\n/**\n * TSL object that represents the transformed vertex bitangent in world space of the current rendered object.\n *\n * @type {Node<vec4>}\n */\nconst transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );\n\n/** @module AccessorsUtils **/\n\n/**\n * TSL object that represents the TBN matrix in view space.\n *\n * @type {Node<mat3>}\n */\nconst TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );\n\n/**\n * TSL object that represents the parallax direction.\n *\n * @type {Node<mat3>}\n */\nconst parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;\n\n/**\n * TSL function for computing parallax uv coordinates.\n *\n * @function\n * @param {Node<vec2>} uv - A uv node.\n * @param {Node<vec2>} scale - A scale node.\n * @returns {Node<vec2>} Parallax uv coordinates.\n */\nconst parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );\n\n/**\n * TSL function for computing bent normals.\n *\n * @function\n * @returns {Node<vec3>} Bent normals.\n */\nconst transformedBentNormalView = /*@__PURE__*/ ( () => {\n\n\t// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n\tlet bentNormal = anisotropyB.cross( positionViewDirection );\n\tbentNormal = bentNormal.cross( anisotropyB ).normalize();\n\tbentNormal = mix( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();\n\n\treturn bentNormal;\n\n\n} )();\n\n/** @module NormalMapNode **/\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { eye_pos, surf_norm, mapN, uv } = inputs;\n\n\tconst q0 = eye_pos.dFdx();\n\tconst q1 = eye_pos.dFdy();\n\tconst st0 = uv.dFdx();\n\tconst st1 = uv.dFdy();\n\n\tconst N = surf_norm; // normalized\n\n\tconst q1perp = q1.cross( N );\n\tconst q0perp = N.cross( q0 );\n\n\tconst T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );\n\tconst B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );\n\n\tconst det = T.dot( T ).max( B.dot( B ) );\n\tconst scale = faceDirection.mul( det.inverseSqrt() );\n\n\treturn add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();\n\n} );\n\n/**\n * This class can be used for applying normals maps to materials.\n *\n * ```js\n * material.normalNode = normalMap( texture( normalTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass NormalMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'NormalMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new normal map node.\n\t *\n\t * @param {Node} node - Represents the normal map data.\n\t * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.\n\t */\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the normal map data.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Controls the intensity of the effect.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * The normal map type.\n\t\t *\n\t\t * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}\n\t\t * @default TangentSpaceNormalMap\n\t\t */\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tlet normalMap = this.node.mul( 2.0 ).sub( 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tnormalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );\n\n\t\t}\n\n\t\tlet outputNode = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutputNode = transformNormalToView( normalMap );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\tconst tangent = builder.hasGeometryAttribute( 'tangent' );\n\n\t\t\tif ( tangent === true ) {\n\n\t\t\t\toutputNode = TBNViewMatrix.mul( normalMap ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\toutputNode = perturbNormal2Arb( {\n\t\t\t\t\teye_pos: positionView,\n\t\t\t\t\tsurf_norm: normalView,\n\t\t\t\t\tmapN: normalMap,\n\t\t\t\t\tuv: uv()\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a normal map node.\n *\n * @function\n * @param {Node} node - Represents the normal map data.\n * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.\n * @returns {NormalMapNode}\n */\nconst normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );\n\n/** @module BumpMapNode **/\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );\n\n\tconst Hll = float( sampleTexture( ( uvNode ) => uvNode ) );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\n/**\n * This class can be used for applying bump maps to materials.\n *\n * ```js\n * material.normalNode = bumpMap( texture( bumpTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass BumpMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BumpMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bump map node.\n\t *\n\t * @param {Node} textureNode - Represents the bump map data.\n\t * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.\n\t */\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the bump map data.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * Controls the intensity of the bump effect.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bump map node.\n *\n * @function\n * @param {Node} textureNode - Represents the bump map data.\n * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.\n * @returns {BumpMapNode}\n */\nconst bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );\n\n/** @module MaterialNode **/\n\nconst _propertyCache = new Map();\n\n/**\n * This class should simplify the node access to material properties.\n * It internal uses reference nodes to make sure  changes to material\n * properties are automatically reflected to predefined TSL objects\n * like e.g. `materialColor`.\n *\n * @augments Node\n */\nclass MaterialNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material node.\n\t *\n\t * @param {String} scope - The scope defines what kind of material property is referred by the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines what material property is referred by the node.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Returns a cached reference node for the given property and type.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @param {String} type - The uniform type of the property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetCache( property, type ) {\n\n\t\tlet node = _propertyCache.get( property );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = materialReference( property, type );\n\n\t\t\t_propertyCache.set( property, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Returns a float-typed material reference node for the given property name.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @return {MaterialReferenceNode<float>} A material reference node representing the property access.\n\t */\n\tgetFloat( property ) {\n\n\t\treturn this.getCache( property, 'float' );\n\n\t}\n\n\t/**\n\t * Returns a color-typed material reference node for the given property name.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @return {MaterialReferenceNode<color>} A material reference node representing the property access.\n\t */\n\tgetColor( property ) {\n\n\t\treturn this.getCache( property, 'color' );\n\n\t}\n\n\t/**\n\t * Returns a texture-typed material reference node for the given property name.\n\t *\n\t * @param {String} property - The name of the material property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetTexture( property ) {\n\n\t\treturn this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );\n\n\t}\n\n\t/**\n\t * The node setup is done depending on the selected scope. Multiple material properties\n\t * might be grouped into a single node composition if they logically belong together.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The node representing the selected scope.\n\t */\n\tsetup( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();\n\n\t\t\tif ( material.map && material.map.isTexture === true ) {\n\n\t\t\t\tnode = colorNode.mul( this.getTexture( 'map' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = this.getFloat( scope );\n\n\t\t\tif ( material.alphaMap && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = opacityNode.mul( this.getTexture( 'alpha' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {\n\n\t\t\tif ( material.specularMap && material.specularMap.isTexture === true ) {\n\n\t\t\t\tnode = this.getTexture( 'specular' ).r;\n\n\t\t\t} else {\n\n\t\t\t\tnode = float( 1 );\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {\n\n\t\t\tconst specularIntensityNode = this.getFloat( scope );\n\n\t\t\tif ( material.specularIntensityMap && material.specularIntensityMap.isTexture === true ) {\n\n\t\t\t\tnode = specularIntensityNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularIntensityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_COLOR ) {\n\n\t\t\tconst specularColorNode = this.getColor( scope );\n\n\t\t\tif ( material.specularColorMap && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = specularColorNode.mul( this.getTexture( scope ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches\n\n\t\t\tconst roughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.roughnessMap && material.roughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = roughnessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.metalnessMap && material.metalnessMap.isTexture === true ) {\n\n\t\t\t\tnode = metalnessNode.mul( this.getTexture( scope ).b );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );\n\t\t\tconst emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );\n\n\t\t\tif ( material.emissiveMap && material.emissiveMap.isTexture === true ) {\n\n\t\t\t\tnode = emissiveNode.mul( this.getTexture( scope ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.NORMAL ) {\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );\n\t\t\t\tnode.normalMapType = material.normalMapType;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tnode = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT ) {\n\n\t\t\tconst clearcoatNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {\n\n\t\t\tconst clearcoatRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatRoughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN ) {\n\n\t\t\tconst sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU\n\n\t\t\tif ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {\n\n\t\t\tconst sheenRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenRoughnessNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenRoughnessNode;\n\n\t\t\t}\n\n\t\t\tnode = node.clamp( 0.07, 1.0 );\n\n\t\t} else if ( scope === MaterialNode.ANISOTROPY ) {\n\n\t\t\tif ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {\n\n\t\t\t\tconst anisotropyPolar = this.getTexture( scope );\n\t\t\t\tconst anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );\n\n\t\t\t\tnode = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = materialAnisotropyVector;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {\n\n\t\t\tconst iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tconst iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );\n\n\t\t\t\tnode = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );\n\n\t\t\t} else {\n\n\t\t\t\tnode = iridescenceThicknessMaximum;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.TRANSMISSION ) {\n\n\t\t\tconst transmissionNode = this.getFloat( scope );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tnode = transmissionNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = transmissionNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.THICKNESS ) {\n\n\t\t\tconst thicknessNode = this.getFloat( scope );\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tnode = thicknessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = thicknessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IOR ) {\n\n\t\t\tnode = this.getFloat( scope );\n\n\t\t} else if ( scope === MaterialNode.LIGHT_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );\n\n\t\t} else if ( scope === MaterialNode.AO ) {\n\n\t\t\tnode = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = this.getCache( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_WIDTH = 'pointWidth';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO = 'ao';\n\n/**\n * TSL object that represents alpha test of the current material.\n *\n * @type {Node<float>}\n */\nconst materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\n\n/**\n * TSL object that represents the diffuse color of the current material.\n * The value is composed via `color` * `map`.\n *\n * @type {Node<vec3>}\n */\nconst materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );\n\n/**\n * TSL object that represents the shininess of the current material.\n *\n * @type {Node<float>}\n */\nconst materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );\n\n/**\n * TSL object that represents the emissive color of the current material.\n * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.\n *\n * @type {Node<vec3>}\n */\nconst materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\n\n/**\n * TSL object that represents the opacity of the current material.\n * The value is composed via `opacity` * `alphaMap`.\n *\n * @type {Node<float>}\n */\nconst materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );\n\n/**\n * TSL object that represents the specular of the current material.\n *\n * @type {Node<vec3>}\n */\nconst materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\n\n/**\n * TSL object that represents the specular intensity of the current material.\n * The value is composed via `specularIntensity` * `specularMap.a`.\n *\n * @type {Node<float>}\n */\nconst materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );\n\n/**\n * TSL object that represents the specular color of the current material.\n * The value is composed via `specularColor` * `specularMap.rgb`.\n *\n * @type {Node<vec3>}\n */\nconst materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );\n\n/**\n * TSL object that represents the specular strength of the current material.\n * The value is composed via `specularMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );\n\n/**\n * TSL object that represents the reflectivity of the current material.\n *\n * @type {Node<float>}\n */\nconst materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );\n\n/**\n * TSL object that represents the roughness of the current material.\n * The value is composed via `roughness` * `roughnessMap.g`\n *\n * @type {Node<float>}\n */\nconst materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\n\n/**\n * TSL object that represents the metalness of the current material.\n * The value is composed via `metalness` * `metalnessMap.b`\n *\n * @type {Node<float>}\n */\nconst materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );\n\n/**\n * TSL object that represents the normal of the current material.\n * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.\n *\n * @type {Node<vec3>}\n */\nconst materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );\n\n/**\n * TSL object that represents the clearcoat of the current material.\n * The value is composed via `clearcoat` * `clearcoatMap.r`\n *\n * @type {Node<float>}\n */\nconst materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );\n\n/**\n * TSL object that represents the clearcoat roughness of the current material.\n * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`\n *\n * @type {Node<float>}\n */\nconst materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );\n\n/**\n * TSL object that represents the clearcoat normal of the current material.\n * The value will be either `clearcoatNormalMap` or `normalView`.\n *\n * @type {Node<vec3>}\n */\nconst materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );\n\n/**\n * TSL object that represents the rotation of the current sprite material.\n *\n * @type {Node<float>}\n */\nconst materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );\n\n/**\n * TSL object that represents the sheen color of the current material.\n * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.\n *\n * @type {Node<vec3>}\n */\nconst materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );\n\n/**\n * TSL object that represents the sheen roughness of the current material.\n * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a` .\n *\n * @type {Node<float>}\n */\nconst materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );\n\n/**\n * TSL object that represents the anisotropy of the current material.\n *\n * @type {Node<vec2>}\n */\nconst materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );\n\n/**\n * TSL object that represents the iridescence of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );\n\n/**\n * TSL object that represents the iridescence IOR of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );\n\n/**\n * TSL object that represents the iridescence thickness of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );\n\n/**\n * TSL object that represents the transmission of the current material.\n * The value is composed via `transmission` * `transmissionMap.r`.\n *\n * @type {Node<float>}\n */\nconst materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );\n\n/**\n * TSL object that represents the thickness of the current material.\n * The value is composed via `thickness` * `thicknessMap.g`.\n *\n * @type {Node<float>}\n */\nconst materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );\n\n/**\n * TSL object that represents the IOR of the current material.\n *\n * @type {Node<float>}\n */\nconst materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );\n\n/**\n * TSL object that represents the attenuation distance of the current material.\n *\n * @type {Node<float>}\n */\nconst materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );\n\n/**\n * TSL object that represents the attenuation color of the current material.\n *\n * @type {Node<vec3>}\n */\nconst materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );\n\n/**\n * TSL object that represents the scale of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );\n\n/**\n * TSL object that represents the dash size of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );\n\n/**\n * TSL object that represents the gap size of the current dashed line material.\n *\n * @type {Node<float>}\n */\nconst materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );\n\n/**\n * TSL object that represents the line width of the current line material.\n *\n * @type {Node<float>}\n */\nconst materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );\n\n/**\n * TSL object that represents the dash offset of the current line material.\n *\n * @type {Node<float>}\n */\nconst materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );\n\n/**\n * TSL object that represents the point width of the current points material.\n *\n * @type {Node<float>}\n */\nconst materialPointWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );\n\n/**\n * TSL object that represents the dispersion of the current material.\n *\n * @type {Node<float>}\n */\nconst materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );\n\n/**\n * TSL object that represents the light map of the current material.\n * The value is composed via `lightMapIntensity` * `lightMap.rgb`.\n *\n * @type {Node<vec3>}\n */\nconst materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );\n\n/**\n * TSL object that represents the ambient occlusion map of the current material.\n * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.\n *\n * @type {Node<float>}\n */\nconst materialAO = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO );\n\n/**\n * TSL object that represents the anisotropy vector of the current material.\n *\n * @type {Node<vec2>}\n */\nconst materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onRenderUpdate( function ( { material } ) {\n\n\tthis.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n} );\n\n/** @module ModelViewProjectionNode **/\n\n/**\n * TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.\n *\n * @type {VaryingNode<vec4>}\n */\nconst modelViewProjection = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupModelViewProjection();\n\n}, 'vec4' ).once() )().varying( 'v_modelViewProjection' );\n\n/** @module IndexNode **/\n\n/**\n * This class represents shader indices of different types. The following predefined node\n * objects cover frequent use cases:\n *\n * - `vertexIndex`: The index of a vertex within a mesh.\n * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.\n * - `drawIndex`: The index of a draw call.\n * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.\n * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.\n * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.\n *\n * @augments Node\n */\nclass IndexNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IndexNode';\n\n\t}\n\n\t/**\n\t * Constructs a new index node.\n\t *\n\t * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The scope of the index node.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst scope = this.scope;\n\n\t\tlet propertyName;\n\n\t\tif ( scope === IndexNode.VERTEX ) {\n\n\t\t\tpropertyName = builder.getVertexIndex();\n\n\t\t} else if ( scope === IndexNode.INSTANCE ) {\n\n\t\t\tpropertyName = builder.getInstanceIndex();\n\n\t\t} else if ( scope === IndexNode.DRAW ) {\n\n\t\t\tpropertyName = builder.getDrawIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_LOCAL ) {\n\n\t\t\tpropertyName = builder.getInvocationLocalIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getInvocationSubgroupIndex();\n\n\t\t} else if ( scope === IndexNode.SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getSubgroupIndex();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.IndexNode: Unknown scope: ' + scope );\n\n\t\t}\n\n\t\tlet output;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\n/**\n * TSL object that represents the index of a vertex within a mesh.\n *\n * @type {IndexNode}\n */\nconst vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );\n\n/**\n * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.\n *\n * @type {IndexNode}\n */\nconst instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );\n\n/**\n * TSL object that represents the index of the subgroup the current compute invocation belongs to.\n *\n * @type {IndexNode}\n */\nconst subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a subgroup.\n *\n * @type {IndexNode}\n */\nconst invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a workgroup load.\n *\n * @type {IndexNode}\n */\nconst invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );\n\n/**\n * TSL object that represents the index of a draw call.\n *\n * @type {IndexNode}\n */\nconst drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );\n\n/** @module InstanceNode **/\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via instancing. The code makes sure\n * vertex positions, normals and colors can be modified via instanced\n * data.\n *\n * @augments Node\n */\nclass InstanceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InstanceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instance node.\n\t *\n\t * @param {Number} count - The number of instances.\n\t * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n\t * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n\t */\n\tconstructor( count, instanceMatrix, instanceColor ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The number of instances.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the transformation of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceMatrix = instanceMatrix;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the color of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceColor = instanceColor;\n\n\t\t/**\n\t\t * The node that represents the instance matrix data.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.instanceMatrixNode = null;\n\n\t\t/**\n\t\t * The node that represents the instance color data.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.instanceColorNode = null;\n\n\t\t/**\n\t\t * The update type is set to `frame` since an update\n\t\t * of instanced buffer data must be checked per frame.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceMatrixNode`.\n\t\t *\n\t\t * @type {InstancedInterleavedBuffer}\n\t\t */\n\t\tthis.buffer = null;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceColorNode`.\n\t\t *\n\t\t * @type {InstancedInterleavedBuffer}\n\t\t */\n\t\tthis.bufferColor = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = this;\n\n\t\tlet { instanceMatrixNode, instanceColorNode } = this;\n\n\t\tif ( instanceMatrixNode === null ) {\n\n\t\t\t// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n\t\t\tif ( count <= 1000 ) {\n\n\t\t\t\tinstanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tconst buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );\n\n\t\t\t\tthis.buffer = buffer;\n\n\t\t\t\tconst bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\t\tconst instanceBuffers = [\n\t\t\t\t\t// F.Signature -> bufferAttribute( array, type, stride, offset )\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 0 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 4 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 8 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 12 )\n\t\t\t\t];\n\n\t\t\t\tinstanceMatrixNode = mat4( ...instanceBuffers );\n\n\t\t\t}\n\n\t\t\tthis.instanceMatrixNode = instanceMatrixNode;\n\n\t\t}\n\n\t\tif ( instanceColor && instanceColorNode === null ) {\n\n\t\t\tconst buffer = new InstancedBufferAttribute( instanceColor.array, 3 );\n\n\t\t\tconst bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\tthis.bufferColor = buffer;\n\n\t\t\tinstanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );\n\n\t\t\tthis.instanceColorNode = instanceColorNode;\n\n\t\t}\n\n\t\t// POSITION\n\n\t\tconst instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;\n\t\tpositionLocal.assign( instancePosition );\n\n\t\t// NORMAL\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst instanceNormal = transformNormal( normalLocal, instanceMatrixNode );\n\n\t\t\t// ASSIGNS\n\n\t\t\tnormalLocal.assign( instanceNormal );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tif ( this.instanceColorNode !== null ) {\n\n\t\t\tvaryingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the internal buffers required an update.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tif ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version ) {\n\n\t\t\tthis.buffer.version = this.instanceMatrix.version;\n\n\t\t}\n\n\t\tif ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version ) {\n\n\t\t\tthis.bufferColor.version = this.instanceColor.version;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance node.\n *\n * @function\n * @param {Number} count - The number of instances.\n * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n * @returns {InstanceNode}\n */\nconst instance = /*@__PURE__*/ nodeProxy( InstanceNode );\n\n/** @module InstancedMeshNode **/\n\n/**\n * This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.\n * It allows an easier setup of the instance node.\n *\n * @augments module:InstanceNode~InstanceNode\n */\nclass InstancedMeshNode extends InstanceNode {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedMeshNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instanced mesh node.\n\t *\n\t * @param {InstancedMesh} instancedMesh - The instanced mesh.\n\t */\n\tconstructor( instancedMesh ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = instancedMesh;\n\n\t\tsuper( count, instanceMatrix, instanceColor );\n\n\t\t/**\n\t\t * A reference to the instanced mesh.\n\t\t *\n\t\t * @type {InstancedMesh}\n\t\t */\n\t\tthis.instancedMesh = instancedMesh;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instanced mesh node.\n *\n * @function\n * @param {InstancedMesh} instancedMesh - The instancedMesh.\n * @returns {InstancedMeshNode}\n */\nconst instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );\n\n/** @module BatchNode **/\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via batching. `BatchNode` must be used\n * with instances of {@link BatchedMesh}.\n *\n * @augments Node\n */\nclass BatchNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BatchNode';\n\n\t}\n\n\t/**\n\t * Constructs a new batch node.\n\t *\n\t * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n\t */\n\tconstructor( batchMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * A reference to batched mesh.\n\t\t *\n\t\t * @type {BatchedMesh}\n\t\t */\n\t\tthis.batchMesh = batchMesh;\n\n\t\t/**\n\t\t * The batching index node.\n\t\t *\n\t\t * @type {IndexNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.batchingIdNode = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.batchingIdNode === null ) {\n\n\t\t\tif ( builder.getDrawIndex() === null ) {\n\n\t\t\t\tthis.batchingIdNode = instanceIndex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.batchingIdNode = drawIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getIndirectIndex = Fn( ( [ id ] ) => {\n\n\t\t\tconst size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );\n\t\t\tconst x = int( id ).modInt( int( size ) );\n\t\t\tconst y = int( id ).div( int( size ) );\n\t\t\treturn textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;\n\n\t\t} ).setLayout( {\n\t\t\tname: 'getIndirectIndex',\n\t\t\ttype: 'uint',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t]\n\t\t} );\n\n\t\tconst indirectId = getIndirectIndex( int( this.batchingIdNode ) );\n\n\t\tconst matricesTexture = this.batchMesh._matricesTexture;\n\n\t\tconst size = textureSize( textureLoad( matricesTexture ), 0 );\n\t\tconst j = float( indirectId ).mul( 4 ).toInt().toVar();\n\n\t\tconst x = j.modInt( size );\n\t\tconst y = j.div( int( size ) );\n\t\tconst batchingMatrix = mat4(\n\t\t\ttextureLoad( matricesTexture, ivec2( x, y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )\n\t\t);\n\n\n\t\tconst colorsTexture = this.batchMesh._colorsTexture;\n\n\t\tif ( colorsTexture !== null ) {\n\n\t\t\tconst getBatchingColor = Fn( ( [ id ] ) => {\n\n\t\t\t\tconst size = textureSize( textureLoad( colorsTexture ), 0 ).x;\n\t\t\t\tconst j = id;\n\t\t\t\tconst x = j.modInt( size );\n\t\t\t\tconst y = j.div( size );\n\t\t\t\treturn textureLoad( colorsTexture, ivec2( x, y ) ).rgb;\n\n\t\t\t} ).setLayout( {\n\t\t\t\tname: 'getBatchingColor',\n\t\t\t\ttype: 'vec3',\n\t\t\t\tinputs: [\n\t\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\tconst color = getBatchingColor( indirectId );\n\n\t\t\tvaryingProperty( 'vec3', 'vBatchColor' ).assign( color );\n\n\t\t}\n\n\t\tconst bm = mat3( batchingMatrix );\n\n\t\tpositionLocal.assign( batchingMatrix.mul( positionLocal ) );\n\n\t\tconst transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );\n\n\t\tconst batchingNormal = bm.mul( transformedNormal ).xyz;\n\n\t\tnormalLocal.assign( batchingNormal );\n\n\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\ttangentLocal.mulAssign( bm );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a batch node.\n *\n * @function\n * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n * @returns {BatchNode}\n */\nconst batch = /*@__PURE__*/ nodeProxy( BatchNode );\n\n/** @module SkinningNode **/\n\nconst _frameId = new WeakMap();\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for skinning/skeletal animation.\n *\n * @augments Node\n */\nclass SkinningNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SkinningNode';\n\n\t}\n\n\t/**\n\t * Constructs a new skinning node.\n\t *\n\t * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n\t * @param {Boolean} [useReference=false] - Whether to use reference nodes for internal skinned mesh related data or not.\n\t */\n\tconstructor( skinnedMesh, useReference = false ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The skinned mesh.\n\t\t *\n\t\t * @type {SkinnedMesh}\n\t\t */\n\t\tthis.skinnedMesh = skinnedMesh;\n\n\t\t/**\n\t\t * Whether to use reference nodes for internal skinned mesh related data or not.\n\t\t * TODO: Explain the purpose of the property.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.useReference = useReference;\n\n\t\t/**\n\t\t * The update type overwritten since skinning nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\t/**\n\t\t * The skin index attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\n\t\t/**\n\t\t * The skin weight attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\tlet bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;\n\n\t\tif ( useReference ) {\n\n\t\t\tbindMatrixNode = reference( 'bindMatrix', 'mat4' );\n\t\t\tbindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );\n\t\t\tboneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t} else {\n\n\t\t\tbindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );\n\t\t\tbindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );\n\t\t\tboneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\t/**\n\t\t * The bind matrix node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixNode = bindMatrixNode;\n\n\t\t/**\n\t\t * The bind matrix inverse node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixInverseNode = bindMatrixInverseNode;\n\n\t\t/**\n\t\t * The bind matrices as a uniform buffer node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.boneMatricesNode = boneMatricesNode;\n\n\t\t/**\n\t\t * The previous bind matrices as a uniform buffer node.\n\t\t * Required for computing motion vectors.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.previousBoneMatricesNode = null;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex position via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [position=positionLocal] - The vertex position in local space.\n\t * @return {Node<vec3>} The transformed vertex position.\n\t */\n\tgetSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// POSITION\n\n\t\tconst skinVertex = bindMatrixNode.mul( position );\n\n\t\tconst skinned = add(\n\t\t\tboneMatX.mul( skinWeightNode.x ).mul( skinVertex ),\n\t\t\tboneMatY.mul( skinWeightNode.y ).mul( skinVertex ),\n\t\t\tboneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),\n\t\t\tboneMatW.mul( skinWeightNode.w ).mul( skinVertex )\n\t\t);\n\n\t\treturn bindMatrixInverseNode.mul( skinned ).xyz;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex normal via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.\n\t * @return {Node<vec3>} The transformed vertex normal.\n\t */\n\tgetSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// NORMAL\n\n\t\tlet skinMatrix = add(\n\t\t\tskinWeightNode.x.mul( boneMatX ),\n\t\t\tskinWeightNode.y.mul( boneMatY ),\n\t\t\tskinWeightNode.z.mul( boneMatZ ),\n\t\t\tskinWeightNode.w.mul( boneMatW )\n\t\t);\n\n\t\tskinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );\n\n\t\treturn skinMatrix.transformDirection( normal ).xyz;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex normal via skinning.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The skinned position from the previous frame.\n\t */\n\tgetPreviousSkinnedPosition( builder ) {\n\n\t\tconst skinnedMesh = builder.object;\n\n\t\tif ( this.previousBoneMatricesNode === null ) {\n\n\t\t\tskinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );\n\n\t\t\tthis.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\treturn this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );\n\n\t}\n\n\t/**\n\t * Returns `true` if bone matrices from the previous frame are required.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Boolean} Whether bone matrices from the previous frame are required or not.\n\t */\n\tneedsPreviousBoneMatrices( builder ) {\n\n\t\tconst mrt = builder.renderer.getMRT();\n\n\t\treturn ( mrt && mrt.has( 'velocity' ) ) || getDataFromObject( builder.object ).useVelocity === true;\n\n\t}\n\n\t/**\n\t * Setups the skinning node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.needsPreviousBoneMatrices( builder ) ) {\n\n\t\t\tpositionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );\n\n\t\t}\n\n\t\tconst skinPosition = this.getSkinnedPosition();\n\n\n\t\tpositionLocal.assign( skinPosition );\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst skinNormal = this.getSkinnedNormal();\n\n\t\t\tnormalLocal.assign( skinNormal );\n\n\t\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\t\ttangentLocal.assign( skinNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the skinning node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\treturn positionLocal.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the state of the skinned mesh by updating the skeleton once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst object = this.useReference ? frame.object : this.skinnedMesh;\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( _frameId.get( skeleton ) === frame.frameId ) return;\n\n\t\t_frameId.set( skeleton, frame.frameId );\n\n\t\tif ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );\n\n\t\tskeleton.update();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a skinning node.\n *\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );\n\n/**\n * TSL function for creating a skinning node with reference usage.\n *\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );\n\n/** @module LoopNode **/\n\n/**\n * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:\n * ```js\n * Loop( count, ( { i } ) => {\n *\n * } );\n * ```\n * However, it is also possible to define a start and end ranges, data types and loop conditions:\n * ```js\n * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {\n *\n * } );\n *```\n * Nested loops can be defined in a compacted form:\n * ```js\n * Loop( 10, 5, ( { i, j } ) => {\n *\n * } );\n * ```\n * Loops that should run backwards can be defined like so:\n * ```js\n * Loop( { start: 10 }, () => {} );\n * ```\n * The module also provides `Break()` and `Continue()` TSL expression for loop control.\n * @augments Node\n */\nclass LoopNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LoopNode';\n\n\t}\n\n\t/**\n\t * Constructs a new loop node.\n\t *\n\t * @param {Array<Any>} params - Depending on the loop type, array holds different parameterization values for the loop.\n\t */\n\tconstructor( params = [] ) {\n\n\t\tsuper();\n\n\t\tthis.params = params;\n\n\t}\n\n\t/**\n\t * Returns a loop variable name based on an index. The pattern is\n\t * `0` = `i`, `1`= `j`, `2`= `k` and so on.\n\t *\n\t * @param {Number} index - The index.\n\t * @return {String} The loop variable name.\n\t */\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt( 0 ) + index );\n\n\t}\n\n\t/**\n\t * Returns properties about this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Object} The node properties.\n\t */\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tconst stack = builder.addStack(); // TODO: cache() it\n\n\t\tproperties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );\n\t\tproperties.stackNode = stack;\n\n\t\tbuilder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred based on the loop configuration.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { returnsNode } = this.getProperties( builder );\n\n\t\treturn returnsNode ? returnsNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\ttype = 'int';\n\t\t\t\tname = this.getVarName( i );\n\t\t\t\tstart = '0';\n\t\t\t\tend = param.build( builder, type );\n\t\t\t\tcondition = '<';\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = builder.generateConst( type, start );\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = builder.generateConst( type, end );\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst internalParam = { start, end, condition };\n\n\t\t\t//\n\n\t\t\tconst startSnippet = internalParam.start;\n\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\tlet declarationSnippet = '';\n\t\t\tlet conditionalSnippet = '';\n\t\t\tlet updateSnippet = '';\n\n\t\t\tif ( ! update ) {\n\n\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '++';\n\t\t\t\t\telse update = '--';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( condition.includes( '<' ) ) update = '+= 1.';\n\t\t\t\t\telse update = '-= 1.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdeclarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;\n\n\t\t\tconditionalSnippet += name + ' ' + condition + ' ' + endSnippet;\n\t\t\tupdateSnippet += name + ' ' + update;\n\n\t\t\tconst forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + forSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = stackNode.build( builder, 'void' );\n\n\t\tconst returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t\treturn returnsSnippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a loop node.\n *\n * @function\n * @param {...Any} params - A list of parameters.\n * @returns {LoopNode}\n */\nconst Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();\n\n/**\n * TSL function for creating a `Continue()` expression.\n *\n * @function\n * @returns {ExpressionNode}\n */\nconst Continue = () => expression( 'continue' ).append();\n\n/**\n * TSL function for creating a `Break()` expression.\n *\n * @function\n * @returns {ExpressionNode}\n */\nconst Break = () => expression( 'break' ).append();\n\n//\n\nconst loop = ( ...params ) => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );\n\treturn Loop( ...params );\n\n};\n\n/** @module MorphNode **/\n\nconst _morphTextures = /*@__PURE__*/ new WeakMap();\nconst _morphVec4 = /*@__PURE__*/ new Vector4();\n\nconst getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = _morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\t_morphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\t_morphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for morph target animation.\n *\n * @augments Node\n */\nclass MorphNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MorphNode';\n\n\t}\n\n\t/**\n\t * Constructs a new morph node.\n\t *\n\t * @param {Mesh} mesh - The mesh holding the morph targets.\n\t */\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The mesh holding the morph targets.\n\t\t *\n\t\t * @type {Mesh}\n\t\t */\n\t\tthis.mesh = mesh;\n\n\t\t/**\n\t\t * A uniform node which represents the morph base influence value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\t/**\n\t\t * The update type overwritten since morph nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Setups the morph node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tLoop( morphTargetsCount, ( { i } ) => {\n\n\t\t\tconst influence = float( 0 ).toVar();\n\n\t\t\tif ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {\n\n\t\t\t\tinfluence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );\n\n\t\t\t} else {\n\n\t\t\t\tinfluence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 0 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\tbufferMap,\n\t\t\t\t\tinfluence,\n\t\t\t\t\tstride,\n\t\t\t\t\twidth,\n\t\t\t\t\tdepth: i,\n\t\t\t\t\toffset: int( 1 )\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates the state of the morphed mesh by updating the base influence.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a morph node.\n *\n * @function\n * @param {Mesh} mesh - The mesh holding the morph targets.\n * @returns {MorphNode}\n */\nconst morphReference = /*@__PURE__*/ nodeProxy( MorphNode );\n\n/**\n * Base class for lighting nodes.\n *\n * @augments Node\n */\nclass LightingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lighting node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLightingNode = true;\n\n\t}\n\n}\n\n/**\n * A generic class that can be used by nodes which contribute\n * ambient occlusion to the scene. E.g. an ambient occlusion map\n * node can be used as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass AONode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AONode';\n\n\t}\n\n\t/**\n\t * Constructs a new AO node.\n\t *\n\t * @param {Node<float>?} [aoNode=null] - The ambient occlusion node.\n\t */\n\tconstructor( aoNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The ambient occlusion node.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = aoNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.ambientOcclusion.mulAssign( this.aoNode );\n\n\t}\n\n}\n\n/**\n * `LightingContextNode` represents an extension of the {@link module:ContextNode~ContextNode} module\n * by adding lighting specific context data. It represents the runtime context of\n * {@link LightsNode}.\n *\n * @augments ContextNode\n */\nclass LightingContextNode extends ContextNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightingContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lighting context node.\n\t *\n\t * @param {LightsNode} node - The lights node.\n\t * @param {LightingModel?} [lightingModel=null] - The current lighting model.\n\t * @param {Node<vec3>?} [backdropNode=null] - A backdrop node.\n\t * @param {Node<float>?} [backdropAlphaNode=null] - A backdrop alpha node.\n\t */\n\tconstructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {\n\n\t\tsuper( node );\n\n\t\t/**\n\t\t * The current lighting model.\n\t\t *\n\t\t * @type {LightingModel?}\n\t\t * @default null\n\t\t */\n\t\tthis.lightingModel = lightingModel;\n\n\t\t/**\n\t\t * A backdrop node.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = backdropNode;\n\n\t\t/**\n\t\t * A backdrop alpha node.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = backdropAlphaNode;\n\n\t\tthis._value = null;\n\n\t}\n\n\t/**\n\t * Returns a lighting context object.\n\t *\n\t * @return {{\n\t * radiance: Node<vec3>,\n\t * irradiance: Node<vec3>,\n\t * iblIrradiance: Node<vec3>,\n\t * ambientOcclusion: Node<float>,\n\t * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},\n\t * backdrop: Node<vec3>,\n\t * backdropAlpha: Node<float>\n\t * }} The lighting context object.\n\t */\n\tgetContext() {\n\n\t\tconst { backdropNode, backdropAlphaNode } = this;\n\n\t\tconst directDiffuse = vec3().toVar( 'directDiffuse' ),\n\t\t\tdirectSpecular = vec3().toVar( 'directSpecular' ),\n\t\t\tindirectDiffuse = vec3().toVar( 'indirectDiffuse' ),\n\t\t\tindirectSpecular = vec3().toVar( 'indirectSpecular' );\n\n\t\tconst reflectedLight = {\n\t\t\tdirectDiffuse,\n\t\t\tdirectSpecular,\n\t\t\tindirectDiffuse,\n\t\t\tindirectSpecular\n\t\t};\n\n\t\tconst context = {\n\t\t\tradiance: vec3().toVar( 'radiance' ),\n\t\t\tirradiance: vec3().toVar( 'irradiance' ),\n\t\t\tiblIrradiance: vec3().toVar( 'iblIrradiance' ),\n\t\t\tambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),\n\t\t\treflectedLight,\n\t\t\tbackdrop: backdropNode,\n\t\t\tbackdropAlpha: backdropAlphaNode\n\t\t};\n\n\t\treturn context;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.value = this._value || ( this._value = this.getContext() );\n\t\tthis.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );\n\n/**\n * A generic class that can be used by nodes which contribute\n * irradiance to the scene. E.g. a light map node can be used\n * as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass IrradianceNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'IrradianceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new irradiance node.\n\t *\n\t * @param {Node<vec3>} node - A node contributing irradiance.\n\t */\n\tconstructor( node ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node contributing irradiance.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.irradiance.addAssign( this.node );\n\n\t}\n\n}\n\n/** @module ScreenNode **/\n\nlet screenSizeVec, viewportVec;\n\n/**\n * This node provides a collection of screen related metrics.\n * Depending on {@link module:ScreenNode~ScreenNode#scope}, the nodes can represent\n * resolution or viewport data as well as fragment or uv coordinates.\n *\n * @augments Node\n */\nclass ScreenNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScreenNode';\n\n\t}\n\n\t/**\n\t * Constructs a new screen node.\n\t *\n\t * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node represents different metric depending on which scope is selected.\n\t\t *\n\t\t * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.\n\t\t * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.\n\t\t * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.\n\t\t * - `ScreenNode.UV`: Normalized coordinates.\n\t\t *\n\t\t * @type {('coordinate'|'viewport'|'size'|'uv')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type depends on the selected scope.\n\t *\n\t * @return {('vec2'|'vec4')} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';\n\t\telse return 'vec2';\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node's update type depends on the selected scope.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tupdateType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\t/**\n\t * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information\n\t * from the current renderer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { renderer } ) {\n\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tviewportVec.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getViewport( viewportVec );\n\n\t\t\t\tviewportVec.multiplyScalar( renderer.getPixelRatio() );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tscreenSizeVec.width = renderTarget.width;\n\t\t\t\tscreenSizeVec.height = renderTarget.height;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( screenSizeVec );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ScreenNode.SIZE ) {\n\n\t\t\toutput = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );\n\n\t\t} else if ( scope === ScreenNode.VIEWPORT ) {\n\n\t\t\toutput = uniform( viewportVec || ( viewportVec = new Vector4() ) );\n\n\t\t} else {\n\n\t\t\toutput = vec2( screenCoordinate.div( screenSize ) );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ScreenNode.COORDINATE ) {\n\n\t\t\tlet coord = builder.getFragCoord();\n\n\t\t\tif ( builder.isFlipY() ) {\n\n\t\t\t\t// follow webgpu standards\n\n\t\t\t\tconst size = builder.getNodeProperties( screenSize ).outputNode.build( builder );\n\n\t\t\t\tcoord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;\n\n\t\t\t}\n\n\t\t\treturn coord;\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\n\n// Screen\n\n/**\n * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );\n\n/**\n * TSL object that represents the screen resolution in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );\n\n// Viewport\n\n/**\n * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.\n *\n * @type {ScreenNode<vec4>}\n */\nconst viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );\n\n/**\n * TSL object that represents the viewport resolution in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportSize = viewport.zw;\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );\n\n/**\n * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.\n *\n * @type {ScreenNode<vec2>}\n */\nconst viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );\n\n// Deprecated\n\nconst viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.' );\n\n\treturn screenSize;\n\n}, 'vec2' ).once() )();\n\nconst viewportTopLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportTopLeft\" is deprecated. Use \"screenUV\" instead.' );\n\n\treturn screenUV;\n\n}, 'vec2' ).once() )();\n\nconst viewportBottomLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168\n\n\tconsole.warn( 'TSL.ViewportNode: \"viewportBottomLeft\" is deprecated. Use \"screenUV.flipY()\" instead.' );\n\n\treturn screenUV.flipY();\n\n}, 'vec2' ).once() )();\n\n/** @module ViewportTextureNode **/\n\nconst _size$4 = /*@__PURE__*/ new Vector2();\n\n/**\n * A special type of texture node which represents the data of the current viewport\n * as a texture. The module extracts data from the current bound framebuffer with\n * a copy operation so no extra render pass is required to produce the texture data\n * (which is good for performance). `ViewportTextureNode` can be used as an input for a\n * variety of effects like refractive or transmissive materials.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass ViewportTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {Node?} [levelNode=null] - The level node.\n\t * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {\n\n\t\tif ( framebufferTexture === null ) {\n\n\t\t\tframebufferTexture = new FramebufferTexture();\n\t\t\tframebufferTexture.minFilter = LinearMipmapLinearFilter;\n\n\t\t}\n\n\t\tsuper( framebufferTexture, uvNode, levelNode );\n\n\t\t/**\n\t\t * Whether to generate mipmaps or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputTextureNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst renderer = frame.renderer;\n\t\trenderer.getDrawingBufferSize( _size$4 );\n\n\t\t//\n\n\t\tconst framebufferTexture = this.value;\n\n\t\tif ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {\n\n\t\t\tframebufferTexture.image.width = _size$4.width;\n\t\t\tframebufferTexture.image.height = _size$4.height;\n\t\t\tframebufferTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n\t\tframebufferTexture.generateMipmaps = this.generateMipmaps;\n\n\t\trenderer.copyFramebufferToTexture( framebufferTexture );\n\n\t\tframebufferTexture.generateMipmaps = currentGenerateMipmaps;\n\n\t}\n\n\tclone() {\n\n\t\tconst viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );\n\t\tviewportTextureNode.generateMipmaps = this.generateMipmaps;\n\n\t\treturn viewportTextureNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a viewport texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );\n\n/**\n * TSL function for creating a viewport texture node with enabled mipmap generation.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );\n\n/** @module ViewportDepthTextureNode **/\n\nlet sharedDepthbuffer = null;\n\n/**\n * Represents the depth of the current viewport as a texture. This module\n * can be used in combination with viewport texture to achieve effects\n * that require depth evaluation.\n *\n * @augments module:ViewportTextureNode~ViewportTextureNode\n */\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {Node?} [levelNode=null] - The level node.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( sharedDepthbuffer === null ) {\n\n\t\t\tsharedDepthbuffer = new DepthTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, sharedDepthbuffer );\n\n\t}\n\n}\n\n/**\n * TSL function for a viewport depth texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @returns {ViewportDepthTextureNode}\n */\nconst viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );\n\n/** @module ViewportDepthNode **/\n\n/**\n * This node offers a collection of features in context of the depth logic in the fragment shader.\n * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current\n * fragment or for depth evaluation purposes.\n *\n * @augments Node\n */\nclass ViewportDepthNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth node.\n\t *\n\t * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.\n\t * @param {Node?} [valueNode=null] - The value node.\n\t */\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The node behaves differently depending on which scope is selected.\n\t\t *\n\t\t * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.\n\t\t * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).\n\t\t * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.\n\t\t * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.\n\t\t *\n\t\t * @type {('depth'|'depthBase'|'linearDepth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * Can be used to define a custom depth value.\n\t\t * The property is ignored in the `ViewportDepthNode.DEPTH` scope.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( { camera } ) {\n\n\t\tconst { scope } = this;\n\t\tconst value = this.valueNode;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\tif ( value !== null ) {\n\n \t\t\t\tnode = depthBase().assign( value );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tnode = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tconst viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );\n\n\t\t\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n/**\n * TSL function for converting a viewZ value to an orthographic depth value.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n/**\n * TSL function for converting an orthographic depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The orthographic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n/**\n * TSL function for converting a viewZ value to a perspective depth value.\n *\n * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );\n\n/**\n * TSL function for converting a perspective depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The perspective depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\n/**\n * TSL function for converting a viewZ value to a logarithmic depth value.\n *\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToLogarithmicDepth = ( viewZ, near, far ) => {\n\n\t// NOTE: viewZ must be negative--see explanation at the end of this comment block.\n\t// The final logarithmic depth formula used here is adapted from one described in an\n\t// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n\t// which was an improvement upon an earlier formula one described in an\n\t// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n\t// Ulrich's formula is the following:\n\t//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n\t//     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n\t// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n\t// opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n\t// Outerra states: \"Notice that the 'C' variant doesnt use a near plane distance, it has it\n\t// set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n\t// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n\t// It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n\t// be used, and ultimately Ulrich's \"near plane\" version was chosen.\n\t// Outerra eventually made another improvement to their original \"C-constant\" variant,\n\t// but it still does not incorporate the camera near plane (for this version,\n\t// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n\t// Here we make 4 changes to Ulrich's formula:\n\t// 1. Clamp the camera near plane so we don't divide by 0.\n\t// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n\t// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n\t// 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n\t//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n\t//    so we do the same here, hence the 'viewZ.negate()' call.\n\t// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n\tnear = near.max( 1e-6 ).toVar();\n\tconst numerator = log2( viewZ.negate().div( near ) );\n\tconst denominator = log2( far.div( near ) );\n\treturn numerator.div( denominator );\n\n};\n\n/**\n * TSL function for converting a logarithmic depth value to a viewZ value.\n *\n * @function\n * @param {Node<float>} depth - The logarithmic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst logarithmicDepthToViewZ = ( depth, near, far ) => {\n\n\t// NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n\t// the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n\t// a negative viewZ).\n\tconst exponent = depth.mul( log( far.div( near ) ) );\n\treturn float( Math.E ).pow( exponent ).mul( near ).negate();\n\n};\n\n/**\n * TSL function for defining a value for the current fragment's depth.\n *\n * @function\n * @param {Node<float>} value - The depth value to set.\n * @returns {ViewportDepthNode<float>}\n */\nconst depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );\n\n/**\n * TSL object that represents the depth value for the current fragment.\n *\n * @type {ViewportDepthNode}\n */\nconst depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\n\n/**\n * TSL function for converting a perspective depth value to linear depth.\n *\n * @function\n * @param {Node<float>} value - The perspective depth.\n * @returns {ViewportDepthNode<float>}\n */\nconst linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );\n\n/**\n * TSL object that represents the linear (orthographic) depth value of the current fragment\n *\n * @type {ViewportDepthNode}\n */\nconst viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );\n\ndepth.assign = ( value ) => depthBase( value );\n\n/** @module BuiltinNode **/\n\n/**\n * The node allows to set values for built-in shader variables. That is\n * required for features like hardware-accelerated vertex clipping.\n *\n * @augments Node\n */\nclass BuiltinNode extends Node {\n\n\t/**\n\t * Constructs a new builtin node.\n\t *\n\t * @param {String} name - The name of the built-in shader variable.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The name of the built-in shader variable.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuiltinNode = true;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the builtin node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( /* builder */ ) {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a builtin node.\n *\n * @function\n * @param {String} name - The name of the built-in shader variable.\n * @returns {BuiltinNode}\n */\nconst builtin = nodeProxy( BuiltinNode );\n\n/** @module ClippingNode **/\n\n/**\n * ```\n * This node is used in {@link NodeMaterial} to setup the clipping\n * which can happen hardware-accelerated (if supported) and optionally\n * use alpha-to-coverage for anti-aliasing clipped edges.\n * ```\n * @augments Node\n */\nclass ClippingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ClippingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new clipping node.\n\t *\n\t * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,\n\t * the selected scope influences the behavior of the node and what type of code is generated.\n\t */\n\tconstructor( scope = ClippingNode.DEFAULT ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node's scope. Similar to other nodes, the selected scope influences\n\t\t * the behavior of the node and what type of code is generated.\n\t\t *\n\t\t * @type {('default'|'hardware'|'alphaToCoverage')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Setups the node depending on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The result node.\n\t */\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst clippingContext = builder.clippingContext;\n\t\tconst { intersectionPlanes, unionPlanes } = clippingContext;\n\n\t\tthis.hardwareClipping = builder.material.hardwareClipping;\n\n\t\tif ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {\n\n\t\t\treturn this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );\n\n\t\t} else if ( this.scope === ClippingNode.HARDWARE ) {\n\n\t\t\treturn this.setupHardwareClipping( unionPlanes, builder );\n\n\t\t} else {\n\n\t\t\treturn this.setupDefault( intersectionPlanes, unionPlanes );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups alpha to coverage.\n\t *\n\t * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @return {Node} The result node.\n\t */\n\tsetupAlphaToCoverage( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst distanceToPlane = float().toVar( 'distanceToPlane' );\n\t\t\tconst distanceGradient = float().toVar( 'distanceToGradient' );\n\n\t\t\tconst clipOpacity = float( 1 ).toVar( 'clipOpacity' );\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( this.hardwareClipping === false && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tclipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tintersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );\n\n\t\t\t\t} );\n\n\t\t\t\tclipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );\n\n\t\t\t}\n\n\t\t\tdiffuseColor.a.mulAssign( clipOpacity );\n\n\t\t\tdiffuseColor.a.equal( 0.0 ).discard();\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups the default clipping.\n\t *\n\t * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @return {Node} The result node.\n\t */\n\tsetupDefault( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( this.hardwareClipping === false && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tpositionView.dot( plane.xyz ).greaterThan( plane.w ).discard();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes );\n\t\t\t\tconst clipped = bool( true ).toVar( 'clipped' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tclipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );\n\n\t\t\t\t} );\n\n\t\t\t\tclipped.discard();\n\n\t\t\t}\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups hardware clipping.\n\t *\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The result node.\n\t */\n\tsetupHardwareClipping( unionPlanes, builder ) {\n\n\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\tbuilder.enableHardwareClipping( numUnionPlanes );\n\n\t\treturn Fn( () => {\n\n\t\t\tconst clippingPlanes = uniformArray( unionPlanes );\n\t\t\tconst hw_clip_distances = builtin( builder.getClipDistance() );\n\n\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\tconst distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();\n\t\t\t\thw_clip_distances.element( i ).assign( distance );\n\n\t\t\t} );\n\n\t\t} )();\n\n\t}\n\n}\n\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\n\n/**\n * TSL function for setting up the default clipping logic.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst clipping = () => nodeObject( new ClippingNode() );\n\n/**\n * TSL function for setting up alpha to coverage.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );\n\n/**\n * TSL function for setting up hardware-based clipping.\n *\n * @function\n * @returns {ClippingNode}\n */\nconst hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );\n\n// See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );\n\n} );\n\nconst hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\n} );\n\nconst getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {\n\n\t// Find the discretized derivatives of our coordinates\n\tconst maxDeriv = max$1(\n\t\tlength( dFdx( position.xyz ) ),\n\t\tlength( dFdy( position.xyz ) )\n\t);\n\n\tconst pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );\n\n\t// Find two nearest log-discretized noise scales\n\tconst pixScales = vec2(\n\t\texp2( floor( log2( pixScale ) ) ),\n\t\texp2( ceil( log2( pixScale ) ) )\n\t);\n\n\t// Compute alpha thresholds at our two noise scales\n\tconst alpha = vec2(\n\t\thash3D( floor( pixScales.x.mul( position.xyz ) ) ),\n\t\thash3D( floor( pixScales.y.mul( position.xyz ) ) ),\n\t);\n\n\t// Factor to interpolate lerp with\n\tconst lerpFactor = fract( log2( pixScale ) );\n\n\t// Interpolate alpha threshold from noise at two scales\n\tconst x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );\n\n\t// Pass into CDF to compute uniformly distrib threshold\n\tconst a = min$1( lerpFactor, lerpFactor.oneMinus() );\n\tconst cases = vec3(\n\t\tx.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),\n\t\tx.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),\n\t\tsub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );\n\n\t// Find our final, uniformly distributed alpha threshold ()\n\tconst threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );\n\n\t// Avoids  == 0. Could also do  =1-\n\treturn clamp( threshold, 1.0e-6, 1.0 );\n\n} ).setLayout( {\n\tname: 'getAlphaHashThreshold',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' }\n\t]\n} );\n\n/**\n * Base class for all node materials.\n *\n * @augments Material\n */\nclass NodeMaterial extends Material {\n\n\tstatic get type() {\n\n\t\treturn 'NodeMaterial';\n\n\t}\n\n\t/**\n\t * Represents the type of the node material.\n\t *\n\t * @type {String}\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tset type( _value ) { /* */ }\n\n\t/**\n\t * Constructs a new node material.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeMaterial = true;\n\n\t\t/**\n\t\t * Whether this material is affected by fog or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.fog = true;\n\n\t\t/**\n\t\t * Whether this material is affected by lights or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.lights = false;\n\n\t\t/**\n\t\t * Whether this material uses hardware clipping or not.\n\t\t * This property is managed by the engine and should not be\n\t\t * modified by apps.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.hardwareClipping = false;\n\n\t\t/**\n\t\t * Node materials which set their `lights` property to `true`\n\t\t * are affected by all lights of the scene. Sometimes selective\n\t\t * lighting is wanted which means only _some_ lights in the scene\n\t\t * affect a material. This can be achieved by creating an instance\n\t\t * of {@link module:LightsNode~LightsNode} with a list of selective\n\t\t * lights and assign the node to this property.\n\t\t *\n\t\t * ```js\n\t\t * const customLightsNode = lights( [ light1, light2 ] );\n\t\t * material.lightsNode = customLightsNode;\n\t\t * ```\n\t\t *\n\t\t * @type {LightsNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * The environment of node materials can be defined by an environment\n\t\t * map assigned to the `envMap` property or by `Scene.environment`\n\t\t * if the node material is a PBR material. This node property allows to overwrite\n\t\t * the default behavior and define the environment with a custom node.\n\t\t *\n\t\t * ```js\n\t\t * material.envNode = pmremTexture( renderTarget.texture );\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = null;\n\n\t\t/**\n\t\t * The lighting of node materials might be influenced by ambient occlusion.\n\t\t * The default AO is inferred from an ambient occlusion map assigned to `aoMap`\n\t\t * and the respective `aoMapIntensity`. This node property allows to overwrite\n\t\t * the default and define the ambient occlusion with a custom node instead.\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link module:MaterialNode.materialAO}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = null;\n\n\t\t/**\n\t\t * The diffuse color of node materials is by default inferred from the\n\t\t * `color` and `map` properties. This node property allows to overwrite the default\n\t\t * and define the diffuse color with a node instead.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = color( 0xff0000 ); // define red color\n\t\t * ```\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link module:MaterialNode.materialColor}.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = null;\n\n\t\t/**\n\t\t * The normals of node materials are by default inferred from the `normalMap`/`normalScale`\n\t\t * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default\n\t\t * and define the normals with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing values instead,\n\t\t * use {@link module:MaterialNode.materialNormal}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.normalNode = null;\n\n\t\t/**\n\t\t * The opacity of node materials is by default inferred from the `opacity`\n\t\t * and `alphaMap` properties. This node property allows to overwrite the default\n\t\t * and define the opacity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialOpacity}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.opacityNode = null;\n\n\t\t/**\n\t\t * This node can be used to to implement a variety of filter-like effects. The idea is\n\t\t * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it\n\t\t * to create an arbitrary effect and then assign the node composition to this property.\n\t\t * Everything behind the object using this material will now be affected by a filter.\n\t\t *\n\t\t * ```js\n\t\t * const material = new NodeMaterial()\n\t\t * material.transparent = true;\n\t\t *\n\t\t * // everything behind the object will be monochromatic\n\t\t * material.backdropNode = viewportSharedTexture().rgb.saturation( 0 );\n\t\t * ```\n\t\t *\n\t\t * Backdrop computations are part of the lighting so only lit materials can use this property.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = null;\n\n\t\t/**\n\t\t * This node allows to modulate the influence of `backdropNode` to the outgoing light.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = null;\n\n\t\t/**\n\t\t * The alpha test of node materials is by default inferred from the `alphaTest`\n\t\t * property. This node property allows to overwrite the default and define the\n\t\t * alpha test with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the alpha test but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAlphaTest}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.alphaTestNode = null;\n\n\t\t/**\n\t\t * The local vertex positions are computed based on multiple factors like the\n\t\t * attribute data, morphing or skinning. This node property allows to overwrite\n\t\t * the default and define local vertex positions with nodes instead.\n\t\t *\n\t\t * If you don't want to overwrite the vertex positions but modify the existing\n\t\t * values instead, use {@link module:Position.positionLocal}.\n\t\t *\n\t\t *```js\n\t\t * material.positionNode = positionLocal.add( displace );\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * This node property is intended for logic which modifies geometry data once or per animation step.\n\t\t * Apps usually place such logic randomly in initialization routines or in the animation loop.\n\t\t * `geometryNode` is intended as a dedicated API so there is an intended spot where goemetry modiciations\n\t\t * can be implemented.\n\t\t *\n\t\t * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example\n\t\t * would be a GPU based particle system that provides a node material for usage on app level. The particle\n\t\t * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is\n\t\t * eventually assigned to `geometryNode`.\n\t\t *\n\t\t * @type {Function}\n\t\t * @default null\n\t\t */\n\t\tthis.geometryNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite depth values in the fragment shader.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite the position used for shadow map rendering which\n\t\t * is by default {@link module:Position.positionWorld}, the vertex position\n\t\t * in world space.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.shadowPositionNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * receive shadows.\n\t\t *\n\t\t * ```js\n\t\t * const totalShadows = float( 1 ).toVar();\n\t\t * material.receivedShadowNode = Fn( ( [ shadow ] ) => {\n\t\t * \ttotalShadows.mulAssign( shadow );\n\t\t * \t//return float( 1 ); // bypass received shadows\n\t\t * \treturn shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color\n\t\t * } );\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.receivedShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * casts shadows. To apply a color to shadows, you can simply do:\n\t\t *\n\t\t * ```js\n\t\t * material.castShadowNode = vec4( 1, 0, 0, 1 );\n\t\t * ```\n\t\t *\n\t\t * Which can be nice to fake colored shadows of semi-transparent objects. It\n\t\t * is also common to use the property with `Fn` function so checks are performed\n\t\t * per fragment.\n\t\t *\n\t\t * ```js\n\t\t * materialCustomShadow.castShadowNode = Fn( () => {\n\t\t * \thash( vertexIndex ).greaterThan( 0.5 ).discard();\n\t\t * \treturn materialColor;\n\t\t * } )();\n\t\t *  ```\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.castShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to define the final output of the material.\n\t\t *\n\t\t * TODO: Explain the differences to `fragmentNode`.\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * MRT configuration is done on renderer or pass level. This node allows to\n\t\t * overwrite what values are written into MRT targets on material level. This\n\t\t * can be useful for implementing selective FX features that should only affect\n\t\t * specific objects.\n\t\t *\n\t\t * @type {MRTNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.mrtNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the fragment shader. Assigning a node will replace the built-in material\n\t\t * logic used in the fragment stage.\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.fragmentNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the vertex shader. Assigning a node will replace the built-in material logic\n\t\t * used in the vertex stage.\n\t\t *\n\t\t * @type {Node<vec4>?}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexNode = null;\n\n\t}\n\n\t/**\n\t * Allows to define a custom cache key that influence the material key computation\n\t * for render objects.\n\t *\n\t * @return {String} The custom cache key.\n\t */\n\tcustomProgramCacheKey() {\n\n\t\treturn this.type + getCacheKey$1( this );\n\n\t}\n\n\t/**\n\t * Builds this material with the given node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\t/**\n\t * Setups a node material observer with the given builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tsetupObserver( builder ) {\n\n\t\treturn new NodeMaterialObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupNormal = () => this.setupNormal( builder );\n\t\tbuilder.context.setupPositionView = () => this.setupPositionView( builder );\n\t\tbuilder.context.setupModelViewProjection = () => this.setupModelViewProjection( builder );\n\n\t\tconst renderer = builder.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tconst vertexNode = this.vertexNode || this.setupVertex( builder );\n\n\t\tbuilder.stack.outputNode = vertexNode;\n\n\t\tthis.setupHardwareClipping( builder );\n\n\t\tif ( this.geometryNode !== null ) {\n\n\t\t\tbuilder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );\n\n\t\t}\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true || this.depthTest === true ) {\n\n\t\t\t// only write depth if depth buffer is configured\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( renderTarget.depthBuffer === true ) this.setupDepth( builder );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderer.depth === true ) this.setupDepth( builder );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.add( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tif ( this.outputNode !== null ) resultNode = this.outputNode;\n\n\t\t\t// MRT\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tconst mrt = renderer.getMRT();\n\t\t\t\tconst materialMRT = this.mrtNode;\n\n\t\t\t\tif ( mrt !== null ) {\n\n\t\t\t\t\tresultNode = mrt;\n\n\t\t\t\t\tif ( materialMRT !== null ) {\n\n\t\t\t\t\t\tresultNode = mrt.merge( materialMRT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialMRT !== null ) {\n\n\t\t\t\t\tresultNode = materialMRT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t\t// < MONITOR >\n\n\t\tbuilder.monitor = this.setupObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the clipping node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ClippingNode} The clipping node.\n\t */\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { unionPlanes, intersectionPlanes } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {\n\n\t\t\tconst samples = builder.renderer.samples;\n\n\t\t\tif ( this.alphaToCoverage && samples > 1 ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.add( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Setups the hardware clipping if available on the current device.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupHardwareClipping( builder ) {\n\n\t\tthis.hardwareClipping = false;\n\n\t\tif ( builder.clippingContext === null ) return;\n\n\t\tconst candidateCount = builder.clippingContext.unionPlanes.length;\n\n\t\t// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n\t\tif ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {\n\n\t\t\tbuilder.stack.add( hardwareClipping() );\n\n\t\t\tthis.hardwareClipping = true;\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t/**\n\t * Setups the depth of this material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null ) {\n\n\t\t\tconst mrt = renderer.getMRT();\n\n\t\t\tif ( mrt && mrt.has( 'depth' ) ) {\n\n\t\t\t\tdepthNode = mrt.get( 'depth' );\n\n\t\t\t} else if ( renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tdepthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepth.assign( depthNode ).append();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method exists\n\t * so derived node materials can modifiy the implementation e.g. sprite materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( /*builder*/ ) {\n\n\t\treturn modelViewMatrix.mul( positionLocal ).xyz;\n\n\t}\n\n\t/**\n\t * Setups the position in clip space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in view space.\n\t */\n\tsetupModelViewProjection( /*builder*/ ) {\n\n\t\treturn cameraProjectionMatrix.mul( positionView );\n\n\t}\n\n\t/**\n\t * Setups the logic for the vertex stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in clip space.\n\t */\n\tsetupVertex( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tthis.setupPosition( builder );\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\n\t\treturn modelViewProjection;\n\n\t}\n\n\t/**\n\t * Setups the computation of the position in local space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in local space.\n\t */\n\tsetupPosition( builder ) {\n\n\t\tconst { object, geometry } = builder;\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).append();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinningReference( object ).append();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).append();\n\n\t\t}\n\n\t\tif ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {\n\n\t\t\tinstancedMesh( object ).append();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( this.positionNode.context( { isPositionNodeInput: true } ) );\n\n\t\t}\n\n\t\treturn positionLocal;\n\n\t}\n\n\t/**\n\t * Setups the computation of the material's diffuse color.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {BufferGeometry} geometry - The geometry.\n\t */\n\tsetupDiffuseColor( { object, geometry } ) {\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );\n\n\t\t}\n\n\t\t// Instanced colors\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh && object._colorsTexture ) {\n\n\t\t\tconst batchColor = varyingProperty( 'vec3', 'vBatchColor' );\n\n\t\t\tcolorNode = batchColor.mul( colorNode );\n\n\t\t}\n\n\n\t\t// COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\tconst alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t}\n\n\t\t// ALPHA HASH\n\n\t\tif ( this.alphaHash === true ) {\n\n\t\t\tdiffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();\n\n\t\t}\n\n\t\tif ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {\n\n\t\t\tdiffuseColor.a.assign( 1.0 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract interface method that can be implemented by derived materials\n\t * to setup material-specific node variables.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node variable\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the normal node from the material.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t}\n\n\t/**\n\t * Setups the environment node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The environment node.\n\t */\n\tsetupEnvironment( /*builder*/ ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the light map node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new IrradianceNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the lights node based on the scene, environment and material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightsNode} The lights node.\n\t */\n\tsetupLights( builder ) {\n\n\t\tconst materialLightsNode = [];\n\n\t\t//\n\n\t\tconst envNode = this.setupEnvironment( builder );\n\n\t\tif ( envNode && envNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( envNode );\n\n\t\t}\n\n\t\tconst lightMapNode = this.setupLightMap( builder );\n\n\t\tif ( lightMapNode && lightMapNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( lightMapNode );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : materialAO;\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\t/**\n\t * This method should be implemented by most derived materials\n\t * since it defines the material's lighting model.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = this.setupOutgoingLight( builder );\n\n\t\tif ( lightsNode && lightsNode.getScope().hasLights ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder );\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\temissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissive );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Setups the output node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\tconst fogNode = builder.fogNode;\n\n\t\t\tif ( fogNode ) {\n\n\t\t\t\toutput.assign( outputNode );\n\n\t\t\t\toutputNode = vec4( fogNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\t/**\n\t * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`\n\t * there is `MeshBasicNodeMaterial`. This utility method is intended for\n\t * defining all material properties of the classic type in the node type.\n\t *\n\t * @param {Material} material - The material to copy properties with their values to this node material.\n\t */\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes this material to JSON.\n\t *\n\t * @param {(Object|String)?} meta - The meta information for serialization.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tconst nodeChildren = getNodeChildren( this );\n\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of nodeChildren ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Copies the properties of the given node material to this instance.\n\t *\n\t * @param {NodeMaterial} source - The material to copy.\n\t * @return {NodeMaterial} A reference to this node material.\n\t */\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.geometryNode = source.geometryNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.shadowPositionNode = source.shadowPositionNode;\n\t\tthis.receivedShadowNode = source.receivedShadowNode;\n\t\tthis.castShadowNode = source.castShadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.mrtNode = source.mrtNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$e = /*@__PURE__*/ new PointsMaterial();\n\n/**\n * Unlike WebGL, WebGPU can render point primitives only with a size\n * of one pixel. This type node material can be used to mimic the WebGL\n * points rendering by rendering small planes via instancing.\n *\n * This material should be used with {@link InstancedPointsGeometry}.\n *\n * @augments NodeMaterial\n */\nclass InstancedPointsNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedPointsNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new instanced points node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInstancedPointsNodeMaterial = true;\n\n\t\t/**\n\t\t * Whether vertex colors should be used or not. If set to `true`,\n\t\t * each point instance can receive a custom color value.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useColor = parameters.vertexColors;\n\n\t\t/**\n\t\t * The points width in pixels.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.pointWidth = 1;\n\n\t\t/**\n\t\t * This node can be used to define the colors for each instance.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.pointColorNode = null;\n\n\t\t/**\n\t\t * This node can be used to define the width for each point instance.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.pointWidthNode = null;\n\n\t\tthis._useAlphaToCoverage = true;\n\n\t\tthis.setDefaultValues( _defaultValues$e );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst useAlphaToCoverage = this._useAlphaToCoverage;\n\t\tconst useColor = this.useColor;\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instancePosition = attribute( 'instancePosition' ).xyz;\n\n\t\t\t// camera space\n\t\t\tconst mvPos = vec4( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// clip space\n\t\t\tconst clipPos = cameraProjectionMatrix.mul( mvPos );\n\n\t\t\t// offset in ndc space\n\t\t\tconst offset = positionGeometry.xy.toVar();\n\n\t\t\toffset.mulAssign( this.pointWidthNode ? this.pointWidthNode : materialPointWidth );\n\n\t\t\toffset.assign( offset.div( viewport.z ) );\n\t\t\toffset.y.assign( offset.y.mul( aspect ) );\n\n\t\t\t// back to clip space\n\t\t\toffset.assign( offset.mul( clipPos.w ) );\n\n\t\t\t//clipPos.xy += offset;\n\t\t\tclipPos.addAssign( vec4( offset, 0, 0 ) );\n\n\t\t\treturn clipPos;\n\n\t\t} )();\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst alpha = float( 1 ).toVar();\n\n\t\t\tconst len2 = lengthSq( uv().mul( 2 ).sub( 1 ) );\n\n\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\tconst dlen = float( len2.fwidth() ).toVar();\n\n\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t} else {\n\n\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t}\n\n\t\t\tlet pointColorNode;\n\n\t\t\tif ( this.pointColorNode ) {\n\n\t\t\t\tpointColorNode = this.pointColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColor = attribute( 'instanceColor' );\n\n\t\t\t\t\tpointColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpointColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\talpha.mulAssign( materialOpacity );\n\n\t\t\treturn vec4( pointColorNode, alpha );\n\n\t\t} )();\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();\n\n/**\n * Node material version of `LineBasicMaterial`.\n *\n * @augments NodeMaterial\n */\nclass LineBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineBasicNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new line basic node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineBasicNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$d );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nconst _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * Node material version of `LineDashedMaterial`.\n *\n * @augments NodeMaterial\n */\nclass LineDashedNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineDashedNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new line dashed node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineDashedNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$c );\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * The offset of dash materials is by default inferred from the `dashOffset`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the offset with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the offset but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineDashOffset}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * The scale of dash materials is by default inferred from the `scale`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the scale with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the scale but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineScale}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * The dash size of dash materials is by default inferred from the `dashSize`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the dash size with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the dash size but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineDashSize}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * The gap size of dash materials is by default inferred from the `gapSize`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the gap size with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the gap size but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialLineGapSize}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the dash specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /* builder */ ) {\n\n\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\tdashSize.assign( dashSizeNode );\n\t\tgapSize.assign( gapSizeNode );\n\n\t\tconst vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );\n\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\tvLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();\n\n\t}\n\n}\n\n/** @module ViewportSharedTextureNode **/\n\nlet _sharedFramebuffer = null;\n\n/**\n * `ViewportTextureNode` creates an internal texture for each node instance. This module\n * shares a texture across all instances of `ViewportSharedTextureNode`. It should\n * be the first choice when using data of the default/screen framebuffer for performance reasons.\n *\n * @augments module:ViewportTextureNode~ViewportTextureNode\n */\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportSharedTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport shared texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {Node?} [levelNode=null] - The level node.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( _sharedFramebuffer === null ) {\n\n\t\t\t_sharedFramebuffer = new FramebufferTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, _sharedFramebuffer );\n\n\t}\n\n\tupdateReference() {\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a shared viewport texture node.\n *\n * @function\n * @param {Node} [uvNode=screenUV] - The uv node.\n * @param {Node?} [levelNode=null] - The level node.\n * @returns {ViewportSharedTextureNode}\n */\nconst viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );\n\nconst _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * This node material can be used to render lines with a size larger than one\n * by representing them as instanced meshes.\n *\n * @augments NodeMaterial\n */\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'Line2NodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new node material for wide line rendering.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLine2NodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$b );\n\n\t\t/**\n\t\t * Whether vertex colors should be used or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useColor = parameters.vertexColors;\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * The line width.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.lineWidth = 1;\n\n\t\t/**\n\t\t * Defines the lines color.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.lineColorNode = null;\n\n\t\t/**\n\t\t * Defines the offset.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * Defines the dash scale.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * Defines the dash size.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * Defines the gap size.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\t/**\n\t\t * Blending is set to `NoBlending` since transparency\n\t\t * is not supported, yet.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.blending = NoBlending;\n\n\t\tthis._useDash = parameters.dashed;\n\t\tthis._useAlphaToCoverage = true;\n\t\tthis._useWorldUnits = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst useAlphaToCoverage = this._useAlphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this._useDash;\n\t\tconst useWorldUnits = this._useWorldUnits;\n\n\t\tconst trimSegment = Fn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( - 0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'trimSegment',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'start', type: 'vec4' },\n\t\t\t\t{ name: 'end', type: 'vec4' }\n\t\t\t]\n\t\t} );\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );\n\t\t\tconst end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tlet lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );\n\t\t\t\tlineDistance = lineDistance.add( offsetNode );\n\n\t\t\t\tvaryingProperty( 'float', 'lineDistance' ).assign( lineDistance );\n\n\t\t\t}\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = vec4().toVar();\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = vec3().toVar();\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = Fn( () => {\n\n\t\t\tconst vUv = uv();\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst vLineDistance = varyingProperty( 'float', 'lineDistance' );\n\n\t\t\t\tvUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\tconst alpha = float( 1 ).toVar( 'alpha' );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage && renderer.samples > 1 ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\tconst dlen = float( len2.fwidth() ).toVar( 'dlen' );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tif ( this.transparent ) {\n\n\t\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t\tthis.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );\n\n\t\t}\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\t/**\n\t * Whether the lines should sized in world units or not.\n\t * When set to `false` the unit is pixel.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tget worldUnits() {\n\n\t\treturn this._useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this._useWorldUnits !== value ) {\n\n\t\t\tthis._useWorldUnits = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether the lines should be dashed or not.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tget dashed() {\n\n\t\treturn this._useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this._useDash !== value ) {\n\n\t\t\tthis._useDash = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\n/** @module Packing **/\n\n/**\n * Packs a direction vector into a color value.\n *\n * @method\n * @param {Node<vec3>} node - The direction to pack.\n * @return {Node<vec3>} The color.\n */\nconst directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );\n\n/**\n * Unpacks a color value into a direction vector.\n *\n * @method\n * @param {Node<vec3>} node - The color to unpack.\n * @return {Node<vec3>} The direction.\n */\nconst colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );\n\nconst _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();\n\n/**\n * Node material version of `MeshNormalMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshNormalNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshNormalNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh normal node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshNormalNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$a );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation by computing the diffuse color\n\t * based on the normal data.\n\t */\n\tsetupDiffuseColor() {\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\tdiffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );\n\n\t}\n\n}\n\n/** @module EquirectUVNode **/\n\n/**\n * Can be used to compute texture coordinates for projecting an\n * equirectangular texture onto a mesh for using it as the scene's\n * background.\n *\n * ```js\n * scene.backgroundNode = texture( equirectTexture, equirectUV() );\n * ```\n *\n * @augments TempNode\n */\nclass EquirectUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'EquirectUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new equirect uv node.\n\t *\n\t * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n\t */\n\tconstructor( dirNode = positionWorldDirection ) {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * A direction vector for sampling why is by default `positionWorldDirection`.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.dirNode = dirNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst dir = this.dirNode;\n\n\t\tconst u = dir.z.atan( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );\n\t\tconst v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );\n\n\t\treturn vec2( u, v );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an equirect uv node.\n *\n * @function\n * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n * @returns {EquirectUVNode}\n */\nconst equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\n/**\n * This class represents a cube render target. It is a special version\n * of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.\n *\n * @augments WebGLCubeRenderTarget\n */\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, options );\n\n\t\tthis.isCubeRenderTarget = true;\n\n\t}\n\n\t/**\n\t * Converts the given equirectangular texture to a cube map.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Texture} texture - The equirectangular texture.\n\t * @return {CubeRenderTarget} A reference to this cube render target.\n\t */\n\tfromEquirectangularTexture( renderer, texture$1 ) {\n\n\t\tconst currentMinFilter = texture$1.minFilter;\n\t\tconst currentGenerateMipmaps = texture$1.generateMipmaps;\n\n\t\ttexture$1.generateMipmaps = true;\n\n\t\tthis.texture.type = texture$1.type;\n\t\tthis.texture.colorSpace = texture$1.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture$1.generateMipmaps;\n\t\tthis.texture.minFilter = texture$1.minFilter;\n\t\tthis.texture.magFilter = texture$1.magFilter;\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst uvNode = equirectUV( positionWorldDirection );\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.colorNode = texture( texture$1, uvNode, 0 );\n\t\tmaterial.side = BackSide;\n\t\tmaterial.blending = NoBlending;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst scene = new Scene();\n\t\tscene.add( mesh );\n\n\t\t// Avoid blurred poles\n\t\tif ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\trenderer.setMRT( null );\n\n\t\tcamera.update( renderer, scene );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\ttexture$1.minFilter = currentMinFilter;\n\t\ttexture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n}\n\n/** @module CubeMapNode **/\n\nconst _cache$1 = new WeakMap();\n\n/**\n * This node can be used to automatically convert environment maps in the\n * equirectangular format into the cube map format.\n *\n * @augments TempNode\n */\nclass CubeMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube map node.\n\t *\n\t * @param {Node} envNode - The node representing the environment map.\n\t */\n\tconstructor( envNode ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The node representing the environment map.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t\t/**\n\t\t * A reference to the internal cube texture.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTexture}\n\t\t * @default null\n\t\t */\n\t\tthis._cubeTexture = null;\n\n\t\t/**\n\t\t * A reference to the internal cube texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTextureNode}\n\t\t */\n\t\tthis._cubeTextureNode = cubeTexture();\n\n\t\tconst defaultTexture = new CubeTexture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * A default cube texture that acts as a placeholder.\n\t\t * It is used when the conversion from equirectangular to cube\n\t\t * map has not finished yet for a given texture.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTexture}\n\t\t */\n\t\tthis._defaultTexture = defaultTexture;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link CubeMapNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, material } = frame;\n\n\t\tconst envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tif ( texture && texture.isTexture ) {\n\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\t\t// check for converted cubemap map\n\n\t\t\t\t\tif ( _cache$1.has( texture ) ) {\n\n\t\t\t\t\t\tconst cubeMap = _cache$1.get( texture );\n\n\t\t\t\t\t\tmapTextureMapping( cubeMap, texture.mapping );\n\t\t\t\t\t\tthis._cubeTexture = cubeMap;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// create cube map from equirectangular map\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( isEquirectangularMapReady$1( image ) ) {\n\n\t\t\t\t\t\t\tconst renderTarget = new CubeRenderTarget( image.height );\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\n\t\t\t\t\t\t\tmapTextureMapping( renderTarget.texture, texture.mapping );\n\t\t\t\t\t\t\tthis._cubeTexture = renderTarget.texture;\n\n\t\t\t\t\t\t\t_cache$1.set( texture, renderTarget.texture );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// default cube texture as fallback when equirectangular texture is not yet loaded\n\n\t\t\t\t\t\t\tthis._cubeTexture = this._defaultTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tthis._cubeTextureNode.value = this._cubeTexture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// envNode already refers to a cube map\n\n\t\t\t\t\tthis._cubeTextureNode = this.envNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateBefore( builder );\n\n\t\treturn this._cubeTextureNode;\n\n\t}\n\n}\n\n/**\n * Returns true if the given equirectangular image has been fully loaded\n * and is ready for further processing.\n *\n * @private\n * @param {Image} image - The equirectangular image to check.\n * @return {Boolean} Whether the image is ready or not.\n */\nfunction isEquirectangularMapReady$1( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * This function is executed when `dispose()` is called on the equirectangular\n * texture. In this case, the generated cube map with its render target\n * is deleted as well.\n *\n * @private\n * @param {Object} event - The event object.\n */\nfunction onTextureDispose( event ) {\n\n\tconst texture = event.target;\n\n\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\tconst renderTarget = _cache$1.get( texture );\n\n\tif ( renderTarget !== undefined ) {\n\n\t\t_cache$1.delete( texture );\n\n\t\trenderTarget.dispose();\n\n\t}\n\n}\n\n/**\n * This function makes sure the generated cube map uses the correct\n * texture mapping that corresponds to the equirectangular original.\n *\n * @private\n * @param {Texture} texture - The cube texture.\n * @param {Number} mapping - The original texture mapping.\n */\nfunction mapTextureMapping( texture, mapping ) {\n\n\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\ttexture.mapping = CubeReflectionMapping;\n\n\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\ttexture.mapping = CubeRefractionMapping;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube map node.\n *\n * @function\n * @param {Node} envNode - The node representing the environment map.\n * @returns {CubeMapNode}\n */\nconst cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );\n\n/**\n * Represents a basic model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular or cube map format.\n * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}\n * or {@link MeshPhongNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass BasicEnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicEnvironmentNode';\n\n\t}\n\n\t/**\n\t * Constructs a new basic environment node.\n\t *\n\t * @param {Node} [envNode=null] - A node representing the environment.\n\t */\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node representing the environment.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// environment property is used in the finish() method of BasicLightingModel\n\n\t\tbuilder.context.environment = cubeMapNode( this.envNode );\n\n\t}\n\n}\n\n/**\n * A specific version of {@link IrradianceNode} that is only relevant\n * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it\n * requires a special scaling factor for the light map.\n *\n * @augments LightingNode\n */\nclass BasicLightMapNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicLightMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new basic light map node.\n\t *\n\t * @param {Node<vec3>?} [lightMapNode=null] - The light map node.\n\t */\n\tconstructor( lightMapNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light map node.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t */\n\t\tthis.lightMapNode = lightMapNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n\t\tconst RECIPROCAL_PI = float( 1 / Math.PI );\n\n\t\tbuilder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );\n\n\t}\n\n}\n\n/**\n * Abstract class for implementing lighting models. The module defines\n * multiple methods that concrete lighting models can implement. These\n * methods are executed at different points during the light evaluation\n * process.\n */\nclass LightingModel {\n\n\t/**\n\t * This method is intended for setting up lighting model and context data\n\t * which are later used in the evaluation process.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tstart( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for executing final tasks like final updates\n\t * to the outgoing light.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the direct light term and\n\t * executed during the build process of directional, point and spot light nodes.\n\t *\n\t * @abstract\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the direct light term for\n\t * rect area light nodes.\n\t *\n\t * @abstract\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirectRectArea( /*input, stack, builder*/ ) {}\n\n\t/**\n\t * This method is intended for implementing the indirect light term.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( /*input, stack, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the ambient occlusion term.\n\t * Unlike other methods, this method must be called manually by the lighting\n\t * model in its indirect term.\n\t *\n\t * @abstract\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tambientOcclusion( /*input, stack, builder*/ ) { }\n\n}\n\n/**\n * Represents the lighting model for unlit materials. The only light contribution\n * is baked indirect lighting modulated with ambient occlusion and the material's\n * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass BasicLightingModel extends LightingModel {\n\n\t/**\n\t * Constructs a new basic lighting model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\t/**\n\t * Implements the baked indirect lighting with its modulation.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( context, stack, builder ) {\n\n\t\tconst ambientOcclusion = context.ambientOcclusion;\n\t\tconst reflectedLight = context.reflectedLight;\n\t\tconst irradianceLightMap = builder.context.irradianceLightMap;\n\n\t\treflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );\n\n\t\t// accumulation (baked indirect lighting only)\n\n\t\tif ( irradianceLightMap ) {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( irradianceLightMap );\n\n\t\t} else {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );\n\n\t\t}\n\n\t\t// modulation\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );\n\n\t}\n\n\t/**\n\t * Implements the environment mapping.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( context, stack, builder ) {\n\n\t\tconst material = builder.material;\n\t\tconst outgoingLight = context.outgoingLight;\n\t\tconst envNode = builder.context.environment;\n\n\t\tif ( envNode ) {\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\toutgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();\n\n/**\n * Node material version of `MeshBasicMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshBasicNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh basic node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshBasicNodeMaterial = true;\n\n\t\t/**\n\t\t * Although the basic material is by definition unlit, we set\n\t\t * this property to `true` since we use a lighting model to compute\n\t\t * the outgoing light of the fragment shader.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$9 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Basic materials are not affected by normal and bump maps so we\n\t * return by default {@link module:Normal.normalView}.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn normalView; // see #28839\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicEnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * This method must be overwriten since light maps are evaluated\n\t * with a special scaling factor for basic materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicLightMapNode<vec3>?} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new BasicLightMapNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * The material overwrites this method because `lights` is set to `true` but\n\t * we still want to return the diffuse color as the outgoing light.\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {BasicLightingModel} The lighting model.\n\t */\n\tsetupLightingModel() {\n\n\t\treturn new BasicLightingModel();\n\n\t}\n\n}\n\nconst F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();\n\n\treturn f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );\n\n} ); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\treturn inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light\n\n} ); // validated\n\nconst G_BlinnPhong_Implicit = () => float( 0.25 );\n\nconst D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {\n\n\treturn shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );\n\n} );\n\nconst BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tconst F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );\n\tconst G = G_BlinnPhong_Implicit();\n\tconst D = D_BlinnPhong( { dotNH } );\n\n\treturn F.mul( G ).mul( D );\n\n} );\n\n/**\n * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.\n *\n * @augments BasicLightingModel\n */\nclass PhongLightingModel extends BasicLightingModel {\n\n\t/**\n\t * Constructs a new phong lighting model.\n\t *\n\t * @param {Boolean} [specular=true] - Whether specular is supported or not.\n\t */\n\tconstructor( specular = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Whether specular is supported or not. Set this to `false` if you are\n\t\t * looking for a Lambert-like material meaning a material for non-shiny\n\t\t * surfaces, without specular highlights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.specular = specular;\n\n\t}\n\n\t/**\n\t * Implements the direct lighting. The specular portion is optional an can be controlled\n\t * with the {@link PhongLightingModel#specular} flag.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\tif ( this.specular === true ) {\n\n\t\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();\n\n/**\n * Node material version of `MeshLambertMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshLambertNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshLambertNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh lambert node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshLambertNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because lambert materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$8 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicEnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhongLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel( false ); // ( specular ) -> force lambert\n\n\t}\n\n}\n\nconst _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();\n\n/**\n * Node material version of `MeshPhongMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshPhongNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhongNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh lambert node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshPhongNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because phong materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * The shininess of phong materials is by default inferred from the `shininess`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the shininess with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the shininess but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialShininess}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.shininessNode = null;\n\n\t\t/**\n\t\t * The specular color of phong materials is by default inferred from the\n\t\t * `specular` property. This node property allows to overwrite the default\n\t\t * and define the specular color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSpecular}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.specularNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$7 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {BasicEnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhongLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel();\n\n\t}\n\n\t/**\n\t * Setups the phong specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// SHININESS\n\n\t\tconst shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tshininess.assign( shininessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tconst specularNode = this.specularNode || materialSpecular;\n\n\t\tspecularColor.assign( specularNode );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.shininessNode = source.shininessNode;\n\t\tthis.specularNode = source.specularNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\treturn float( 0 );\n\n\t}\n\n\tconst dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );\n\tconst geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nconst getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness();\n\n\tlet roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = roughnessFactor.add( geometryRoughness );\n\troughnessFactor = roughnessFactor.min( 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );\n\tconst gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );\n\n\treturn div( 0.5, gv.add( gl ).max( EPSILON ) );\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' },\n\t\t{ name: 'dotNV', type: 'float' }\n\t]\n} ); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {\n\n\tconst gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );\n\tconst gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );\n\tconst v = div( 0.5, gv.add( gl ) );\n\n\treturn v.saturate();\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNL', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nconst D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n\treturn a2.div( denom.pow2() ).mul( 1 / Math.PI );\n\n} ).setLayout( {\n\tname: 'D_GGX',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} ); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {\n\n\tconst a2 = alphaT.mul( alphaB );\n\tconst v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );\n\tconst v2 = v.dot( v );\n\tconst w2 = a2.div( v2 );\n\n\treturn RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );\n\n} ).setLayout( {\n\tname: 'D_GGX_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBH', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;\n\n\tconst normalView = inputs.normalView || transformedNormalView;\n\n\tconst alpha = roughness.pow2(); // UE4's roughness\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\tconst dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\tconst dotNH = normalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tlet F = F_Schlick( { f0, f90, dotVH } );\n\tlet V, D;\n\n\tif ( defined( USE_IRIDESCENCE ) ) {\n\n\t\tF = iridescence.mix( F, f );\n\n\t}\n\n\tif ( defined( USE_ANISOTROPY ) ) {\n\n\t\tconst dotTL = anisotropyT.dot( lightDirection );\n\t\tconst dotTV = anisotropyT.dot( positionViewDirection );\n\t\tconst dotTH = anisotropyT.dot( halfDir );\n\t\tconst dotBL = anisotropyB.dot( lightDirection );\n\t\tconst dotBV = anisotropyB.dot( positionViewDirection );\n\t\tconst dotBH = anisotropyB.dot( halfDir );\n\n\t\tV = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );\n\t\tD = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );\n\n\t} else {\n\n\t\tV = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );\n\t\tD = D_GGX( { alpha, dotNH } );\n\n\t}\n\n\treturn F.mul( V ).mul( D );\n\n} ); // validated\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile\nconst DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {\n\n\tconst c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tconst r = roughness.mul( c0 ).add( c1 );\n\n\tconst a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );\n\n\tconst fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );\n\n\treturn fab;\n\n} ).setLayout( {\n\tname: 'DFGApprox',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNV', type: 'vec3' }\n\t]\n} );\n\nconst EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { dotNV, specularColor, specularF90, roughness } = inputs;\n\n\tconst fab = DFGApprox( { dotNV, roughness } );\n\treturn specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n} );\n\nconst Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {\n\n\tconst x = dotVH.oneMinus().saturate();\n\tconst x2 = x.mul( x );\n\tconst x5 = x.mul( x2, x2 ).clamp( 0, .9999 );\n\n\treturn f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );\n\n} ).setLayout( {\n\tname: 'Schlick_to_F0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' },\n\t\t{ name: 'f90', type: 'float' },\n\t\t{ name: 'dotVH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {\n\n\tconst alpha = roughness.pow2();\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tconst invAlpha = float( 1.0 ).div( alpha );\n\tconst cos2h = dotNH.pow2();\n\tconst sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );\n\n} ).setLayout( {\n\tname: 'D_Charlie',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );\n\n} ).setLayout( {\n\tname: 'V_Neubelt',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'dotNV', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' }\n\t]\n} );\n\nconst BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp();\n\tconst dotNH = transformedNormalView.dot( halfDir ).clamp();\n\n\tconst D = D_Charlie( { roughness: sheenRoughness, dotNH } );\n\tconst V = V_Neubelt( { dotNV, dotNL } );\n\n\treturn sheen.mul( D ).mul( V );\n\n} );\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {\n\n\tconst LUT_SIZE = 64.0;\n\tconst LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tconst dotNV = N.dot( V ).saturate();\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tconst uv = vec2( roughness, dotNV.oneMinus().sqrt() );\n\n\tuv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );\n\n\treturn uv;\n\n} ).setLayout( {\n\tname: 'LTC_Uv',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tconst l = f.length();\n\n\treturn max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );\n\n} ).setLayout( {\n\tname: 'LTC_ClippedSphereFormFactor',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' }\n\t]\n} );\n\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {\n\n\tconst x = v1.dot( v2 );\n\tconst y = x.abs().toVar();\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tconst a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();\n\tconst b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();\n\tconst v = a.div( b );\n\n\tconst theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );\n\n\treturn v1.cross( v2 ).mul( theta_sintheta );\n\n} ).setLayout( {\n\tname: 'LTC_EdgeVectorFormFactor',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// construct orthonormal basis around N\n\t\tconst T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();\n\t\tconst T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t\t// compute transform\n\t\tconst mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();\n\t\tconst coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();\n\t\tconst coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();\n\t\tconst coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'mInv', type: 'mat3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\n/** @module TextureBicubic **/\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\n\nconst w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );\n\nconst w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );\n\nconst w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );\n\nconst w3 = ( a ) => mul( bC, pow( a, 3 ) );\n\nconst g0 = ( a ) => w0( a ).add( w1( a ) );\n\nconst g1 = ( a ) => w2( a ).add( w3( a ) );\n\n// h0 and h1 are the two offset functions\nconst h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );\n\nconst h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );\n\nconst bicubic = ( textureNode, texelSize, lod ) => {\n\n\tconst uv = textureNode.uvNode;\n\tconst uvScaled = mul( uv, texelSize.zw ).add( 0.5 );\n\n\tconst iuv = floor( uvScaled );\n\tconst fuv = fract( uvScaled );\n\n\tconst g0x = g0( fuv.x );\n\tconst g1x = g1( fuv.x );\n\tconst h0x = h0( fuv.x );\n\tconst h1x = h1( fuv.x );\n\tconst h0y = h0( fuv.y );\n\tconst h1y = h1( fuv.y );\n\n\tconst p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\n\tconst a = g0( fuv.y ).mul( add( g0x.mul( textureNode.sample( p0 ).level( lod ) ), g1x.mul( textureNode.sample( p1 ).level( lod ) ) ) );\n\tconst b = g1( fuv.y ).mul( add( g0x.mul( textureNode.sample( p2 ).level( lod ) ), g1x.mul( textureNode.sample( p3 ).level( lod ) ) ) );\n\n\treturn a.add( b );\n\n};\n\n/**\n * Applies mipped bicubic texture filtering to the given texture node.\n *\n * @method\n * @param {TextureNode} textureNode - The texture node that should be filtered.\n * @param {Node<float>} [lodNode=float(3)] - Defines the LOD to sample from.\n * @return {Node} The filtered texture sample.\n */\nconst textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {\n\n\tconst fLodSize = vec2( textureNode.size( int( lodNode ) ) );\n\tconst cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );\n\tconst fLodSizeInv = div( 1.0, fLodSize );\n\tconst cLodSizeInv = div( 1.0, cLodSize );\n\tconst fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );\n\tconst cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );\n\n\treturn fract( lodNode ).mix( fSample, cSample );\n\n} );\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {\n\n\t// Direction of refracted light.\n\tconst refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );\n\n\t// Compute rotation-independent scaling of the model matrix.\n\tconst modelScale = vec3(\n\t\tlength( modelMatrix[ 0 ].xyz ),\n\t\tlength( modelMatrix[ 1 ].xyz ),\n\t\tlength( modelMatrix[ 2 ].xyz )\n\t);\n\n\t// The thickness is specified in local space.\n\treturn normalize( refractionVector ).mul( thickness.mul( modelScale ) );\n\n} ).setLayout( {\n\tname: 'getVolumeTransmissionRay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'n', type: 'vec3' },\n\t\t{ name: 'v', type: 'vec3' },\n\t\t{ name: 'thickness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' },\n\t\t{ name: 'modelMatrix', type: 'mat4' }\n\t]\n} );\n\nconst applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {\n\n\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\treturn roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );\n\n} ).setLayout( {\n\tname: 'applyIorToRoughness',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' }\n\t]\n} );\n\nconst viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();\n\nconst getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {\n\n\tconst vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n\n\tconst transmissionSample = vTexture.sample( fragCoord );\n\t//const transmissionSample = viewportMipTexture( fragCoord );\n\n\tconst lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );\n\n\treturn textureBicubic( transmissionSample, lod );\n\n} );\n\nconst volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {\n\n\tIf( attenuationDistance.notEqual( 0 ), () => {\n\n\t\t// Compute light attenuation using Beer's law.\n\t\tconst attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );\n\t\tconst transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );\n\n\t\treturn transmittance;\n\n\t} );\n\n\t// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.\n\treturn vec3( 1.0 );\n\n} ).setLayout( {\n\tname: 'volumeAttenuation',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'transmissionDistance', type: 'float' },\n\t\t{ name: 'attenuationColor', type: 'vec3' },\n\t\t{ name: 'attenuationDistance', type: 'float' }\n\t]\n} );\n\nconst getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {\n\n\tlet transmittedLight, transmittance;\n\n\tif ( dispersion ) {\n\n\t\ttransmittedLight = vec4().toVar();\n\t\ttransmittance = vec3().toVar();\n\n\t\tconst halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );\n\t\tconst iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );\n\n\t\tLoop( { start: 0, end: 3 }, ( { i } ) => {\n\n\t\t\tconst ior = iors.element( i );\n\n\t\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\t\trefractionCoords.addAssign( 1.0 );\n\t\t\trefractionCoords.divAssign( 2.0 );\n\t\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\tconst transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\t\ttransmittedLight.element( i ).assign( transmissionSample.element( i ) );\n\t\t\ttransmittedLight.a.addAssign( transmissionSample.a );\n\n\t\t\ttransmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );\n\n\t\t} );\n\n\t\ttransmittedLight.a.divAssign( 3.0 );\n\n\t} else {\n\n\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\trefractionCoords.addAssign( 1.0 );\n\t\trefractionCoords.divAssign( 2.0 );\n\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\ttransmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );\n\n\t}\n\n\tconst attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );\n\tconst dotNV = n.dot( v ).clamp();\n\n\t// Get the specular component.\n\tconst F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness\n\t\tdotNV,\n\t\tspecularColor,\n\t\tspecularF90,\n\t\troughness\n\t} ) );\n\n\t// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n\t// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n\tconst transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );\n\n\treturn vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );\n\n} );\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/ mat3(\n\t3.2404542, - 0.9692660, 0.0556434,\n\t- 1.5371385, 1.8760108, - 0.2040259,\n\t- 0.4985314, 0.0415560, 1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = ( fresnel0 ) => {\n\n\tconst sqrtF0 = fresnel0.sqrt();\n\treturn vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );\n\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = ( transmittedIor, incidentIor ) => {\n\n\treturn transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();\n\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = ( OPD, shift ) => {\n\n\tconst phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );\n\tconst val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tconst pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tconst VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tconst x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );\n\n\tlet xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );\n\txyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );\n\n\tconst rgb = XYZ_TO_REC709.mul( xyz );\n\n\treturn rgb;\n\n};\n\nconst evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {\n\n\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\tconst iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tconst sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );\n\n\t// Handle TIR:\n\tconst cosTheta2Sq = sinTheta2Sq.oneMinus();\n\n\tIf( cosTheta2Sq.lessThan( 0 ), () => {\n\n\t\treturn vec3( 1.0 );\n\n\t} );\n\n\tconst cosTheta2 = cosTheta2Sq.sqrt();\n\n\t// First interface\n\tconst R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\tconst R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );\n\t//const R21 = R12;\n\tconst T121 = R12.oneMinus();\n\tconst phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );\n\tconst phi21 = float( Math.PI ).sub( phi12 );\n\n\t// Second interface\n\tconst baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0\n\tconst R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );\n\tconst R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );\n\tconst phi23 = vec3(\n\t\tbaseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )\n\t);\n\n\t// Phase shift\n\tconst OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );\n\tconst phi = vec3( phi21 ).add( phi23 );\n\n\t// Compound terms\n\tconst R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );\n\tconst r123 = R123.sqrt();\n\tconst Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tconst C0 = R12.add( Rs );\n\tconst I = C0.toVar();\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tconst Cm = Rs.sub( T121 ).toVar();\n\n\tLoop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {\n\n\t\tCm.mulAssign( r123 );\n\t\tconst Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );\n\t\tI.addAssign( Cm.mul( Sm ) );\n\n\t} );\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn I.max( vec3( 0.0 ) );\n\n} ).setLayout( {\n\tname: 'evalIridescence',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'outsideIOR', type: 'float' },\n\t\t{ name: 'eta2', type: 'float' },\n\t\t{ name: 'cosTheta1', type: 'float' },\n\t\t{ name: 'thinFilmThickness', type: 'float' },\n\t\t{ name: 'baseF0', type: 'vec3' }\n\t]\n} );\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approximation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {\n\n\tconst dotNV = normal.dot( viewDir ).saturate();\n\n\tconst r2 = roughness.pow2();\n\n\tconst a = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),\n\t\tfloat( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )\n\t);\n\n\tconst b = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),\n\t\tfloat( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )\n\t);\n\n\tconst DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );\n\n\treturn DG.mul( 1.0 / Math.PI ).saturate();\n\n} );\n\nconst clearcoatF0 = vec3( 0.04 );\nconst clearcoatF90 = float( 1 );\n\n\n/**\n * Represents the lighting model for a PBR material.\n *\n * @augments LightingModel\n */\nclass PhysicalLightingModel extends LightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {Boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {Boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Whether clearcoat is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clearcoat = clearcoat;\n\n\t\t/**\n\t\t * Whether sheen is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.sheen = sheen;\n\n\t\t/**\n\t\t * Whether iridescence is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.iridescence = iridescence;\n\n\t\t/**\n\t\t * Whether anisotropy is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.anisotropy = anisotropy;\n\n\t\t/**\n\t\t * Whether transmission is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.transmission = transmission;\n\n\t\t/**\n\t\t * Whether dispersion is supported or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.dispersion = dispersion;\n\n\t\t/**\n\t\t * The clear coat radiance.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatRadiance = null;\n\n\t\t/**\n\t\t * The clear coat specular direct.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatSpecularDirect = null;\n\n\t\t/**\n\t\t * The clear coat specular indirect.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatSpecularIndirect = null;\n\n\t\t/**\n\t\t * The sheen specular direct.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenSpecularDirect = null;\n\n\t\t/**\n\t\t * The sheen specular indirect.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenSpecularIndirect = null;\n\n\t\t/**\n\t\t * The iridescence Fresnel.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceFresnel = null;\n\n\t\t/**\n\t\t * The iridescence F0.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceF0 = null;\n\n\t}\n\n\t/**\n\t * Depending on what features are requested, the method prepares certain node variables\n\t * which are later used for lighting computations.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t */\n\tstart( context ) {\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );\n\t\t\tthis.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );\n\t\t\tthis.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );\n\t\t\tthis.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.iridescence === true ) {\n\n\t\t\tconst dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tthis.iridescenceFresnel = evalIridescence( {\n\t\t\t\toutsideIOR: float( 1.0 ),\n\t\t\t\teta2: iridescenceIOR,\n\t\t\t\tcosTheta1: dotNVi,\n\t\t\t\tthinFilmThickness: iridescenceThickness,\n\t\t\t\tbaseF0: specularColor\n\t\t\t} );\n\n\t\t\tthis.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );\n\n\t\t}\n\n\t\tif ( this.transmission === true ) {\n\n\t\t\tconst position = positionWorld;\n\t\t\tconst v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX\n\t\t\tconst n = transformedNormalWorld;\n\n\t\t\tcontext.backdrop = getIBLVolumeRefraction(\n\t\t\t\tn,\n\t\t\t\tv,\n\t\t\t\troughness,\n\t\t\t\tdiffuseColor,\n\t\t\t\tspecularColor,\n\t\t\t\tspecularF90, // specularF90\n\t\t\t\tposition, // positionWorld\n\t\t\t\tmodelWorldMatrix, // modelMatrix\n\t\t\t\tcameraViewMatrix, // viewMatrix\n\t\t\t\tcameraProjectionMatrix, // projMatrix\n\t\t\t\tior,\n\t\t\t\tthickness,\n\t\t\t\tattenuationColor,\n\t\t\t\tattenuationDistance,\n\t\t\t\tthis.dispersion ? dispersion : null\n\t\t\t);\n\n\t\t\tcontext.backdropAlpha = transmission;\n\n\t\t\tdiffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );\n\n\t\t}\n\n\t}\n\n\t// Fdez-Agera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n\t// Approximates multi-scattering in order to preserve energy.\n\t// http://www.jcgt.org/published/0008/01/03/\n\n\tcomputeMultiscattering( singleScatter, multiScatter, specularF90 ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst fab = DFGApprox( { roughness, dotNV } );\n\n\t\tconst Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;\n\n\t\tconst FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n\t\tconst Ess = fab.x.add( fab.y );\n\t\tconst Ems = Ess.oneMinus();\n\n\t\tconst Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21\n\t\tconst Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );\n\n\t\tsingleScatter.addAssign( FssEss );\n\t\tmultiScatter.addAssign( Fms.mul( Ems ) );\n\n\t}\n\n\t/**\n\t * Implements the direct light.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = transformedNormalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();\n\t\t\tconst ccIrradiance = dotNLcc.mul( lightColor );\n\n\t\t\tthis.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );\n\n\t\t}\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );\n\n\t}\n\n\t/**\n\t * This method is intended for implementing the direct light term for\n\t * rect area light nodes.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst N = transformedNormalView;\n\t\tconst V = positionViewDirection;\n\t\tconst P = positionView.toVar();\n\n\t\tconst uv = LTC_Uv( { N, V, roughness } );\n\n\t\tconst t1 = ltc_1.sample( uv ).toVar();\n\t\tconst t2 = ltc_2.sample( uv ).toVar();\n\n\t\tconst mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3( 0, 1, 0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t).toVar();\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tconst fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();\n\n\t\treflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );\n\n\t\treflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( context, stack, builder ) {\n\n\t\tthis.indirectDiffuse( context, stack, builder );\n\t\tthis.indirectSpecular( context, stack, builder );\n\t\tthis.ambientOcclusion( context, stack, builder );\n\n\t}\n\n\t/**\n\t * Implements the indirect diffuse term.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirectDiffuse( { irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect specular term.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.addAssign( iblIrradiance.mul(\n\t\t\t\tsheen,\n\t\t\t\tIBLSheenBRDF( {\n\t\t\t\t\tnormal: transformedNormalView,\n\t\t\t\t\tviewDir: positionViewDirection,\n\t\t\t\t\troughness: sheenRoughness\n\t\t\t\t} )\n\t\t\t) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst clearcoatEnv = EnvironmentBRDF( {\n\t\t\t\tdotNV: dotNVcc,\n\t\t\t\tspecularColor: clearcoatF0,\n\t\t\t\tspecularF90: clearcoatF90,\n\t\t\t\troughness: clearcoatRoughness\n\t\t\t} );\n\n\t\t\tthis.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );\n\n\t\t}\n\n\t\t// Both indirect specular and indirect diffuse light accumulate here\n\n\t\tconst singleScattering = vec3().toVar( 'singleScattering' );\n\t\tconst multiScattering = vec3().toVar( 'multiScattering' );\n\t\tconst cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );\n\n\t\tthis.computeMultiscattering( singleScattering, multiScattering, specularF90 );\n\n\t\tconst totalScattering = singleScattering.add( multiScattering );\n\n\t\tconst diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );\n\n\t\treflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );\n\t\treflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );\n\n\t\treflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );\n\n\t}\n\n\t/**\n\t * Implements the ambient occlusion term.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tambientOcclusion( { ambientOcclusion, reflectedLight } ) {\n\n\t\tconst dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst aoNV = dotNV.add( ambientOcclusion );\n\t\tconst aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();\n\n\t\tconst aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\t\treflectedLight.indirectSpecular.mulAssign( aoNode );\n\n\t}\n\n\t/**\n\t * Used for final lighting accumulations depending on the requested features.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( context ) {\n\n\t\tconst { outgoingLight } = context;\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst Fcc = F_Schlick( {\n\t\t\t\tdotVH: dotNVcc,\n\t\t\t\tf0: clearcoatF0,\n\t\t\t\tf90: clearcoatF90\n\t\t\t} );\n\n\t\t\tconst clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );\n\n\t\t\toutgoingLight.assign( clearcoatLight );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tconst sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();\n\t\t\tconst sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );\n\n\t\t\toutgoingLight.assign( sheenLight );\n\n\t\t}\n\n\t}\n\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/ float( 1.0 );\nconst cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );\nconst cubeUV_r1 = /*@__PURE__*/ float( 0.8 );\nconst cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );\nconst cubeUV_r4 = /*@__PURE__*/ float( 0.4 );\nconst cubeUV_m4 = /*@__PURE__*/ float( 2.0 );\nconst cubeUV_r5 = /*@__PURE__*/ float( 0.305 );\nconst cubeUV_m5 = /*@__PURE__*/ float( 3.0 );\nconst cubeUV_r6 = /*@__PURE__*/ float( 0.21 );\nconst cubeUV_m6 = /*@__PURE__*/ float( 4.0 );\n\nconst cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );\nconst cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( - 1.0 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).Else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).Else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).Else( () => {\n\n\t\tmip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y\n\n\t} ).ElseIf( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nconst textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.sample( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nconst blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( all( axis.equals( vec3( 0.0 ) ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tLoop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n\n/** @module PMREMNode **/\n\nlet _generator = null;\n\nconst _cache = new WeakMap();\n\n/**\n * Generates the cubeUV size based on the given image height.\n *\n * @private\n * @param {Number} imageHeight - The image height.\n * @return {{texelWidth: Number,texelHeight: Number, maxMip: Number}} The result object.\n */\nfunction _generateCubeUVSize( imageHeight ) {\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\n/**\n * Generates a PMREM from the given texture .\n *\n * @private\n * @param {Texture} texture - The texture to create the PMREM for.\n * @return {Texture} The PMREM.\n */\nfunction _getPMREMFromTexture( texture ) {\n\n\tlet cacheTexture = _cache.get( texture );\n\n\tconst pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;\n\n\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\tconst image = texture.image;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( isCubeMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromCubemap( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = _generator.fromEquirectangular( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcacheTexture.pmremVersion = texture.pmremVersion;\n\n\t\t_cache.set( texture, cacheTexture );\n\n\t}\n\n\treturn cacheTexture.texture;\n\n}\n\n/**\n * This node represents a PMREM which is a special type of preprocessed\n * environment map intended for PBR materials.\n *\n * ```js\n * const material = new MeshStandardNodeMaterial();\n * material.envNode = pmremTexture( envMap );\n * ```\n *\n * @augments TempNode\n */\nclass PMREMNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PMREMNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Texture} value - The input texture.\n\t * @param {Node<vec2>} [uvNode=null] - The uv node.\n\t * @param {Node<float>} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Reference to the input texture.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Reference to the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture | null}\n\t\t * @default null\n\t\t */\n\t\tthis._pmrem = null;\n\n\t\t/**\n\t\t *  The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t *  The level node.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Reference to a PMREM generator.\n\t\t *\n\t\t * @private\n\t\t * @type {PMREMGenerator}\n\t\t * @default null\n\t\t */\n\t\tthis._generator = null;\n\n\t\tconst defaultTexture = new Texture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * The texture node holding the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._texture = texture( defaultTexture );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's width.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._width = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's height.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._height = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's max Mip.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._maxMip = uniform( 0 );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tset value( value ) {\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t}\n\n\t/**\n\t * The node's texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Uses the given PMREM texture to update internal values.\n\t *\n\t * @param {Texture} texture - The PMREM texture.\n\t */\n\tupdateFromTexture( texture ) {\n\n\t\tconst cubeUVSize = _generateCubeUVSize( texture.image.height );\n\n\t\tthis._texture.value = texture;\n\t\tthis._width.value = cubeUVSize.texelWidth;\n\t\tthis._height.value = cubeUVSize.texelHeight;\n\t\tthis._maxMip.value = cubeUVSize.maxMip;\n\n\t}\n\n\tupdateBefore() {\n\n\t\tlet pmrem = this._pmrem;\n\n\t\tconst pmremVersion = pmrem ? pmrem.pmremVersion : - 1;\n\t\tconst texture = this._value;\n\n\t\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\t\tif ( texture.isPMREMTexture === true ) {\n\n\t\t\t\tpmrem = texture;\n\n\t\t\t} else {\n\n\t\t\t\tpmrem = _getPMREMFromTexture( texture );\n\n\t\t\t}\n\n\t\t\tif ( pmrem !== null ) {\n\n\t\t\t\tthis._pmrem = pmrem;\n\n\t\t\t\tthis.updateFromTexture( pmrem );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( _generator === null ) {\n\n\t\t\t_generator = builder.createPMREMGenerator();\n\n\t\t}\n\n\t\t//\n\n\t\tthis.updateBefore( builder );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {\n\n\t\t\tuvNode = vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t}\n\n\t\tuvNode = vec3( uvNode.x, uvNode.y.negate(), uvNode.z );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\treturn textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given cube map image has been fully loaded.\n *\n * @private\n * @param {Array<(Image|Object)>} image - The cube map image.\n * @return {Boolean} Whether the given cube map is ready or not.\n */\nfunction isCubeMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\tlet count = 0;\n\tconst length = 6;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t}\n\n\treturn count === length;\n\n\n}\n\n/**\n * Returns `true` if the given equirectangular image has been fully loaded.\n *\n * @private\n * @param {(Image|Object)} image - The equirectangular image.\n * @return {Boolean} Whether the given cube map is ready or not.\n */\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * TSL function for creating a PMREM node.\n *\n * @function\n * @param {Texture} value - The input texture.\n * @param {Node<vec2>} [uvNode=null] - The uv node.\n * @param {Node<float>} [levelNode=null] - The level node.\n * @returns {PMREMNode}\n */\nconst pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );\n\nconst _envNodeCache = new WeakMap();\n\n/**\n * Represents a physical model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.\n * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass EnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'EnvironmentNode';\n\n\t}\n\n\t/**\n\t * Constructs a new environment node.\n\t *\n\t * @param {Node} [envNode=null] - A node representing the environment.\n\t */\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node representing the environment.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { material } = builder;\n\n\t\tlet envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tlet cacheEnvNode = _envNodeCache.get( value );\n\n\t\t\tif ( cacheEnvNode === undefined ) {\n\n\t\t\t\tcacheEnvNode = pmremTexture( value );\n\n\t\t\t\t_envNodeCache.set( value, cacheEnvNode );\n\n\t\t\t}\n\n\t\t\tenvNode\t= cacheEnvNode;\n\n\t\t}\n\n\t\t//\n\n\t\tconst envMap = material.envMap;\n\t\tconst intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode\n\n\t\tconst useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n\t\tconst radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;\n\n\t\tconst radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );\n\t\tconst irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );\n\n\t\tconst isolateRadiance = cache( radiance );\n\t\tconst isolateIrradiance = cache( irradiance );\n\n\t\t//\n\n\t\tbuilder.context.radiance.addAssign( isolateRadiance );\n\n\t\tbuilder.context.iblIrradiance.addAssign( isolateIrradiance );\n\n\t\t//\n\n\t\tconst clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n\n\t\tif ( clearcoatRadiance ) {\n\n\t\t\tconst clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );\n\t\t\tconst isolateClearcoatRadiance = cache( clearcoatRadianceContext );\n\n\t\t\tclearcoatRadiance.addAssign( isolateClearcoatRadiance );\n\n\t\t}\n\n\t}\n\n}\n\nconst createRadianceContext = ( roughnessNode, normalViewNode ) => {\n\n\tlet reflectVec = null;\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\tif ( reflectVec === null ) {\n\n\t\t\t\treflectVec = positionViewDirection.negate().reflect( normalViewNode );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();\n\n\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\n\n\t\t\t}\n\n\t\t\treturn reflectVec;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn roughnessNode;\n\n\t\t}\n\t};\n\n};\n\nconst createIrradianceContext = ( normalWorldNode ) => {\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\treturn normalWorldNode;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn float( 1.0 );\n\n\t\t}\n\t};\n\n};\n\nconst _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();\n\n/**\n * Node material version of `MeshStandardMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshStandardNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshStandardNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh standard node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshStandardNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because standard materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * The emissive color of standard materials is by default inferred from the `emissive`,\n\t\t * `emissiveIntensity` and `emissiveMap` properties. This node property allows to\n\t\t * overwrite the default and define the emissive color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the emissive color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialEmissive}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.emissiveNode = null;\n\n\t\t/**\n\t\t * The metalness of standard materials is by default inferred from the `metalness`,\n\t\t * and `metalnessMap` properties. This node property allows to\n\t\t * overwrite the default and define the metalness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the metalness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialMetalness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.metalnessNode = null;\n\n\t\t/**\n\t\t * The roughness of standard materials is by default inferred from the `roughness`,\n\t\t * and `roughnessMap` properties. This node property allows to\n\t\t * overwrite the default and define the roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the roughness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialRoughness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.roughnessNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$6 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link EnvironmentNode}\n\t * to implement the PBR (PMREM based) environment mapping. Besides, the\n\t * method honors `Scene.environment`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {EnvironmentNode<vec3>?} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tlet envNode = super.setupEnvironment( builder );\n\n\t\tif ( envNode === null && builder.environmentNode ) {\n\n\t\t\tenvNode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn envNode ? new EnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhysicalLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel();\n\n\t}\n\n\t/**\n\t * Setups the specular related node variables.\n\t */\n\tsetupSpecular() {\n\n\t\tconst specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );\n\n\t\tspecularColor.assign( specularColorNode );\n\t\tspecularF90.assign( 1.0 );\n\n\t}\n\n\t/**\n\t * Setups the standard specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants() {\n\n\t\t// METALNESS\n\n\t\tconst metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;\n\n\t\tmetalness.assign( metalnessNode );\n\n\t\t// ROUGHNESS\n\n\t\tlet roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;\n\t\troughnessNode = getRoughness( { roughness: roughnessNode } );\n\n\t\troughness.assign( roughnessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tthis.setupSpecular();\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.emissiveNode = source.emissiveNode;\n\n\t\tthis.metalnessNode = source.metalnessNode;\n\t\tthis.roughnessNode = source.roughnessNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();\n\n/**\n * Node material version of `MeshPhysicalMaterial`.\n *\n * @augments MeshStandardNodeMaterial\n */\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhysicalNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh physical node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshPhysicalNodeMaterial = true;\n\n\t\t/**\n\t\t * The clearcoat of physical materials is by default inferred from the `clearcoat`\n\t\t * and `clearcoatMap` properties. This node property allows to overwrite the default\n\t\t * and define the clearcoat with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialClearcoat}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatNode = null;\n\n\t\t/**\n\t\t * The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`\n\t\t * and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default\n\t\t * and define the clearcoat roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat roughness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialClearcoatRoughness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatRoughnessNode = null;\n\n\t\t/**\n\t\t * The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the clearcoat normal with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat normal but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialClearcoatNormal}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatNormalNode = null;\n\n\t\t/**\n\t\t * The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`\n\t\t * and `sheenColorMap` properties. This node property allows to overwrite the default\n\t\t * and define the sheen with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the sheen but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSheen}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenNode = null;\n\n\t\t/**\n\t\t * The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and\n\t\t * `sheenRoughnessMap` properties. This node property allows to overwrite the default\n\t\t * and define the sheen roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the sheen roughness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSheenRoughness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenRoughnessNode = null;\n\n\t\t/**\n\t\t * The iridescence of physical materials is by default inferred from the `iridescence`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the iridescence with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIridescence}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceNode = null;\n\n\t\t/**\n\t\t * The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the iridescence IOR with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence IOR but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIridescenceIOR}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceIORNode = null;\n\n\t\t/**\n\t\t * The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`\n\t\t * and `iridescenceThicknessMap` properties. This node property allows to overwrite the default\n\t\t * and define the iridescence thickness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence thickness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIridescenceThickness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceThicknessNode = null;\n\n\t\t/**\n\t\t * The specular intensity of physical materials is by default inferred from the `specularIntensity`\n\t\t * and `specularIntensityMap` properties. This node property allows to overwrite the default\n\t\t * and define the specular intensity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular intensity but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSpecularIntensity}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.specularIntensityNode = null;\n\n\t\t/**\n\t\t * The specular color of physical materials is by default inferred from the `specularColor`\n\t\t * and `specularColorMap` properties. This node property allows to overwrite the default\n\t\t * and define the specular color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialSpecularColor}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.specularColorNode = null;\n\n\t\t/**\n\t\t * The ior of physical materials is by default inferred from the `ior`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the ior with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the ior but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialIOR}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.iorNode = null;\n\n\t\t/**\n\t\t * The transmission of physical materials is by default inferred from the `transmission` and\n\t\t * `transmissionMap` properties. This node property allows to overwrite the default\n\t\t * and define the transmission with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the transmission but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialTransmission}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.transmissionNode = null;\n\n\t\t/**\n\t\t * The thickness of physical materials is by default inferred from the `thickness` and\n\t\t * `thicknessMap` properties. This node property allows to overwrite the default\n\t\t * and define the thickness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the thickness but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialThickness}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessNode = null;\n\n\t\t/**\n\t\t * The attenuation distance of physical materials is by default inferred from the\n\t\t * `attenuationDistance` property. This node property allows to overwrite the default\n\t\t * and define the attenuation distance with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the attenuation distance but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAttenuationDistance}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.attenuationDistanceNode = null;\n\n\t\t/**\n\t\t * The attenuation color of physical materials is by default inferred from the\n\t\t * `attenuationColor` property. This node property allows to overwrite the default\n\t\t * and define the attenuation color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the attenuation color but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAttenuationColor}.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.attenuationColorNode = null;\n\n\t\t/**\n\t\t * The dispersion of physical materials is by default inferred from the\n\t\t * `dispersion` property. This node property allows to overwrite the default\n\t\t * and define the dispersion with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the dispersion but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialDispersion}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.dispersionNode = null;\n\n\t\t/**\n\t\t * The anisotropy of physical materials is by default inferred from the\n\t\t * `anisotropy` property. This node property allows to overwrite the default\n\t\t * and define the anisotropy with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the anisotropy but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialAnisotropy}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.anisotropyNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$5 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use clearcoat or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useClearcoat() {\n\n\t\treturn this.clearcoat > 0 || this.clearcoatNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use iridescence or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useIridescence() {\n\n\t\treturn this.iridescence > 0 || this.iridescenceNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use sheen or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useSheen() {\n\n\t\treturn this.sheen > 0 || this.sheenNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use anisotropy or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useAnisotropy() {\n\n\t\treturn this.anisotropy > 0 || this.anisotropyNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use transmission or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useTransmission() {\n\n\t\treturn this.transmission > 0 || this.transmissionNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use dispersion or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useDispersion() {\n\n\t\treturn this.dispersion > 0 || this.dispersionNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the specular related node variables.\n\t */\n\tsetupSpecular() {\n\n\t\tconst iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;\n\n\t\tior.assign( iorNode );\n\t\tspecularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );\n\t\tspecularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhysicalLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );\n\n\t}\n\n\t/**\n\t * Setups the physical specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( builder ) {\n\n\t\tsuper.setupVariants( builder );\n\n\t\t// CLEARCOAT\n\n\t\tif ( this.useClearcoat ) {\n\n\t\t\tconst clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;\n\t\t\tconst clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;\n\n\t\t\tclearcoat.assign( clearcoatNode );\n\t\t\tclearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );\n\n\t\t}\n\n\t\t// SHEEN\n\n\t\tif ( this.useSheen ) {\n\n\t\t\tconst sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;\n\t\t\tconst sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;\n\n\t\t\tsheen.assign( sheenNode );\n\t\t\tsheenRoughness.assign( sheenRoughnessNode );\n\n\t\t}\n\n\t\t// IRIDESCENCE\n\n\t\tif ( this.useIridescence ) {\n\n\t\t\tconst iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;\n\t\t\tconst iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;\n\t\t\tconst iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;\n\n\t\t\tiridescence.assign( iridescenceNode );\n\t\t\tiridescenceIOR.assign( iridescenceIORNode );\n\t\t\tiridescenceThickness.assign( iridescenceThicknessNode );\n\n\t\t}\n\n\t\t// ANISOTROPY\n\n\t\tif ( this.useAnisotropy ) {\n\n\t\t\tconst anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();\n\n\t\t\tanisotropy.assign( anisotropyV.length() );\n\n\t\t\tIf( anisotropy.equal( 0.0 ), () => {\n\n\t\t\t\tanisotropyV.assign( vec2( 1.0, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tanisotropyV.divAssign( vec2( anisotropy ) );\n\t\t\t\tanisotropy.assign( anisotropy.saturate() );\n\n\t\t\t} );\n\n\t\t\t// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n\t\t\talphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );\n\n\t\t\tanisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );\n\t\t\tanisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );\n\n\t\t}\n\n\t\t// TRANSMISSION\n\n\t\tif ( this.useTransmission ) {\n\n\t\t\tconst transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;\n\t\t\tconst thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;\n\t\t\tconst attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;\n\t\t\tconst attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;\n\n\t\t\ttransmission.assign( transmissionNode );\n\t\t\tthickness.assign( thicknessNode );\n\t\t\tattenuationDistance.assign( attenuationDistanceNode );\n\t\t\tattenuationColor.assign( attenuationColorNode );\n\n\t\t\tif ( this.useDispersion ) {\n\n\t\t\t\tconst dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;\n\n\t\t\t\tdispersion.assign( dispersionNode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the clearcoat normal node.\n\t *\n\t * @return {Node<vec3>} The clearcoat noraml.\n\t */\n\tsetupClearcoatNormal() {\n\n\t\treturn this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.clearcoatNode = source.clearcoatNode;\n\t\tthis.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n\t\tthis.clearcoatNormalNode = source.clearcoatNormalNode;\n\n\t\tthis.sheenNode = source.sheenNode;\n\t\tthis.sheenRoughnessNode = source.sheenRoughnessNode;\n\n\t\tthis.iridescenceNode = source.iridescenceNode;\n\t\tthis.iridescenceIORNode = source.iridescenceIORNode;\n\t\tthis.iridescenceThicknessNode = source.iridescenceThicknessNode;\n\n\t\tthis.specularIntensityNode = source.specularIntensityNode;\n\t\tthis.specularColorNode = source.specularColorNode;\n\n\t\tthis.transmissionNode = source.transmissionNode;\n\t\tthis.thicknessNode = source.thicknessNode;\n\t\tthis.attenuationDistanceNode = source.attenuationDistanceNode;\n\t\tthis.attenuationColorNode = source.attenuationColorNode;\n\t\tthis.dispersionNode = source.dispersionNode;\n\n\t\tthis.anisotropyNode = source.anisotropyNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\n/** @module MeshSSSNodeMaterial **/\n\n/**\n * Represents the lighting model for {@link MeshSSSNodeMaterial}.\n *\n * @augments PhysicalLightingModel\n */\nclass SSSLightingModel extends PhysicalLightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {Boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {Boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t * @param {Boolean} [sss=false] - Whether SSS is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false, sss = false ) {\n\n\t\tsuper( clearcoat, sheen, iridescence, anisotropy, transmission, dispersion );\n\n\t\t/**\n\t\t * Whether the lighting model should use SSS or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useSSS = sss;\n\n\t}\n\n\t/**\n\t * Extends the default implementation with a SSS term.\n\t *\n\t * Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look]{@link https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/}\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tif ( this.useSSS === true ) {\n\n\t\t\tconst material = builder.material;\n\n\t\t\tconst { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;\n\n\t\t\tconst scatteringHalf = lightDirection.add( transformedNormalView.mul( thicknessDistortionNode ) ).normalize();\n\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );\n\t\t\tconst scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );\n\n\t\t\treflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );\n\n\t\t}\n\n\t\tsuper.direct( { lightDirection, lightColor, reflectedLight }, stack, builder );\n\n\t}\n\n}\n\n/**\n * This node material is an experimental extension of {@link MeshPhysicalNodeMaterial}\n * that implements a Subsurface scattering (SSS) term.\n *\n * @augments MeshPhysicalNodeMaterial\n */\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshSSSNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh SSS node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * Represents the thickness color.\n\t\t *\n\t\t * @type {Node<vec3>?}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessColorNode = null;\n\n\t\t/**\n\t\t * Represents the distortion factor.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessDistortionNode = float( 0.1 );\n\n\t\t/**\n\t\t * Represents the thickness ambient factor.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessAmbientNode = float( 0.0 );\n\n\t\t/**\n\t\t * Represents the thickness attenuation.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessAttenuationNode = float( .1 );\n\n\t\t/**\n\t\t * Represents the thickness power.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessPowerNode = float( 2.0 );\n\n\t\t/**\n\t\t * Represents the thickness scale.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t */\n\t\tthis.thicknessScaleNode = float( 10.0 );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use SSS or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget useSSS() {\n\n\t\treturn this.thicknessColorNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {SSSLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.thicknessColorNode = source.thicknessColorNode;\n\t\tthis.thicknessDistortionNode = source.thicknessDistortionNode;\n\t\tthis.thicknessAmbientNode = source.thicknessAmbientNode;\n\t\tthis.thicknessAttenuationNode = source.thicknessAttenuationNode;\n\t\tthis.thicknessPowerNode = source.thicknessPowerNode;\n\t\tthis.thicknessScaleNode = source.thicknessScaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {\n\n\t// dotNL will be from -1.0 to 1.0\n\tconst dotNL = normal.dot( lightDirection );\n\tconst coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );\n\n\tif ( builder.material.gradientMap ) {\n\n\t\tconst gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );\n\n\t\treturn vec3( gradientMap.r );\n\n\t} else {\n\n\t\tconst fw = coord.fwidth().mul( 0.5 );\n\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );\n\n\t}\n\n} );\n\n/**\n * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ToonLightingModel extends LightingModel {\n\n\t/**\n\t * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is\n\t * reduced to a small number of discrete shades to create a comic-like, flat look.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, stack, builder ) {\n\n\t\tconst irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {ContextNode} input - The current node context.\n\t * @param {StackNode} stack - The current stack.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( { ambientOcclusion, irradiance, reflectedLight } ) {\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();\n\n/**\n * Node material version of `MeshToonMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshToonNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshToonNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh toon node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshToonNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because toon materials react on lights.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$4 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {ToonLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ToonLightingModel();\n\n\t}\n\n}\n\n/** @module MatcapUVNode **/\n\n/**\n * Can be used to compute texture coordinates for projecting a\n * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.\n *\n * @augments TempNode\n */\nclass MatcapUVNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MatcapUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new matcap uv node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t}\n\n\tsetup() {\n\n\t\tconst x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();\n\t\tconst y = positionViewDirection.cross( x );\n\n\t\treturn vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t}\n\n}\n\n/**\n * TSL function for creating a matcap uv node.\n *\n * @function\n * @returns {MatcapUVNode}\n */\nconst matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );\n\nconst _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();\n\n/**\n * Node material version of `MeshMatcapMaterial`.\n *\n * @augments NodeMaterial\n */\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshMatcapNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh normal node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshMatcapNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$3 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the matcap specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( builder ) {\n\n\t\tconst uv = matcapUV;\n\n\t\tlet matcapColor;\n\n\t\tif ( builder.material.matcap ) {\n\n\t\t\tmatcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );\n\n\t\t} else {\n\n\t\t\tmatcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing\n\n\t\t}\n\n\t\tdiffuseColor.rgb.mulAssign( matcapColor.rgb );\n\n\t}\n\n}\n\nconst _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();\n\n/**\n * Node material version of `PointsMaterial`.\n *\n * Since WebGPU can render point primitives only with a size of one pixel,\n * this material type does not evaluate the `size` and `sizeAttenuation`\n * property of `PointsMaterial`. Use {@link InstancedPointsNodeMaterial}\n * instead if you need points with a size larger than one pixel.\n *\n * @augments NodeMaterial\n */\nclass PointsNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'PointsNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new points node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$2 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\n/** @module RotateNode **/\n\n/**\n * Applies a rotation to the given position node.\n *\n * @augments TempNode\n */\nclass RotateNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RotateNode';\n\n\t}\n\n\t/**\n\t * Constructs a new rotate node.\n\t *\n\t * @param {Node} positionNode - The position node.\n\t * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n\t * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n\t */\n\tconstructor( positionNode, rotationNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The position node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.positionNode = positionNode;\n\n\t\t/**\n\t\t *  Represents the rotation that is applied to the position node.\n\t\t *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.rotationNode = rotationNode;\n\n\t}\n\n\t/**\n\t * The type of the {@link RotateNode#positionNode} defines the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node's type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.positionNode.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { rotationNode, positionNode } = this;\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( nodeType === 'vec2' ) {\n\n\t\t\tconst cosAngle = rotationNode.cos();\n\t\t\tconst sinAngle = rotationNode.sin();\n\n\t\t\tconst rotationMatrix = mat2(\n\t\t\t\tcosAngle, sinAngle,\n\t\t\t\tsinAngle.negate(), cosAngle\n\t\t\t);\n\n\t\t\treturn rotationMatrix.mul( positionNode );\n\n\t\t} else {\n\n\t\t\tconst rotation = rotationNode;\n\t\t\tconst rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\n\t\t\treturn rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a rotate node.\n *\n * @function\n * @param {Node} positionNode - The position node.\n * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n * @returns {RotateNode}\n */\nconst rotate = /*@__PURE__*/ nodeProxy( RotateNode );\n\nconst _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();\n\n/**\n * Node material version of `SpriteMaterial`.\n *\n * @augments NodeMaterial\n */\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis._useSizeAttenuation = true;\n\n\t\t/**\n\t\t * This property makes it possible to define the position of the sprite with a\n\t\t * node. That can be useful when the material is used with instanced rendering\n\t\t * and node data are defined with an instanced attribute node:\n\t\t * ```js\n\t\t * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t * material.positionNode = instancedBufferAttribute( positionAttribute );\n\t\t * ```\n\t\t * Another possibility is to compute the instanced data with a compute shader:\n\t\t * ```js\n\t\t * const positionBuffer = instancedArray( particleCount, 'vec3' );\n\t\t * particleMaterial.positionNode = positionBuffer.toAttribute();\n\t\t * ```\n\t\t *\n\t\t * @type {Node<vec2>?}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * The rotation of sprite materials is by default inferred from the `rotation`,\n\t\t * property. This node property allows to overwrite the default and define\n\t\t * the rotation with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the rotation but modify the existing\n\t\t * value instead, use {@link module:MaterialNode.materialRotation}.\n\t\t *\n\t\t * @type {Node<float>?}\n\t\t * @default null\n\t\t */\n\t\tthis.rotationNode = null;\n\n\t\t/**\n\t\t * This node property provides an additional way to scale sprites next to\n\t\t * `Object3D.scale`. The scale transformation based in `Object3D.scale`\n\t\t * is multiplied with the scale value of this node in the vertex shader.\n\t\t *\n\t\t * @type {Node<vec2>?}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$1 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method implements\n\t * the sprite specific vertex shader.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( builder ) {\n\n\t\tconst { object, camera } = builder;\n\n\t\tconst sizeAttenuation = this.sizeAttenuation;\n\n\t\tconst { positionNode, rotationNode, scaleNode } = this;\n\n\t\tconst mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );\n\n\t\tlet scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = scale.mul( scaleNode );\n\n\t\t}\n\n\t\tif ( sizeAttenuation === false ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tscale = scale.mul( mvPosition.z.negate() );\n\n\t\t\t} else {\n\n\t\t\t\tconst orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );\n\t\t\t\tscale = scale.mul( orthoScale.mul( 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet alignedPosition = positionGeometry.xy;\n\n\t\tif ( object.center && object.center.isVector2 === true ) {\n\n\t\t\tconst center = reference$1( 'center', 'vec2', object );\n\n\t\t\talignedPosition = alignedPosition.sub( center.sub( 0.5 ) );\n\n\t\t}\n\n\t\talignedPosition = alignedPosition.mul( scale );\n\n\t\tconst rotation = float( rotationNode || materialRotation );\n\n\t\tconst rotatedPosition = rotate( alignedPosition, rotation );\n\n\t\treturn vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\t/**\n\t * Whether to use size attenuation or not.\n\t *\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tget sizeAttenuation() {\n\n\t\treturn this._useSizeAttenuation;\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( this._useSizeAttenuation !== value ) {\n\n\t\t\tthis._useSizeAttenuation = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ShadowMaskModel extends LightingModel {\n\n\t/**\n\t * Constructs a new shadow mask model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The shadow mask node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.shadowNode = float( 1 ).toVar( 'shadowMask' );\n\n\t}\n\n\t/**\n\t * Only used to save the shadow mask.\n\t *\n\t * @param {Object} input - The input data.\n\t */\n\tdirect( { shadowMask } ) {\n\n\t\tthis.shadowNode.mulAssign( shadowMask );\n\n\t}\n\n\t/**\n\t * Uses the shadow mask to produce the final color.\n\t *\n\t * @param {ContextNode} context - The current node context.\n\t */\n\tfinish( context ) {\n\n\t\tdiffuseColor.a.mulAssign( this.shadowNode.oneMinus() );\n\n\t\tcontext.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment\n\n\t}\n\n}\n\nconst _defaultValues = /*@__PURE__*/ new ShadowMaterial();\n\n/**\n * Node material version of `ShadowMaterial`.\n *\n * @augments NodeMaterial\n */\nclass ShadowNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because so it's possible to implement\n\t\t * the shadow mask effect.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {ShadowMaskModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ShadowMaskModel();\n\n\t}\n\n}\n\n/** @module Texture3DNode **/\n\nconst normal = Fn( ( { texture, uv } ) => {\n\n\tconst epsilon = 0.0001;\n\n\tconst ret = vec3().toVar();\n\n\tIf( uv.x.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 1, 0 ) );\n\n\t} ).ElseIf( uv.z.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, 1 ) );\n\n\t} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( - 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, - 1, 0 ) );\n\n\t} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, - 1 ) );\n\n\t} ).Else( () => {\n\n\t\tconst step = 0.01;\n\n\t\tconst x = texture.sample( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );\n\t\tconst y = texture.sample( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );\n\t\tconst z = texture.sample( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, 0.0, step ) ) ).r );\n\n\t\tret.assign( vec3( x, y, z ) );\n\n\t} );\n\n\treturn ret.normalize();\n\n} );\n\n/**\n * This type of uniform node represents a 3D texture.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass Texture3DNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'Texture3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new 3D texture node.\n\t *\n\t * @param {Data3DTexture} value - The 3D texture.\n\t * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n\t * @param {Node<int>?} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTexture3DNode = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture3D'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture3D';\n\n\t}\n\n\t/**\n\t * Returns a default uv node which is in context of 3D textures a three-dimensional\n\t * uv node.\n\t *\n\t * @return {Node<vec3>} The default uv node.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn vec3( 0.5, 0.5, 0.5 );\n\n\t}\n\n\t/**\n\t * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n\t * for 3D textures. The uv transformation matrix is not applied to 3D textures.\n\t *\n\t * @param {Boolean} value - The update toggle.\n\t */\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for 3d TextureNode\n\n\t/**\n\t * Overwrites the default implementation to return the unmodified uv node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The unmodified uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, 'vec3' );\n\n\t}\n\n\t/**\n\t * TODO.\n\t *\n\t * @param {Node<vec3>} uvNode - The uv node .\n\t * @return {Node<vec3>} TODO.\n\t */\n\tnormal( uvNode ) {\n\n\t\treturn normal( { texture: this, uv: uvNode } );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a 3D texture node.\n *\n * @function\n * @param {Data3DTexture} value - The 3D texture.\n * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.\n * @param {Node<int>?} [levelNode=null] - The level node.\n * @returns {Texture3DNode}\n */\nconst texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );\n\n/** @module VolumeNodeMaterial **/\n\n/**\n * Node material intended for volume rendering. The volumetic data are\n * defined with an instance of {@link Data3DTexture}.\n *\n * @augments NodeMaterial\n */\nclass VolumeNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'VolumeNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new volume node material.\n\t *\n\t * @param {Object?} parameters - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVolumeNodeMaterial = true;\n\n\t\t/**\n\t\t * The base color of the volume.\n\t\t *\n\t\t * @type {Color}\n\t\t * @default 100\n\t\t */\n\t\tthis.base = new Color( 0xffffff );\n\n\t\t/**\n\t\t * A 3D data texture holding the volumetric data.\n\t\t *\n\t\t * @type {Data3DTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.map = null;\n\n\t\t/**\n\t\t * This number of samples for each ray that hits the mesh's surface\n\t\t * and travels through the volume.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 100\n\t\t */\n\t\tthis.steps = 100;\n\n\t\t/**\n\t\t * Callback for {@link VolumeNodeMaterial#testNode}.\n\t\t *\n\t\t * @callback testNodeCallback\n\t\t * @param {Data3DTexture<float>} map - The 3D texture.\n\t\t * @param {Node<float>} mapValue - The sampled value inside the volume.\n\t\t * @param {Node<vec3>} probe - The probe which is the entry point of the ray on the mesh's surface.\n\t\t * @param {Node<vec4>} finalColor - The final color.\n\t\t */\n\n\t\t/**\n\t\t * The volume rendering of this material works by shooting rays\n\t\t * from the camera position through each fragment of the mesh's\n\t\t * surface and sample the inner volume in a raymarching fashion\n\t\t * mutiple times.\n\t\t *\n\t\t * This node can be used to assign a callback function of type `Fn`\n\t\t * that will be exexuted per sample. The callback receives the\n\t\t * texture, the sampled texture value as well as position on the surface\n\t\t * where the rays enters the volume. The last parameter is a color\n\t\t * that allows the callback to determine the final color.\n\t\t *\n\t\t * @type {testNodeCallback?}\n\t\t * @default null\n\t\t */\n\t\tthis.testNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst map = texture3D( this.map, null, 0 );\n\n\t\tconst hitBox = Fn( ( { orig, dir } ) => {\n\n\t\t\tconst box_min = vec3( - 0.5 );\n\t\t\tconst box_max = vec3( 0.5 );\n\n\t\t\tconst inv_dir = dir.reciprocal();\n\n\t\t\tconst tmin_tmp = box_min.sub( orig ).mul( inv_dir );\n\t\t\tconst tmax_tmp = box_max.sub( orig ).mul( inv_dir );\n\n\t\t\tconst tmin = min$1( tmin_tmp, tmax_tmp );\n\t\t\tconst tmax = max$1( tmin_tmp, tmax_tmp );\n\n\t\t\tconst t0 = max$1( tmin.x, max$1( tmin.y, tmin.z ) );\n\t\t\tconst t1 = min$1( tmax.x, min$1( tmax.y, tmax.z ) );\n\n\t\t\treturn vec2( t0, t1 );\n\n\t\t} );\n\n\t\tthis.fragmentNode = Fn( () => {\n\n\t\t\tconst vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );\n\t\t\tconst vDirection = varying( positionGeometry.sub( vOrigin ) );\n\n\t\t\tconst rayDir = vDirection.normalize();\n\t\t\tconst bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();\n\n\t\t\tbounds.x.greaterThan( bounds.y ).discard();\n\n\t\t\tbounds.assign( vec2( max$1( bounds.x, 0.0 ), bounds.y ) );\n\n\t\t\tconst p = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();\n\t\t\tconst inc = vec3( rayDir.abs().reciprocal() ).toVar();\n\t\t\tconst delta = float( min$1( inc.x, min$1( inc.y, inc.z ) ) ).toVar( 'delta' ); // used 'delta' name in loop\n\n\t\t\tdelta.divAssign( materialReference( 'steps', 'float' ) );\n\n\t\t\tconst ac = vec4( materialReference( 'base', 'color' ), 0.0 ).toVar();\n\n\t\t\tLoop( { type: 'float', start: bounds.x, end: bounds.y, update: '+= delta' }, () => {\n\n\t\t\t\tconst d = property( 'float', 'd' ).assign( map.sample( p.add( 0.5 ) ).r );\n\n\t\t\t\tif ( this.testNode !== null ) {\n\n\t\t\t\t\tthis.testNode( { map: map, mapValue: d, probe: p, finalColor: ac } ).append();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default to show surface of mesh\n\t\t\t\t\tac.a.assign( 1 );\n\t\t\t\t\tBreak();\n\n\t\t\t\t}\n\n\t\t\t\tp.addAssign( rayDir.mul( delta ) );\n\n\t\t\t} );\n\n\t\t\tac.a.equal( 0 ).discard();\n\n\t\t\treturn vec4( ac );\n\n\t\t} )();\n\n\t\tsuper.setup( builder );\n\n\t}\n\n}\n\n/**\n * This module manages the internal animation loop of the renderer.\n *\n * @private\n */\nclass Animation {\n\n\t/**\n\t * Constructs a new animation loop management component.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( nodes, info ) {\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * A reference to the context from `requestAnimationFrame()` can\n\t\t * be called (usually `window`).\n\t\t *\n\t\t * @type {Window|XRSession}\n\t\t */\n\t\tthis._context = self;\n\n\t\t/**\n\t\t * The user-defined animation loop.\n\t\t *\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._animationLoop = null;\n\n\t\t/**\n\t\t * The requestId whic is returned from the `requestAnimationFrame()` call.\n\t\t * Can be used to cancel the stop the animation loop.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis._requestId = null;\n\n\t}\n\n\t/**\n\t * Starts the internal animation loop.\n\t */\n\tstart() {\n\n\t\tconst update = ( time, frame ) => {\n\n\t\t\tthis._requestId = this._context.requestAnimationFrame( update );\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\tthis.nodes.nodeFrame.update();\n\n\t\t\tthis.info.frame = this.nodes.nodeFrame.frameId;\n\n\t\t\tif ( this._animationLoop !== null ) this._animationLoop( time, frame );\n\n\t\t};\n\n\t\tupdate();\n\n\t}\n\n\t/**\n\t * Stops the internal animation loop.\n\t */\n\tstop() {\n\n\t\tthis._context.cancelAnimationFrame( this._requestId );\n\n\t\tthis._requestId = null;\n\n\t}\n\n\t/**\n\t * Defines the user-level animation loop.\n\t *\n\t * @param {Function} callback - The animation loop.\n\t */\n\tsetAnimationLoop( callback ) {\n\n\t\tthis._animationLoop = callback;\n\n\t}\n\n\t/**\n\t * Defines the context in which `requestAnimationFrame()` is executed.\n\t *\n\t * @param {Window|XRSession} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis._context = context;\n\n\t}\n\n\t/**\n\t * Frees all internal resources and stops the animation loop.\n\t */\n\tdispose() {\n\n\t\tthis.stop();\n\n\t}\n\n}\n\n/**\n * Data structure for the renderer. It allows defining values\n * with chained, hierarchical keys. Keys are meant to be\n * objects since the module internally works with Weak Maps\n * for perforamnce reasons.\n *\n * @private\n */\nclass ChainMap {\n\n\t/**\n\t * Constructs a new chained map.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The root Weak Map.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.weakMap = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns the value for the given array of keys.\n\t *\n\t * @param {Array<Object>} keys - List of keys.\n\t * @return {Any} The value. Returns `undefined` if no value was found.\n\t */\n\tget( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return undefined;\n\n\t\t}\n\n\t\treturn map.get( keys[ keys.length - 1 ] );\n\n\t}\n\n\t/**\n\t * Sets the value for the given keys.\n\t *\n\t * @param {Array<Object>} keys - List of keys.\n\t * @param {Any} value - The value to set.\n\t * @return {ChainMap} A reference to this chain map.\n\t */\n\tset( keys, value ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tconst key = keys[ i ];\n\n\t\t\tif ( map.has( key ) === false ) map.set( key, new WeakMap() );\n\n\t\t\tmap = map.get( key );\n\n\t\t}\n\n\t\tmap.set( keys[ keys.length - 1 ], value );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes a value for the given keys.\n\t *\n\t * @param {Array<Object>} keys - The keys.\n\t * @return {Boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.\n\t */\n\tdelete( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return false;\n\n\t\t}\n\n\t\treturn map.delete( keys[ keys.length - 1 ] );\n\n\t}\n\n}\n\nlet _id$9 = 0;\n\nfunction getKeys( obj ) {\n\n\tconst keys = Object.keys( obj );\n\n\tlet proto = Object.getPrototypeOf( obj );\n\n\twhile ( proto ) {\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( proto );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( descriptors[ key ] !== undefined ) {\n\n\t\t\t\tconst descriptor = descriptors[ key ];\n\n\t\t\t\tif ( descriptor && typeof descriptor.get === 'function' ) {\n\n\t\t\t\t\tkeys.push( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tproto = Object.getPrototypeOf( proto );\n\n\t}\n\n\treturn keys;\n\n}\n\n/**\n * A render object is the renderer's representation of single entity that gets drawn\n * with a draw command. There is no unique mapping of render objects to 3D objects in the\n * scene since render objects also depend from the used material, the current render context\n * and the current scene's lighting.\n *\n * In general, the basic process of the renderer is:\n *\n * - Analyze the 3D objects in the scene and generate render lists containing render items.\n * - Process the render lists by calling one or more render commands for each render item.\n * - For each render command, request a render object and perform the draw.\n *\n * The module provides an interface to get data required for the draw command like the actual\n * draw parameters or vertex buffers. It also holds a series of caching related methods since\n * creating render objects should only be done when necessary.\n *\n * @private\n */\nclass RenderObject {\n\n\t/**\n\t * Constructs a new render object.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t */\n\tconstructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {\n\n\t\tthis.id = _id$9 ++;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t * @private\n\t\t */\n\t\tthis._nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t * @private\n\t\t */\n\t\tthis._geometries = geometries;\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The 3D object's material.\n\t\t *\n\t\t * @type {Material}\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the 3D object should be rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The lights node.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lightsNode;\n\n\t\t/**\n\t\t * The render context.\n\t\t *\n\t\t * @type {RenderContext}\n\t\t */\n\t\tthis.context = renderContext;\n\n\t\t/**\n\t\t * The 3D object's geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = object.geometry;\n\n\t\t/**\n\t\t * The render object's version.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = material.version;\n\n\t\t/**\n\t\t * The draw range of the geometry.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.drawRange = null;\n\n\t\t/**\n\t\t * An array holding the buffer attributes\n\t\t * of the render object. This entails attribute\n\t\t * definitions on geometry and node level.\n\t\t *\n\t\t * @type {Array<BufferAttribute>?}\n\t\t * @default null\n\t\t */\n\t\tthis.attributes = null;\n\n\t\t/**\n\t\t * A reference to a render pipeline the render\n\t\t * object is processed with.\n\t\t *\n\t\t * @type {RenderPipeline}\n\t\t * @default null\n\t\t */\n\t\tthis.pipeline = null;\n\n\t\t/**\n\t\t * An array holding the vertex buffers which can\n\t\t * be buffer attributes but also interleaved buffers.\n\t\t *\n\t\t * @type {Array<BufferAttribute|InterleavedBuffer>?}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexBuffers = null;\n\n\t\t/**\n\t\t * The parameters for the draw command.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.drawParams = null;\n\n\t\t/**\n\t\t * If this render object is used inside a render bundle,\n\t\t * this property points to the respective bundle group.\n\t\t *\n\t\t * @type {BundleGroup?}\n\t\t * @default null\n\t\t */\n\t\tthis.bundle = null;\n\n\t\t/**\n\t\t * The clipping context.\n\t\t *\n\t\t * @type {ClippingContext}\n\t\t */\n\t\tthis.clippingContext = clippingContext;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n\t\t/**\n\t\t * The initial node cache key.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.initialNodesCacheKey = this.getDynamicCacheKey();\n\n\t\t/**\n\t\t * The initial cache key.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.initialCacheKey = this.getCacheKey();\n\n\t\t/**\n\t\t * The node builder state.\n\t\t *\n\t\t * @type {NodeBuilderState?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._nodeBuilderState = null;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {Array<BindGroup>?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * Reference to the node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._monitor = null;\n\n\t\t/**\n\t\t * An event listener which is defined by `RenderObjects`. It performs\n\t\t * clean up tasks when `dispose()` on this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onDispose = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderObject = true;\n\n\t\t/**\n\t\t * An event listener which is executed when `dispose()` is called on\n\t\t * the render object's material.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onMaterialDispose = () => {\n\n\t\t\tthis.dispose();\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'dispose', this.onMaterialDispose );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} context - The clipping context to set.\n\t */\n\tupdateClipping( context ) {\n\n\t\tthis.clippingContext = context;\n\n\t}\n\n\t/**\n\t * Whether the clipping requires an update or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget clippingNeedsUpdate() {\n\n\t\tif ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;\n\n\t\tthis.clippingContextCacheKey = this.clippingContext.cacheKey;\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * The number of clipping planes defined in context of hardware clipping.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget hardwareClippingPlanes() {\n\n\t\treturn this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n\n\t}\n\n\t/**\n\t * Returns the node builder state of this render object.\n\t *\n\t * @return {NodeBuilderState} The node buider state.\n\t */\n\tgetNodeBuilderState() {\n\n\t\treturn this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );\n\n\t}\n\n\t/**\n\t * Returns the node material observer of this render object.\n\t *\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tgetMonitor() {\n\n\t\treturn this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );\n\n\t}\n\n\t/**\n\t * Returns an array of bind groups of this render object.\n\t *\n\t * @return {Array<BindGroup>} The bindings.\n\t */\n\tgetBindings() {\n\n\t\treturn this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );\n\n\t}\n\n\t/**\n\t * Returns the index of the render object's geometry.\n\t *\n\t * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex() {\n\n\t\treturn this._geometries.getIndex( this );\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute.\n\t *\n\t * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect() {\n\n\t\treturn this._geometries.getIndirect( this );\n\n\t}\n\n\t/**\n\t * Returns an array that acts as a key for identifying the render object in a chain map.\n\t *\n\t * @return {Array<Object>} An array with object references.\n\t */\n\tgetChainArray() {\n\n\t\treturn [ this.object, this.material, this.context, this.lightsNode ];\n\n\t}\n\n\t/**\n\t * This method is used when the geometry of a 3D object has been exchanged and the\n\t * respective render object now requires an update.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to set.\n\t */\n\tsetGeometry( geometry ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.attributes = null;\n\n\t}\n\n\t/**\n\t * Returns the buffer attributes of the render object. The returned array holds\n\t * attribute definitions on geometry and node level.\n\t *\n\t * @return {Array<BufferAttribute>} An array with buffer attributes.\n\t */\n\tgetAttributes() {\n\n\t\tif ( this.attributes !== null ) return this.attributes;\n\n\t\tconst nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n\t\tconst geometry = this.geometry;\n\n\t\tconst attributes = [];\n\t\tconst vertexBuffers = new Set();\n\n\t\tfor ( const nodeAttribute of nodeAttributes ) {\n\n\t\t\tconst attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );\n\n\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\t\tvertexBuffers.add( bufferAttribute );\n\n\t\t}\n\n\t\tthis.attributes = attributes;\n\t\tthis.vertexBuffers = Array.from( vertexBuffers.values() );\n\n\t\treturn attributes;\n\n\t}\n\n\t/**\n\t * Returns the vertex buffers of the render object.\n\t *\n\t * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.\n\t */\n\tgetVertexBuffers() {\n\n\t\tif ( this.vertexBuffers === null ) this.getAttributes();\n\n\t\treturn this.vertexBuffers;\n\n\t}\n\n\t/**\n\t * Returns the draw parameters for the render object.\n\t *\n\t * @return {{vertexCount: Number, firstVertex: Number, instanceCount: Number, firstInstance: Number}} The draw parameters.\n\t */\n\tgetDrawParameters() {\n\n\t\tconst { object, material, geometry, group, drawRange } = this;\n\n\t\tconst drawParams = this.drawParams || ( this.drawParams = {\n\t\t\tvertexCount: 0,\n\t\t\tfirstVertex: 0,\n\t\t\tinstanceCount: 0,\n\t\t\tfirstInstance: 0\n\t\t} );\n\n\t\tconst index = this.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\t\tconst instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );\n\n\t\tif ( instanceCount === 0 ) return null;\n\n\t\tdrawParams.instanceCount = instanceCount;\n\n\t\tif ( object.isBatchedMesh === true ) return drawParams;\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {\n\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tlet firstVertex = drawRange.start * rangeFactor;\n\t\tlet lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tfirstVertex = Math.max( firstVertex, group.start * rangeFactor );\n\t\t\tlastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tconst position = geometry.attributes.position;\n\t\tlet itemCount = Infinity;\n\n\t\tif ( hasIndex ) {\n\n\t\t\titemCount = index.count;\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\titemCount = position.count;\n\n\t\t}\n\n\t\tfirstVertex = Math.max( firstVertex, 0 );\n\t\tlastVertex = Math.min( lastVertex, itemCount );\n\n\t\tconst count = lastVertex - firstVertex;\n\n\t\tif ( count < 0 || count === Infinity ) return null;\n\n\t\tdrawParams.vertexCount = count;\n\t\tdrawParams.firstVertex = firstVertex;\n\n\t\treturn drawParams;\n\n\t}\n\n\t/**\n\t * Returns the render object's geometry cache key.\n\t *\n\t * The geometry cache key is part of the material cache key.\n\t *\n\t * @return {String} The geometry cache key.\n\t */\n\tgetGeometryCacheKey() {\n\n\t\tconst { geometry } = this;\n\n\t\tlet cacheKey = '';\n\n\t\tfor ( const name of Object.keys( geometry.attributes ).sort() ) {\n\n\t\t\tconst attribute = geometry.attributes[ name ];\n\n\t\t\tcacheKey += name + ',';\n\n\t\t\tif ( attribute.data ) cacheKey += attribute.data.stride + ',';\n\t\t\tif ( attribute.offset ) cacheKey += attribute.offset + ',';\n\t\t\tif ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';\n\t\t\tif ( attribute.normalized ) cacheKey += 'n,';\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tcacheKey += 'index,';\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's material cache key.\n\t *\n\t * The material cache key is part of the render object cache key.\n\t *\n\t * @return {String} The material cache key.\n\t */\n\tgetMaterialCacheKey() {\n\n\t\tconst { object, material } = this;\n\n\t\tlet cacheKey = material.customProgramCacheKey();\n\n\t\tfor ( const property of getKeys( material ) ) {\n\n\t\t\tif ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tlet valueKey;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\t// some material values require a formatting\n\n\t\t\t\tconst type = typeof value;\n\n\t\t\t\tif ( type === 'number' ) {\n\n\t\t\t\t\tvalueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n\n\t\t\t\t} else if ( type === 'object' ) {\n\n\t\t\t\t\tvalueKey = '{';\n\n\t\t\t\t\tif ( value.isTexture ) {\n\n\t\t\t\t\t\tvalueKey += value.mapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalueKey += '}';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalueKey = String( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalueKey = String( value );\n\n\t\t\t}\n\n\t\t\tcacheKey += /*property + ':' +*/ valueKey + ',';\n\n\t\t}\n\n\t\tcacheKey += this.clippingContextCacheKey + ',';\n\n\t\tif ( object.geometry ) {\n\n\t\t\tcacheKey += this.getGeometryCacheKey();\n\n\t\t}\n\n\t\tif ( object.skeleton ) {\n\n\t\t\tcacheKey += object.skeleton.bones.length + ',';\n\n\t\t}\n\n\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\tcacheKey += object.morphTargetInfluences.length + ',';\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tcacheKey += object._matricesTexture.uuid + ',';\n\n\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\tcacheKey += object._colorsTexture.uuid + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\t// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n\t\t\tcacheKey += object.uuid + ',';\n\n\t\t}\n\n\t\tcacheKey += object.receiveShadow + ',';\n\n\t\treturn hashString( cacheKey );\n\n\t}\n\n\t/**\n\t * Whether the geometry requires an update or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget needsGeometryUpdate() {\n\n\t\treturn this.geometry.id !== this.object.geometry.id;\n\n\t}\n\n\t/**\n\t * Whether the render object requires an update or not.\n\t *\n\t * Note: There are two distinct places where render objects are checked for an update.\n\t *\n\t * 1. In `RenderObjects.get()` which is executed when the render object is request. This\n\t * method checks the `needsUpdate` flag and recreates the render object if necessary.\n\t * 2. In `Renderer._renderObjectDirect()` right after getting the render object via\n\t * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect\n\t * a need for a refresh due to material, geometry or object related value changes.\n\t *\n\t * TODO: Investigate if it's possible to merge boths steps so there is only a single place\n\t * that performs the 'needsUpdate' check.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t */\n\tget needsUpdate() {\n\n\t\treturn /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );\n\n\t}\n\n\t/**\n\t * Returns the dynamic cache key which represents a key that is computed per draw command.\n\t *\n\t * @return {String} The cache key.\n\t */\n\tgetDynamicCacheKey() {\n\n\t\t// Environment Nodes Cache Key\n\n\t\tlet cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );\n\n\t\tif ( this.object.receiveShadow ) {\n\n\t\t\tcacheKey += 1;\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's cache key.\n\t *\n\t * @return {String} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn this.getMaterialCacheKey() + this.getDynamicCacheKey();\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.material.removeEventListener( 'dispose', this.onMaterialDispose );\n\n\t\tthis.onDispose();\n\n\t}\n\n}\n\nconst _chainArray = [];\n\n/**\n * This module manages the render objects of the renderer.\n *\n * @private\n */\nclass RenderObjects {\n\n\t/**\n\t * Constructs a new render object management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Bindings} bindings - Renderer component for managing bindings.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, nodes, geometries, pipelines, bindings, info ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t */\n\t\tthis.geometries = geometries;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing bindings.\n\t\t *\n\t\t * @type {Bindings}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * A dictionary that manages render contexts in chain maps\n\t\t * for each pass ID.\n\t\t *\n\t\t * @type {Object<String,ChainMap>}\n\t\t */\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Returns a render object for the given object and state data.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the 3D object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} passId - An optional ID for identifying the pass.\n\t * @return {RenderObject} The render object.\n\t */\n\tget( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\t// reuse chainArray\n\t\t_chainArray[ 0 ] = object;\n\t\t_chainArray[ 1 ] = material;\n\t\t_chainArray[ 2 ] = renderContext;\n\t\t_chainArray[ 3 ] = lightsNode;\n\n\t\tlet renderObject = chainMap.get( _chainArray );\n\n\t\tif ( renderObject === undefined ) {\n\n\t\t\trenderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\tchainMap.set( _chainArray, renderObject );\n\n\t\t} else {\n\n\t\t\trenderObject.updateClipping( clippingContext );\n\n\t\t\tif ( renderObject.needsGeometryUpdate ) {\n\n\t\t\t\trenderObject.setGeometry( object.geometry );\n\n\t\t\t}\n\n\t\t\tif ( renderObject.version !== material.version || renderObject.needsUpdate ) {\n\n\t\t\t\tif ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {\n\n\t\t\t\t\trenderObject.dispose();\n\n\t\t\t\t\trenderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderObject.version = material.version;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderObject;\n\n\t}\n\n\t/**\n\t * Returns a chain map for the given pass ID.\n\t *\n\t * @param {String} [passId='default'] - The pass ID.\n\t * @return {ChainMap} The chain map.\n\t */\n\tgetChainMap( passId = 'default' ) {\n\n\t\treturn this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Factory method for creating render objects with the given list of parameters.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} passId - An optional ID for identifying the pass.\n\t * @return {RenderObject} The render object.\n\t */\n\tcreateRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\tconst renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );\n\n\t\trenderObject.onDispose = () => {\n\n\t\t\tthis.pipelines.delete( renderObject );\n\t\t\tthis.bindings.delete( renderObject );\n\t\t\tthis.nodes.delete( renderObject );\n\n\t\t\tchainMap.delete( renderObject.getChainArray() );\n\n\t\t};\n\n\t\treturn renderObject;\n\n\t}\n\n\n}\n\n/**\n * Data structure for the renderer. It is intended to manage\n * data of objects in dictionaries.\n *\n * @private\n */\nclass DataMap {\n\n\t/**\n\t * Constructs a new data map.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * `DataMap` internally uses a weak map\n\t\t * to manage its data.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Deletes the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object?} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tlet map = null;\n\n\t\tif ( this.data.has( object ) ) {\n\n\t\t\tmap = this.data.get( object );\n\n\t\t\tthis.data.delete( object );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given object has a dictionary defined.\n\t *\n\t * @param {Object} object - The object to test.\n\t * @return {Boolean} Whether a dictionary is defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n}\n\nconst AttributeType = {\n\tVERTEX: 1,\n\tINDEX: 2,\n\tSTORAGE: 3,\n\tINDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\n\n/**\n * This renderer module manages geometry attributes.\n *\n * @private\n * @augments DataMap\n */\nclass Attributes extends DataMap {\n\n\t/**\n\t * Constructs a new attribute management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Deletes the data for the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {Object} The deleted attribute data.\n\t */\n\tdelete( attribute ) {\n\n\t\tconst attributeData = super.delete( attribute );\n\n\t\tif ( attributeData !== undefined ) {\n\n\t\t\tthis.backend.destroyAttribute( attribute );\n\n\t\t}\n\n\t\treturn attributeData;\n\n\t}\n\n\t/**\n\t * Updates the given attribute. This method creates attribute buffers\n\t * for new attributes and updates data for existing ones.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {Number} type - The attribute type.\n\t */\n\tupdate( attribute, type ) {\n\n\t\tconst data = this.get( attribute );\n\n\t\tif ( data.version === undefined ) {\n\n\t\t\tif ( type === AttributeType.VERTEX ) {\n\n\t\t\t\tthis.backend.createAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDEX ) {\n\n\t\t\t\tthis.backend.createIndexAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.STORAGE ) {\n\n\t\t\t\tthis.backend.createStorageAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDIRECT ) {\n\n\t\t\t\tthis.backend.createIndirectStorageAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tdata.version = this._getBufferAttribute( attribute ).version;\n\n\t\t} else {\n\n\t\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\t\tif ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {\n\n\t\t\t\tthis.backend.updateAttribute( attribute );\n\n\t\t\t\tdata.version = bufferAttribute.version;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Utility method for handling interleaved buffer attributes correctly.\n\t * To process them, their `InterleavedBuffer` is returned.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {BufferAttribute|InterleavedBuffer}\n\t */\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given array has values that require an Uint32 array type.\n *\n * @private\n * @function\n * @param {Array<Number>} array - The array to test.\n * @return {Booolean} Whether the given array has values that require an Uint32 array type or not.\n */\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\n/**\n * Returns the wireframe version for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {Number} The versio.\n */\nfunction getWireframeVersion( geometry ) {\n\n\treturn ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;\n\n}\n\n/**\n * Returns a wireframe index attribute for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {BufferAttribute} The wireframe index attribute.\n */\nfunction getWireframeIndex( geometry ) {\n\n\tconst indices = [];\n\n\tconst geometryIndex = geometry.index;\n\tconst geometryPosition = geometry.attributes.position;\n\n\tif ( geometryIndex !== null ) {\n\n\t\tconst array = geometryIndex.array;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst a = array[ i + 0 ];\n\t\t\tconst b = array[ i + 1 ];\n\t\t\tconst c = array[ i + 2 ];\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = geometryPosition.array;\n\n\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\tconst a = i + 0;\n\t\t\tconst b = i + 1;\n\t\t\tconst c = i + 2;\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t}\n\n\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\tattribute.version = getWireframeVersion( geometry );\n\n\treturn attribute;\n\n}\n\n/**\n * This renderer module manages geometries.\n *\n * @private\n * @augments DataMap\n */\nclass Geometries extends DataMap {\n\n\t/**\n\t * Constructs a new geometry management component.\n\t *\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( attributes, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * Weak Map for managing attributes for wireframe rendering.\n\t\t *\n\t\t * @type {WeakMap<BufferGeometry,BufferAttribute>}\n\t\t */\n\t\tthis.wireframes = new WeakMap();\n\n\t\t/**\n\t\t * This Weak Map is used to make sure buffer attributes are\n\t\t * updated only once per render call.\n\t\t *\n\t\t * @type {WeakMap<BufferAttribute,Number>}\n\t\t */\n\t\tthis.attributeCall = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has an initialized geometry.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether if the given render object has an initialized geometry or not.\n\t */\n\thas( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\n\t\treturn super.has( geometry ) && this.get( geometry ).initialized === true;\n\n\t}\n\n\t/**\n\t * Prepares the geometry of the given render object for rendering.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tif ( this.has( renderObject ) === false ) this.initGeometry( renderObject );\n\n\t\tthis.updateAttributes( renderObject );\n\n\t}\n\n\t/**\n\t * Initializes the geometry of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tinitGeometry( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\t\tconst geometryData = this.get( geometry );\n\n\t\tgeometryData.initialized = true;\n\n\t\tthis.info.memory.geometries ++;\n\n\t\tconst onDispose = () => {\n\n\t\t\tthis.info.memory.geometries --;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst geometryAttributes = renderObject.getAttributes();\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.attributes.delete( index );\n\n\t\t\t}\n\n\t\t\tfor ( const geometryAttribute of geometryAttributes ) {\n\n\t\t\t\tthis.attributes.delete( geometryAttribute );\n\n\t\t\t}\n\n\t\t\tconst wireframeAttribute = this.wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute !== undefined ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t};\n\n\t\tgeometry.addEventListener( 'dispose', onDispose );\n\n\t}\n\n\t/**\n\t * Updates the geometry attributes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAttributes( renderObject ) {\n\n\t\t// attributes\n\n\t\tconst attributes = renderObject.getAttributes();\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.STORAGE );\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.VERTEX );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indexes\n\n\t\tconst index = this.getIndex( renderObject );\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.updateAttribute( index, AttributeType.INDEX );\n\n\t\t}\n\n\t\t// indirect\n\n\t\tconst indirect = renderObject.geometry.indirect;\n\n\t\tif ( indirect !== null ) {\n\n\t\t\tthis.updateAttribute( indirect, AttributeType.INDIRECT );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {Number} type - The attribute type.\n\t */\n\tupdateAttribute( attribute, type ) {\n\n\t\tconst callId = this.info.render.calls;\n\n\t\tif ( ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( this.attributeCall.get( attribute ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.attributeCall.get( attribute ) === undefined ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t} else if ( this.attributeCall.get( attribute.data ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute.data, callId );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect( renderObject ) {\n\n\t\treturn renderObject.geometry.indirect;\n\n\t}\n\n\t/**\n\t * Returns the index of the given render object's geometry. This is implemented\n\t * in a method to return a wireframe index if necessary.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex( renderObject ) {\n\n\t\tconst { geometry, material } = renderObject;\n\n\t\tlet index = geometry.index;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tconst wireframes = this.wireframes;\n\n\t\t\tlet wireframeAttribute = wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute === undefined ) {\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tindex = wireframeAttribute;\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n}\n\n/**\n * This renderer module provides a series of statistical information\n * about the GPU memory and the rendering process. Useful for debugging\n * and monitoring.\n */\nclass Info {\n\n\t/**\n\t * Constructs a new info component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Whether frame related metrics should automatically\n\t\t * be resetted or not. This property should be set to `false`\n\t\t * by apps which manage their own animation loop. They must\n\t\t * then call `renderer.info.reset()` once per frame manually.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\n\t\t/**\n\t\t * The current frame ID. This ID is managed\n\t\t * by `NodeFrame`.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.frame = 0;\n\n\t\t/**\n\t\t * The number of render calls since the\n\t\t * app has been started.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.calls = 0;\n\n\t\t/**\n\t\t * Render related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {Number} calls - The number of render calls since the app has been started.\n\t\t * @property {Number} frameCalls - The number of render calls of the current frame.\n\t\t * @property {Number} drawCalls - The number of draw calls of the current frame.\n\t\t * @property {Number} triangles - The number of rendered triangle primitives of the current frame.\n\t\t * @property {Number} points - The number of rendered point primitives of the current frame.\n\t\t * @property {Number} lines - The number of rendered line primitives of the current frame.\n\t\t * @property {Number} previousFrameCalls - The number of render calls of the previous frame.\n\t\t * @property {Number} timestamp - The timestamp of the frame when using `renderer.renderAsync()`.\n\t\t * @property {Number} timestampCalls - The number of render calls using `renderer.renderAsync()`.\n\t\t */\n\t\tthis.render = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\tdrawCalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0,\n\t\t\ttimestamp: 0,\n\t\t\tpreviousFrameCalls: 0,\n\t\t\ttimestampCalls: 0\n\t\t};\n\n\t\t/**\n\t\t * Compute related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {Number} calls - The number of compute calls since the app has been started.\n\t\t * @property {Number} frameCalls - The number of compute calls of the current frame.\n\t\t * @property {Number} previousFrameCalls - The number of compute calls of the previous frame.\n\t\t * @property {Number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.\n\t\t * @property {Number} timestampCalls - The number of render calls using `renderer.computeAsync()`.\n\t\t */\n\t\tthis.compute = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\ttimestamp: 0,\n\t\t\tpreviousFrameCalls: 0,\n\t\t\ttimestampCalls: 0\n\t\t};\n\n\t\t/**\n\t\t * Memory related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {Number} geometries - The number of active geometries.\n\t\t * @property {Number} frameCalls - The number of active textures.\n\t\t */\n\t\tthis.memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\n\t}\n\n\t/**\n\t * This method should be executed per draw call and updates the corresponding metrics.\n\t *\n\t * @param {Object3D} object - The 3D object that is going to be rendered.\n\t * @param {Number} count - The vertex or index count.\n\t * @param {Number} instanceCount - The instance count.\n\t */\n\tupdate( object, count, instanceCount ) {\n\n\t\tthis.render.drawCalls ++;\n\n\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\tthis.render.triangles += instanceCount * ( count / 3 );\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\tthis.render.points += instanceCount * count;\n\n\t\t} else if ( object.isLineSegments ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count / 2 );\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count - 1 );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPUInfo: Unknown object type.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Used by async render methods to updated timestamp metrics.\n\t *\n\t * @param {('render'|'compute')} type - The type of render call.\n\t * @param {Number} time - The duration of the compute/render call in milliseconds.\n\t */\n\tupdateTimestamp( type, time ) {\n\n\t\tif ( this[ type ].timestampCalls === 0 ) {\n\n\t\t\tthis[ type ].timestamp = 0;\n\n\t\t}\n\n\n\t\tthis[ type ].timestamp += time;\n\n\t\tthis[ type ].timestampCalls ++;\n\n\n\t\tif ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {\n\n\t\t\tthis[ type ].timestampCalls = 0;\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Resets frame related metrics.\n\t */\n\treset() {\n\n\t\tconst previousRenderFrameCalls = this.render.frameCalls;\n\t\tthis.render.previousFrameCalls = previousRenderFrameCalls;\n\n\t\tconst previousComputeFrameCalls = this.compute.frameCalls;\n\t\tthis.compute.previousFrameCalls = previousComputeFrameCalls;\n\n\n\t\tthis.render.drawCalls = 0;\n\t\tthis.render.frameCalls = 0;\n\t\tthis.compute.frameCalls = 0;\n\n\t\tthis.render.triangles = 0;\n\t\tthis.render.points = 0;\n\t\tthis.render.lines = 0;\n\n\n\t}\n\n\t/**\n\t * Performs a complete reset of the object.\n\t */\n\tdispose() {\n\n\t\tthis.reset();\n\n\t\tthis.calls = 0;\n\n\t\tthis.render.calls = 0;\n\t\tthis.compute.calls = 0;\n\n\t\tthis.render.timestamp = 0;\n\t\tthis.compute.timestamp = 0;\n\t\tthis.memory.geometries = 0;\n\t\tthis.memory.textures = 0;\n\n\t}\n\n}\n\n/**\n * Abstract class for representing pipelines.\n *\n * @private\n * @abstract\n */\nclass Pipeline {\n\n\t/**\n\t * Constructs a new pipeline.\n\t *\n\t * @param {String} cacheKey - The pipeline's cache key.\n\t */\n\tconstructor( cacheKey ) {\n\n\t\t/**\n\t\t * The pipeline's cache key.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.cacheKey = cacheKey;\n\n\t\t/**\n\t\t * How often the pipeline is currently in use.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\n/**\n * Class for representing render pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderPipeline extends Pipeline {\n\n\t/**\n\t * Constructs a new render pipeline.\n\t *\n\t * @param {String} cacheKey - The pipeline's cache key.\n\t * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.\n\t * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.\n\t */\n\tconstructor( cacheKey, vertexProgram, fragmentProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\t/**\n\t\t * The pipeline's vertex shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.vertexProgram = vertexProgram;\n\n\t\t/**\n\t\t * The pipeline's fragment shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.fragmentProgram = fragmentProgram;\n\n\t}\n\n}\n\n/**\n * Class for representing compute pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass ComputePipeline extends Pipeline {\n\n\t/**\n\t * Constructs a new render pipeline.\n\t *\n\t * @param {String} cacheKey - The pipeline's cache key.\n\t * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.\n\t */\n\tconstructor( cacheKey, computeProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\t/**\n\t\t * The pipeline's compute shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.computeProgram = computeProgram;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputePipeline = true;\n\n\t}\n\n}\n\nlet _id$8 = 0;\n\n/**\n * Class for representing programmable stages which are vertex,\n * fragment or compute shaders. Unlike fixed-function states (like blending),\n * they represent the programmable part of a pipeline.\n *\n * @private\n */\nclass ProgrammableStage {\n\n\t/**\n\t * Constructs a new programmable stage.\n\t *\n\t * @param {String} code - The shader code.\n\t * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.\n\t * @param {String} name - The name of the shader.\n\t * @param {Array<Object>?} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t * @param {Array<Object>?} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t */\n\tconstructor( code, stage, name, transforms = null, attributes = null ) {\n\n\t\t/**\n\t\t * The id of the programmable stage.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$8 ++;\n\n\t\t/**\n\t\t * The shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.code = code;\n\n\t\t/**\n\t\t * The type of stage.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.stage = stage;\n\n\t\t/**\n\t\t * The name of the stage.\n\t\t * This is used for debugging purposes.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t\t *\n\t\t * @type {Array<Object>?}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t\t *\n\t\t * @type {Array<Object>?}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * How often the programmable stage is currently in use.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\n/**\n * This renderer module manages the pipelines of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Pipelines extends DataMap {\n\n\t/**\n\t * Constructs a new pipeline management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * A references to the bindings management component.\n\t\t * This reference will be set inside the `Bindings`\n\t\t * constructor.\n\t\t *\n\t\t * @type {Bindings?}\n\t\t * @default null\n\t\t */\n\t\tthis.bindings = null;\n\n\t\t/**\n\t\t * Internal cache for maintaining pipelines.\n\t\t * The key of the map is a cache key, the value the pipeline.\n\t\t *\n\t\t * @type {Map<String,Pipeline>}\n\t\t */\n\t\tthis.caches = new Map();\n\n\t\t/**\n\t\t * This dictionary maintains for each shader stage type (vertex,\n\t\t * fragment and compute) the progammable stage objects which\n\t\t * represent the actual shader code.\n\t\t *\n\t\t * @type {Object<String,Map>}\n\t\t */\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );\n\t\t\t\tthis.programs.compute.set( nodeBuilderState.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>?} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {RenderPipeline} The render pipeline.\n\t */\n\tgetForRender( renderObject, promises = null ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\tconst name = renderObject.material ? renderObject.material.name : '';\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex', name );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment', name );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Deletes the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @return {Object?} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Updates the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @param {String} cacheKey - The cache key.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @param {String} cacheKey - The cache key.\n\t * @param {Array} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t// The `promises` array is `null` by default and only set to an empty array when\n\t\t\t// `Renderer.compileAsync()` is used. The next call actually fills the array with\n\t\t\t// pending promises that resolve when the render pipelines are ready for rendering.\n\n\t\t\tthis.backend.createRenderPipeline( renderObject, promises );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a compute pipeline.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @return {String} The cache key.\n\t */\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn computeNode.id + ',' + stageCompute.id;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a render pipeline.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @return {String} The cache key.\n\t */\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\treturn stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );\n\n\t}\n\n\t/**\n\t * Releases the given pipeline.\n\t *\n\t * @private\n\t * @param {Pipeline} pipeline - The pipeline to release.\n\t */\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t/**\n\t * Releases the shader program.\n\t *\n\t * @private\n\t * @param {Object} program - The shdaer program to release.\n\t */\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t/**\n\t * Returns `true` if the compute pipeline for the given compute node requires an update.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @return {Boolean} Whether the compute pipeline for the given compute node requires an update or not.\n\t */\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t/**\n\t * Returns `true` if the render pipeline for the given render object requires an update.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render object for the given render object requires an update or not.\n\t */\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\treturn data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );\n\n\t}\n\n}\n\n/**\n * This renderer module manages the bindings of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Bindings extends DataMap {\n\n\t/**\n\t * Constructs a new bindings management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Textures} textures - Renderer component for managing textures.\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing textures.\n\t\t *\n\t\t * @type {Textures}\n\t\t */\n\t\tthis.textures = textures;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._updateBindings( this.getForCompute( computeNode ) );\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis._updateBindings( this.getForRender( renderObject ) );\n\n\t}\n\n\t/**\n\t * Updates the given array of bindings.\n\t *\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_updateBindings( bindings ) {\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis._update( bindGroup, bindings );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Initializes the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to initialize.\n\t */\n\t_init( bindGroup ) {\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to update.\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_update( bindGroup, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tlet needsBindingsUpdate = false;\n\t\tlet cacheBindings = true;\n\t\tlet cacheIndex = 0;\n\t\tlet version = 0;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isNodeUniformsGroup ) {\n\n\t\t\t\tconst updated = this.nodes.updateGroup( binding );\n\n\t\t\t\t// every uniforms group is a uniform buffer. So if no update is required,\n\t\t\t\t// we move one with the next binding. Otherwise the next if block will update the group.\n\n\t\t\t\tif ( updated === false ) continue;\n\n\t\t\t}\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tbinding.update();\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texturesTextureData = this.textures.get( binding.texture );\n\n\t\t\t\tif ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tconst texture = binding.texture;\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t\tconst textureData = backend.get( texture );\n\n\t\t\t\tif ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {\n\n\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcacheIndex = cacheIndex * 10 + texture.id;\n\t\t\t\t\tversion += texture.version;\n\n\t\t\t\t}\n\n\t\t\t\tif ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {\n\n\t\t\t\t\t// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend\n\t\t\t\t\tconsole.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\tif ( binding.store === true ) {\n\n\t\t\t\t\t\ttextureData.needsMipmap = true;\n\n\t\t\t\t\t} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {\n\n\t\t\t\t\t\tthis.backend.generateMipmaps( texture );\n\n\t\t\t\t\t\ttextureData.needsMipmap = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tthis.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Default sorting function for opaque render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {Number} A numeric value which defines the sort order.\n */\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n/**\n * Default sorting function for transparent render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {Number} A numeric value which defines the sort order.\n */\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given transparent material requires a double pass.\n *\n * @private\n * @function\n * @param {Material} material - The transparent material.\n * @return {Boolean} Whether the given material requires a double pass or not.\n */\nfunction needsDoublePass( material ) {\n\n\tconst hasTransmission = material.transmission > 0 || material.transmissionNode;\n\n\treturn hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n\n}\n\n/**\n * When the renderer analyzes the scene at the beginning of a render call,\n * it stores 3D object for further processing in render lists. Depending on the\n * properties of a 3D objects (like their transformation or material state), the\n * objects are maintained in ordered lists for the actual rendering.\n *\n * Render lists are unique per scene and camera combination.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderList {\n\n\t/**\n\t * Constructs a render list.\n\t *\n\t * @param {Lighting} lighting - The lighting management component.\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( lighting, scene, camera ) {\n\n\t\t/**\n\t\t * 3D objects are transformed into render items and stored in this array.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.renderItems = [];\n\n\t\t/**\n\t\t * The current render items index.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderItemsIndex = 0;\n\n\t\t/**\n\t\t * A list with opaque render items.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.opaque = [];\n\n\t\t/**\n\t\t * A list with transparent render items which require\n\t\t * double pass rendering (e.g. transmissive objects).\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transparentDoublePass = [];\n\n\t\t/**\n\t\t * A list with transparent render items.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transparent = [];\n\n\t\t/**\n\t\t * A list with transparent render bundle data.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.bundles = [];\n\n\t\t/**\n\t\t * The render list's lights node. This node is later\n\t\t * relevant for the actual analytical light nodes which\n\t\t * compute the scene's lighting in the shader.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lighting.getNode( scene, camera );\n\n\t\t/**\n\t\t * The scene's lights stored in an array. This array\n\t\t * is used to setup the lights node.\n\t\t *\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis.lightsArray = [];\n\n\t\t/**\n\t\t * The scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * How many objects perform occlusion query tests.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.occlusionQueryCount = 0;\n\n\t}\n\n\t/**\n\t * This method is called right at the beginning of a render call\n\t * before the scene is analyzed. It prepares the internal data\n\t * structures for the upcoming render lists generation.\n\t *\n\t * @return {RenderList} A reference to this render list.\n\t */\n\tbegin() {\n\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque.length = 0;\n\t\tthis.transparentDoublePass.length = 0;\n\t\tthis.transparent.length = 0;\n\t\tthis.bundles.length = 0;\n\n\t\tthis.lightsArray.length = 0;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a render item for the giving render item state. The state is defined\n\t * by a series of object-related parameters.\n\t *\n\t * The method avoids object creation by holding render items and reusing them in\n\t * subsequent render calls (just with different property values).\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Number} groupOrder - The current group order.\n\t * @param {Number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t * @return {Object} The render item.\n\t */\n\tgetNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tlet renderItem = this.renderItems[ this.renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group,\n\t\t\t\tclippingContext: clippingContext\n\t\t\t};\n\n\t\t\tthis.renderItems[ this.renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\t\t\trenderItem.clippingContext = clippingContext;\n\n\t\t}\n\n\t\tthis.renderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\t/**\n\t * Pushes the given object as a render item to the internal render lists.\n\t * The selected lists depend on the object properties.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Number} groupOrder - The current group order.\n\t * @param {Number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\tpush( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( object.occlusionTest === true ) this.occlusionQueryCount ++;\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );\n\n\t\t\tthis.transparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inserts the given object as a render item at the start of the internal render lists.\n\t * The selected lists depend on the object properties.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Number} groupOrder - The current group order.\n\t * @param {Number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\tunshift( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( material.transparent === true || material.transmission > 0 ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );\n\n\t\t\tthis.transparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pushes render bundle group data into the render list.\n\t *\n\t * @param {Object} group - Bundle group data.\n\t */\n\tpushBundle( group ) {\n\n\t\tthis.bundles.push( group );\n\n\t}\n\n\t/**\n\t * Pushes a light into the render list.\n\t *\n\t * @param {Light} light - The light.\n\t */\n\tpushLight( light ) {\n\n\t\tthis.lightsArray.push( light );\n\n\t}\n\n\t/**\n\t * Sorts the internal render lists.\n\t *\n\t * @param {Function} customOpaqueSort - A custom sort function for opaque objects.\n\t * @param {Function} customTransparentSort -  A custom sort function for transparent objects.\n\t */\n\tsort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\t/**\n\t * This method performs finalizing tasks right after the render lists\n\t * have been generated.\n\t */\n\tfinish() {\n\n\t\t// update lights\n\n\t\tthis.lightsNode.setLights( this.lightsArray );\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = this.renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.groupOrder = null;\n\t\t\trenderItem.renderOrder = null;\n\t\t\trenderItem.z = null;\n\t\t\trenderItem.group = null;\n\t\t\trenderItem.clippingContext = null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * This renderer module manages the render lists which are unique\n * per scene and camera combination.\n *\n * @private\n */\nclass RenderLists {\n\n\t/**\n\t * Constructs a render lists management component.\n\t *\n\t * @param {Lighting} lighting - The lighting management component.\n\t */\n\tconstructor( lighting ) {\n\n\t\t/**\n\t\t * The lighting management component.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = lighting;\n\n\t\t/**\n\t\t * The internal chain map which holds the render lists.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\t/**\n\t * Returns a render list for the given scene and camera.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera.\n\t * @return {RenderList} The render list.\n\t */\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet list = lists.get( keys );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderList( this.lighting, scene, camera );\n\t\t\tlists.set( keys, list );\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nlet _id$7 = 0;\n\n/**\n * Any render or compute command is executed in a specific context that defines\n * the state of the renderer and its backend. Typical examples for such context\n * data are the current clear values or data from the active framebuffer. This\n * module is used to represent these contexts as objects.\n *\n * @private\n */\nclass RenderContext {\n\n\t/**\n\t * Constructs a new render context.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The context's ID.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$7 ++;\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a color attachment.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.color = true;\n\n\t\t/**\n\t\t * Whether the color attachment should be cleared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearColor = true;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default true\n\t\t */\n\t\tthis.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a depth attachment.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = true;\n\n\t\t/**\n\t\t * Whether the depth attachment should be cleared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearDepth = true;\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.clearDepthValue = 1;\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a stencil attachment.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = false;\n\n\t\t/**\n\t\t * Whether the stencil attachment should be cleared or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearStencil = true;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.clearStencilValue = 1;\n\n\t\t/**\n\t\t * By default the viewport encloses the entire framebuffer If a smaller\n\t\t * viewport is manually defined, this property is to `true` by the renderer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.viewport = false;\n\n\t\t/**\n\t\t * The viewport value. This value is in physical pixels meaning it incorporates\n\t\t * the renderer's pixel ratio. The viewport property of render targets or\n\t\t * the renderer is in logical pixels.\n\t\t *\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis.viewportValue = new Vector4();\n\n\t\t/**\n\t\t * When the scissor test is active and scissor rectangle smaller than the\n\t\t * framebuffers dimensions, this property is to `true` by the renderer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.scissor = false;\n\n\t\t/**\n\t\t * The scissor rectangle.\n\t\t *\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis.scissorValue = new Vector4();\n\n\t\t/**\n\t\t * The textures of the active render target.\n\t\t * `null` when no render target is set.\n\t\t *\n\t\t * @type {Array<Texture>?}\n\t\t * @default null\n\t\t */\n\t\tthis.textures = null;\n\n\t\t/**\n\t\t * The depth texture of the active render target.\n\t\t * `null` when no render target is set.\n\t\t *\n\t\t * @type {DepthTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.depthTexture = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.activeCubeFace = 0;\n\n\t\t/**\n\t\t * The number of MSAA samples. This value is always `1` when\n\t\t * MSAA isn't used.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.sampleCount = 1;\n\n\t\t/**\n\t\t * The framebuffers width in physical pixels.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.width = 0;\n\n\t\t/**\n\t\t * The framebuffers height in physical pixels.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.height = 0;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderContext = true;\n\n\t}\n\n\t/**\n\t * Returns the cache key of this render context.\n\t *\n\t * @return {Number} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n}\n\n/**\n * Computes a cache key for the given render context.\n *\n * @param {RenderContext} renderContext - The render context.\n * @return {Number} The cache key.\n */\nfunction getCacheKey( renderContext ) {\n\n\tconst { textures, activeCubeFace } = renderContext;\n\n\tconst values = [ activeCubeFace ];\n\n\tfor ( const texture of textures ) {\n\n\t\tvalues.push( texture.id );\n\n\t}\n\n\treturn hashArray( values );\n\n}\n\n/**\n * This module manages the render contexts of the renderer.\n *\n * @private\n */\nclass RenderContexts {\n\n\t/**\n\t * Constructs a new render context management component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A dictionary that manages render contexts in chain maps\n\t\t * for each attachment state.\n\t\t *\n\t\t * @type {Object<String,ChainMap>}\n\t\t */\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Returns a render context for the given scene, camera and render target.\n\t *\n\t * @param {Scene?} [scene=null] - The scene. The parameter can become `null` e.g. when the renderer clears a render target.\n\t * @param {Camera?} [camera=null] - The camera that is used to render the scene. The parameter can become `null` e.g. when the renderer clears a render target.\n\t * @param {RenderTarget?} [renderTarget=null] - The active render target.\n\t * @return {RenderContext} The render context.\n\t */\n\tget( scene = null, camera = null, renderTarget = null ) {\n\n\t\tconst chainKey = [];\n\t\tif ( scene !== null ) chainKey.push( scene );\n\t\tif ( camera !== null ) chainKey.push( camera );\n\n\t\tif ( chainKey.length === 0 ) {\n\n\t\t\tchainKey.push( { id: 'default' } );\n\n\t\t}\n\n\n\t\tlet attachmentState;\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\tattachmentState = 'default';\n\n\t\t} else {\n\n\t\t\tconst format = renderTarget.texture.format;\n\t\t\tconst count = renderTarget.textures.length;\n\n\t\t\tattachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;\n\n\t\t}\n\n\t\tconst chainMap = this.getChainMap( attachmentState );\n\n\t\tlet renderState = chainMap.get( chainKey );\n\n\t\tif ( renderState === undefined ) {\n\n\t\t\trenderState = new RenderContext();\n\n\t\t\tchainMap.set( chainKey, renderState );\n\n\t\t}\n\n\t\tif ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\n\t\treturn renderState;\n\n\t}\n\n\t/**\n\t * Returns a chain map for the given attachment state.\n\t *\n\t * @param {String} attachmentState - The attachment state.\n\t * @return {ChainMap} The chain map.\n\t */\n\tgetChainMap( attachmentState ) {\n\n\t\treturn this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n}\n\nconst _size$3 = /*@__PURE__*/ new Vector3();\n\n/**\n * This module manages the textures of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Textures extends DataMap {\n\n\t/**\n\t * Constructs a new texture management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, backend, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t}\n\n\t/**\n\t * Updates the given render target. Based on the given render target configuration,\n\t * it updates the texture states representing the attachments of the framebuffer.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target to update.\n\t * @param {Number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tupdateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {\n\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tconst sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\t\tconst depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst size = this.getSize( textures[ 0 ] );\n\n\t\tconst mipWidth = size.width >> activeMipmapLevel;\n\t\tconst mipHeight = size.height >> activeMipmapLevel;\n\n\t\tlet depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];\n\t\tconst useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n\n\t\tlet textureNeedsUpdate = false;\n\n\t\tif ( depthTexture === undefined && useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\t\t\tdepthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n\t\t\tdepthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\tdepthTextureMips[ activeMipmapLevel ] = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\t\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\t\tdepthTexture.image.height = mipHeight;\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderTargetData.width = size.width;\n\t\trenderTargetData.height = size.height;\n\t\trenderTargetData.textures = textures;\n\t\trenderTargetData.depthTexture = depthTexture || null;\n\t\trenderTargetData.depth = renderTarget.depthBuffer;\n\t\trenderTargetData.stencil = renderTarget.stencilBuffer;\n\t\trenderTargetData.renderTarget = renderTarget;\n\n\t\tif ( renderTargetData.sampleCount !== sampleCount ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\trenderTargetData.sampleCount = sampleCount;\n\n\t\t}\n\n\t\t//\n\n\t\tconst options = { sampleCount };\n\n\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsUpdate ) texture.needsUpdate = true;\n\n\t\t\tthis.updateTexture( texture, options );\n\n\t\t}\n\n\t\tif ( depthTexture ) {\n\n\t\t\tthis.updateTexture( depthTexture, options );\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( renderTargetData.initialized !== true ) {\n\n\t\t\trenderTargetData.initialized = true;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tthis._destroyTexture( textures[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( depthTexture ) {\n\n\t\t\t\t\tthis._destroyTexture( depthTexture );\n\n\t\t\t\t}\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given texture. Depending on the texture state, this method\n\t * triggers the upload of texture data to the GPU memory. If the texture data are\n\t * not yet ready for the upload, it uses default texture data for as a placeholder.\n\t *\n\t * @param {Texture} texture - The texture to update.\n\t * @param {Object} [options={}] - The options.\n\t */\n\tupdateTexture( texture, options = {} ) {\n\n\t\tconst textureData = this.get( texture );\n\t\tif ( textureData.initialized === true && textureData.version === texture.version ) return;\n\n\t\tconst isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n\t\tconst backend = this.backend;\n\n\t\tif ( isRenderTarget && textureData.initialized === true ) {\n\n\t\t\t// it's an update\n\n\t\t\tbackend.destroySampler( texture );\n\t\t\tbackend.destroyTexture( texture );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tconst renderTarget = this.renderer.getRenderTarget();\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttexture.type = renderTarget.texture.type;\n\n\t\t\t} else {\n\n\t\t\t\ttexture.type = UnsignedByteType;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { width, height, depth } = this.getSize( texture );\n\n\t\toptions.width = width;\n\t\toptions.height = height;\n\t\toptions.depth = depth;\n\t\toptions.needsMipmaps = this.needsMipmaps( texture );\n\t\toptions.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;\n\n\t\t//\n\n\t\tif ( isRenderTarget || texture.isStorageTexture === true ) {\n\n\t\t\tbackend.createSampler( texture );\n\t\t\tbackend.createTexture( texture, options );\n\n\t\t\ttextureData.generation = texture.version;\n\n\t\t} else {\n\n\t\t\tconst needsCreate = textureData.initialized !== true;\n\n\t\t\tif ( needsCreate ) backend.createSampler( texture );\n\n\t\t\tif ( texture.version > 0 ) {\n\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.images ) {\n\n\t\t\t\t\t\tconst images = [];\n\n\t\t\t\t\t\tfor ( const image of texture.images ) {\n\n\t\t\t\t\t\t\timages.push( image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toptions.images = images;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toptions.image = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {\n\n\t\t\t\t\t\tbackend.createTexture( texture, options );\n\n\t\t\t\t\t\ttextureData.isDefaultTexture = false;\n\t\t\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.source.dataReady === true ) backend.updateTexture( texture, options );\n\n\t\t\t\t\tif ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// async update\n\n\t\t\t\tbackend.createDefaultTexture( texture );\n\n\t\t\t\ttextureData.isDefaultTexture = true;\n\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( textureData.initialized !== true ) {\n\n\t\t\ttextureData.initialized = true;\n\t\t\ttextureData.generation = texture.version;\n\n\t\t\t//\n\n\t\t\tthis.info.memory.textures ++;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\ttexture.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis._destroyTexture( texture );\n\n\t\t\t\tthis.info.memory.textures --;\n\n\t\t\t};\n\n\t\t\ttexture.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\t/**\n\t * Computes the size of the given texture and writes the result\n\t * into the target vector. This vector is also returned by the\n\t * method.\n\t *\n\t * If no texture data are available for the compute yet, the method\n\t * returns default size values.\n\t *\n\t * @param {Texture} texture - The texture to compute the size for.\n\t * @param {Vector3} target - The target vector.\n\t * @return {Vector3} The target vector.\n\t */\n\tgetSize( texture, target = _size$3 ) {\n\n\t\tlet image = texture.images ? texture.images[ 0 ] : texture.image;\n\n\t\tif ( image ) {\n\n\t\t\tif ( image.image !== undefined ) image = image.image;\n\n\t\t\ttarget.width = image.width || 1;\n\t\t\ttarget.height = image.height || 1;\n\t\t\ttarget.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );\n\n\t\t} else {\n\n\t\t\ttarget.width = target.height = target.depth = 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the number of mipmap levels for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Number} width - The texture's width.\n\t * @param {Number} height - The texture's height.\n\t * @return {Number} The number of mipmap levels.\n\t */\n\tgetMipLevels( texture, width, height ) {\n\n\t\tlet mipLevelCount;\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tif ( texture.mipmaps ) {\n\n\t\t\t\tmipLevelCount = texture.mipmaps.length;\n\n\t\t\t} else {\n\n\t\t\t\tmipLevelCount = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;\n\n\t\t}\n\n\t\treturn mipLevelCount;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture requires mipmaps.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether mipmaps are required or not.\n\t */\n\tneedsMipmaps( texture ) {\n\n\t\treturn this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is an environment map.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Boolean} Whether the given texture is an environment map or not.\n\t */\n\tisEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t/**\n\t * Frees internal resource when the given texture isn't\n\t * required anymore.\n\t *\n\t * @param {Texture} texture - The texture to destroy.\n\t */\n\t_destroyTexture( texture ) {\n\n\t\tthis.backend.destroySampler( texture );\n\t\tthis.backend.destroyTexture( texture );\n\n\t\tthis.delete( texture );\n\n\t}\n\n}\n\n/**\n * A four-component version of {@link Color} which is internally\n * used by the renderer to represents clear color with alpha as\n * one object.\n *\n * @private\n * @augments Color\n */\nclass Color4 extends Color {\n\n\t/**\n\t * Constructs a new four-component color.\n\t *\n\t * @param {Number|String} r - The red value.\n\t * @param {Number} g - The green value.\n\t * @param {Number} b - The blue value.\n\t * @param {Number} [a=1] - The alpha value.\n\t */\n\tconstructor( r, g, b, a = 1 ) {\n\n\t\tsuper( r, g, b );\n\n\t\tthis.a = a;\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @param {Number|String} r - The red value.\n\t * @param {Number} g - The green value.\n\t * @param {Number} b - The blue value.\n\t * @param {Number} [a=1] - The alpha value.\n\t * @return {Color4} A reference to this object.\n\t */\n\tset( r, g, b, a = 1 ) {\n\n\t\tthis.a = a;\n\n\t\treturn super.set( r, g, b );\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @param {Color4} color - The color to copy.\n\t * @return {Color4} A reference to this object.\n\t */\n\tcopy( color ) {\n\n\t\tif ( color.a !== undefined ) this.a = color.a;\n\n\t\treturn super.copy( color );\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @return {Color4} The cloned color.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b, this.a );\n\n\t}\n\n}\n\n/** @module ParameterNode **/\n\n/**\n * Special version of {@link PropertyNode} which is used for parameters.\n *\n * @augments PropertyNode\n */\nclass ParameterNode extends PropertyNode {\n\n\tstatic get type() {\n\n\t\treturn 'ParameterNode';\n\n\t}\n\n\t/**\n\t * Constructs a new parameter node.\n\t *\n\t * @param {String} nodeType - The type of the node.\n\t * @param {String?} [name=null] - The name of the parameter in the shader.\n\t */\n\tconstructor( nodeType, name = null ) {\n\n\t\tsuper( nodeType, name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isParameterNode = true;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgenerate() {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a parameter node.\n *\n * @function\n * @param {String} type - The type of the node.\n * @param {String?} name - The name of the parameter in the shader.\n * @returns {ParameterNode}\n */\nconst parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );\n\n/** @module StackNode **/\n\n/**\n * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.\n * They are usually needed in cases like `If`, `Else`.\n *\n * @augments Node\n */\nclass StackNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StackNode';\n\n\t}\n\n\t/**\n\t * Constructs a new stack node.\n\t *\n\t * @param {StackNode?} [parent=null] - The parent stack node.\n\t */\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * List of nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * The parent stack node.\n\t\t *\n\t\t * @type {StackNode}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The current conditional node.\n\t\t *\n\t\t * @private\n\t\t * @type {ConditionalNode}\n\t\t * @default null\n\t\t */\n\t\tthis._currentCond = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\t/**\n\t * Adds a node to this stack.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tadd( node ) {\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `if` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = select( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\t/**\n\t * Represent an `elseif` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElseIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = select( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `else` statement in TSL.\n\t *\n\t * @param {Function} method - TSL code which is executed in the `else` case.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder, 'void' );\n\n\t\t}\n\n\t\tsetCurrentStack( previousStack );\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n\t//\n\n\telse( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );\n\t\treturn this.Else( ...params );\n\n\t}\n\n\telseif( ...params ) { // @deprecated, r168\n\n\t\tconsole.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );\n\t\treturn this.ElseIf( ...params );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a stack node.\n *\n * @function\n * @param {StackNode?} [parent=null] - The parent stack node.\n * @returns {StackNode}\n */\nconst stack = /*@__PURE__*/ nodeProxy( StackNode );\n\n/** @module OutputStructNode **/\n\n/**\n * This node can be used to define multiple outputs in a shader programs.\n *\n * @augments Node\n */\nclass OutputStructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'OutputStructNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node. The constructor can be invoked with an\n\t * arbitrary number of nodes representing the members.\n\t *\n\t * @param {...Node} members - A parameter list of nodes.\n\t */\n\tconstructor( ...members ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * An array of nodes which defines the output.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.members = members;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputStructNode = true;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst members = this.members;\n\t\tconst types = [];\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\ttypes.push( members[ i ].getNodeType( builder ) );\n\n\t\t}\n\n\t\tthis.nodeType = builder.getStructTypeFromNode( this, types ).name;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst propertyName = builder.getOutputStructName();\n\t\tconst members = this.members;\n\n\t\tconst structPrefix = propertyName !== '' ? propertyName + '.' : '';\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst snippet = members[ i ].build( builder, output );\n\n\t\t\tbuilder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an output struct node.\n *\n * @function\n * @param {...Node} members - A parameter list of nodes.\n * @returns {OutputStructNode}\n */\nconst outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );\n\n/** @module MRTNode **/\n\n/**\n * Returns the MRT texture index for the given name.\n *\n * @param {Array<Texture>} textures - The textures of a MRT-configured render target.\n * @param {String} name - The name of the MRT texture which index is requested.\n * @return {Number} The texture index.\n */\nfunction getTextureIndex( textures, name ) {\n\n\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\tif ( textures[ i ].name === name ) {\n\n\t\t\treturn i;\n\n\t\t}\n\n\t}\n\n\treturn - 1;\n\n}\n\n/**\n * This node can be used setup a MRT context for rendering. A typical MRT setup for\n * post-processing is shown below:\n * ```js\n * const mrtNode = mrt( {\n *   output: output,\n *   normal: normalView\n * } ) );\n * ```\n * The MRT output is defined as a dictionary.\n *\n * @augments OutputStructNode\n */\nclass MRTNode extends OutputStructNode {\n\n\tstatic get type() {\n\n\t\treturn 'MRTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node.\n\t *\n\t * @param {Object<String, Node>} outputNodes - The MRT outputs.\n\t */\n\tconstructor( outputNodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A dictionary representing the MRT outputs. The key\n\t\t * is the name of the output, the value the node which produces\n\t\t * the output result.\n\t\t *\n\t\t * @type {Object<String, Node>}\n\t\t */\n\t\tthis.outputNodes = outputNodes;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMRTNode = true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the MRT node has an output with the given name.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.\n\t */\n\thas( name ) {\n\n\t\treturn this.outputNodes[ name ] !== undefined;\n\n\t}\n\n\t/**\n\t * Returns the output node for the given name.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @return {Node} The output node.\n\t */\n\tget( name ) {\n\n\t\treturn this.outputNodes[ name ];\n\n\t}\n\n\t/**\n\t * Merges the outputs of the given MRT node with the outputs of this node.\n\t *\n\t * @param {MRTNode} mrtNode - The MRT to merge.\n\t * @return {MRTNode} A new MRT node with merged outputs..\n\t */\n\tmerge( mrtNode ) {\n\n\t\tconst outputs = { ...this.outputNodes, ...mrtNode.outputNodes };\n\n\t\treturn mrt( outputs );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst outputNodes = this.outputNodes;\n\t\tconst mrt = builder.renderer.getRenderTarget();\n\n\t\tconst members = [];\n\n\t\tconst textures = mrt.textures;\n\n\t\tfor ( const name in outputNodes ) {\n\n\t\t\tconst index = getTextureIndex( textures, name );\n\n\t\t\tmembers[ index ] = vec4( outputNodes[ name ] );\n\n\t\t}\n\n\t\tthis.members = members;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a MRT node.\n *\n * @function\n * @param {Object<String, Node>} outputNodes - The MRT outputs.\n * @returns {MRTNode}\n */\nconst mrt = /*@__PURE__*/ nodeProxy( MRTNode );\n\n/** @module Hash **/\n\n/**\n * Generates a hash value in the range `[0, 1]` from the given seed.\n *\n * @method\n * @param {Node<float>} seed - The seed.\n * @return {Node<float>} The hash value.\n */\nconst hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {\n\n\t// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n\tconst state = seed.toUint().mul( 747796405 ).add( 2891336453 );\n\tconst word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );\n\tconst result = word.shiftRight( 22 ).bitXor( word );\n\n\treturn result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)\n\n} );\n\n/** @module MathUtils **/\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * The corners are mapped to `0` and the center to `1`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.\n * @return {Node<float>} The remapped value.\n */\nconst parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces \"s\" shaped curves.\n * @return {Node<float>} The remapped value.\n */\nconst gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} a - First control parameter.\n * @param {Node<float>} b - Second control parameter.\n * @return {Node<float>} The remapped value.\n */\nconst pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );\n\n/**\n * A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @method\n * @param {Node<float>} x - The value to compute the sin for.\n * @param {Node<float>} k - Controls the amount of bounces.\n * @return {Node<float>} The result value.\n */\nconst sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\n\n/** @module TriNoise3D **/\n\nconst tri = /*@__PURE__*/ Fn( ( [ x ] ) => {\n\n\treturn x.fract().sub( .5 ).abs();\n\n} ).setLayout( {\n\tname: 'tri',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {\n\n\treturn vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'tri3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\n/**\n * Generates a noise value from the given position, speed and time parameters.\n *\n * @method\n * @param {Node<vec3>} position - The position.\n * @param {Node<float>} speed - The speed.\n * @param {Node<float>} time - The time.\n * @return {Node<float>} The generated noise.\n */\nconst triNoise3D = /*@__PURE__*/ Fn( ( [ position, speed, time ] ) => {\n\n\tconst p = vec3( position ).toVar();\n\tconst z = float( 1.4 ).toVar();\n\tconst rz = float( 0.0 ).toVar();\n\tconst bp = vec3( p ).toVar();\n\n\tLoop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {\n\n\t\tconst dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();\n\t\tp.addAssign( dg.add( time.mul( float( 0.1 ).mul( speed ) ) ) );\n\t\tbp.mulAssign( 1.8 );\n\t\tz.mulAssign( 1.5 );\n\t\tp.mulAssign( 1.2 );\n\n\t\tconst t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();\n\t\trz.addAssign( t.div( z ) );\n\t\tbp.addAssign( 0.14 );\n\n\t} );\n\n\treturn rz;\n\n} ).setLayout( {\n\tname: 'triNoise3D',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' },\n\t\t{ name: 'speed', type: 'float' },\n\t\t{ name: 'time', type: 'float' }\n\t]\n} );\n\n/** @module FunctionOverloadingNode **/\n\n/**\n * This class allows to define multiple overloaded versions\n * of the same function. Depending on the parameters of the function\n * call, the node picks the best-fit overloaded version.\n *\n * @augments Node\n */\nclass FunctionOverloadingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionOverloadingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n\t * @param {...Node} parametersNodes - A list of parameter nodes.\n\t */\n\tconstructor( functionNodes = [], ...parametersNodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Array of `Fn` function definitions.\n\t\t *\n\t\t * @type {Array<Function>}\n\t\t */\n\t\tthis.functionNodes = functionNodes;\n\n\t\t/**\n\t\t * A list of parameter nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.parametersNodes = parametersNodes;\n\n\t\t/**\n\t\t * The selected overloaded function call.\n\t\t *\n\t\t * @private\n\t\t * @type {ShaderCallNodeInternal}\n\t\t */\n\t\tthis._candidateFnCall = null;\n\n\t\t/**\n\t\t * This node is marked as global.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the function's return type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.functionNodes[ 0 ].shaderNode.layout.type;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst params = this.parametersNodes;\n\n\t\tlet candidateFnCall = this._candidateFnCall;\n\n\t\tif ( candidateFnCall === null ) {\n\n\t\t\tlet candidateFn = null;\n\t\t\tlet candidateScore = - 1;\n\n\t\t\tfor ( const functionNode of this.functionNodes ) {\n\n\t\t\t\tconst shaderNode = functionNode.shaderNode;\n\t\t\t\tconst layout = shaderNode.layout;\n\n\t\t\t\tif ( layout === null ) {\n\n\t\t\t\t\tthrow new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst inputs = layout.inputs;\n\n\t\t\t\tif ( params.length === inputs.length ) {\n\n\t\t\t\t\tlet score = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\t\tconst param = params[ i ];\n\t\t\t\t\t\tconst input = inputs[ i ];\n\n\t\t\t\t\t\tif ( param.getNodeType( builder ) === input.type ) {\n\n\t\t\t\t\t\t\tscore ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscore = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( score > candidateScore ) {\n\n\t\t\t\t\t\tcandidateFn = functionNode;\n\t\t\t\t\t\tcandidateScore = score;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._candidateFnCall = candidateFnCall = candidateFn( ...params );\n\n\t\t}\n\n\t\treturn candidateFnCall;\n\n\t}\n\n}\n\nconst overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );\n\n/**\n * TSL function for creating a function overloading node.\n *\n * @function\n * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n * @returns {FunctionOverloadingNode}\n */\nconst overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );\n\n/** @module Timer **/\n\n/**\n * Represents the elapsed time in seconds.\n *\n * @type {UniformNode<float>}\n */\nconst time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );\n\n/**\n * Represents the delta time in seconds.\n *\n * @type {UniformNode<float>}\n */\nconst deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );\n\n/**\n * Represents the current frame ID.\n *\n * @type {UniformNode<uint>}\n */\nconst frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );\n\n// Deprecated\n\nconst timerLocal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerLocal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\nconst timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerGlobal() is deprecated. Use \"time\" instead.' );\n\treturn time.mul( timeScale );\n\n};\n\nconst timerDelta = ( timeScale = 1 ) => { // @deprecated, r170\n\n\tconsole.warn( 'TSL: timerDelta() is deprecated. Use \"deltaTime\" instead.' );\n\treturn deltaTime.mul( timeScale );\n\n};\n\n/** @module Oscillators **/\n\n/**\n * Generates a sine wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );\n\n/**\n * Generates a square wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSquare = ( t = time ) => t.fract().round();\n\n/**\n * Generates a triangle wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();\n\n/**\n * Generates a sawtooth wave oscillation based on a timer.\n *\n * @method\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSawtooth = ( t = time ) => t.fract();\n\n/** @module UVUtils **/\n\n/**\n * Rotates the given uv coordinates around a center point\n *\n * @method\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} rotation - The rotation defined in radians.\n * @param {Node<vec2>} center - The center of rotation\n * @return {Node<vec2>} The rotated uv coordinates.\n */\nconst rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {\n\n\treturn rotate( uv.sub( center ), rotation ).add( center );\n\n} );\n\n/**\n * Applies a spherical warping effect to the given uv coordinates.\n *\n * @method\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} strength - The strength of the effect.\n * @param {Node<vec2>} center - The center point\n * @return {Node<vec2>} The updated uv coordinates.\n */\nconst spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {\n\n\tconst delta = uv.sub( center );\n\tconst delta2 = delta.dot( delta );\n\tconst delta4 = delta2.mul( delta2 );\n\tconst deltaOffset = delta4.mul( strength );\n\n\treturn uv.add( delta.mul( deltaOffset ) );\n\n} );\n\n/** @module SpriteUtils **/\n\n/**\n * This can be used to achieve a billboarding behavior for flat meshes. That means they are\n * oriented always towards the camera.\n *\n * ```js\n * material.vertexNode = billboarding();\n * ```\n *\n * @method\n * @param {Object} config - The configuration object.\n * @param {Node<vec3>?} [config.position=null] - Can be used to define the vertex positions in world space.\n * @param {Boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.\n * @param {Boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.\n * @return {Node<vec3>} The updated vertex position in clip space.\n */\nconst billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {\n\n\tlet worldMatrix;\n\n\tif ( position !== null ) {\n\n\t\tworldMatrix = modelWorldMatrix.toVar();\n\t\tworldMatrix[ 3 ][ 0 ] = position.x;\n\t\tworldMatrix[ 3 ][ 1 ] = position.y;\n\t\tworldMatrix[ 3 ][ 2 ] = position.z;\n\n\t} else {\n\n\t\tworldMatrix = modelWorldMatrix;\n\n\t}\n\n\tconst modelViewMatrix = cameraViewMatrix.mul( worldMatrix );\n\n\tif ( defined( horizontal ) ) {\n\n\t\tmodelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();\n\t\tmodelViewMatrix[ 0 ][ 1 ] = 0;\n\t\tmodelViewMatrix[ 0 ][ 2 ] = 0;\n\n\t}\n\n\tif ( defined( vertical ) ) {\n\n\t\tmodelViewMatrix[ 1 ][ 0 ] = 0;\n\t\tmodelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();\n\t\tmodelViewMatrix[ 1 ][ 2 ] = 0;\n\n\t}\n\n\tmodelViewMatrix[ 2 ][ 0 ] = 0;\n\tmodelViewMatrix[ 2 ][ 1 ] = 0;\n\tmodelViewMatrix[ 2 ][ 2 ] = 1;\n\n\treturn cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\n} );\n\n/** @module ViewportUtils **/\n\n/**\n * A special version of a screen uv function that involves a depth comparison\n * when computing the final uvs. The function mitigates visual errors when\n * using viewport texture nodes for refraction purposes. Without this function\n * objects in front of a refractive surface might appear on the refractive surface\n * which is incorrect.\n *\n * @method\n * @param {Node<vec2>?} uv - Optional uv coordinates. By default `screenUV` is used.\n * @return {Node<vec2>} The update uv coordinates.\n */\nconst viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {\n\n\tconst depth = linearDepth();\n\tconst depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );\n\tconst finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );\n\n\treturn finalUV;\n\n} );\n\n/** @module SpriteSheetUVNode **/\n\n/**\n * Can be used to compute texture coordinates for animated sprite sheets.\n *\n * ```js\n * const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );\n *\n * material.colorNode = texture( spriteSheet, uvNode );\n * ```\n *\n * @augments Node\n */\nclass SpriteSheetUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteSheetUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite sheet uv node.\n\t *\n\t * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n\t * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n\t * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n\t */\n\tconstructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The node that defines the number of sprites in the x and y direction (e.g 6x6).\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.countNode = countNode;\n\n\t\t/**\n\t\t * The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * The node that defines the current frame/sprite.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { frameNode, uvNode, countNode } = this;\n\n\t\tconst { width, height } = countNode;\n\n\t\tconst frameNum = frameNode.mod( width.mul( height ) ).floor();\n\n\t\tconst column = frameNum.mod( width );\n\t\tconst row = height.sub( frameNum.add( 1 ).div( width ).ceil() );\n\n\t\tconst scale = countNode.reciprocal();\n\t\tconst uvFrameOffset = vec2( column, row );\n\n\t\treturn uvNode.add( uvFrameOffset ).mul( scale );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a sprite sheet uv node.\n *\n * @function\n * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n * @returns {SpriteSheetUVNode}\n */\nconst spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );\n\n/** @module TriplanarTexturesNode **/\n\n/**\n * Can be used for triplanar texture mapping.\n *\n * ```js\n * material.colorNode = triplanarTexture( texture( diffuseMap ) );\n * ```\n *\n * @augments Node\n */\nclass TriplanarTexturesNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TriplanarTexturesNode';\n\n\t}\n\n\t/**\n\t * Constructs a new triplanar textures node.\n\t *\n\t * @param {Node} textureXNode - First texture node.\n\t * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n\t * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n\t * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n\t * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n\t * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n\t */\n\tconstructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * First texture node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.textureXNode = textureXNode;\n\n\t\t/**\n\t\t * Second texture node. When not set, the shader will sample from `textureXNode` instead.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.textureYNode = textureYNode;\n\n\t\t/**\n\t\t * Third texture node. When not set, the shader will sample from `textureXNode` instead.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.textureZNode = textureZNode;\n\n\t\t/**\n\t\t * The scale node.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t * @default float(1)\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * Vertex positions in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t * @default positionLocal\n\t\t */\n\t\tthis.positionNode = positionNode;\n\n\t\t/**\n\t\t * Normals in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t * @default normalLocal\n\t\t */\n\t\tthis.normalNode = normalNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;\n\n\t\t// Ref: https://github.com/keijiro/StandardTriplanar\n\n\t\t// Blending factor of triplanar mapping\n\t\tlet bf = normalNode.abs().normalize();\n\t\tbf = bf.div( bf.dot( vec3( 1.0 ) ) );\n\n\t\t// Triplanar mapping\n\t\tconst tx = positionNode.yz.mul( scaleNode );\n\t\tconst ty = positionNode.zx.mul( scaleNode );\n\t\tconst tz = positionNode.xy.mul( scaleNode );\n\n\t\t// Base color\n\t\tconst textureX = textureXNode.value;\n\t\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\t\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\t\tconst cx = texture( textureX, tx ).mul( bf.x );\n\t\tconst cy = texture( textureY, ty ).mul( bf.y );\n\t\tconst cz = texture( textureZ, tz ).mul( bf.z );\n\n\t\treturn add( cx, cy, cz );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n * @returns {TriplanarTexturesNode}\n */\nconst triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {Node<float>?} [scaleNode=float(1)] - The scale node.\n * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.\n * @returns {TriplanarTexturesNode}\n */\nconst triplanarTexture = ( ...params ) => triplanarTextures( ...params );\n\n/** @module ReflectorNode **/\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, - 1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size$2 = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n\n_defaultRT.depthTexture = new DepthTexture( 1, 1 );\n\nlet _inReflector = false;\n\n/**\n * This node can be used to implement mirror-like flat reflective surfaces.\n *\n * ```js\n * const groundReflector = reflector();\n * material.colorNode = groundReflector;\n *\n * const plane = new Mesh( geometry, material );\n * plane.add( groundReflector.target );\n * ```\n *\n * @augments module:TextureNode~TextureNode\n */\nclass ReflectorNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector node.\n\t *\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {Number} [parameters.resolution=1] - The resolution scale.\n\t * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n\t * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters.defaultTexture || _defaultRT.texture, _defaultUV );\n\n\t\t/**\n\t\t * A reference to the internal reflector base node which holds the actual implementation.\n\t\t *\n\t\t * @private\n\t\t * @type {ReflectorBaseNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );\n\n\t\t/**\n\t\t * A reference to the internal depth node.\n\t\t *\n\t\t * @private\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis._depthNode = null;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\t/**\n\t * A reference to the internal reflector node.\n\t *\n\t * @type {ReflectorBaseNode}\n\t */\n\tget reflector() {\n\n\t\treturn this._reflectorBaseNode;\n\n\t}\n\n\t/**\n\t * A reference to 3D object the reflector is linked to.\n\t *\n\t * @type {Object3D}\n\t */\n\tget target() {\n\n\t\treturn this._reflectorBaseNode.target;\n\n\t}\n\n\t/**\n\t * Returns a node representing the mirror's depth. That can be used\n\t * to implement more advanced reflection effects like distance attenuation.\n\t *\n\t * @return {Node} The depth node.\n\t */\n\tgetDepthNode() {\n\n\t\tif ( this._depthNode === null ) {\n\n\t\t\tif ( this._reflectorBaseNode.depth !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );\n\n\t\t\t}\n\n\t\t\tthis._depthNode = nodeObject( new ReflectorNode( {\n\t\t\t\tdefaultTexture: _defaultRT.depthTexture,\n\t\t\t\treflector: this._reflectorBaseNode\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn this._depthNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// ignore if used in post-processing\n\t\tif ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst texture = new this.constructor( this.reflectorNode );\n\t\ttexture._reflectorBaseNode = this._reflectorBaseNode;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Holds the actual implementation of the reflector.\n *\n * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented\n * in `ReflectorNode`, see #29619.\n *\n * @private\n * @augments Node\n */\nclass ReflectorBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector base node.\n\t *\n\t * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {Number} [parameters.resolution=1] - The resolution scale.\n\t * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t */\n\tconstructor( textureNode, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolution = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true,\n\t\t\tdepth = false\n\t\t} = parameters;\n\n\t\t/**\n\t\t * Represents the rendered reflections as a texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The 3D object the reflector is linked to.\n\t\t *\n\t\t * @type {Object3D}\n\t\t * @default {new Object3D()}\n\t\t */\n\t\tthis.target = target;\n\n\t\t/**\n\t\t * The resolution scale.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default {1}\n\t\t */\n\t\tthis.resolution = resolution;\n\n\t\t/**\n\t\t * Whether mipmaps should be generated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.generateMipmaps = generateMipmaps;\n\n\t\t/**\n\t\t * Whether reflectors can render other reflector nodes or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default {true}\n\t\t */\n\t\tthis.bounces = bounces;\n\n\t\t/**\n\t\t * Whether depth data should be generated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}\n\t\t * is `true`. Otherwise it's `NodeUpdateType.FRAME`.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * Weak map for managing virtual cameras.\n\t\t *\n\t\t * @type {WeakMap<Camera, Camera>}\n\t\t */\n\t\tthis.virtualCameras = new WeakMap();\n\n\t\t/**\n\t\t * Weak map for managing render targets.\n\t\t *\n\t\t * @type {WeakMap<Camera, RenderTarget>}\n\t\t */\n\t\tthis.renderTargets = new WeakMap();\n\n\t}\n\n\t/**\n\t * Updates the resolution of the internal render target.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target to resize.\n\t * @param {Renderer} renderer - The renderer that is used to determine the new size.\n\t */\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolution;\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\trenderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Returns a virtual camera for the given camera. The virtual camera is used to\n\t * render the scene from the reflector's view so correct reflections can be produced.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {Camera} The corresponding virtual camera.\n\t */\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\t/**\n\t * Returns a render target for the given camera. The reflections are rendered\n\t * into this render target.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {RenderTarget} The render target.\n\t */\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t\trenderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tif ( this.depth === true ) {\n\n\t\t\t\trenderTarget.depthTexture = new DepthTexture();\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( _view.dot( _normal ) > 0 ) return;\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, - 1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = - 1.0;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.textureNode.value = renderTarget.texture;\n\n\t\tif ( this.depth === true ) {\n\n\t\t\tthis.textureNode.getDepthNode().value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst currentAutoClear = renderer.autoClear;\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reflector node.\n *\n * @function\n * @param {Object} [parameters={}] - An object holding configuration parameters.\n * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n * @param {Number} [parameters.resolution=1] - The resolution scale.\n * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n * @returns {ReflectorNode}\n */\nconst reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nconst _camera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n/**\n * The purpose of this special geometry is to fill the entire viewport with a single triangle.\n *\n * Reference: {@link https://github.com/mrdoob/three.js/pull/21358}\n *\n * @private\n * @augments BufferGeometry\n */\nclass QuadGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new quad geometry.\n\t *\n\t * @param {Boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.\n\t */\n\tconstructor( flipY = false ) {\n\n\t\tsuper();\n\n\t\tconst uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\n\t}\n\n}\n\nconst _geometry = /*@__PURE__*/ new QuadGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single quad mesh for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * @augments BufferGeometry\n */\nclass QuadMesh extends Mesh {\n\n\t/**\n\t * Constructs a new quad mesh.\n\t *\n\t * @param {Material?} [material=null] - The material to render the quad mesh with.\n\t */\n\tconstructor( material = null ) {\n\n\t\tsuper( _geometry, material );\n\n\t\t/**\n\t\t * The camera to render the quad mesh with.\n\t\t *\n\t\t * @type {OrthographicCamera}\n\t\t * @readonly\n\t\t */\n\t\tthis.camera = _camera;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isQuadMesh = true;\n\n\t}\n\n\t/**\n\t * Async version of `render()`.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( renderer ) {\n\n\t\treturn renderer.renderAsync( this, _camera );\n\n\t}\n\n\t/**\n\t * Renders the quad mesh\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this, _camera );\n\n\t}\n\n}\n\n/** @module RTTNode **/\n\nconst _size$1 = /*@__PURE__*/ new Vector2();\n\n/**\n * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).\n * This module is especially relevant in context of post processing where certain nodes require\n * texture input for their effects. With the helper function `convertToTexture()` which is based\n * on this module, the node system can automatically ensure texture input if required.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass RTTNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'RTTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new RTT node.\n\t *\n\t * @param {Node} node - The node to render a texture with.\n\t * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n\t * @param {Number?} [height=null] - The height of the internal render target.\n\t * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n\t */\n\tconstructor( node, width = null, height = null, options = { type: HalfFloatType } ) {\n\n\t\tconst renderTarget = new RenderTarget( width, height, options );\n\n\t\tsuper( renderTarget.texture, uv() );\n\n\t\t/**\n\t\t * The node to render a texture with.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The width of the internal render target.\n\t\t * If not width is applied, the render target is automatically resized.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.width = width;\n\n\t\t/**\n\t\t * The height of the internal render target.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.height = height;\n\n\t\t/**\n\t\t * The pixel ratio\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.pixelRatio = 1;\n\n\t\t/**\n\t\t * The render target\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * Whether the texture requires an update or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.textureNeedsUpdate = true;\n\n\t\t/**\n\t\t * Whether the texture should automatically be updated or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoUpdate = true;\n\n\t\t/**\n\t\t * The node which is used with the quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis._rttNode = null;\n\n\t\t/**\n\t\t * The internal quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh( new NodeMaterial() );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link RTTNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Whether the internal render target should automatically be resized or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget autoSize() {\n\n\t\treturn this.width === null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._rttNode = this.node.context( builder.getSharedContext() );\n\t\tthis._quadMesh.material.name = 'RTT';\n\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Sets the size of the internal render target\n\t *\n\t * @param {Number} width - The width to set.\n\t * @param {Number} height - The width to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tconst effectiveWidth = width * this.pixelRatio;\n\t\tconst effectiveHeight = height * this.pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tthis.textureNeedsUpdate = true;\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio. This will also resize the render target.\n\t *\n\t * @param {Number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis.pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this.width, this.height );\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\tif ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;\n\n\t\tthis.textureNeedsUpdate = false;\n\n\t\t//\n\n\t\tif ( this.autoSize === true ) {\n\n\t\t\tthis.pixelRatio = renderer.getPixelRatio();\n\n\t\t\tconst size = renderer.getSize( _size$1 );\n\n\t\t\tthis.setSize( size.width, size.height );\n\n\t\t}\n\n\t\t//\n\n\t\tthis._quadMesh.material.fragmentNode = this._rttNode;\n\n\t\t//\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new TextureNode( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.referenceNode = this;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a RTT node.\n *\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {Number?} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );\n\n/**\n * TSL function for converting nodes to textures nodes.\n *\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {Number?} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst convertToTexture = ( node, ...params ) => {\n\n\tif ( node.isTextureNode ) return node;\n\tif ( node.isPassNode ) return node.getTextureNode();\n\n\treturn rtt( node, ...params );\n\n};\n\n/** @module PostProcessingUtils **/\n\n/**\n * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n * depth value and the camera's inverse projection matrix.\n *\n * @method\n * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.\n * @param {Node<float>} depth - The fragment's depth value.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The fragments position in view space.\n */\nconst getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {\n\n\tlet clipSpacePosition;\n\n\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\tscreenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );\n\t\tclipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );\n\n\t} else {\n\n\t\tclipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );\n\n\t}\n\n\tconst viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );\n\n\treturn viewSpacePosition.xyz.div( viewSpacePosition.w );\n\n} );\n\n/**\n * Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n * and the camera's projection matrix\n *\n * @method\n * @param {Node<vec3>} viewPosition - The fragments position in view space.\n * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.\n * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.\n */\nconst getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {\n\n\tconst sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );\n\tconst sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();\n\treturn vec2( sampleUv.x, sampleUv.y.oneMinus() );\n\n} );\n\n/**\n * Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n * target is available or if flat surface normals are required.\n *\n * @method\n * @param {Node<vec2>} uv - The texture coordinate.\n * @param {DepthTexture} depthTexture - The depth texture.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The computed normal vector.\n */\nconst getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {\n\n\tconst size = textureSize( textureLoad( depthTexture ) );\n\tconst p = ivec2( uv.mul( size ) ).toVar();\n\n\tconst c0 = textureLoad( depthTexture, p ).toVar();\n\n\tconst l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();\n\tconst l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();\n\tconst r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();\n\tconst r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();\n\tconst b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();\n\tconst b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();\n\tconst t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();\n\tconst t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();\n\n\tconst dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();\n\tconst dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();\n\tconst db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();\n\tconst dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();\n\n\tconst ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();\n\n\tconst dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );\n\tconst dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );\n\n\treturn normalize( cross( dpdx, dpdy ) );\n\n} );\n\n/**\n * This special type of instanced buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link module:StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments InstancedBufferAttribute\n */\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n\n\t/**\n\t * Constructs a new storage instanced buffer attribute.\n\t *\n\t * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n\t * The subsequent parameters are then obsolete.\n\t * @param {Number} itemSize - The item size.\n\t * @param {TypedArray.contructor} [typeClass=Float32Array] - A typed array constructor.\n\t */\n\tconstructor( count, itemSize, typeClass = Float32Array ) {\n\n\t\tconst array = ArrayBuffer.isView( count ) ? count : new typeClass( count * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageInstancedBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link module:StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments BufferAttribute\n */\nclass StorageBufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new storage buffer attribute.\n\t *\n\t * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n\t * The subsequent parameters are then obsolete.\n\t * @param {Number} itemSize - The item size.\n\t * @param {TypedArray.contructor} [typeClass=Float32Array] - A typed array constructor.\n\t */\n\tconstructor( count, itemSize, typeClass = Float32Array ) {\n\n\t\tconst array = ArrayBuffer.isView( count ) ? count : new typeClass( count * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferAttribute = true;\n\n\t}\n\n}\n\n/** @module StorageArrayElementNode **/\n\n/**\n * This class enables element access on instances of {@link StorageBufferNode}.\n * In most cases, it is indirectly used when accessing elements with the\n * {@link StorageBufferNode#element} method.\n *\n * ```js\n * const position = positionStorage.element( instanceIndex );\n * ```\n *\n * @augments ArrayElementNode\n */\nclass StorageArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs storage buffer element node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( storageBufferNode, indexNode ) {\n\n\t\tsuper( storageBufferNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * The storage buffer node.\n\t *\n\t * @param {Node} value\n\t * @type {StorageBufferNode}\n\t */\n\tset storageBufferNode( value ) {\n\n\t\tthis.node = value;\n\n\t}\n\n\tget storageBufferNode() {\n\n\t\treturn this.node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true ) {\n\n\t\t\t\tbuilder.setupPBO( this.node );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\n\t\t//\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {\n\n\t\t\t\tsnippet = builder.generatePBO( this );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = this.node.build( builder );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder );\n\n\t\t}\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage element node.\n *\n * @function\n * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n * @param {Node} indexNode - The index node that defines the element access.\n * @returns {StorageArrayElementNode}\n */\nconst storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );\n\n/** @module StorageBufferNode **/\n\n/**\n * This node is used in context of compute shaders and allows to define a\n * storage buffer for data. A typical workflow is to create instances of\n * this node with the convenience functions `attributeArray()` or `instancedArray()`,\n * setup up a compute shader that writes into the buffers and then convert\n * the storage buffers to attribute nodes for rendering.\n *\n * ```js\n * const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node\n *\n * const computeInit = Fn( () => { // the compute shader\n *\n * \tconst position = positionBuffer.element( instanceIndex );\n *\n * \t// compute position data\n *\n * \tposition.x = 1;\n * \tposition.y = 1;\n * \tposition.z = 1;\n *\n * } )().compute( particleCount );\n *\n * const particleMaterial = new THREE.SpriteNodeMaterial();\n * particleMaterial.positionNode = positionBuffer.toAttribute();\n *\n * renderer.computeAsync( computeInit );\n *\n * ```\n *\n * @augments BufferNode\n */\nclass StorageBufferNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageBufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage buffer node.\n\t *\n\t * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n\t * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {Number} [bufferCount=0] - The buffer count.\n\t */\n\tconstructor( value, bufferType = null, bufferCount = 0 ) {\n\n\t\tif ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {\n\n\t\t\tbufferType = getTypeFromLength( value.itemSize );\n\t\t\tbufferCount = value.count;\n\n\t\t}\n\n\t\tsuper( value, bufferType, bufferCount );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferNode = true;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'readWrite'\n\t\t */\n\t\tthis.access = NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * Whether the node is atomic or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isAtomic = false;\n\n\t\t/**\n\t\t * Whether the node represents a PBO or not.\n\t\t * Only relevant for WebGL.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isPBO = false;\n\n\t\t/**\n\t\t * A reference to the internal buffer attribute node.\n\t\t *\n\t\t * @type {BufferAttributeNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._attribute = null;\n\n\t\t/**\n\t\t * A reference to the internal varying node.\n\t\t *\n\t\t * @type {VaryingNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._varying = null;\n\n\t\t/**\n\t\t * `StorageBufferNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {\n\n\t\t\t// TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n\t\t\tif ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;\n\t\t\telse value.isStorageBufferAttribute = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the buffer data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferCount === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n\n\t}\n\n\t/**\n\t * Enables element access with the given index node.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {StorageArrayElementNode} A node representing the element access.\n\t */\n\telement( indexNode ) {\n\n\t\treturn storageElement( this, indexNode );\n\n\t}\n\n\t/**\n\t * Defines whether this node is a PBO or not. Only relevant for WebGL.\n\t *\n\t * @param {Boolean} value - The value so set.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetPBO( value ) {\n\n\t\tthis.isPBO = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the `isPBO` value.\n\t *\n\t * @return {Boolean} Whether the node represents a PBO or not.\n\t */\n\tgetPBO() {\n\n\t\treturn this.isPBO;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {String} value - The node access.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Defines whether the node is atomic or not.\n\t *\n\t * @param {Boolean} value - The atomic flag.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAtomic( value ) {\n\n\t\tthis.isAtomic = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for making this node atomic.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoAtomic() {\n\n\t\treturn this.setAtomic( true );\n\n\t}\n\n\t/**\n\t * Returns attribute data for this storage buffer node.\n\t *\n\t * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.\n\t */\n\tgetAttributeData() {\n\n\t\tif ( this._attribute === null ) {\n\n\t\t\tthis._attribute = bufferAttribute( this.value );\n\t\t\tthis._varying = varying( this._attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tattribute: this._attribute,\n\t\t\tvarying: this._varying\n\t\t};\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type from the availability of storage buffers\n\t * and the attribute data.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.getNodeType( builder );\n\n\t\t}\n\n\t\tconst { attribute } = this.getAttributeData();\n\n\t\treturn attribute.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage buffer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.generate( builder );\n\n\t\t}\n\n\t\tconst { attribute, varying } = this.getAttributeData();\n\n\t\tconst output = varying.build( builder );\n\n\t\tbuilder.registerTransform( output, attribute );\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage buffer node.\n *\n * @function\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {Number} [count=0] - The buffer count.\n * @returns {StorageBufferNode}\n */\nconst storage = ( value, type = null, count = 0 ) => nodeObject( new StorageBufferNode( value, type, count ) );\n\nconst storageObject = ( value, type, count ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.' );\n\n\treturn storage( value, type, count ).setPBO( true );\n\n};\n\n/** @module Arrays **/\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.\n *\n * @function\n * @param {Number} count - The data count.\n * @param {String} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst attributeArray = ( count, type = 'float' ) => {\n\n\tconst itemSize = getLengthFromType( type );\n\tconst typedArray = getTypedArrayFromType( type );\n\n\tconst buffer = new StorageBufferAttribute( count, itemSize, typedArray );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.\n *\n * @function\n * @param {Number} count - The data count.\n * @param {String} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst instancedArray = ( count, type = 'float' ) => {\n\n\tconst itemSize = getLengthFromType( type );\n\tconst typedArray = getTypedArrayFromType( type );\n\n\tconst buffer = new StorageInstancedBufferAttribute( count, itemSize, typedArray );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n/** @module VertexColorNode **/\n\n/**\n * An attribute node for representing vertex colors.\n *\n * @augments module:AttributeNode~AttributeNode\n */\nclass VertexColorNode extends AttributeNode {\n\n\tstatic get type() {\n\n\t\treturn 'VertexColorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t *\n\t * @param {Number} [index=0] - The attribute index.\n\t */\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVertexColorNode = true;\n\n\t\t/**\n\t\t * The attribute index to enable more than one sets of vertex colors.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.index = index;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation by honoring the attribute index.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'color' + ( index > 0 ? index : '' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tlet result;\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tresult = super.generate( builder );\n\n\t\t} else {\n\n\t\t\t// Vertex color fallback should be white\n\t\t\tresult = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @function\n * @param {Number} index - The attribute index.\n * @returns {VertexColorNode}\n */\nconst vertexColor = ( index ) => nodeObject( new VertexColorNode( index ) );\n\n/** @module PointUVNode **/\n\n/**\n * A node for representing the uv coordinates of points.\n *\n * Can only be used with a WebGL backend. In WebGPU, point\n * primitives always have the size of one pixel and can thus\n * can't be used as sprite-like objects that display textures.\n *\n * @augments Node\n */\nclass PointUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PointUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point uv node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointUVNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\n/**\n * TSL object that represents the uv coordinates of points.\n *\n * @type {PointUVNode}\n */\nconst pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\n/** @module SceneNode **/\n\n/**\n * This module allows access to a collection of scene properties. The following predefined TSL objects\n * are available for easier use:\n *\n * - `backgroundBlurriness`: A node that represents the scene's background blurriness.\n * - `backgroundIntensity`: A node that represents the scene's background intensity.\n * - `backgroundRotation`: A node that represents the scene's background rotation.\n *\n * @augments Node\n */\nclass SceneNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SceneNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scene node.\n\t *\n\t * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.\n\t * @param {Scene?} [scene=null] - A reference to the scene.\n\t */\n\tconstructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines the type of scene property that is accessed.\n\t\t *\n\t\t * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene that is going to be accessed.\n\t\t *\n\t\t * @type {Scene?}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = scene;\n\n\t}\n\n\t/**\n\t * Depending on the scope, the method returns a different type of node that represents\n\t * the respective scene property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scene = this.scene !== null ? this.scene : builder.scene;\n\n\t\tlet output;\n\n\t\tif ( scope === SceneNode.BACKGROUND_BLURRINESS ) {\n\n\t\t\toutput = reference( 'backgroundBlurriness', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {\n\n\t\t\toutput = reference( 'backgroundIntensity', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {\n\n\t\t\toutput = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\t\t\tconst background = scene.background;\n\n\t\t\t\tif ( background !== null && background.isTexture && background.mapping !== UVMapping ) {\n\n\t\t\t\t\t_e1.copy( scene.backgroundRotation );\n\n\t\t\t\t\t// accommodate left-handed frame\n\t\t\t\t\t_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;\n\n\t\t\t\t\t_m1.makeRotationFromEuler( _e1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_m1.identity();\n\n\t\t\t\t}\n\n\t\t\t\treturn _m1;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.SceneNode: Unknown scope:', scope );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\n\n/**\n * TSL object that represents the scene's background blurriness.\n *\n * @type {SceneNode}\n */\nconst backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );\n\n/**\n * TSL object that represents the scene's background intensity.\n *\n * @type {SceneNode}\n */\nconst backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );\n\n/**\n * TSL object that represents the scene's background rotation.\n *\n * @type {SceneNode}\n */\nconst backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );\n\n/** @module StorageTextureNode **/\n\n/**\n * This special version of a texture node can be used to\n * write data into a storage texture with a compute shader.\n *\n * ```js\n * const storageTexture = new THREE.StorageTexture( width, height );\n *\n * const computeTexture = Fn( ( { storageTexture } ) => {\n *\n * \tconst posX = instanceIndex.modInt( width );\n * \tconst posY = instanceIndex.div( width );\n * \tconst indexUV = uvec2( posX, posY );\n *\n * \t// generate RGB values\n *\n * \tconst r = 1;\n * \tconst g = 1;\n * \tconst b = 1;\n *\n * \ttextureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();\n *\n * } );\n *\n * const computeNode = computeTexture( { storageTexture } ).compute( width * height );\n * renderer.computeAsync( computeNode );\n * ```\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass StorageTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage texture node.\n\t *\n\t * @param {StorageTexture} value - The storage texture.\n\t * @param {Node<vec2|vec3>} uvNode - The uv node.\n\t * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n\t */\n\tconstructor( value, uvNode, storeNode = null ) {\n\n\t\tsuper( value, uvNode );\n\n\t\t/**\n\t\t * The value node that should be stored in the texture.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.storeNode = storeNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTextureNode = true;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'writeOnly'\n\t\t */\n\t\tthis.access = NodeAccess.WRITE_ONLY;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'storageTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageTexture';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.storeNode = this.storeNode;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {String} value - The node access.\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the stroge node. If no `storeNode`\n\t * is defined, the texture node is generated as normal texture.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {String} output - The current output.\n\t * @return {String} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tsnippet = this.generateStore( builder );\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read/write node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadWrite() {\n\n\t\treturn this.setAccess( NodeAccess.READ_WRITE );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a write-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoWriteOnly() {\n\n\t\treturn this.setAccess( NodeAccess.WRITE_ONLY );\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tgenerateStore( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst { uvNode, storeNode } = properties;\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\t\tconst uvSnippet = uvNode.build( builder, 'uvec2' );\n\t\tconst storeSnippet = storeNode.build( builder, 'vec4' );\n\n\t\tconst snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );\n\n\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage texture node.\n *\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );\n\n\n/**\n * TODO: Explain difference to `storageTexture()`.\n *\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst textureStore = ( value, uvNode, storeNode ) => {\n\n\tconst node = storageTexture( value, uvNode, storeNode );\n\n\tif ( storeNode !== null ) node.append();\n\n\treturn node;\n\n};\n\n/** @module UserDataNode **/\n\n/**\n * A special type of reference node that allows to link values in\n * `userData` fields to node objects.\n * ```js\n * sprite.userData.rotation = 1; // stores individual rotation per sprite\n *\n * const material = new THREE.SpriteNodeMaterial();\n * material.rotationNode = userData( 'rotation', 'float' );\n * ```\n * Since `UserDataNode` is extended from {@link module:ReferenceNode~ReferenceNode}, the node value\n * will automatically be updated when the `rotation` user data field changes.\n *\n * @augments module:ReferenceNode~ReferenceNode\n */\nclass UserDataNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'UserDataNode';\n\n\t}\n\n\t/**\n\t * Constructs a new user data node.\n\t *\n\t * @param {String} property - The property name that should be referenced by the node.\n\t * @param {String} inputType - The node data type of the reference.\n\t * @param {Object?} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n\t */\n\tconstructor( property, inputType, userData = null ) {\n\n\t\tsuper( property, inputType, userData );\n\n\t\t/**\n\t\t * A reference to the `userData` object. If not provided, the `userData`\n\t\t * property of the 3D object that uses the node material is evaluated.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.userData = userData;\n\n\t}\n\n\t/**\n\t * Overwritten to make sure {@link module:ReferenceNode~ReferenceNode#reference} points to the correct\n\t * `userData` field.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.\n\t * @return {Object} A reference to the `userData` field.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.userData !== null ? this.userData : state.object.userData;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a user data node.\n *\n * @function\n * @param {String} name - The property name that should be referenced by the node.\n * @param {String} inputType - The node data type of the reference.\n * @param {Object?} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n * @returns {UserDataNode}\n */\nconst userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\n\nconst _objectData = new WeakMap();\n\n/** @module VelocityNode **/\n\n/**\n * A node for representing motion or velocity vectors. Foundation\n * for advanced post processing effects like motion blur or TRAA.\n *\n * The node keeps track of the model, view and projection matrices\n * of the previous frame and uses them to compute offsets in NDC space.\n * These offsets represent the final velocity.\n *\n * @augments TempNode\n */\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t *\n\t * @param {Number} [index=0] - The attribute index.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The current projection matrix.\n\t\t *\n\t\t * @type {Matrix4?}\n\t\t * @default null\n\t\t */\n\t\tthis.projectionMatrix = null;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes are updated per object.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes save data after the update.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Uniform node representing the previous model matrix in world space.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * Uniform node representing the previous projection matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the previous view matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\t/**\n\t * Sets the given projection matrix.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix to set.\n\t */\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\t/**\n\t * Updates velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten to updated velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\t/**\n\t * Implements the velocity computation based on the previous and current vertex data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec2>} The motion vector.\n\t */\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\n\t}\n\n\treturn matrix;\n\n}\n\n/**\n * TSL object that represents the velocity of a render pass.\n *\n * @type {VelocityNode}\n */\nconst velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n\nconst blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendBurn',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( base.div( blend.oneMinus() ), 1.0 );\n\n} ).setLayout( {\n\tname: 'blendDodge',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn base.oneMinus().mul( blend.oneMinus() ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendScreen',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );\n\n} ).setLayout( {\n\tname: 'blendOverlay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\nconst blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\tconst outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );\n\n\treturn vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );\n\n} ).setLayout( {\n\tname: 'blendColor',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec4' },\n\t\t{ name: 'blend', type: 'vec4' }\n\t]\n} );\n\n// deprecated\n\nconst burn = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.' );\n\treturn blendBurn( params );\n\n};\n\nconst dodge = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.' );\n\treturn blendDodge( params );\n\n};\n\nconst screen = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.' );\n\treturn blendScreen( params );\n\n};\n\nconst overlay = ( ...params ) => { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.' );\n\treturn blendOverlay( params );\n\n};\n\n/** @module ColorAdjustment **/\n\n/**\n * Computes a grayscale value for the given RGB color value.\n *\n * @method\n * @param {Node<vec3>} color - The color value to compute the grayscale for.\n * @return {Node<vec3>} The grayscale color.\n */\nconst grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\treturn luminance( color.rgb );\n\n} );\n\n/**\n * Super-saturates or desaturates the given RGB color.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.\n * @return {Node<vec3>} The saturated color.\n */\nconst saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\treturn adjustment.mix( luminance( color.rgb ), color.rgb );\n\n} );\n\n/**\n * Selectively enhance the intensity of less saturated RGB colors. Can result\n * in a more natural and visually appealing image with enhanced color depth\n * compared to {@link ColorAdjustment#saturation}.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.\n * @return {Node<vec3>} The updated color.\n */\nconst vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );\n\n\treturn mix( color.rgb, mx, amt );\n\n} );\n\n/**\n * Updates the hue component of the given RGB color while preserving its luminance and saturation.\n *\n * @method\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.\n * @return {Node<vec3>} The updated color.\n */\nconst hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst k = vec3( 0.57735, 0.57735, 0.57735 );\n\n\tconst cosAngle = adjustment.cos();\n\n\treturn vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );\n\n} );\n\n/**\n * Computes the luminance for the given RGB color value.\n *\n * @method\n * @param {Node<vec3>} color - The color value to compute the luminance for.\n * @param {Node<vec3>?} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.\n * @return {Node<vec3>} The luminance.\n */\nconst luminance = (\n\tcolor,\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )\n) => dot( color, luminanceCoefficients );\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @method\n * @param {Node<vec4>} color Input (-Infinity < input < +Infinity)\n * @param {Node<vec3>} slope Slope (0  slope < +Infinity)\n * @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {Node<vec3>} power Power (0 < power < +Infinity)\n * @param {Node<float>} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)\n * @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return {Node<vec4>} Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - {@link https://blender.stackexchange.com/a/55239/43930}\n * - {@link https://docs.acescentral.com/specifications/acescc/}\n */\nconst cdl = /*@__PURE__*/ Fn( ( [\n\tcolor,\n\tslope = vec3( 1 ),\n\toffset = vec3( 0 ),\n\tpower = vec3( 1 ),\n\tsaturation = float( 1 ),\n\t// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )\n] ) => {\n\n\t// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n\t// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n\t// values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n\tconst luma = color.rgb.dot( vec3( luminanceCoefficients ) );\n\n\tconst v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();\n\tconst pv = v.pow( power ).toVar();\n\n\tIf( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line\n\tIf( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line\n\tIf( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line\n\n\tv.assign( luma.add( v.sub( luma ).mul( saturation ) ) );\n\n\treturn vec4( v.rgb, color.a );\n\n} );\n\n/** @module PosterizeNode **/\n\n/**\n * Represents a posterize effect which reduces the number of colors\n * in an image, resulting in a more blocky and stylized appearance.\n *\n * @augments TempNode\n */\nclass PosterizeNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PosterizeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new posterize node.\n\t *\n\t * @param {Node} sourceNode - The input color.\n\t * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n\t */\n\tconstructor( sourceNode, stepsNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The input color.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.stepsNode = stepsNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { sourceNode, stepsNode } = this;\n\n\t\treturn sourceNode.mul( stepsNode ).floor().div( stepsNode );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @function\n * @param {Node} sourceNode - The input color.\n * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n * @returns {PosterizeNode}\n */\nconst posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );\n\n/** @module PassNode **/\n\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * Represents the texture of a pass node.\n *\n * @augments module:TextureNode~TextureNode\n */\nclass PassTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {Texture} texture - The output texture.\n\t */\n\tconstructor( passNode, texture ) {\n\n\t\tsuper( texture );\n\n\t\t/**\n\t\t * A reference to the pass node.\n\t\t *\n\t\t * @type {PassNode}\n\t\t */\n\t\tthis.passNode = passNode;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.object.isQuadMesh ) this.passNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.value );\n\n\t}\n\n}\n\n/**\n * An extension of `PassTextureNode` which allows to manage more than one\n * internal texture. Relevant for the `getPreviousTexture()` related API.\n *\n * @augments module:PassTextureNode~PassTextureNode\n */\nclass PassMultipleTextureNode extends PassTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassMultipleTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {String} textureName - The output texture name.\n\t * @param {Boolean} [previousTexture=false] - Whether previous frame data should be used or not.\n\t */\n\tconstructor( passNode, textureName, previousTexture = false ) {\n\n\t\t// null is passed to the super call since this class does not\n\t\t// use an external texture for rendering pass data into. Instead\n\t\t// the texture is managed by the pass node itself\n\n\t\tsuper( passNode, null );\n\n\t\t/**\n\t\t * The output texture name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.textureName = textureName;\n\n\t\t/**\n\t\t * Whether previous frame data should be used or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.previousTexture = previousTexture;\n\n\t}\n\n\t/**\n\t * Updates the texture reference of this node.\n\t */\n\tupdateTexture() {\n\n\t\tthis.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateTexture();\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.textureName, this.previousTexture );\n\n\t}\n\n}\n\n/**\n * Represents a render pass (sometimes called beauty pass) in context of post processing.\n * This pass produces a render for the given scene and camera and can provide multiple outputs\n * via MRT for further processing.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n *\n * @augments TempNode\n */\nclass PassNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass node.\n\t *\n\t * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Object} options - Options for the internal render target.\n\t */\n\tconstructor( scope, scene, camera, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The scope of the pass. The scope determines whether the node outputs color or depth.\n\t\t *\n\t\t * @type {('color'|'depth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * A reference to the camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Options for the internal render target.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.options = options;\n\n\t\t/**\n\t\t * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._width = 1;\n\n\t\t/**\n\t\t * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._height = 1;\n\n\t\tconst depthTexture = new DepthTexture();\n\t\tdepthTexture.isRenderTargetTexture = true;\n\t\t//depthTexture.type = FloatType;\n\t\tdepthTexture.name = 'depth';\n\n\t\tconst renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );\n\t\trenderTarget.texture.name = 'output';\n\t\trenderTarget.depthTexture = depthTexture;\n\n\t\t/**\n\t\t * The pass's render target.\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * A dictionary holding the internal result textures.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, Texture>}\n\t\t */\n\t\tthis._textures = {\n\t\t\toutput: renderTarget.texture,\n\t\t\tdepth: depthTexture\n\t\t};\n\n\t\t/**\n\t\t * A dictionary holding the internal texture nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, TextureNode>}\n\t\t */\n\t\tthis._textureNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal depth nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._linearDepthNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal viewZ nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._viewZNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture data of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, Texture>}\n\t\t */\n\t\tthis._previousTextures = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture nodes of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<String, TextureNode>}\n\t\t */\n\t\tthis._previousTextureNodes = {};\n\n\t\t/**\n\t\t * The `near` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraNear = uniform( 0 );\n\n\t\t/**\n\t\t * The `far` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraFar = uniform( 0 );\n\n\t\t/**\n\t\t * A MRT node configuring the MRT settings.\n\t\t *\n\t\t * @private\n\t\t * @type {MRTNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPassNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link PassNode#updateBefore} method.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Sets the given MRT node to setup MRT for this pass.\n\t *\n\t * @param {MRTNode} mrt - The MRT object.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the current MRT node.\n\t *\n\t * @return {MRTNode} The current MRT node.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns the texture for the given output name.\n\t *\n\t * @param {String} name - The output name to get the texture for.\n\t * @return {Texture} The texture.\n\t */\n\tgetTexture( name ) {\n\n\t\tlet texture = this._textures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\tconst refTexture = this.renderTarget.texture;\n\n\t\t\ttexture = refTexture.clone();\n\t\t\ttexture.name = name;\n\n\t\t\tthis._textures[ name ] = texture;\n\n\t\t\tthis.renderTarget.textures.push( texture );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Returns the texture holding the data of the previous frame for the given output name.\n\t *\n\t * @param {String} name - The output name to get the texture for.\n\t * @return {Texture} The texture holding the data of the previous frame.\n\t */\n\tgetPreviousTexture( name ) {\n\n\t\tlet texture = this._previousTextures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\ttexture = this.getTexture( name ).clone();\n\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Switches current and previous textures for the given output name.\n\t *\n\t * @param {String} name - The output name.\n\t */\n\ttoggleTexture( name ) {\n\n\t\tconst prevTexture = this._previousTextures[ name ];\n\n\t\tif ( prevTexture !== undefined ) {\n\n\t\t\tconst texture = this._textures[ name ];\n\n\t\t\tconst index = this.renderTarget.textures.indexOf( texture );\n\t\t\tthis.renderTarget.textures[ index ] = prevTexture;\n\n\t\t\tthis._textures[ name ] = prevTexture;\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t\tthis._textureNodes[ name ].updateTexture();\n\t\t\tthis._previousTextureNodes[ name ].updateTexture();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the texture node for the given output name.\n\t *\n\t * @param {String} [name='output'] - The output name to get the texture node for.\n\t * @return {TextureNode} The texture node.\n\t */\n\tgetTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._textureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._textureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns the previous texture node for the given output name.\n\t *\n\t * @param {String} [name='output'] - The output name to get the previous texture node for.\n\t * @return {TextureNode} The previous texture node.\n\t */\n\tgetPreviousTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._previousTextureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\tif ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._previousTextureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns a viewZ node of this pass.\n\t *\n\t * @param {String} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The viewZ node.\n\t */\n\tgetViewZNode( name = 'depth' ) {\n\n\t\tlet viewZNode = this._viewZNodes[ name ];\n\n\t\tif ( viewZNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\n\t\t\tthis._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn viewZNode;\n\n\t}\n\n\t/**\n\t * Returns a linear depth node of this pass.\n\t *\n\t * @param {String} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The linear depth node.\n\t */\n\tgetLinearDepthNode( name = 'depth' ) {\n\n\t\tlet linearDepthNode = this._linearDepthNodes[ name ];\n\n\t\tif ( linearDepthNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\t\t\tconst viewZNode = this.getViewZNode( name );\n\n\t\t\t// TODO: just if ( builder.camera.isPerspectiveCamera )\n\n\t\t\tthis._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn linearDepthNode;\n\n\t}\n\n\tsetup( { renderer } ) {\n\n\t\tthis.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n\t\t// Disable MSAA for WebGL backend for now\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tthis.renderTarget.samples = 0;\n\n\t\t}\n\n\t\treturn this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene, camera } = this;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tconst size = renderer.getSize( _size );\n\n\t\tthis.setSize( size.width, size.height );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\trenderer.render( scene, camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t}\n\n\t/**\n\t * Sets the size of the pass's render target. Honors the pixel ratio.\n\t *\n\t * @param {Number} width - The width to set.\n\t * @param {Number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio the pass's render target and updates the size.\n\t *\n\t * @param {Number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\n}\n\nPassNode.COLOR = 'color';\nPassNode.DEPTH = 'depth';\n\n/**\n * TSL function for creating a pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );\n\n/**\n * TSL function for creating a pass texture node.\n *\n * @function\n * @param {PassNode} pass - The pass node.\n * @param {Texture} texture - The output texture.\n * @returns {PassTextureNode}\n */\nconst passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );\n\n/**\n * TSL function for creating a depth pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst depthPass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera, options ) );\n\n/** @module ToonOutlinePassNode **/\n\n/**\n * Represents a render pass for producing a toon outline effect on compatible objects.\n * Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`\n * will receive the outline.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = toonOutlinePass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n * @augments PassNode\n */\nclass ToonOutlinePassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToonOutlinePassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new outline pass node.\n\t *\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Node} colorNode - Defines the outline's color.\n\t * @param {Node} thicknessNode - Defines the outline's thickness.\n\t * @param {Node} alphaNode - Defines the outline's alpha.\n\t */\n\tconstructor( scene, camera, colorNode, thicknessNode, alphaNode ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\t/**\n\t\t * Defines the outline's color.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * Defines the outline's thickness.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.thicknessNode = thicknessNode;\n\n\t\t/**\n\t\t * Defines the outline's alpha.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.alphaNode = alphaNode;\n\n\t\t/**\n\t\t * An internal material cache.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakMap<Material, NodeMaterial>}\n\t\t */\n\t\tthis._materialCache = new WeakMap();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {\n\n\t\t\t// only render outline for supported materials\n\n\t\t\tif ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {\n\n\t\t\t\tif ( material.wireframe === false ) {\n\n\t\t\t\t\tconst outlineMaterial = this._getOutlineMaterial( material );\n\t\t\t\t\trenderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// default\n\n\t\t\trenderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );\n\n\t\t} );\n\n\t\tsuper.updateBefore( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t}\n\n\t/**\n\t * Creates the material used for outline rendering.\n\t *\n\t * @private\n\t * @return {NodeMaterial} The outline material.\n\t */\n\t_createMaterial() {\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.isMeshToonOutlineMaterial = true;\n\t\tmaterial.name = 'Toon_Outline';\n\t\tmaterial.side = BackSide;\n\n\t\t// vertex node\n\n\t\tconst outlineNormal = normalLocal.negate();\n\t\tconst mvp = cameraProjectionMatrix.mul( modelViewMatrix );\n\n\t\tconst ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex\n\t\tconst pos = mvp.mul( vec4( positionLocal, 1.0 ) );\n\t\tconst pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );\n\t\tconst norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n\t\tmaterial.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );\n\n\t\t// color node\n\n\t\tmaterial.colorNode = vec4( this.colorNode, this.alphaNode );\n\n\t\treturn material;\n\n\t}\n\n\t/**\n\t * For the given toon material, this method returns a corresponding\n\t * outline material.\n\t *\n\t * @private\n\t * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.\n\t * @return {NodeMaterial} The outline material.\n\t */\n\t_getOutlineMaterial( originalMaterial ) {\n\n\t\tlet outlineMaterial = this._materialCache.get( originalMaterial );\n\n\t\tif ( outlineMaterial === undefined ) {\n\n\t\t\toutlineMaterial = this._createMaterial();\n\n\t\t\tthis._materialCache.set( originalMaterial, outlineMaterial );\n\n\t\t}\n\n\t\treturn outlineMaterial;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a toon outline pass node.\n *\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Color} color - Defines the outline's color.\n * @param {Number} [thickness=0.003] - Defines the outline's thickness.\n * @param {Number} [alpha=1] - Defines the outline's alpha.\n * @returns {ToonOutlinePassNode}\n */\nconst toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );\n\n/** @module ToneMappingFunctions **/\n\n/**\n * Linear tone mapping, exposure only.\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\treturn color.mul( exposure ).clamp();\n\n} ).setLayout( {\n\tname: 'linearToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Reinhard tone mapping.\n *\n * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tcolor = color.mul( exposure );\n\n\treturn color.div( color.add( 1.0 ) ).clamp();\n\n} ).setLayout( {\n\tname: 'reinhardToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Cineon tone mapping.\n *\n * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor = color.mul( exposure );\n\tcolor = color.sub( 0.004 ).max( 0.0 );\n\n\tconst a = color.mul( color.mul( 6.2 ).add( 0.5 ) );\n\tconst b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );\n\n\treturn a.div( b ).pow( 2.2 );\n\n} ).setLayout( {\n\tname: 'cineonToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );\n\tconst b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );\n\n\treturn a.div( b );\n\n} );\n\n/**\n * ACESFilmic tone mapping.\n *\n * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst ACESInputMat = mat3(\n\t\t0.59719, 0.35458, 0.04823,\n\t\t0.07600, 0.90834, 0.01566,\n\t\t0.02840, 0.13383, 0.83777\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst ACESOutputMat = mat3(\n\t\t1.60475, - 0.53108, - 0.07367,\n\t\t- 0.10208, 1.10813, - 0.00605,\n\t\t- 0.00327, - 0.07276, 1.07602\n\t);\n\n\tcolor = color.mul( exposure ).div( 0.6 );\n\n\tcolor = ACESInputMat.mul( color );\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat.mul( color );\n\n\t// Clamp to [0, 1]\n\treturn color.clamp();\n\n} ).setLayout( {\n\tname: 'acesFilmicToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );\n\nconst agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = vec3( x_immutable ).toVar();\n\tconst x2 = vec3( x.mul( x ) ).toVar();\n\tconst x4 = vec3( x2.mul( x2 ) ).toVar();\n\n\treturn float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );\n\n} );\n\n/**\n * AgX tone mapping.\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst colortone = vec3( color ).toVar();\n\tconst AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );\n\tconst AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );\n\tconst AgxMinEv = float( - 12.47393 );\n\tconst AgxMaxEv = float( 4.026069 );\n\tcolortone.mulAssign( exposure );\n\tcolortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );\n\tcolortone.assign( AgXInsetMatrix.mul( colortone ) );\n\tcolortone.assign( max$1( colortone, 1e-10 ) );\n\tcolortone.assign( log2( colortone ) );\n\tcolortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\tcolortone.assign( agxDefaultContrastApprox( colortone ) );\n\tcolortone.assign( AgXOutsetMatrix.mul( colortone ) );\n\tcolortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );\n\tcolortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\n\treturn colortone;\n\n} ).setLayout( {\n\tname: 'agxToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Neutral tone mapping.\n *\n * Reference: {@link https://modelviewer.dev/examples/tone-mapping}\n *\n * @method\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst StartCompression = float( 0.8 - 0.04 );\n\tconst Desaturation = float( 0.15 );\n\n\tcolor = color.mul( exposure );\n\n\tconst x = min$1( color.r, min$1( color.g, color.b ) );\n\tconst offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );\n\n\tcolor.subAssign( offset );\n\n\tconst peak = max$1( color.r, max$1( color.g, color.b ) );\n\n\tIf( peak.lessThan( StartCompression ), () => {\n\n\t\treturn color;\n\n\t} );\n\n\tconst d = sub( 1, StartCompression );\n\tconst newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );\n\tcolor.mulAssign( newPeak.div( peak ) );\n\tconst g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );\n\n\treturn mix( color, vec3( newPeak ), g );\n\n} ).setLayout( {\n\tname: 'neutralToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/** @module CodeNode **/\n\n/**\n * This class represents native code sections. It is the base\n * class for modules like {@link FunctionNode} which allows to implement\n * functions with native shader languages.\n *\n * @augments Node\n */\nclass CodeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CodeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new code node.\n\t *\n\t * @param {String} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( 'code' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCodeNode = true;\n\n\t\t/**\n\t\t * The native code.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.code = code;\n\n\t\t/**\n\t\t * An array of includes\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t * @default []\n\t\t */\n\t\tthis.includes = includes;\n\n\t\t/**\n\t\t * The used language.\n\t\t *\n\t\t * @type {('js'|'wgsl'|'glsl')}\n\t\t * @default ''\n\t\t */\n\t\tthis.language = language;\n\n\t}\n\n\t/**\n\t * The method is overwritten so it always returns `true`.\n\t *\n\t * @return {Boolean} Whether this node is global or not.\n\t */\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Sets the includes of this code node.\n\t *\n\t * @param {Array<Node>} includes - The includes to set.\n\t * @return {CodeNode} A reference to this node.\n\t */\n\tsetIncludes( includes ) {\n\n\t\tthis.includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the includes of this code node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<Node>} The includes.\n\t */\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this.includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.code = this.code;\n\t\tdata.language = this.language;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.code = data.code;\n\t\tthis.language = data.language;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a code node.\n *\n * @function\n * @param {String} [code=''] - The native code.\n * @param {Array<Node>} [includes=[]] - An array of includes.\n * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n * @returns {CodeNode}\n */\nconst code = /*@__PURE__*/ nodeProxy( CodeNode );\n\n/**\n * TSL function for creating a JS code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst js = ( src, includes ) => code( src, includes, 'js' );\n\n/**\n * TSL function for creating a WGSL code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst wgsl = ( src, includes ) => code( src, includes, 'wgsl' );\n\n/**\n * TSL function for creating a GLSL code node.\n *\n * @function\n * @param {String} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst glsl = ( src, includes ) => code( src, includes, 'glsl' );\n\n/**\n * This class represents a native shader function. It can be used to implement\n * certain aspects of a node material with native shader code. There are two predefined\n * TSL functions for easier usage.\n *\n * - `wgslFn`: Creates a WGSL function node.\n * - `glslFn`: Creates a GLSL function node.\n *\n * A basic example with one include looks like so:\n *\n * ```js\n * const desaturateWGSLFn = wgslFn( `\n *\tfn desaturate( color:vec3<f32> ) -> vec3<f32> {\n *\t\tlet lum = vec3<f32>( 0.299, 0.587, 0.114 );\n *\t\treturn vec3<f32>( dot( lum, color ) );\n *\t}`\n *);\n * const someWGSLFn = wgslFn( `\n *\tfn someFn( color:vec3<f32> ) -> vec3<f32> {\n * \t\treturn desaturate( color );\n * \t}\n * `, [ desaturateWGSLFn ] );\n * material.colorNode = someWGSLFn( { color: texture( map ) } );\n *```\n * @augments CodeNode\n */\nclass FunctionNode extends CodeNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function node.\n\t *\n\t * @param {String} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( code, includes, language );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\t/**\n\t * Returns the inputs of this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<NodeFunctionInput>} The inputs.\n\t */\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\t/**\n\t * Returns the node function for this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeFunction} The node function.\n\t */\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tconst code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tnodeCode.code = code + '\\n';\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst nativeFn = ( code, includes = [], language = '' ) => {\n\n\tfor ( let i = 0; i < includes.length; i ++ ) {\n\n\t\tconst include = includes[ i ];\n\n\t\t// TSL Function: glslFn, wgslFn\n\n\t\tif ( typeof include === 'function' ) {\n\n\t\t\tincludes[ i ] = include.functionNode;\n\n\t\t}\n\n\t}\n\n\tconst functionNode = nodeObject( new FunctionNode( code, includes, language ) );\n\n\tconst fn = ( ...params ) => functionNode.call( ...params );\n\tfn.functionNode = functionNode;\n\n\treturn fn;\n\n};\n\nconst glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );\nconst wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );\n\n/** @module ScriptableValueNode **/\n\n/**\n * `ScriptableNode` uses this class to manage script inputs and outputs.\n *\n * @augments Node\n */\nclass ScriptableValueNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableValueNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {Any} [value=null] - The value.\n\t */\n\tconstructor( value = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A reference to the value.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Depending on the type of `_value`, this property might cache parsed data.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._cache = null;\n\n\t\t/**\n\t\t * If this node represents an input, this property represents the input type.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.inputType = null;\n\n\t\t/**\n\t\t * If this node represents an output, this property represents the output type.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.outputType = null;\n\n\t\t/**\n\t\t * An event dispatcher for managing events.\n\t\t *\n\t\t * @type {EventDispatcher}\n\t\t */\n\t\tthis.events = new EventDispatcher();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableValueNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node represents an output or not.\n\t *\n\t * @type {Boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget isScriptableOutputNode() {\n\n\t\treturn this.outputType !== null;\n\n\t}\n\n\tset value( val ) {\n\n\t\tif ( this._value === val ) return;\n\n\t\tif ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {\n\n\t\t\tURL.revokeObjectURL( this._cache );\n\n\t\t\tthis._cache = null;\n\n\t\t}\n\n\t\tthis._value = val;\n\n\t\tthis.events.dispatchEvent( { type: 'change' } );\n\n\t\tthis.refresh();\n\n\t}\n\n\t/**\n\t * The node's value.\n\t *\n\t * @type {Any}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Dispatches the `refresh` event.\n\t */\n\trefresh() {\n\n\t\tthis.events.dispatchEvent( { type: 'refresh' } );\n\n\t}\n\n\t/**\n\t * The `value` property usually represents a node or even binary data in form of array buffers.\n\t * In this case, this method tries to return the actual value behind the complex type.\n\t *\n\t * @return {Any} The value.\n\t */\n\tgetValue() {\n\n\t\tconst value = this.value;\n\n\t\tif ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {\n\n\t\t\tthis._cache = URL.createObjectURL( new Blob( [ value.value ] ) );\n\n\t\t} else if ( value && value.value !== null && value.value !== undefined && (\n\t\t\t( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||\n\t\t\t( this.inputType === 'Number' && typeof value.value === 'number' ) ||\n\t\t\t( this.inputType === 'Vector2' && value.value.isVector2 ) ||\n\t\t\t( this.inputType === 'Vector3' && value.value.isVector3 ) ||\n\t\t\t( this.inputType === 'Vector4' && value.value.isVector4 ) ||\n\t\t\t( this.inputType === 'Color' && value.value.isColor ) ||\n\t\t\t( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||\n\t\t\t( this.inputType === 'Matrix4' && value.value.isMatrix4 )\n\t\t) ) {\n\n\t\t\treturn value.value;\n\n\t\t}\n\n\t\treturn this._cache || value;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the value.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.value && this.value.isNode ? this.value : float();\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tif ( this.value !== null ) {\n\n\t\t\tif ( this.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tdata.value = arrayBufferToBase64( this.value );\n\n\t\t\t} else {\n\n\t\t\t\tdata.value = this.value ? this.value.toJSON( data.meta ).uuid : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.value = null;\n\n\t\t}\n\n\t\tdata.inputType = this.inputType;\n\t\tdata.outputType = this.outputType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tlet value = null;\n\n\t\tif ( data.value !== null ) {\n\n\t\t\tif ( data.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tvalue = base64ToArrayBuffer( data.value );\n\n\t\t\t} else if ( data.inputType === 'Texture' ) {\n\n\t\t\t\tvalue = data.meta.textures[ data.value ];\n\n\t\t\t} else {\n\n\t\t\t\tvalue = data.meta.nodes[ data.value ] || null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.inputType = data.inputType;\n\t\tthis.outputType = data.outputType;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a scriptable value node.\n *\n * @function\n * @param {Any} [value=null] - The value.\n * @returns {ScriptableValueNode}\n */\nconst scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );\n\n/** @module ScriptableNode **/\n\n/**\n * A Map-like data structure for managing resources of scriptable nodes.\n *\n * @augments Map\n */\nclass Resources extends Map {\n\n\tget( key, callback = null, ...params ) {\n\n\t\tif ( this.has( key ) ) return super.get( key );\n\n\t\tif ( callback !== null ) {\n\n\t\t\tconst value = callback( ...params );\n\t\t\tthis.set( key, value );\n\t\t\treturn value;\n\n\t\t}\n\n\t}\n\n}\n\nclass Parameters {\n\n\tconstructor( scriptableNode ) {\n\n\t\tthis.scriptableNode = scriptableNode;\n\n\t}\n\n\tget parameters() {\n\n\t\treturn this.scriptableNode.parameters;\n\n\t}\n\n\tget layout() {\n\n\t\treturn this.scriptableNode.getLayout();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\treturn this.scriptableNode.getInputLayout( id );\n\n\t}\n\n\tget( name ) {\n\n\t\tconst param = this.parameters[ name ];\n\t\tconst value = param ? param.getValue() : null;\n\n\t\treturn value;\n\n\t}\n\n}\n\n/**\n * Defines the resouces (e.g. namespaces) of scriptable nodes.\n *\n * @type {Resources}\n */\nconst ScriptableNodeResources = new Resources();\n\n/**\n * This type of node allows to implement nodes with custom scripts. The script\n * section is represented as an instance of `CodeNode` written with JavaScript.\n * The script itself must adhere to a specific structure.\n *\n * - main(): Executed once by default and every time `node.needsUpdate` is set.\n * - layout: The layout object defines the script's interface (inputs and outputs).\n *\n * ```js\n * ScriptableNodeResources.set( 'TSL', TSL );\n *\n * const scriptableNode = scriptable( js( `\n * \tlayout = {\n * \t\toutputType: 'node',\n * \t\telements: [\n * \t\t\t{ name: 'source', inputType: 'node' },\n * \t\t]\n * \t};\n *\n * \tconst { mul, oscSine } = TSL;\n *\n * \tfunction main() {\n * \t\tconst source = parameters.get( 'source' ) || float();\n * \t\treturn mul( source, oscSine() ) );\n * \t}\n *\n * ` ) );\n *\n * scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );\n *\n * const material = new THREE.MeshBasicNodeMaterial();\n * material.colorNode = scriptableNode;\n * ```\n *\n * @augments Node\n */\nclass ScriptableNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {CodeNode?} [codeNode=null] - The code node.\n\t * @param {Object} [parameters={}] - The parameters definition.\n\t */\n\tconstructor( codeNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The code node.\n\t\t *\n\t\t * @type {CodeNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.codeNode = codeNode;\n\n\t\t/**\n\t\t * The parameters definition.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t\tthis._local = new Resources();\n\t\tthis._output = scriptableValue();\n\t\tthis._outputs = {};\n\t\tthis._source = this.source;\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\n\t\tthis.onRefresh = this.onRefresh.bind( this );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableNode = true;\n\n\t}\n\n\t/**\n\t * The source code of the scriptable node.\n\t *\n\t * @type {String}\n\t */\n\tget source() {\n\n\t\treturn this.codeNode ? this.codeNode.code : '';\n\n\t}\n\n\t/**\n\t * Sets the reference of a local script variable.\n\t *\n\t * @param {String} name - The variable name.\n\t * @param {Object} value - The reference to set.\n\t * @return {Resources} The resource map\n\t */\n\tsetLocal( name, value ) {\n\n\t\treturn this._local.set( name, value );\n\n\t}\n\n\t/**\n\t * Gets the value of a local script variable.\n\t *\n\t * @param {String} name - The variable name.\n\t * @return {Object} The value.\n\t */\n\tgetLocal( name ) {\n\n\t\treturn this._local.get( name );\n\n\t}\n\n\t/**\n\t * Event listener for the `refresh` event.\n\t */\n\tonRefresh() {\n\n\t\tthis._refresh();\n\n\t}\n\n\t/**\n\t * Returns an input from the layout with the given id/name.\n\t *\n\t * @param {String} id - The id/name of the input.\n\t * @return {Object} The element entry.\n\t */\n\tgetInputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.inputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns an output from the layout with the given id/name.\n\t *\n\t * @param {String} id - The id/name of the output.\n\t * @return {Object} The element entry.\n\t */\n\tgetOutputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.outputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines a script output for the given name and value.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @param {Node} value - The node value.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tsetOutput( name, value ) {\n\n\t\tconst outputs = this._outputs;\n\n\t\tif ( outputs[ name ] === undefined ) {\n\n\t\t\toutputs[ name ] = scriptableValue( value );\n\n\t\t} else {\n\n\t\t\toutputs[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a script output for the given name.\n\t *\n\t * @param {String} name - The name of the output.\n\t * @return {ScriptableValueNode} The node value.\n\t */\n\tgetOutput( name ) {\n\n\t\treturn this._outputs[ name ];\n\n\t}\n\n\t/**\n\t * Returns a paramater for the given name\n\t *\n\t * @param {String} name - The name of the parameter.\n\t * @return {ScriptableValueNode} The node value.\n\t */\n\tgetParameter( name ) {\n\n\t\treturn this.parameters[ name ];\n\n\t}\n\n\t/**\n\t * Sets a value for the given parameter name.\n\t *\n\t * @param {String} name - The parameter name.\n\t * @param {Any} value - The parameter value.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tsetParameter( name, value ) {\n\n\t\tconst parameters = this.parameters;\n\n\t\tif ( value && value.isScriptableNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( value && value.isScriptableValueNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( parameters[ name ] === undefined ) {\n\n\t\t\tparameters[ name ] = scriptableValue( value );\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else {\n\n\t\t\tparameters[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the value of this node which is the value of\n\t * the default output.\n\t *\n\t * @return {Node} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.getDefaultOutput().getValue();\n\n\t}\n\n\t/**\n\t * Deletes a parameter from the script.\n\t *\n\t * @param {String} name - The parameter to remove.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tdeleteParameter( name ) {\n\n\t\tlet valueNode = this.parameters[ name ];\n\n\t\tif ( valueNode ) {\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.removeEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes all parameters from the script.\n\t *\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tclearParameters() {\n\n\t\tfor ( const name of Object.keys( this.parameters ) ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calls a function from the script.\n\t *\n\t * @param {String} name - The function name.\n\t * @param {...Any} params - A list of parameters.\n\t * @return {Any} The result of the function call.\n\t */\n\tcall( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method( ...params );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Asynchronously calls a function from the script.\n\t *\n\t * @param {String} name - The function name.\n\t * @param {...Any} params - A list of parameters.\n\t * @return {Any} The result of the function call.\n\t */\n\tasync callAsync( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten since the node types is inferred from the script's output.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getDefaultOutputNode().getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Refreshes the script node.\n\t *\n\t * @param {String?} [output=null] - An optional output.\n\t */\n\trefresh( output = null ) {\n\n\t\tif ( output !== null ) {\n\n\t\t\tthis.getOutput( output ).refresh();\n\n\t\t} else {\n\n\t\t\tthis._refresh();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns an object representation of the script.\n\t *\n\t * @return {Object} The result object.\n\t */\n\tgetObject() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._object !== null ) return this._object;\n\n\t\t//\n\n\t\tconst refresh = () => this.refresh();\n\t\tconst setOutput = ( id, value ) => this.setOutput( id, value );\n\n\t\tconst parameters = new Parameters( this );\n\n\t\tconst THREE = ScriptableNodeResources.get( 'THREE' );\n\t\tconst TSL = ScriptableNodeResources.get( 'TSL' );\n\n\t\tconst method = this.getMethod();\n\t\tconst params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];\n\n\t\tthis._object = method( ...params );\n\n\t\tconst layout = this._object.layout;\n\n\t\tif ( layout ) {\n\n\t\t\tif ( layout.cache === false ) {\n\n\t\t\t\tthis._local.clear();\n\n\t\t\t}\n\n\t\t\t// default output\n\t\t\tthis._output.outputType = layout.outputType || null;\n\n\t\t\tif ( Array.isArray( layout.elements ) ) {\n\n\t\t\t\tfor ( const element of layout.elements ) {\n\n\t\t\t\t\tconst id = element.id || element.name;\n\n\t\t\t\t\tif ( element.inputType ) {\n\n\t\t\t\t\t\tif ( this.getParameter( id ) === undefined ) this.setParameter( id, null );\n\n\t\t\t\t\t\tthis.getParameter( id ).inputType = element.inputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( element.outputType ) {\n\n\t\t\t\t\t\tif ( this.getOutput( id ) === undefined ) this.setOutput( id, null );\n\n\t\t\t\t\t\tthis.getOutput( id ).outputType = element.outputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this._object;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tfor ( const name in this.parameters ) {\n\n\t\t\tlet valueNode = this.parameters[ name ];\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the layout of the script.\n\t *\n\t * @return {Object} The script's layout.\n\t */\n\tgetLayout() {\n\n\t\treturn this.getObject().layout;\n\n\t}\n\n\t/**\n\t * Returns default node output of the script.\n\t *\n\t * @return {Node} The default node output.\n\t */\n\tgetDefaultOutputNode() {\n\n\t\tconst output = this.getDefaultOutput().value;\n\n\t\tif ( output && output.isNode ) {\n\n\t\t\treturn output;\n\n\t\t}\n\n\t\treturn float();\n\n\t}\n\n\t/**\n\t * Returns default output of the script.\n\t *\n\t * @return {ScriptableValueNode} The default output.\n\t */\n\tgetDefaultOutput()\t{\n\n\t\treturn this._exec()._output;\n\n\t}\n\n\t/**\n\t * Returns a function created from the node's script.\n\t *\n\t * @return {Function} The function representing the node's code.\n\t */\n\tgetMethod() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._method !== null ) return this._method;\n\n\t\t//\n\n\t\tconst parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];\n\t\tconst interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];\n\n\t\tconst properties = interfaceProps.join( ', ' );\n\t\tconst declarations = 'var ' + properties + '; var output = {};\\n';\n\t\tconst returns = '\\nreturn { ...output, ' + properties + ' };';\n\n\t\tconst code = declarations + this.codeNode.code + returns;\n\n\t\t//\n\n\t\tthis._method = new Function( ...parametersProps, code );\n\n\t\treturn this._method;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tif ( this._method === null ) return;\n\n\t\tif ( this._object && typeof this._object.dispose === 'function' ) {\n\n\t\t\tthis._object.dispose();\n\n\t\t}\n\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._source = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\t\tthis._output.value = null;\n\t\tthis._outputs = {};\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.getDefaultOutputNode();\n\n\t}\n\n\tgetCacheKey( force ) {\n\n\t\tconst values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];\n\n\t\tfor ( const param in this.parameters ) {\n\n\t\t\tvalues.push( this.parameters[ param ].getCacheKey( force ) );\n\n\t\t}\n\n\t\treturn hashArray( values );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.dispose();\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn this.source !== this._source;\n\n\t}\n\n\t/**\n\t * Executes the `main` function of the script.\n\t *\n\t * @private\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\t_exec()\t{\n\n\t\tif ( this.codeNode === null ) return this;\n\n\t\tif ( this._needsOutputUpdate === true ) {\n\n\t\t\tthis._value = this.call( 'main' );\n\n\t\t\tthis._needsOutputUpdate = false;\n\n\t\t}\n\n\t\tthis._output.value = this._value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Executes the refresh.\n\t *\n\t * @private\n\t */\n\t_refresh() {\n\n\t\tthis.needsUpdate = true;\n\n\t\tthis._exec();\n\n\t\tthis._output.refresh();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a scriptable node.\n *\n * @function\n * @param {CodeNode?} [codeNode=null] - The code node.\n * @param {Object} [parameters={}] - The parameters definition.\n * @returns {ScriptableNode}\n */\nconst scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );\n\n/** @module Fog **/\n\n/**\n * Returns a node that represents the `z` coordinate in view space\n * for the current fragment. It's a different representation of the\n * default depth value.\n *\n * This value can be part of a computation that defines how the fog\n * density increases when moving away from the camera.\n *\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node} The viewZ node.\n */\nfunction getViewZNode( builder ) {\n\n\tlet viewZ;\n\n\tconst getViewZ = builder.context.getViewZ;\n\n\tif ( getViewZ !== undefined ) {\n\n\t\tviewZ = getViewZ( this );\n\n\t}\n\n\treturn ( viewZ || positionView.z ).negate();\n\n}\n\n/**\n * Constructs a new range factor node.\n *\n * @function\n * @param {Node} near - Defines the near value.\n * @param {Node} far - Defines the far value.\n */\nconst rangeFogFactor = Fn( ( [ near, far ], builder ) => {\n\n\tconst viewZ = getViewZNode( builder );\n\n\treturn smoothstep( near, far, viewZ );\n\n} );\n\n/**\n * Represents an exponential squared fog. This type of fog gives\n * a clear view near the camera and a faster than exponentially\n * densening fog farther from the camera.\n *\n * @function\n * @param {Node} density - Defines the fog density.\n */\nconst densityFogFactor = Fn( ( [ density ], builder ) => {\n\n\tconst viewZ = getViewZNode( builder );\n\n\treturn density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();\n\n} );\n\n/**\n * This class can be used to configure a fog for the scene.\n * Nodes of this type are assigned to `Scene.fogNode`.\n *\n * @function\n * @param {Node} color - Defines the color of the fog.\n * @param {Node} factor - Defines how the fog is factored in the scene.\n */\nconst fog = Fn( ( [ color, factor ] ) => {\n\n\treturn vec4( factor.toFloat().mix( output.rgb, color.toVec3() ), output.a );\n\n} );\n\n// Deprecated\n\nfunction rangeFog( color, near, far ) { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"rangeFog( color, near, far )\" is deprecated. Use \"fog( color, rangeFogFactor( near, far ) )\" instead.' );\n\treturn fog( color, rangeFogFactor( near, far ) );\n\n}\n\nfunction densityFog( color, density ) { // @deprecated, r171\n\n\tconsole.warn( 'THREE.TSL: \"densityFog( color, density )\" is deprecated. Use \"fog( color, densityFogFactor( density ) )\" instead.' );\n\treturn fog( color, densityFogFactor( density ) );\n\n}\n\n/** @module RangeNode **/\n\nlet min = null;\nlet max = null;\n\n/**\n * `RangeNode` generates random instanced attribute data in a defined range.\n * An exemplary use case for this utility node is to generate random per-instance\n * colors:\n * ```js\n * const material = new MeshBasicNodeMaterial();\n * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );\n * const mesh = new InstancedMesh( geometry, material, count );\n * ```\n * @augments Node\n */\nclass RangeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RangeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new range node.\n\t *\n\t * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n\t * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n\t */\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t *  A node defining the lower bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.minNode = minNode;\n\n\t\t/**\n\t\t *  A node defining the upper bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Number} The vector length.\n\t */\n\tgetVectorLength( builder ) {\n\n\t\tconst minLength = builder.getTypeLength( getValueType( this.minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\tconst minValue = this.minNode.value;\n\t\t\tconst maxValue = this.maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b, 1 );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b, 1 );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( object.count <= 4096 ) {\n\n\t\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: Improve anonymous buffer attribute creation removing this part\n\t\t\t\tconst bufferAttribute = new InstancedBufferAttribute( array, 4 );\n\t\t\t\tbuilder.geometry.setAttribute( '__range' + this.id, bufferAttribute );\n\n\t\t\t\toutput = instancedBufferAttribute( bufferAttribute ).convert( nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a range node.\n *\n * @function\n * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n * @returns {RangeNode}\n */\nconst range = /*@__PURE__*/ nodeProxy( RangeNode );\n\n/** @module ComputeBuiltinNode **/\n\n/**\n * `ComputeBuiltinNode` represents a compute-scope builtin value that expose information\n * about the currently running dispatch and/or the device it is running on.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass ComputeBuiltinNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeBuiltinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute builtin node.\n\t *\n\t * @param {String} builtinName - The built-in name.\n\t * @param {String} nodeType - The node type.\n\t */\n\tconstructor( builtinName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The built-in name.\n\t\t *\n\t\t * @private\n\t\t * @type {String}\n\t\t */\n\t\tthis._builtinName = builtinName;\n\n\t}\n\n\t/**\n\t * This method is overwritten since hash is derived from the built-in name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\treturn this.getBuiltinName( builder );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is simply derived from `nodeType`..\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Sets the builtin name.\n\t *\n\t * @param {String} builtinName - The built-in name.\n\t * @return {ComputeBuiltinNode} A reference to this node.\n\t */\n\tsetBuiltinName( builtinName ) {\n\n\t\tthis._builtinName = builtinName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the builtin name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The builtin name.\n\t */\n\tgetBuiltinName( /*builder*/ ) {\n\n\t\treturn this._builtinName;\n\n\t}\n\n\t/**\n\t * Whether the current node builder has the builtin or not.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\thasBuiltin( builder ) {\n\n\t\tbuilder.hasBuiltin( this._builtinName );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst builtinName = this.getBuiltinName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( builder.shaderStage === 'compute' ) {\n\n\t\t\treturn builder.format( builtinName, nodeType, output );\n\n\t\t} else {\n\n\t\t\tconsole.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._builtinName = this._builtinName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._builtinName = data._builtinName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a compute builtin node.\n *\n * @function\n * @param {String} name - The built-in name.\n * @param {String} nodeType - The node type.\n * @returns {ComputeBuiltinNode}\n */\nconst computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );\n\n/**\n * TSL function for creating a `numWorkgroups` builtin node.\n * Represents the number of workgroups dispatched by the compute shader.\n * ```js\n * // Run 512 invocations/threads with a workgroup size of 128.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 4\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512, [128]);\n *\n * // Run 512 invocations/threads with the default workgroup size of 64.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 8\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512);\n * ```\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );\n\n/**\n * TSL function for creating a `workgroupId` builtin node.\n * Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.\n * ```js\n * // Execute 12 compute threads with a workgroup size of 3.\n * const computeFn = Fn( () => {\n *\n * \tIf( workgroupId.x.modInt( 2 ).equal( 0 ), () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( instanceIndex );\n *\n * \t} ).Else( () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( 0 );\n *\n * \t} );\n *\n * } )().compute( 12, [ 3 ] );\n *\n * // workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];\n * // Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];\n * ```\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );\n\n/**\n * TSL function for creating a `localId` builtin node. A non-linearized 3-dimensional\n * representation of the current invocation's position within a 3D workgroup grid.\n *\n * @function\n * @returns {ComputeBuiltinNode<uvec3>}\n */\nconst localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );\n\n/**\n * TSL function for creating a `subgroupSize` builtin node. A device dependent variable\n * that exposes the size of the current invocation's subgroup.\n *\n * @function\n * @returns {ComputeBuiltinNode<uint>}\n */\nconst subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );\n\n/** @module BarrierNode **/\n\n/**\n * Represents a GPU control barrier that synchronizes compute operations within a given scope.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass BarrierNode extends Node {\n\n\t/**\n\t * Constructs a new barrier node.\n\t *\n\t * @param {String} scope - The scope defines the behavior of the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tbuilder.addFlowCode( `\\t// ${scope}Barrier \\n` );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( `${scope}Barrier()`, this );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a barrier node.\n *\n * @function\n * @param {String} scope - The scope defines the behavior of the node..\n * @returns {BarrierNode}\n */\nconst barrier = nodeProxy( BarrierNode );\n\n/**\n * TSL function for creating a workgroup barrier. All compute shader\n * invocations must wait for each invocation within a workgroup to\n * complete before the barrier can be surpassed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst workgroupBarrier = () => barrier( 'workgroup' ).append();\n\n/**\n * TSL function for creating a storage barrier. All invocations must\n * wait for each access to variables within the 'storage' address space\n * to complete before the barrier can be passed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst storageBarrier = () => barrier( 'storage' ).append();\n\n/**\n * TSL function for creating a texture barrier. All invocations must\n * wait for each access to variables within the 'texture' address space\n * to complete before the barrier can be passed.\n *\n * @function\n * @returns {BarrierNode}\n */\nconst textureBarrier = () => barrier( 'texture' ).append();\n\n/** @module WorkgroupInfoNode **/\n\n/**\n * Represents an element of a 'workgroup' scoped buffer.\n *\n * @augments ArrayElementNode\n */\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n\n\t/**\n\t * Constructs a new workgroup info element node.\n\t *\n\t * @param {Node} workgroupInfoNode - The workgroup info node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( workgroupInfoNode, indexNode ) {\n\n\t\tsuper( workgroupInfoNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWorkgroupInfoElementNode = true;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\t\tsnippet = super.generate( builder );\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\t// TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * A node allowing the user to create a 'workgroup' scoped buffer within the\n * context of a compute shader. Typically, workgroup scoped buffers are\n * created to hold data that is transfered from a global storage scope into\n * a local workgroup scope. For invocations within a workgroup, data\n * access speeds on 'workgroup' scoped buffers can be significantly faster\n * than similar access operations on globally accessible storage buffers.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass WorkgroupInfoNode extends Node {\n\n\t/**\n\t * Constructs a new buffer scoped to type scope.\n\t *\n\t * @param {String} scope - TODO.\n\t * @param {String} bufferType - The data type of a 'workgroup' scoped buffer element.\n\t * @param {Number} [bufferCount=0] - The number of elements in the buffer.\n\t */\n\tconstructor( scope, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( bufferType );\n\n\t\t/**\n\t\t * The buffer type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer count.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWorkgroupInfoNode = true;\n\n\t\t/**\n\t\t * The data type of the array buffer.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.elementType = bufferType;\n\n\t\t/**\n\t\t * TODO.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Sets the name/label of this node.\n\t *\n\t * @param {String} name - The name to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the scope of this node.\n\t *\n\t * @param {String} scope - The scope to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tsetScope( scope ) {\n\n\t\tthis.scope = scope;\n\n\t\treturn this;\n\n\t}\n\n\n\t/**\n\t * The data type of the array buffer.\n\t *\n\t * @return {String} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation since the input type\n\t * is inferred from the scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn `${this.scope}Array`;\n\n\t}\n\n\t/**\n\t * This method can be used to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {WorkgroupInfoElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a workgroup info node.\n * Creates a new 'workgroup' scoped array buffer.\n *\n * @function\n * @param {String} type - The data type of a 'workgroup' scoped buffer element.\n * @param {Number} [count=0] - The number of elements in the buffer.\n * @returns {WorkgroupInfoNode}\n */\nconst workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );\n\n/** @module AtomicFunctionNode **/\n\n/**\n * `AtomicFunctionNode` represents any function that can operate on atomic variable types\n * within a shader. In an atomic function, any modifiation to an atomic variable will\n * occur as an indivisble step with a defined order relative to other modifications.\n * Accordingly, even if multiple atomic functions are modifying an atomic variable at once\n * atomic operations will not interfer with each other.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments TempNode\n */\nclass AtomicFunctionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AtomicFunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new atomic function node.\n\t *\n\t * @param {String} method - The signature of the atomic function to construct.\n\t * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n\t * @param {Node} valueNode - The value that mutates the atomic variable.\n\t * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n\t */\n\tconstructor( method, pointerNode, valueNode, storeNode = null ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The signature of the atomic function to construct.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * An atomic variable or element of an atomic buffer.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.pointerNode = pointerNode;\n\n\t\t/**\n\t\t * A value that modifies the atomic variable.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.storeNode = storeNode;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return the type of\n\t * the pointer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.pointerNode.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the input type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {String} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getInputType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.pointerNode;\n\t\tconst b = this.valueNode;\n\n\t\tconst params = [];\n\n\t\tparams.push( `&${ a.build( builder, inputType ) }` );\n\t\tparams.push( b.build( builder, inputType ) );\n\n\t\tconst methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tconst varSnippet = this.storeNode.build( builder, inputType );\n\n\t\t\tbuilder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( methodSnippet, this );\n\n\t\t}\n\n\t}\n\n}\n\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\n/**\n * TSL function for creating an atomic function node.\n *\n * @function\n * @param {String} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicNode = nodeProxy( AtomicFunctionNode );\n\n/**\n * TSL function for appending an atomic function call into the programmatic flow of a compute shader.\n *\n * @function\n * @param {String} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicFunc = ( method, pointerNode, valueNode, storeNode = null ) => {\n\n\tconst node = atomicNode( method, pointerNode, valueNode, storeNode );\n\tnode.append();\n\n\treturn node;\n\n};\n\n/**\n * Stores a value in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );\n\n/**\n * Increments the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );\n\n/**\n * Decrements the value stored in the atomic variable.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the maximum between its current value and a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the minimum between its current value and a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the bitwise AND of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the bitwise OR of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );\n\n/**\n * Stores in an atomic variable the bitwise XOR of its value with a parameter.\n *\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.\n * @returns {AtomicFunctionNode}\n */\nconst atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );\n\n/** @module Lights **/\n\nlet uniformsLib;\n\nfunction getLightData( light ) {\n\n\tuniformsLib = uniformsLib || new WeakMap();\n\n\tlet uniforms = uniformsLib.get( light );\n\n\tif ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );\n\n\treturn uniforms;\n\n}\n\n/**\n * TSL function for getting a shadow matrix uniform node for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<mat4>} The shadow matrix uniform node.\n */\nfunction lightShadowMatrix( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\tif ( light.castShadow !== true ) {\n\n\t\t\tlight.shadow.updateMatrices( light );\n\n\t\t}\n\n\t\treturn light.shadow.matrix;\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting projected uv coordinates for the given light.\n * Relevant when using maps with spot lights.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The projected uvs.\n */\nfunction lightProjectionUV( light ) {\n\n\tconst data = getLightData( light );\n\n\tif ( data.projectionUV === undefined ) {\n\n\t\tconst spotLightCoord = lightShadowMatrix( light ).mul( positionWorld );\n\n\t\tdata.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\n\n\t}\n\n\treturn data.projectionUV;\n\n}\n\n/**\n * TSL function for getting the position in world space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in world space.\n */\nfunction lightPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the light target position in world space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light target position in world space.\n */\nfunction lightTargetPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the position in view space for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in view space.\n */\nfunction lightViewPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\tself.value = self.value || new Vector3();\n\t\tself.value.setFromMatrixPosition( light.matrixWorld );\n\n\t\tself.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting the light target direction for the given light.\n *\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The light's target direction.\n */\nconst lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );\n\n/** @module LightsNode **/\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nconst getLightNodeById = ( id, lightNodes ) => {\n\n\tfor ( const lightNode of lightNodes ) {\n\n\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\treturn lightNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\nconst _lightsNodeRef = /*@__PURE__*/ new WeakMap();\n\n/**\n * This node represents the scene's lighting and manages the lighting model's life cycle\n * for the current build 3D object. It is responsible for computing the total outgoing\n * light in a given lighting context.\n *\n * @augments Node\n */\nclass LightsNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightsNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lights node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * A node representing the total diffuse light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );\n\n\t\t/**\n\t\t * A node representing the total specular light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalSpecularNode = vec3().toVar( 'totalSpecular' );\n\n\t\t/**\n\t\t * A node representing the outgoing light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.outgoingLightNode = vec3().toVar( 'outgoingLight' );\n\n\t\t/**\n\t\t * An array representing the lights in the scene.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis._lights = [];\n\n\t\t/**\n\t\t * For each light in the scene, this node will create a\n\t\t * corresponding light node.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<LightingNode>?}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodes = null;\n\n\t\t/**\n\t\t * A hash for identifying the current light nodes setup.\n\t\t *\n\t\t * @private\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodesHash = null;\n\n\t\t/**\n\t\t * `LightsNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default {@link Node#customCacheKey} implementation by including the\n\t * light IDs into the cache key.\n\t *\n\t * @return {Number} The custom cache key.\n\t */\n\tcustomCacheKey() {\n\n\t\tconst lightIDs = [];\n\t\tconst lights = this._lights;\n\n\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\tlightIDs.push( lights[ i ].id );\n\n\t\t}\n\n\t\treturn hashArray( lightIDs );\n\n\t}\n\n\t/**\n\t * Computes a hash value for identifying the current light nodes setup.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {String} The computed hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this._lightNodesHash === null ) {\n\n\t\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this._lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getSelf().getHash() );\n\n\t\t\t}\n\n\t\t\tthis._lightNodesHash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._lightNodesHash;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst properties = builder.getDataFromNode( this );\n\n\t\tfor ( const node of properties.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates lighting nodes for each scene light. This makes it possible to further\n\t * process lights in the node system.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t */\n\tsetupLightsNode( builder ) {\n\n\t\tconst lightNodes = [];\n\n\t\tconst previousLightNodes = this._lightNodes;\n\n\t\tconst lights = sortLights( this._lights );\n\t\tconst nodeLibrary = builder.renderer.library;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isNode ) {\n\n\t\t\t\tlightNodes.push( nodeObject( light ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet lightNode = null;\n\n\t\t\t\tif ( previousLightNodes !== null ) {\n\n\t\t\t\t\tlightNode = getLightNodeById( light.id, previousLightNodes ); // reuse existing light node\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightNode === null ) {\n\n\t\t\t\t\t// find the corresponding node type for a given light\n\n\t\t\t\t\tconst lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );\n\n\t\t\t\t\tif ( lightNodeClass === null ) {\n\n\t\t\t\t\t\tconsole.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lightNode = null;\n\n\t\t\t\t\tif ( ! _lightsNodeRef.has( light ) ) {\n\n\t\t\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\t\t\t\t\t\t_lightsNodeRef.set( light, lightNode );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlightNode = _lightsNodeRef.get( light );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlightNodes.push( lightNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._lightNodes = lightNodes;\n\n\t}\n\n\t/**\n\t * Setups the internal lights by building all respective\n\t * light nodes.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.\n\t */\n\tsetupLights( builder, lightNodes ) {\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The implementation makes sure that for each light in the scene\n\t * there is a corresponding light node. By building the light nodes\n\t * and evaluating the lighting model the outgoing light is computed.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} A node representing the outgoing light.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tconst properties = builder.getDataFromNode( this );\n\t\t\tproperties.nodes = stack.nodes;\n\n\t\t\t//\n\n\t\t\tlightingModel.start( context, stack, builder );\n\n\t\t\t// lights\n\n\t\t\tthis.setupLights( builder, _lightNodes );\n\n\t\t\t//\n\n\t\t\tlightingModel.indirect( context, stack, builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\tif ( backdropAlpha !== null ) {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdrop );\n\n\t\t\t\t}\n\n\t\t\t\tcontext.material.transparent = true;\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( context, stack, builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Configures this node with an array of lights.\n\t *\n\t * @param {Array<Light>} lights - An array of lights.\n\t * @return {LightsNode} A reference to this node.\n\t */\n\tsetLights( lights ) {\n\n\t\tthis._lights = lights;\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an array of the scene's lights.\n\t *\n\t * @return {Array<Light>} The scene's lights.\n\t */\n\tgetLights() {\n\n\t\treturn this._lights;\n\n\t}\n\n\t/**\n\t * Whether the scene has lights or not.\n\t *\n\t * @type {Boolean}\n\t */\n\tget hasLights() {\n\n\t\treturn this._lights.length > 0;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `LightsNode` and configuring\n * it with the given array of lights.\n *\n * @function\n * @param {Array<Light>} lights - An array of lights.\n * @return {LightsNode} The created lights node.\n */\nconst lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );\n\n/** @module ShadowBaseNode **/\n\n/**\n * Base class for all shadow nodes.\n *\n * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.\n * Lighting nodes might share the same shadow node type or use specific ones depending on\n * their requirements.\n *\n * @augments Node\n */\nclass ShadowBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow base node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t */\n\tconstructor( light ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The shadow casting light.\n\t\t *\n\t\t * @type {Light}\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * Overwritten since shadows are updated by default per render.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowBaseNode = true;\n\n\t}\n\n\t/**\n\t * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.\n\t *\n\t * @param {(NodeBuilder|{Material})} object - A configuration object that must at least hold a material reference.\n\t */\n\tsetupShadowPosition( { material } ) {\n\n\t\t// Use assign inside an Fn()\n\n\t\tshadowPositionWorld.assign( material.shadowPositionNode || positionWorld );\n\n\t}\n\n\t/**\n\t * Can be called when the shadow isn't required anymore. That can happen when\n\t * a lighting node stops casting shadows by setting {@link Object3D#castShadow}\n\t * to `false`.\n\t */\n\tdispose() {\n\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t}\n\n}\n\n/**\n * TSL object that represents the vertex position in world space during the shadow pass.\n *\n * @type {Node<vec3>}\n */\nconst shadowPositionWorld = /*@__PURE__*/ vec3().toVar( 'shadowPositionWorld' );\n\n/** @module RendererUtils **/\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererState( renderer, state = {} ) {\n\n\tstate.toneMapping = renderer.toneMapping;\n\tstate.toneMappingExposure = renderer.toneMappingExposure;\n\tstate.outputColorSpace = renderer.outputColorSpace;\n\tstate.renderTarget = renderer.getRenderTarget();\n\tstate.activeCubeFace = renderer.getActiveCubeFace();\n\tstate.activeMipmapLevel = renderer.getActiveMipmapLevel();\n\tstate.renderObjectFunction = renderer.getRenderObjectFunction();\n\tstate.pixelRatio = renderer.getPixelRatio();\n\tstate.mrt = renderer.getMRT();\n\tstate.clearColor = renderer.getClearColor( state.clearColor || new Color() );\n\tstate.clearAlpha = renderer.getClearAlpha();\n\tstate.autoClear = renderer.autoClear;\n\tstate.scissorTest = renderer.getScissorTest();\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n * Besides, the function also resets the state of the renderer to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererState( renderer, state ) {\n\n\tstate = saveRendererState( renderer, state );\n\n\trenderer.setMRT( null );\n\trenderer.setRenderObjectFunction( null );\n\trenderer.setClearColor( 0x000000, 1 );\n\trenderer.autoClear = true;\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given renderer from the given state object.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererState( renderer, state ) {\n\n\trenderer.toneMapping = state.toneMapping;\n\trenderer.toneMappingExposure = state.toneMappingExposure;\n\trenderer.outputColorSpace = state.outputColorSpace;\n\trenderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );\n\trenderer.setRenderObjectFunction( state.renderObjectFunction );\n\trenderer.setPixelRatio( state.pixelRatio );\n\trenderer.setMRT( state.mrt );\n\trenderer.setClearColor( state.clearColor, state.clearAlpha );\n\trenderer.autoClear = state.autoClear;\n\trenderer.setScissorTest( state.scissorTest );\n\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveSceneState( scene, state = {} ) {\n\n\tstate.background = scene.background;\n\tstate.backgroundNode = scene.backgroundNode;\n\tstate.overrideMaterial = scene.overrideMaterial;\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n * Besides, the function also resets the state of the scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetSceneState( scene, state ) {\n\n\tstate = saveSceneState( scene, state );\n\n\tscene.background = null;\n\tscene.backgroundNode = null;\n\tscene.overrideMaterial = null;\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given scene from the given state object.\n *\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreSceneState( scene, state ) {\n\n\tscene.background = state.background;\n\tscene.backgroundNode = state.backgroundNode;\n\tscene.overrideMaterial = state.overrideMaterial;\n\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererAndSceneState( renderer, scene, state = {} ) {\n\n\tstate = saveRendererState( renderer, state );\n\tstate = saveSceneState( scene, state );\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n * Besides, the function also resets the state of the renderer and scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererAndSceneState( renderer, scene, state ) {\n\n\tstate = resetRendererState( renderer, state );\n\tstate = resetSceneState( scene, state );\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given renderer and scene from the given state object.\n *\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererAndSceneState( renderer, scene, state ) {\n\n\trestoreRendererState( renderer, state );\n\trestoreSceneState( scene, state );\n\n}\n\nvar RendererUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tresetRendererAndSceneState: resetRendererAndSceneState,\n\tresetRendererState: resetRendererState,\n\tresetSceneState: resetSceneState,\n\trestoreRendererAndSceneState: restoreRendererAndSceneState,\n\trestoreRendererState: restoreRendererState,\n\trestoreSceneState: restoreSceneState,\n\tsaveRendererAndSceneState: saveRendererAndSceneState,\n\tsaveRendererState: saveRendererState,\n\tsaveSceneState: saveSceneState\n});\n\n/** @module ShadowNode **/\n\nconst shadowMaterialLib = /*@__PURE__*/ new WeakMap();\nconst linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {\n\n\tlet dist = positionWorld.sub( position ).length();\n\tdist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );\n\tdist = dist.saturate(); // clamp to [ 0, 1 ]\n\n\treturn dist;\n\n} );\n\nconst linearShadowDistance = ( light ) => {\n\n\tconst camera = light.shadow.camera;\n\n\tconst nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );\n\tconst farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );\n\n\tconst referencePosition = objectPosition( light );\n\n\treturn linearDistance( referencePosition, nearDistance, farDistance );\n\n};\n\nconst getShadowMaterial = ( light ) => {\n\n\tlet material = shadowMaterialLib.get( light );\n\n\tif ( material === undefined ) {\n\n\t\tconst depthNode = light.isPointLight ? linearShadowDistance( light ) : null;\n\n\t\tmaterial = new NodeMaterial();\n\t\tmaterial.colorNode = vec4( 0, 0, 0, 1 );\n\t\tmaterial.depthNode = depthNode;\n\t\tmaterial.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n\t\tmaterial.name = 'ShadowMaterial';\n\t\tmaterial.fog = false;\n\n\t\tshadowMaterialLib.set( light, material );\n\n\t}\n\n\treturn material;\n\n};\n\n/**\n * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map\n * with a binary `[0,1]` result.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\treturn texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );\n\n} );\n\n/**\n * A shadow filtering function performing PCF filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx0 = texelSize.x.negate().mul( radius );\n\tconst dy0 = texelSize.y.negate().mul( radius );\n\tconst dx1 = texelSize.x.mul( radius );\n\tconst dy1 = texelSize.y.mul( radius );\n\tconst dx2 = dx0.div( 2 );\n\tconst dy2 = dy0.div( 2 );\n\tconst dx3 = dx1.div( 2 );\n\tconst dy3 = dy1.div( 2 );\n\n\treturn add(\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy, shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t).mul( 1 / 17 );\n\n} );\n\n/**\n * A shadow filtering function performing PCF soft filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {\n\n\tconst depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx = texelSize.x;\n\tconst dy = texelSize.y;\n\n\tconst uv = shadowCoord.xy;\n\tconst f = fract( uv.mul( mapSize ).add( 0.5 ) );\n\tuv.subAssign( f.mul( texelSize ) );\n\n\treturn add(\n\t\tdepthCompare( uv, shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( texelSize ), shadowCoord.z ),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tf.y\n\t\t)\n\t).mul( 1 / 9 );\n\n} );\n\n/**\n * A shadow filtering function performing VSM filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {\n\n\tconst occlusion = float( 1 ).toVar();\n\n\tconst distribution = texture( depthTexture ).sample( shadowCoord.xy ).rg;\n\n\tconst hardShadow = step( shadowCoord.z, distribution.x );\n\n\tIf( hardShadow.notEqual( float( 1.0 ) ), () => {\n\n\t\tconst distance = shadowCoord.z.sub( distribution.x );\n\t\tconst variance = max$1( 0, distribution.y.mul( distribution.y ) );\n\t\tlet softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality\n\t\tsoftnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );\n\t\tocclusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );\n\n\t} );\n\n\treturn occlusion;\n\n} );\n\n/**\n * Represents the shader code for the first VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst depth = shadowPass.sample( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;\n\t\tmean.addAssign( depth );\n\t\tsquaredMean.addAssign( depth.mul( depth ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\n/**\n * Represents the shader code for the second VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {\n\n\tconst mean = float( 0 ).toVar();\n\tconst squaredMean = float( 0 ).toVar();\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tconst distribution = shadowPass.sample( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );\n\t\tmean.addAssign( distribution.x );\n\t\tsquaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];\n\n//\n\nlet _rendererState;\nconst _quadMesh$1 = /*@__PURE__*/ new QuadMesh();\n\n/**\n * Represents the default shadow implementation for lighting nodes.\n *\n * @augments module:ShadowBaseNode~ShadowBaseNode\n */\nclass ShadowNode extends ShadowBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t * @param {LightShadow?} [shadow=null] - An optional light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * The light shadow which defines the properties light's\n\t\t * shadow.\n\t\t *\n\t\t * @type {LightShadow?}\n\t\t * @default null\n\t\t */\n\t\tthis.shadow = shadow || light.shadow;\n\n\t\t/**\n\t\t * A reference to the shadow map which is a render target.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.shadowMap = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * first VSM render pass.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * second VSM render pass.\n\t\t *\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the first VSM pass.\n\t\t *\n\t\t * @type {NodeMaterial?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the second VSM pass.\n\t\t *\n\t\t * @type {NodeMaterial?}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t/**\n\t\t * A reference to the output node which defines the\n\t\t * final result of this shadow node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._node = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNode = true;\n\n\t}\n\n\t/**\n\t * Setups the shadow filtering.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {\n\n\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\tconst shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );\n\n\t\treturn frustumTest.select( shadowNode, float( 1 ) );\n\n\t}\n\n\t/**\n\t * Setups the shadow coordinates.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\tconst { shadow } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tlet shadowCoord = shadowPosition;\n\t\tlet coordZ;\n\n\t\tif ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {\n\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tcoordZ = shadowCoord.z;\n\n\t\t\tif ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst w = shadowCoord.w;\n\t\t\tshadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z\n\n\t\t\t// The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n\t\t\t// updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n\t\t\t// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n\t\t\tconst cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );\n\t\t\tconst cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );\n\n\t\t\tcoordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );\n\n\t\t}\n\n\t\tshadowCoord = vec3(\n\t\t\tshadowCoord.x,\n\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\tcoordZ.add( bias )\n\t\t);\n\n\t\treturn shadowCoord;\n\n\t}\n\n\t/**\n\t * Returns the shadow filtering function for the given shadow type.\n\t *\n\t * @param {Number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn _shadowFilterLib[ type ];\n\n\t}\n\n\t/**\n\t * Setups the shadow output node.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} The shadow output node.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst { light, shadow } = this;\n\n\t\tconst shadowMapType = renderer.shadowMap.type;\n\n\t\tconst depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );\n\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\tconst shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\t\tshadowMap.depthTexture = depthTexture;\n\n\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t// VSM\n\n\t\tif ( shadowMapType === VSMShadowMap ) {\n\n\t\t\tdepthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n\t\t\tthis.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\t\t\tthis.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );\n\n\t\t\tconst shadowPassVertical = texture( depthTexture );\n\t\t\tconst shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );\n\n\t\t\tconst samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\t\t\tlet material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMVertical';\n\n\t\t\tmaterial = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMHorizontal';\n\n\t\t}\n\n\t\t//\n\n\t\tconst shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );\n\t\tconst normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tconst shadowPosition = lightShadowMatrix( light ).mul( shadowPositionWorld.add( transformedNormalWorld.mul( normalBias ) ) );\n\t\tconst shadowCoord = this.setupShadowCoord( builder, shadowPosition );\n\n\t\t//\n\n\t\tconst filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;\n\n\t\tif ( filterFn === null ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );\n\n\t\t}\n\n\t\tconst shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;\n\n\t\tconst shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );\n\n\t\tconst shadowColor = texture( shadowMap.texture, shadowCoord );\n\t\tconst shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();\n\n\t\tthis.shadowMap = shadowMap;\n\t\tthis.shadow.map = shadowMap;\n\n\t\treturn shadowOutput;\n\n\t}\n\n\t/**\n\t * The implementation performs the setup of the output node. An output is only\n\t * produces if shadow mapping is globally enabled in the renderer.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {ShaderCallNodeInternal} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( builder.renderer.shadowMap.enabled === false ) return;\n\n\t\treturn Fn( () => {\n\n\t\t\tlet node = this._node;\n\n\t\t\tthis.setupShadowPosition( builder );\n\n\t\t\tif ( node === null ) {\n\n\t\t\t\tthis._node = node = this.setupShadow( builder );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.shadowNode ) { // @deprecated, r171\n\n\t\t\t\tconsole.warn( 'THREE.NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.' );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.receivedShadowNode ) {\n\n\t\t\t\tnode = builder.material.receivedShadowNode( node );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Renders the shadow. The logic of this function could be included\n\t * into {@link ShadowNode#updateShadow} however more specialized shadow\n\t * nodes might require a custom shadow map rendering. By having a\n\t * dedicated method, it's easier to overwrite the default behavior.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tshadow.updateMatrices( light );\n\n\t\tshadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.render( scene, shadow.camera );\n\n\t}\n\n\t/**\n\t * Updates the shadow.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light, shadow } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\n\t\tconst shadowType = renderer.shadowMap.type;\n\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\n\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst useVelocity = currentMRT ? currentMRT.has( 'velocity' ) : false;\n\n\t\t_rendererState = resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, _camera, geometry, material, group, ...params ) => {\n\n\t\t\tif ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {\n\n\t\t\t\tif ( useVelocity ) {\n\n\t\t\t\t\tgetDataFromObject( object ).useVelocity = true;\n\n\t\t\t\t}\n\n\t\t\t\tobject.onBeforeShadow( renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t\trenderer.renderObject( object, scene, _camera, geometry, material, group, ...params );\n\n\t\t\t\tobject.onAfterShadow( renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.setRenderTarget( shadowMap );\n\n\t\tthis.renderShadow( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\t// vsm blur pass\n\n\t\tif ( light.isPointLight !== true && shadowType === VSMShadowMap ) {\n\n\t\t\tthis.vsmPass( renderer );\n\n\t\t}\n\n\t\trestoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * For VSM additional render passes are required.\n\t *\n\t * @param {Renderer} renderer - A reference to the current renderer.\n\t */\n\tvsmPass( renderer ) {\n\n\t\tconst { shadow } = this;\n\n\t\tthis.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\t\tthis.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapVertical );\n\t\t_quadMesh$1.material = this.vsmMaterialVertical;\n\t\t_quadMesh$1.render( renderer );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapHorizontal );\n\t\t_quadMesh$1.material = this.vsmMaterialHorizontal;\n\t\t_quadMesh$1.render( renderer );\n\n\t}\n\n\t/**\n\t * Frees the internal resources of this shadow node.\n\t */\n\tdispose() {\n\n\t\tthis.shadowMap.dispose();\n\t\tthis.shadowMap = null;\n\n\t\tif ( this.vsmShadowMapVertical !== null ) {\n\n\t\t\tthis.vsmShadowMapVertical.dispose();\n\t\t\tthis.vsmShadowMapVertical = null;\n\n\t\t\tthis.vsmMaterialVertical.dispose();\n\t\t\tthis.vsmMaterialVertical = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapHorizontal !== null ) {\n\n\t\t\tthis.vsmShadowMapHorizontal.dispose();\n\t\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t\tthis.vsmMaterialHorizontal.dispose();\n\t\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t}\n\n\t\tsuper.dispose();\n\n\t}\n\n\t/**\n\t * The implementation performs the update of the shadow map if necessary.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { shadow } = this;\n\n\t\tconst needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `ShadowNode`.\n *\n * @function\n * @param {Light} light - The shadow casting light.\n * @param {LightShadow} shadow - The light shadow.\n * @return {ShadowNode} The created shadow node.\n */\nconst shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );\n\n/**\n * Base class for analytic light nodes.\n *\n * @augments LightingNode\n */\nclass AnalyticLightNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AnalyticLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new analytic light node.\n\t *\n\t * @param {Light?} [light=null] - The light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light source.\n\t\t *\n\t\t * @type {Light?}\n\t\t * @default null\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * The light's color value.\n\t\t *\n\t\t * @type {Color}\n\t\t */\n\t\tthis.color = new Color();\n\n\t\t/**\n\t\t * The light's color node. Points to `colorNode` of the light source, if set. Otherwise\n\t\t * it creates a uniform node based on {@link AnalyticLightNode#color}.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.\n\t\t * The final color node is represented by a different node when using shadows.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.baseColorNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow.\n\t\t *\n\t\t * @type {ShadowNode?}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow color.\n\t\t *\n\t\t * @type {Node?}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowColorNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAnalyticLightNode = true;\n\n\t\t/**\n\t\t * Overwritten since analytic light nodes are updated\n\t\t * once per frame.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Overwrites the default {@link Node#customCacheKey} implementation by including the\n\t * `light.id` and `light.castShadow` into the cache key.\n\t *\n\t * @return {Number} The custom cache key.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn hash$1( this.light.id, this.light.castShadow ? 1 : 0 );\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\t/**\n\t * Setups the shadow node for this light. The method exists so concrete light classes\n\t * can setup different types of shadow nodes.\n\t *\n\t * @return {ShadowNode} The created shadow node.\n\t */\n\tsetupShadowNode() {\n\n\t\treturn shadow( this.light );\n\n\t}\n\n\t/**\n\t * Setups the shadow for this light. This method is only executed if the light\n\t * cast shadows and the current build object receives shadows. It incorporates\n\t * shadows into the lighting computation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.shadowMap.enabled === false ) return;\n\n\t\tlet shadowColorNode = this.shadowColorNode;\n\n\t\tif ( shadowColorNode === null ) {\n\n\t\t\tconst customShadowNode = this.light.shadow.shadowNode;\n\n\t\t\tlet shadowNode;\n\n\t\t\tif ( customShadowNode !== undefined ) {\n\n\t\t\t\tshadowNode = nodeObject( customShadowNode );\n\n\t\t\t} else {\n\n\t\t\t\tshadowNode = this.setupShadowNode( builder );\n\n\t\t\t}\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\tthis.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );\n\n\t\t\tthis.baseColorNode = this.colorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.colorNode = shadowColorNode;\n\n\t}\n\n\t/**\n\t * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.\n\t * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or\n\t * invocate the respective interface methods.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tthis.colorNode = this.baseColorNode || this.colorNode;\n\n\t\tif ( this.light.castShadow ) {\n\n\t\t\tif ( builder.object.receiveShadow ) {\n\n\t\t\t\tthis.setupShadow( builder );\n\n\t\t\t}\n\n\t\t} else if ( this.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.dispose();\n\t\t\tthis.shadowNode = null;\n\t\t\tthis.shadowColorNode = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The update method is used to update light uniforms per frame.\n\t * Potentially overwritten in concrete light nodes to update light\n\t * specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\n/** @module LightUtils **/\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.\n * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.\n * @param {Node<float>} inputs.decayExponent - The light's decay exponent.\n * @return {Node<float>} The distance falloff.\n */\nconst getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { lightDistance, cutoffDistance, decayExponent } = inputs;\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();\n\n\treturn cutoffDistance.greaterThan( 0 ).select(\n\t\tdistanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\n/** @module PointShadowNode **/\n\nconst _clearColor$2 = /*@__PURE__*/ new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {\n\n\tconst v = pos.toVar();\n\n\t// Number of texels to avoid at the edge of each square\n\n\tconst absV = abs( v );\n\n\t// Intersect unit cube\n\n\tconst scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );\n\tabsV.mulAssign( scaleToCube );\n\n\t// Apply scale to avoid seams\n\n\t// two texels less per square (one texel will do for NEAREST)\n\tv.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );\n\n\t// Unwrap\n\n\t// space: -1 ... 1 range for each square\n\t//\n\t// #X##\t\tdim    := ( 4 , 2 )\n\t//  # #\t\tcenter := ( 1 , 1 )\n\n\tconst planar = vec2( v.xy ).toVar();\n\n\tconst almostATexel = texelSizeY.mul( 1.5 );\n\tconst almostOne = almostATexel.oneMinus();\n\n\tIf( absV.z.greaterThanEqual( almostOne ), () => {\n\n\t\tIf( v.z.greaterThan( 0.0 ), () => {\n\n\t\t\tplanar.x.assign( sub( 4.0, v.x ) );\n\n\t\t} );\n\n\t} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signX = sign( v.x );\n\t\tplanar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );\n\n\t} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signY = sign( v.y );\n\t\tplanar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );\n\t\tplanar.y.assign( v.z.mul( signY ).sub( 2.0 ) );\n\n\t} );\n\n\t// Transform to UV space\n\n\t// scale := 0.5 / dim\n\t// translate := ( center + 0.5 ) / dim\n\treturn vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();\n\n} ).setLayout( {\n\tname: 'cubeToUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'pos', type: 'vec3' },\n\t\t{ name: 'texelSizeY', type: 'float' }\n\t]\n} );\n\nconst BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {\n\n\treturn texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );\n\n} );\n\nconst PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {\n\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\tconst offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );\n\n\treturn texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )\n\t\t.mul( 1.0 / 9.0 );\n\n} );\n\nconst pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {\n\n\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t// the vector from the light to the world-space position of the fragment.\n\tconst lightToPosition = shadowCoord.xyz.toVar();\n\tconst lightToPositionLength = lightToPosition.length();\n\n\tconst cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );\n\tconst cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );\n\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\tconst mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );\n\n\tconst result = float( 1.0 ).toVar();\n\n\tIf( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tconst dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?\n\t\tdp.addAssign( bias );\n\n\t\t// bd3D = base direction 3D\n\t\tconst bd3D = lightToPosition.normalize();\n\t\tconst texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );\n\n\t\t// percentage-closer filtering\n\t\tresult.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );\n\n\t} );\n\n\treturn result;\n\n} );\n\nconst _viewport = /*@__PURE__*/ new Vector4();\nconst _viewportSize = /*@__PURE__*/ new Vector2();\nconst _shadowMapSize = /*@__PURE__*/ new Vector2();\n\n\n/**\n * Represents the shadow implementation for point light nodes.\n *\n * @augments module:ShadowNode~ShadowNode\n */\nclass PointShadowNode extends ShadowNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point shadow node.\n\t *\n\t * @param {PointLight} light - The shadow casting point light.\n\t * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light, shadow );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return point light shadow specific\n\t * filtering functions.\n\t *\n\t * @param {Number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation so the unaltered shadow position is used.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\treturn shadowPosition;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to only use point light specific\n\t * shadow filter functions.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {\n\n\t\treturn pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation with point light specific\n\t * rendering code.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\tshadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );\n\n\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t//\n\n\t\tconst previousAutoClear = renderer.autoClear;\n\n\t\tconst previousClearColor = renderer.getClearColor( _clearColor$2 );\n\t\tconst previousClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.autoClear = false;\n\t\trenderer.setClearColor( shadow.clearColor, shadow.clearAlpha );\n\t\trenderer.clear();\n\n\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\tconst x = _viewportSize.x * viewport.x;\n\t\t\tconst y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );\n\n\t\t\t_viewport.set(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t);\n\n\t\t\tshadowMap.viewport.copy( _viewport );\n\n\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\trenderer.render( scene, shadow.camera );\n\n\t\t}\n\n\t\t//\n\n\t\trenderer.autoClear = previousAutoClear;\n\t\trenderer.setClearColor( previousClearColor, previousClearAlpha );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `PointShadowNode`.\n *\n * @function\n * @param {PointLight} light - The shadow casting point light.\n * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.\n * @return {PointShadowNode} The created point shadow node.\n */\nconst pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );\n\nconst directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {\n\n\tconst lightingModel = builder.context.lightingModel;\n\n\tconst lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode\n\n\tconst lightDirection = lVector.normalize();\n\tconst lightDistance = lVector.length();\n\n\tconst lightAttenuation = getDistanceAttenuation( {\n\t\tlightDistance,\n\t\tcutoffDistance,\n\t\tdecayExponent\n\t} );\n\n\tconst lightColor = color.mul( lightAttenuation );\n\n\tconst reflectedLight = builder.context.reflectedLight;\n\n\tlightingModel.direct( {\n\t\tlightDirection,\n\t\tlightColor,\n\t\treflectedLight\n\t}, builder.stack, builder );\n\n} );\n\n/**\n * Module for representing point lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass PointLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point light node.\n\t *\n\t * @param {PointLight?} [light=null] - The point light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the cutoff distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the decay exponent.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.decayExponentNode = uniform( 2 ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated point light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\t/**\n\t * Overwritten to setup point light specific shadow.\n\t *\n\t * @return {PointShadowNode}\n\t */\n\tsetupShadowNode() {\n\n\t\treturn pointShadow( this.light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tdirectPointLight( {\n\t\t\tcolor: this.colorNode,\n\t\t\tlightViewPosition: lightViewPosition( this.light ),\n\t\t\tcutoffDistance: this.cutoffDistanceNode,\n\t\t\tdecayExponent: this.decayExponentNode\n\t\t} ).append();\n\n\t}\n\n}\n\n/** @module Procedural **/\n\n/**\n * Creates a 2x2 checkerboard pattern that can be used as procedural texture data.\n *\n * @method\n * @param {Node<vec2>} coord - The uv coordinates.\n * @return {Node<float>} The result data.\n */\nconst checker = /*@__PURE__*/ Fn( ( [ coord = uv() ] ) => {\n\n\tconst uv = coord.mul( 2.0 );\n\n\tconst cx = uv.x.floor();\n\tconst cy = uv.y.floor();\n\tconst result = cx.add( cy ).mod( 2.0 );\n\n\treturn result.sign();\n\n} );\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\n\n\nconst mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {\n\n\tconst f = float( f_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst b = bool( b_immutable ).toVar();\n\n\treturn select( b, t, f );\n\n} ).setLayout( {\n\tname: 'mx_select',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'b', type: 'bool' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'f', type: 'float' }\n\t]\n} );\n\nconst mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {\n\n\tconst b = bool( b_immutable ).toVar();\n\tconst val = float( val_immutable ).toVar();\n\n\treturn select( b, val.negate(), val );\n\n} ).setLayout( {\n\tname: 'mx_negate_if',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'val', type: 'float' },\n\t\t{ name: 'b', type: 'bool' }\n\t]\n} );\n\nconst mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\n\treturn int( floor( x ) );\n\n} ).setLayout( {\n\tname: 'mx_floor',\n\ttype: 'int',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\ti.assign( mx_floor( x ) );\n\n\treturn x.sub( float( i ) );\n\n} );\n\nconst mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );\n\nconst mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = float( v7_immutable ).toVar();\n\tconst v6 = float( v6_immutable ).toVar();\n\tconst v5 = float( v5_immutable ).toVar();\n\tconst v4 = float( v4_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 'v4', type: 'float' },\n\t\t{ name: 'v5', type: 'float' },\n\t\t{ name: 'v6', type: 'float' },\n\t\t{ name: 'v7', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = vec3( v7_immutable ).toVar();\n\tconst v6 = vec3( v6_immutable ).toVar();\n\tconst v5 = vec3( v5_immutable ).toVar();\n\tconst v4 = vec3( v4_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 'v4', type: 'vec3' },\n\t\t{ name: 'v5', type: 'vec3' },\n\t\t{ name: 'v6', type: 'vec3' },\n\t\t{ name: 'v7', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );\n\nconst mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();\n\tconst v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();\n\tconst v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );\n\nconst mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );\n\nconst mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );\n\nconst mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );\n\nconst mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {\n\n\tconst k = int( k_immutable ).toVar();\n\tconst x = uint( x_immutable ).toVar();\n\n\treturn x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );\n\n} ).setLayout( {\n\tname: 'mx_rotl32',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'uint' },\n\t\t{ name: 'k', type: 'int' }\n\t]\n} );\n\nconst mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {\n\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 4 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 6 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 8 ) ) );\n\tb.addAssign( a );\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 16 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 19 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 4 ) ) );\n\tb.addAssign( a );\n\n} );\n\nconst mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {\n\n\tconst c = uint( c_immutable ).toVar();\n\tconst b = uint( b_immutable ).toVar();\n\tconst a = uint( a_immutable ).toVar();\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 14 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 11 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 25 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 16 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 4 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 14 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 24 ) ) );\n\n\treturn c;\n\n} ).setLayout( {\n\tname: 'mx_bjfinal',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'a', type: 'uint' },\n\t\t{ name: 'b', type: 'uint' },\n\t\t{ name: 'c', type: 'uint' }\n\t]\n} );\n\nconst mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {\n\n\tconst bits = uint( bits_immutable ).toVar();\n\n\treturn float( bits ).div( float( uint( int( 0xffffffff ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bits_to_01',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'bits', type: 'uint' }\n\t]\n} );\n\nconst mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\n\treturn t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );\n\n} ).setLayout( {\n\tname: 'mx_fade',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 1 ) ).toVar();\n\tconst seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();\n\n\treturn mx_bjfinal( seed.add( uint( x ) ), seed, seed );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_0',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 2 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_1',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 3 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_2',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {\n\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 4 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_3',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {\n\n\tconst yy = int( yy_immutable ).toVar();\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 5 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\tb.addAssign( uint( yy ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_4',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' },\n\t\t{ name: 'yy', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );\n\nconst mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_0',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y, z ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_1',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );\n\nconst mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );\n\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );\n\nconst mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_2',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_3',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );\n\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_2',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );\n\nconst mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = float( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_float',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = vec3( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\n\treturn vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec2',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();\n\tconst f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();\n\n\treturn vec4( c, f );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec4',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();\n\tconst off = vec2( tmp.x, tmp.y ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();\n\tconst diff = vec2( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( abs( diff.x ), abs( diff.y ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst zoff = int( zoff_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();\n\tconst diff = vec3( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( max$1( abs( diff.x ), abs( diff.y ) ), abs( diff.z ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'zoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );\n\nconst mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_0',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\t\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );\n\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_1',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );\n\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\n\nconst mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {\n\n\tconst s = hsv.y;\n\tconst v = hsv.z;\n\n\tconst result = vec3().toVar();\n\n\tIf( s.lessThan( 0.0001 ), () => {\n\n\t\tresult.assign( vec3( v, v, v ) );\n\n\t} ).Else( () => {\n\n\t\tlet h = hsv.x;\n\t\th = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache\n\t\tconst hi = int( trunc( h ) );\n\t\tconst f = h.sub( float( hi ) );\n\t\tconst p = v.mul( s.oneMinus() );\n\t\tconst q = v.mul( s.mul( f ).oneMinus() );\n\t\tconst t = v.mul( s.mul( f.oneMinus() ).oneMinus() );\n\n\t\tIf( hi.equal( int( 0 ) ), () => {\n\n\t\t\tresult.assign( vec3( v, t, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 1 ) ), () => {\n\n\t\t\tresult.assign( vec3( q, v, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 2 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, v, t ) );\n\n\t\t} ).ElseIf( hi.equal( int( 3 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, q, v ) );\n\n\t\t} ).ElseIf( hi.equal( int( 4 ) ), () => {\n\n\t\t\tresult.assign( vec3( t, p, v ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tresult.assign( vec3( v, p, q ) );\n\n\t\t} );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hsvtorgb',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hsv', type: 'vec3' }\n\t]\n} );\n\nconst mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {\n\n\tconst c = vec3( c_immutable ).toVar();\n\tconst r = float( c.x ).toVar();\n\tconst g = float( c.y ).toVar();\n\tconst b = float( c.z ).toVar();\n\tconst mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();\n\tconst maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();\n\tconst delta = float( maxcomp.sub( mincomp ) ).toVar();\n\tconst h = float().toVar(), s = float().toVar(), v = float().toVar();\n\tv.assign( maxcomp );\n\n\tIf( maxcomp.greaterThan( 0.0 ), () => {\n\n\t\ts.assign( delta.div( maxcomp ) );\n\n\t} ).Else( () => {\n\n\t\ts.assign( 0.0 );\n\n\t} );\n\n\tIf( s.lessThanEqual( 0.0 ), () => {\n\n\t\th.assign( 0.0 );\n\n\t} ).Else( () => {\n\n\t\tIf( r.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( g.sub( b ).div( delta ) );\n\n\t\t} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( add( 2.0, b.sub( r ).div( delta ) ) );\n\n\t\t} ).Else( () => {\n\n\t\t\th.assign( add( 4.0, r.sub( g ).div( delta ) ) );\n\n\t\t} );\n\n\t\th.mulAssign( 1.0 / 6.0 );\n\n\t\tIf( h.lessThan( 0.0 ), () => {\n\n\t\t\th.addAssign( 1.0 );\n\n\t\t} );\n\n\t} );\n\n\treturn vec3( h, s, v );\n\n} ).setLayout( {\n\tname: 'mx_rgbtohsv',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'c', type: 'vec3' }\n\t]\n} );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {\n\n\tconst color = vec3( color_immutable ).toVar();\n\tconst isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();\n\tconst linSeg = vec3( color.div( 12.92 ) ).toVar();\n\tconst powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();\n\n\treturn mix( linSeg, powSeg, isAbove );\n\n} ).setLayout( {\n\tname: 'mx_srgb_texture_to_lin_rec709',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst mx_aastep = ( threshold, value ) => {\n\n\tthreshold = float( threshold );\n\tvalue = float( value );\n\n\tconst afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );\n\n\treturn smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );\n\n};\n\nconst _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );\nconst mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );\nconst mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );\n\nconst _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );\nconst mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );\nconst mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );\n\nconst mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => uv_geo.mul( uv_scale ).add( uv_offset );\n\nconst mx_safepower = ( in1, in2 = 1 ) => {\n\n\tin1 = float( in1 );\n\n\treturn in1.abs().pow( in2 ).mul( in1.sign() );\n\n};\n\nconst mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );\n\nconst mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {\n\n\ttexcoord = texcoord.convert( 'vec2|vec3' ); // overloading type\n\n\tconst noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );\n\n\treturn noise_vec4.mul( amplitude ).add( pivot );\n\n};\n\nconst mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\n\nconst mx_cell_noise_float = ( texcoord = uv() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );\n\nconst mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\n\n/** @module getParallaxCorrectNormal **/\n\n/**\n * This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).\n *\n * Reference: {@link https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html}\n *\n * ```js\n * const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );\n * material.envNode = pmremTexture( renderTarget.texture, uvNode );\n * ```\n * @function\n * @param {Node<vec3>} normal - The normal to correct.\n * @param {Node<vec3>} cubeSize - The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms).\n * @param {Node<vec3>} cubePos - The cube position.\n * @return {Node<vec3>} The parallax corrected normal.\n */\nconst getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {\n\n\tconst nDir = normalize( normal ).toVar( 'nDir' );\n\tconst rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmax' );\n\tconst rbmin = sub( float( - 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmin' );\n\tconst rbminmax = vec3().toVar( 'rbminmax' );\n\trbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );\n\trbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );\n\trbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );\n\n\tconst correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );\n\tconst boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );\n\treturn boxIntersection.sub( cubePos );\n\n} );\n\nconst getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {\n\n\t// normal is assumed to have unit length\n\n\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tlet result = shCoefficients.element( 0 ).mul( 0.886227 );\n\n\t// band 1\n\tresult = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );\n\n\t// band 2\n\tresult = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );\n\tresult = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );\n\n\treturn result;\n\n} );\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBRDF_GGX: BRDF_GGX,\n\tBRDF_Lambert: BRDF_Lambert,\n\tBasicShadowFilter: BasicShadowFilter,\n\tBreak: Break,\n\tContinue: Continue,\n\tDFGApprox: DFGApprox,\n\tD_GGX: D_GGX,\n\tDiscard: Discard,\n\tEPSILON: EPSILON,\n\tF_Schlick: F_Schlick,\n\tFn: Fn,\n\tINFINITY: INFINITY,\n\tIf: If,\n\tLoop: Loop,\n\tNodeAccess: NodeAccess,\n\tNodeShaderStage: NodeShaderStage,\n\tNodeType: NodeType,\n\tNodeUpdateType: NodeUpdateType,\n\tPCFShadowFilter: PCFShadowFilter,\n\tPCFSoftShadowFilter: PCFSoftShadowFilter,\n\tPI: PI,\n\tPI2: PI2,\n\tReturn: Return,\n\tSchlick_to_F0: Schlick_to_F0,\n\tScriptableNodeResources: ScriptableNodeResources,\n\tShaderNode: ShaderNode,\n\tTBNViewMatrix: TBNViewMatrix,\n\tVSMShadowFilter: VSMShadowFilter,\n\tV_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n\tabs: abs,\n\tacesFilmicToneMapping: acesFilmicToneMapping,\n\tacos: acos,\n\tadd: add,\n\taddMethodChaining: addMethodChaining,\n\taddNodeElement: addNodeElement,\n\tagxToneMapping: agxToneMapping,\n\tall: all,\n\talphaT: alphaT,\n\tand: and,\n\tanisotropy: anisotropy,\n\tanisotropyB: anisotropyB,\n\tanisotropyT: anisotropyT,\n\tany: any,\n\tappend: append,\n\tarrayBuffer: arrayBuffer,\n\tasin: asin,\n\tassign: assign,\n\tatan: atan,\n\tatan2: atan2,\n\tatomicAdd: atomicAdd,\n\tatomicAnd: atomicAnd,\n\tatomicFunc: atomicFunc,\n\tatomicMax: atomicMax,\n\tatomicMin: atomicMin,\n\tatomicOr: atomicOr,\n\tatomicStore: atomicStore,\n\tatomicSub: atomicSub,\n\tatomicXor: atomicXor,\n\tattenuationColor: attenuationColor,\n\tattenuationDistance: attenuationDistance,\n\tattribute: attribute,\n\tattributeArray: attributeArray,\n\tbackgroundBlurriness: backgroundBlurriness,\n\tbackgroundIntensity: backgroundIntensity,\n\tbackgroundRotation: backgroundRotation,\n\tbatch: batch,\n\tbillboarding: billboarding,\n\tbitAnd: bitAnd,\n\tbitNot: bitNot,\n\tbitOr: bitOr,\n\tbitXor: bitXor,\n\tbitangentGeometry: bitangentGeometry,\n\tbitangentLocal: bitangentLocal,\n\tbitangentView: bitangentView,\n\tbitangentWorld: bitangentWorld,\n\tbitcast: bitcast,\n\tblendBurn: blendBurn,\n\tblendColor: blendColor,\n\tblendDodge: blendDodge,\n\tblendOverlay: blendOverlay,\n\tblendScreen: blendScreen,\n\tblur: blur,\n\tbool: bool,\n\tbuffer: buffer,\n\tbufferAttribute: bufferAttribute,\n\tbumpMap: bumpMap,\n\tburn: burn,\n\tbvec2: bvec2,\n\tbvec3: bvec3,\n\tbvec4: bvec4,\n\tbypass: bypass,\n\tcache: cache,\n\tcall: call,\n\tcameraFar: cameraFar,\n\tcameraNear: cameraNear,\n\tcameraNormalMatrix: cameraNormalMatrix,\n\tcameraPosition: cameraPosition,\n\tcameraProjectionMatrix: cameraProjectionMatrix,\n\tcameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n\tcameraViewMatrix: cameraViewMatrix,\n\tcameraWorldMatrix: cameraWorldMatrix,\n\tcbrt: cbrt,\n\tcdl: cdl,\n\tceil: ceil,\n\tchecker: checker,\n\tcineonToneMapping: cineonToneMapping,\n\tclamp: clamp,\n\tclearcoat: clearcoat,\n\tclearcoatRoughness: clearcoatRoughness,\n\tcode: code,\n\tcolor: color,\n\tcolorSpaceToWorking: colorSpaceToWorking,\n\tcolorToDirection: colorToDirection,\n\tcompute: compute,\n\tcond: cond,\n\tcontext: context,\n\tconvert: convert,\n\tconvertColorSpace: convertColorSpace,\n\tconvertToTexture: convertToTexture,\n\tcos: cos,\n\tcross: cross,\n\tcubeTexture: cubeTexture,\n\tdFdx: dFdx,\n\tdFdy: dFdy,\n\tdashSize: dashSize,\n\tdefaultBuildStages: defaultBuildStages,\n\tdefaultShaderStages: defaultShaderStages,\n\tdefined: defined,\n\tdegrees: degrees,\n\tdeltaTime: deltaTime,\n\tdensityFog: densityFog,\n\tdensityFogFactor: densityFogFactor,\n\tdepth: depth,\n\tdepthPass: depthPass,\n\tdifference: difference,\n\tdiffuseColor: diffuseColor,\n\tdirectPointLight: directPointLight,\n\tdirectionToColor: directionToColor,\n\tdispersion: dispersion,\n\tdistance: distance,\n\tdiv: div,\n\tdodge: dodge,\n\tdot: dot,\n\tdrawIndex: drawIndex,\n\tdynamicBufferAttribute: dynamicBufferAttribute,\n\telement: element,\n\temissive: emissive,\n\tequal: equal,\n\tequals: equals,\n\tequirectUV: equirectUV,\n\texp: exp,\n\texp2: exp2,\n\texpression: expression,\n\tfaceDirection: faceDirection,\n\tfaceForward: faceForward,\n\tfaceforward: faceforward,\n\tfloat: float,\n\tfloor: floor,\n\tfog: fog,\n\tfract: fract,\n\tframeGroup: frameGroup,\n\tframeId: frameId,\n\tfrontFacing: frontFacing,\n\tfwidth: fwidth,\n\tgain: gain,\n\tgapSize: gapSize,\n\tgetConstNodeType: getConstNodeType,\n\tgetCurrentStack: getCurrentStack,\n\tgetDirection: getDirection,\n\tgetDistanceAttenuation: getDistanceAttenuation,\n\tgetGeometryRoughness: getGeometryRoughness,\n\tgetNormalFromDepth: getNormalFromDepth,\n\tgetParallaxCorrectNormal: getParallaxCorrectNormal,\n\tgetRoughness: getRoughness,\n\tgetScreenPosition: getScreenPosition,\n\tgetShIrradianceAt: getShIrradianceAt,\n\tgetTextureIndex: getTextureIndex,\n\tgetViewPosition: getViewPosition,\n\tglsl: glsl,\n\tglslFn: glslFn,\n\tgrayscale: grayscale,\n\tgreaterThan: greaterThan,\n\tgreaterThanEqual: greaterThanEqual,\n\thash: hash,\n\thighpModelNormalViewMatrix: highpModelNormalViewMatrix,\n\thighpModelViewMatrix: highpModelViewMatrix,\n\thue: hue,\n\tinstance: instance,\n\tinstanceIndex: instanceIndex,\n\tinstancedArray: instancedArray,\n\tinstancedBufferAttribute: instancedBufferAttribute,\n\tinstancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n\tinstancedMesh: instancedMesh,\n\tint: int,\n\tinverseSqrt: inverseSqrt,\n\tinversesqrt: inversesqrt,\n\tinvocationLocalIndex: invocationLocalIndex,\n\tinvocationSubgroupIndex: invocationSubgroupIndex,\n\tior: ior,\n\tiridescence: iridescence,\n\tiridescenceIOR: iridescenceIOR,\n\tiridescenceThickness: iridescenceThickness,\n\tivec2: ivec2,\n\tivec3: ivec3,\n\tivec4: ivec4,\n\tjs: js,\n\tlabel: label,\n\tlength: length,\n\tlengthSq: lengthSq,\n\tlessThan: lessThan,\n\tlessThanEqual: lessThanEqual,\n\tlightPosition: lightPosition,\n\tlightProjectionUV: lightProjectionUV,\n\tlightShadowMatrix: lightShadowMatrix,\n\tlightTargetDirection: lightTargetDirection,\n\tlightTargetPosition: lightTargetPosition,\n\tlightViewPosition: lightViewPosition,\n\tlightingContext: lightingContext,\n\tlights: lights,\n\tlinearDepth: linearDepth,\n\tlinearToneMapping: linearToneMapping,\n\tlocalId: localId,\n\tlog: log,\n\tlog2: log2,\n\tlogarithmicDepthToViewZ: logarithmicDepthToViewZ,\n\tloop: loop,\n\tluminance: luminance,\n\tmat2: mat2,\n\tmat3: mat3,\n\tmat4: mat4,\n\tmatcapUV: matcapUV,\n\tmaterialAO: materialAO,\n\tmaterialAlphaTest: materialAlphaTest,\n\tmaterialAnisotropy: materialAnisotropy,\n\tmaterialAnisotropyVector: materialAnisotropyVector,\n\tmaterialAttenuationColor: materialAttenuationColor,\n\tmaterialAttenuationDistance: materialAttenuationDistance,\n\tmaterialClearcoat: materialClearcoat,\n\tmaterialClearcoatNormal: materialClearcoatNormal,\n\tmaterialClearcoatRoughness: materialClearcoatRoughness,\n\tmaterialColor: materialColor,\n\tmaterialDispersion: materialDispersion,\n\tmaterialEmissive: materialEmissive,\n\tmaterialIOR: materialIOR,\n\tmaterialIridescence: materialIridescence,\n\tmaterialIridescenceIOR: materialIridescenceIOR,\n\tmaterialIridescenceThickness: materialIridescenceThickness,\n\tmaterialLightMap: materialLightMap,\n\tmaterialLineDashOffset: materialLineDashOffset,\n\tmaterialLineDashSize: materialLineDashSize,\n\tmaterialLineGapSize: materialLineGapSize,\n\tmaterialLineScale: materialLineScale,\n\tmaterialLineWidth: materialLineWidth,\n\tmaterialMetalness: materialMetalness,\n\tmaterialNormal: materialNormal,\n\tmaterialOpacity: materialOpacity,\n\tmaterialPointWidth: materialPointWidth,\n\tmaterialReference: materialReference,\n\tmaterialReflectivity: materialReflectivity,\n\tmaterialRefractionRatio: materialRefractionRatio,\n\tmaterialRotation: materialRotation,\n\tmaterialRoughness: materialRoughness,\n\tmaterialSheen: materialSheen,\n\tmaterialSheenRoughness: materialSheenRoughness,\n\tmaterialShininess: materialShininess,\n\tmaterialSpecular: materialSpecular,\n\tmaterialSpecularColor: materialSpecularColor,\n\tmaterialSpecularIntensity: materialSpecularIntensity,\n\tmaterialSpecularStrength: materialSpecularStrength,\n\tmaterialThickness: materialThickness,\n\tmaterialTransmission: materialTransmission,\n\tmax: max$1,\n\tmaxMipLevel: maxMipLevel,\n\tmediumpModelViewMatrix: mediumpModelViewMatrix,\n\tmetalness: metalness,\n\tmin: min$1,\n\tmix: mix,\n\tmixElement: mixElement,\n\tmod: mod,\n\tmodInt: modInt,\n\tmodelDirection: modelDirection,\n\tmodelNormalMatrix: modelNormalMatrix,\n\tmodelPosition: modelPosition,\n\tmodelScale: modelScale,\n\tmodelViewMatrix: modelViewMatrix,\n\tmodelViewPosition: modelViewPosition,\n\tmodelViewProjection: modelViewProjection,\n\tmodelWorldMatrix: modelWorldMatrix,\n\tmodelWorldMatrixInverse: modelWorldMatrixInverse,\n\tmorphReference: morphReference,\n\tmrt: mrt,\n\tmul: mul,\n\tmx_aastep: mx_aastep,\n\tmx_cell_noise_float: mx_cell_noise_float,\n\tmx_contrast: mx_contrast,\n\tmx_fractal_noise_float: mx_fractal_noise_float,\n\tmx_fractal_noise_vec2: mx_fractal_noise_vec2,\n\tmx_fractal_noise_vec3: mx_fractal_noise_vec3,\n\tmx_fractal_noise_vec4: mx_fractal_noise_vec4,\n\tmx_hsvtorgb: mx_hsvtorgb,\n\tmx_noise_float: mx_noise_float,\n\tmx_noise_vec3: mx_noise_vec3,\n\tmx_noise_vec4: mx_noise_vec4,\n\tmx_ramplr: mx_ramplr,\n\tmx_ramptb: mx_ramptb,\n\tmx_rgbtohsv: mx_rgbtohsv,\n\tmx_safepower: mx_safepower,\n\tmx_splitlr: mx_splitlr,\n\tmx_splittb: mx_splittb,\n\tmx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n\tmx_transform_uv: mx_transform_uv,\n\tmx_worley_noise_float: mx_worley_noise_float,\n\tmx_worley_noise_vec2: mx_worley_noise_vec2,\n\tmx_worley_noise_vec3: mx_worley_noise_vec3,\n\tnegate: negate,\n\tneutralToneMapping: neutralToneMapping,\n\tnodeArray: nodeArray,\n\tnodeImmutable: nodeImmutable,\n\tnodeObject: nodeObject,\n\tnodeObjects: nodeObjects,\n\tnodeProxy: nodeProxy,\n\tnormalFlat: normalFlat,\n\tnormalGeometry: normalGeometry,\n\tnormalLocal: normalLocal,\n\tnormalMap: normalMap,\n\tnormalView: normalView,\n\tnormalWorld: normalWorld,\n\tnormalize: normalize,\n\tnot: not,\n\tnotEqual: notEqual,\n\tnumWorkgroups: numWorkgroups,\n\tobjectDirection: objectDirection,\n\tobjectGroup: objectGroup,\n\tobjectPosition: objectPosition,\n\tobjectScale: objectScale,\n\tobjectViewPosition: objectViewPosition,\n\tobjectWorldMatrix: objectWorldMatrix,\n\toneMinus: oneMinus,\n\tor: or,\n\torthographicDepthToViewZ: orthographicDepthToViewZ,\n\toscSawtooth: oscSawtooth,\n\toscSine: oscSine,\n\toscSquare: oscSquare,\n\toscTriangle: oscTriangle,\n\toutput: output,\n\toutputStruct: outputStruct,\n\toverlay: overlay,\n\toverloadingFn: overloadingFn,\n\tparabola: parabola,\n\tparallaxDirection: parallaxDirection,\n\tparallaxUV: parallaxUV,\n\tparameter: parameter,\n\tpass: pass,\n\tpassTexture: passTexture,\n\tpcurve: pcurve,\n\tperspectiveDepthToViewZ: perspectiveDepthToViewZ,\n\tpmremTexture: pmremTexture,\n\tpointUV: pointUV,\n\tpointWidth: pointWidth,\n\tpositionGeometry: positionGeometry,\n\tpositionLocal: positionLocal,\n\tpositionPrevious: positionPrevious,\n\tpositionView: positionView,\n\tpositionViewDirection: positionViewDirection,\n\tpositionWorld: positionWorld,\n\tpositionWorldDirection: positionWorldDirection,\n\tposterize: posterize,\n\tpow: pow,\n\tpow2: pow2,\n\tpow3: pow3,\n\tpow4: pow4,\n\tproperty: property,\n\tradians: radians,\n\trand: rand,\n\trange: range,\n\trangeFog: rangeFog,\n\trangeFogFactor: rangeFogFactor,\n\treciprocal: reciprocal,\n\treference: reference,\n\treferenceBuffer: referenceBuffer,\n\treflect: reflect,\n\treflectVector: reflectVector,\n\treflectView: reflectView,\n\treflector: reflector,\n\trefract: refract,\n\trefractVector: refractVector,\n\trefractView: refractView,\n\treinhardToneMapping: reinhardToneMapping,\n\tremainder: remainder,\n\tremap: remap,\n\tremapClamp: remapClamp,\n\trenderGroup: renderGroup,\n\trenderOutput: renderOutput,\n\trendererReference: rendererReference,\n\trotate: rotate,\n\trotateUV: rotateUV,\n\troughness: roughness,\n\tround: round,\n\trtt: rtt,\n\tsRGBTransferEOTF: sRGBTransferEOTF,\n\tsRGBTransferOETF: sRGBTransferOETF,\n\tsampler: sampler,\n\tsaturate: saturate,\n\tsaturation: saturation,\n\tscreen: screen,\n\tscreenCoordinate: screenCoordinate,\n\tscreenSize: screenSize,\n\tscreenUV: screenUV,\n\tscriptable: scriptable,\n\tscriptableValue: scriptableValue,\n\tselect: select,\n\tsetCurrentStack: setCurrentStack,\n\tshaderStages: shaderStages,\n\tshadow: shadow,\n\tshadowPositionWorld: shadowPositionWorld,\n\tsharedUniformGroup: sharedUniformGroup,\n\tsheen: sheen,\n\tsheenRoughness: sheenRoughness,\n\tshiftLeft: shiftLeft,\n\tshiftRight: shiftRight,\n\tshininess: shininess,\n\tsign: sign,\n\tsin: sin,\n\tsinc: sinc,\n\tskinning: skinning,\n\tskinningReference: skinningReference,\n\tsmoothstep: smoothstep,\n\tsmoothstepElement: smoothstepElement,\n\tspecularColor: specularColor,\n\tspecularF90: specularF90,\n\tspherizeUV: spherizeUV,\n\tsplit: split,\n\tspritesheetUV: spritesheetUV,\n\tsqrt: sqrt,\n\tstack: stack,\n\tstep: step,\n\tstorage: storage,\n\tstorageBarrier: storageBarrier,\n\tstorageObject: storageObject,\n\tstorageTexture: storageTexture,\n\tstring: string,\n\tsub: sub,\n\tsubgroupIndex: subgroupIndex,\n\tsubgroupSize: subgroupSize,\n\ttan: tan,\n\ttangentGeometry: tangentGeometry,\n\ttangentLocal: tangentLocal,\n\ttangentView: tangentView,\n\ttangentWorld: tangentWorld,\n\ttemp: temp,\n\ttexture: texture,\n\ttexture3D: texture3D,\n\ttextureBarrier: textureBarrier,\n\ttextureBicubic: textureBicubic,\n\ttextureCubeUV: textureCubeUV,\n\ttextureLoad: textureLoad,\n\ttextureSize: textureSize,\n\ttextureStore: textureStore,\n\tthickness: thickness,\n\ttime: time,\n\ttimerDelta: timerDelta,\n\ttimerGlobal: timerGlobal,\n\ttimerLocal: timerLocal,\n\ttoOutputColorSpace: toOutputColorSpace,\n\ttoWorkingColorSpace: toWorkingColorSpace,\n\ttoneMapping: toneMapping,\n\ttoneMappingExposure: toneMappingExposure,\n\ttoonOutlinePass: toonOutlinePass,\n\ttransformDirection: transformDirection,\n\ttransformNormal: transformNormal,\n\ttransformNormalToView: transformNormalToView,\n\ttransformedBentNormalView: transformedBentNormalView,\n\ttransformedBitangentView: transformedBitangentView,\n\ttransformedBitangentWorld: transformedBitangentWorld,\n\ttransformedClearcoatNormalView: transformedClearcoatNormalView,\n\ttransformedNormalView: transformedNormalView,\n\ttransformedNormalWorld: transformedNormalWorld,\n\ttransformedTangentView: transformedTangentView,\n\ttransformedTangentWorld: transformedTangentWorld,\n\ttransmission: transmission,\n\ttranspose: transpose,\n\ttriNoise3D: triNoise3D,\n\ttriplanarTexture: triplanarTexture,\n\ttriplanarTextures: triplanarTextures,\n\ttrunc: trunc,\n\ttslFn: tslFn,\n\tuint: uint,\n\tuniform: uniform,\n\tuniformArray: uniformArray,\n\tuniformGroup: uniformGroup,\n\tuniforms: uniforms,\n\tuserData: userData,\n\tuv: uv,\n\tuvec2: uvec2,\n\tuvec3: uvec3,\n\tuvec4: uvec4,\n\tvarying: varying,\n\tvaryingProperty: varyingProperty,\n\tvec2: vec2,\n\tvec3: vec3,\n\tvec4: vec4,\n\tvectorComponents: vectorComponents,\n\tvelocity: velocity,\n\tvertexColor: vertexColor,\n\tvertexIndex: vertexIndex,\n\tvertexStage: vertexStage,\n\tvibrance: vibrance,\n\tviewZToLogarithmicDepth: viewZToLogarithmicDepth,\n\tviewZToOrthographicDepth: viewZToOrthographicDepth,\n\tviewZToPerspectiveDepth: viewZToPerspectiveDepth,\n\tviewport: viewport,\n\tviewportBottomLeft: viewportBottomLeft,\n\tviewportCoordinate: viewportCoordinate,\n\tviewportDepthTexture: viewportDepthTexture,\n\tviewportLinearDepth: viewportLinearDepth,\n\tviewportMipTexture: viewportMipTexture,\n\tviewportResolution: viewportResolution,\n\tviewportSafeUV: viewportSafeUV,\n\tviewportSharedTexture: viewportSharedTexture,\n\tviewportSize: viewportSize,\n\tviewportTexture: viewportTexture,\n\tviewportTopLeft: viewportTopLeft,\n\tviewportUV: viewportUV,\n\twgsl: wgsl,\n\twgslFn: wgslFn,\n\tworkgroupArray: workgroupArray,\n\tworkgroupBarrier: workgroupBarrier,\n\tworkgroupId: workgroupId,\n\tworkingToColorSpace: workingToColorSpace,\n\txor: xor\n});\n\nconst _clearColor$1 = /*@__PURE__*/ new Color4();\n\n/**\n * This renderer module manages the background.\n *\n * @private\n * @augments DataMap\n */\nclass Background extends DataMap {\n\n\t/**\n\t * Constructs a new background management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( renderer, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * Updates the background for the given scene. Depending on how `Scene.background`\n\t * or `Scene.backgroundNode` are configured, this method might configure a simple clear\n\t * or add a mesh to the render list for rendering the background as a textured plane\n\t * or skybox.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {RenderContext} renderContext - The current render context.\n\t */\n\tupdate( scene, renderList, renderContext ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst background = this.nodes.getBackgroundNode( scene ) || scene.background;\n\n\t\tlet forceClear = false;\n\n\t\tif ( background === null ) {\n\n\t\t\t// no background settings, use clear color configuration from the renderer\n\n\t\t\trenderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = renderer._clearColor.a;\n\n\t\t} else if ( background.isColor === true ) {\n\n\t\t\t// background is an opaque color\n\n\t\t\tbackground.getRGB( _clearColor$1, LinearSRGBColorSpace );\n\t\t\t_clearColor$1.a = 1;\n\n\t\t\tforceClear = true;\n\n\t\t} else if ( background.isNode === true ) {\n\n\t\t\tconst sceneData = this.get( scene );\n\t\t\tconst backgroundNode = background;\n\n\t\t\t_clearColor$1.copy( renderer._clearColor );\n\n\t\t\tlet backgroundMesh = sceneData.backgroundMesh;\n\n\t\t\tif ( backgroundMesh === undefined ) {\n\n\t\t\t\tconst backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\n\t\t\t\t\tgetUV: () => backgroundRotation.mul( normalWorld ),\n\t\t\t\t\tgetTextureLevel: () => backgroundBlurriness\n\t\t\t\t} );\n\n\t\t\t\tlet viewProj = modelViewProjection;\n\t\t\t\tviewProj = viewProj.setZ( viewProj.w );\n\n\t\t\t\tconst nodeMaterial = new NodeMaterial();\n\t\t\t\tnodeMaterial.name = 'Background.material';\n\t\t\t\tnodeMaterial.side = BackSide;\n\t\t\t\tnodeMaterial.depthTest = false;\n\t\t\t\tnodeMaterial.depthWrite = false;\n\t\t\t\tnodeMaterial.fog = false;\n\t\t\t\tnodeMaterial.lights = false;\n\t\t\t\tnodeMaterial.vertexNode = viewProj;\n\t\t\t\tnodeMaterial.colorNode = backgroundMeshNode;\n\n\t\t\t\tsceneData.backgroundMeshNode = backgroundMeshNode;\n\t\t\t\tsceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );\n\t\t\t\tbackgroundMesh.frustumCulled = false;\n\t\t\t\tbackgroundMesh.name = 'Background.mesh';\n\n\t\t\t\tbackgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\n\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\n\n\t\t\t\tsceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );\n\t\t\t\tsceneData.backgroundMeshNode.needsUpdate = true;\n\n\t\t\t\tbackgroundMesh.material.needsUpdate = true;\n\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\n\n\t\t\t}\n\n\t\t\trenderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Renderer: Unsupported background configuration.', background );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\n\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\n\n\t\t\tclearColorValue.r = _clearColor$1.r;\n\t\t\tclearColorValue.g = _clearColor$1.g;\n\t\t\tclearColorValue.b = _clearColor$1.b;\n\t\t\tclearColorValue.a = _clearColor$1.a;\n\n\t\t\t// premultiply alpha\n\n\t\t\tif ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {\n\n\t\t\t\tclearColorValue.r *= clearColorValue.a;\n\t\t\t\tclearColorValue.g *= clearColorValue.a;\n\t\t\t\tclearColorValue.b *= clearColorValue.a;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\n\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\n\n\t\t} else {\n\n\t\t\trenderContext.clearColor = false;\n\t\t\trenderContext.clearDepth = false;\n\t\t\trenderContext.clearStencil = false;\n\n\t\t}\n\n\t}\n\n}\n\nlet _id$6 = 0;\n\n/**\n * A bind group represents a collection of bindings and thus a collection\n * or resources. Bind groups are assigned to pipelines to provide them\n * with the required resources (like uniform buffers or textures).\n *\n * @private\n */\nclass BindGroup {\n\n\t/**\n\t * Constructs a new bind group.\n\t *\n\t * @param {String} name - The bind group's name.\n\t * @param {Array<Binding>} bindings - An array of bindings.\n\t * @param {Number} index - The group index.\n\t * @param {Array<Binding>} bindingsReference - An array of reference bindings.\n\t */\n\tconstructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {\n\n\t\t/**\n\t\t * The bind group's name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {Array<Binding>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * The group index.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.index = index;\n\n\t\t/**\n\t\t * An array of reference bindings.\n\t\t *\n\t\t * @type {Array<Binding>}\n\t\t */\n\t\tthis.bindingsReference = bindingsReference;\n\n\t\t/**\n\t\t * The group's ID.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$6 ++;\n\n\t}\n\n}\n\n/**\n * This module represents the state of a node builder after it was\n * used to build the nodes for a render object. The state holds the\n * results of the build for further processing in the renderer.\n *\n * Render objects with identical cache keys share the same node builder state.\n *\n * @private\n */\nclass NodeBuilderState {\n\n\t/**\n\t * Constructs a new node builder state.\n\t *\n\t * @param {String?} vertexShader - The native vertex shader code.\n\t * @param {String?} fragmentShader - The native fragment shader code.\n\t * @param {String?} computeShader - The native compute shader code.\n\t * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.\n\t * @param {Array<BindGroup>} bindings - An array of bind groups.\n\t * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.\n\t * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.\n\t * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.\n\t * @param {NodeMaterialObserver} monitor - A node material observer.\n\t * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.\n\t */\n\tconstructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {\n\n\t\t/**\n\t\t * The native vertex shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.vertexShader = vertexShader;\n\n\t\t/**\n\t\t * The native fragment shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.fragmentShader = fragmentShader;\n\n\t\t/**\n\t\t * The native compute shader code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.computeShader = computeShader;\n\n\t\t/**\n\t\t * An array with transform attribute objects.\n\t\t * Only relevant when using compute shaders with WebGL 2.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * An array of node attributes representing\n\t\t * the attributes of the shaders.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.nodeAttributes = nodeAttributes;\n\n\t\t/**\n\t\t * An array of bind groups representing the uniform or storage\n\t\t * buffers, texture or samplers of the shader.\n\t\t *\n\t\t * @type {Array<BindGroup>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * An array of nodes that implement their `update()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = updateNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateBefore()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = updateBeforeNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateAfter()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = updateAfterNodes;\n\n\t\t/**\n\t\t * A node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver}\n\t\t */\n\t\tthis.monitor = monitor;\n\n\t\t/**\n\t\t * How often this state is used by render objects.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n\t/**\n\t * This method is used to create a array of bind groups based\n\t * on the existing bind groups of this state. Shared groups are\n\t * not cloned.\n\t *\n\t * @return {Array<BindGroup>} A array of bind groups.\n\t */\n\tcreateBindings() {\n\n\t\tconst bindings = [];\n\n\t\tfor ( const instanceGroup of this.bindings ) {\n\n\t\t\tconst shared = instanceGroup.bindings[ 0 ].groupNode.shared; // TODO: Is it safe to always check the first binding in the group?\n\n\t\t\tif ( shared !== true ) {\n\n\t\t\t\tconst bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );\n\t\t\t\tbindings.push( bindingsGroup );\n\n\t\t\t\tfor ( const instanceBinding of instanceGroup.bindings ) {\n\n\t\t\t\t\tbindingsGroup.bindings.push( instanceBinding.clone() );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbindings.push( instanceGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader attributes that are going to be generated\n * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}\n * and {@link NodeBuilder#bufferAttributes} for this purpose.\n */\nclass NodeAttribute {\n\n\t/**\n\t * Constructs a new node attribute.\n\t *\n\t * @param {String} name - The name of the attribute.\n\t * @param {String} type - The type of the attribute.\n\t * @param {Node?} node - An optional reference to the node.\n\t */\n\tconstructor( name, type, node = null ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeAttribute = true;\n\n\t\t/**\n\t\t * The name of the attribute.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the attribute.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * An optional reference to the node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader uniforms that are going to be generated\n * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}\n * for this purpose.\n */\nclass NodeUniform {\n\n\t/**\n\t * Constructs a new node uniform.\n\t *\n\t * @param {String} name - The name of the uniform.\n\t * @param {String} type - The type of the uniform.\n\t * @param {UniformNode} node - An reference to the node.\n\t */\n\tconstructor( name, type, node ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeUniform = true;\n\n\t\t/**\n\t\t * The name of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * An reference to the node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis.node = node.getSelf();\n\n\t}\n\n\t/**\n\t * The value of the uniform node.\n\t *\n\t * @type {Any}\n\t */\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n\t/**\n\t * The id of the uniform node.\n\t *\n\t * @type {Number}\n\t */\n\tget id() {\n\n\t\treturn this.node.id;\n\n\t}\n\n\t/**\n\t * The uniform node's group.\n\t *\n\t * @type {UniformGroupNode}\n\t */\n\tget groupNode() {\n\n\t\treturn this.node.groupNode;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader variables that are going to be generated\n * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for\n * this purpose.\n */\nclass NodeVar {\n\n\t/**\n\t * Constructs a new node variable.\n\t *\n\t * @param {String} name - The name of the variable.\n\t * @param {String} type - The type of the variable.\n\t */\n\tconstructor( name, type ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeVar = true;\n\n\t\t/**\n\t\t * The name of the variable.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the variable.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader varyings that are going to be generated\n * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for\n * this purpose.\n *\n * @augments NodeVar\n */\nclass NodeVarying extends NodeVar {\n\n\t/**\n\t * Constructs a new node varying.\n\t *\n\t * @param {String} name - The name of the varying.\n\t * @param {String} type - The type of the varying.\n\t */\n\tconstructor( name, type ) {\n\n\t\tsuper( name, type );\n\n\t\t/**\n\t\t * Whether this varying requires interpolation or not. This property can be used\n\t\t * to check if the varying can be optimized for a variable.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsInterpolation = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeVarying = true;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent user-defined, native shader code portions that are going to be\n * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}\n * for this purpose.\n */\nclass NodeCode {\n\n\t/**\n\t * Constructs a new code node.\n\t *\n\t * @param {String} name - The name of the code.\n\t * @param {String} type - The node type.\n\t * @param {String} [code=''] - The native shader code.\n\t */\n\tconstructor( name, type, code = '' ) {\n\n\t\t/**\n\t\t * The name of the code.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The node type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The native shader code.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.code = code;\n\n\t\tObject.defineProperty( this, 'isNodeCode', { value: true } );\n\n\t}\n\n}\n\nlet _id$5 = 0;\n\n/**\n * This utility class is used in {@link NodeBuilder} as an internal\n * cache data structure for node data.\n */\nclass NodeCache {\n\n\t/**\n\t * Constructs a new node cache.\n\t *\n\t * @param {NodeCache?} parent - A reference to a parent cache.\n\t */\n\tconstructor( parent = null ) {\n\n\t\t/**\n\t\t * The id of the cache.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t */\n\t\tthis.id = _id$5 ++;\n\n\t\t/**\n\t\t * A weak map for managing node data.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.nodesData = new WeakMap();\n\n\t\t/**\n\t\t * Reference to a parent node cache.\n\t\t *\n\t\t * @type {NodeCache?}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t}\n\n\t/**\n\t * Returns the data for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @return {Object?} The data for the node.\n\t */\n\tgetData( node ) {\n\n\t\tlet data = this.nodesData.get( node );\n\n\t\tif ( data === undefined && this.parent !== null ) {\n\n\t\t\tdata = this.parent.getData( node );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Sets the data for a given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {Object} data - The data that should be cached.\n\t */\n\tsetData( node, data ) {\n\n\t\tthis.nodesData.set( node, data );\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader struct data that are going to be generated\n * by the builder. A dictionary of struct types is maintained in {@link NodeBuilder#structs}\n * for this purpose.\n */\nclass StructTypeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructTypeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new struct type node.\n\t *\n\t * @param {String} name - The name of the struct.\n\t * @param {Array<String>} types - An array of types.\n\t */\n\tconstructor( name, types ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the struct.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\n\t\t/**\n\t\t * An array of types.\n\t\t *\n\t\t * @type {Array<String>}\n\t\t */\n\t\tthis.types = types;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStructTypeNode = true;\n\n\t}\n\n\t/**\n\t * Returns the member types.\n\t *\n\t * @return {Array<String>} The types.\n\t */\n\tgetMemberTypes() {\n\n\t\treturn this.types;\n\n\t}\n\n}\n\n/**\n * Abstract base class for uniforms.\n *\n * @abstract\n * @private\n */\nclass Uniform {\n\n\t/**\n\t * Constructs a new uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Any} value - The uniform's value.\n\t */\n\tconstructor( name, value ) {\n\n\t\t/**\n\t\t * The uniform's name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The uniform's value.\n\t\t *\n\t\t * @type {Any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * Used to build the uniform buffer according to the STD140 layout.\n\t\t * Derived uniforms will set this property to a data type specific\n\t\t * value.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.boundary = 0;\n\n\t\t/**\n\t\t * The item size. Derived uniforms will set this property to a data\n\t\t * type specific value.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.itemSize = 0;\n\n\t\t/**\n\t\t * This property is set by {@link UniformsGroup} and marks\n\t\t * the start position in the uniform buffer.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.offset = 0;\n\n\t}\n\n\t/**\n\t * Sets the uniform's value.\n\t *\n\t * @param {Any} value - The value to set.\n\t */\n\tsetValue( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * Returns the uniform's value.\n\t *\n\t * @return {Any} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.value;\n\n\t}\n\n}\n\n/**\n * Represents a Number uniform.\n *\n * @private\n * @augments Uniform\n */\nclass NumberUniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Number} value - The uniform's value.\n\t */\n\tconstructor( name, value = 0 ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNumberUniform = true;\n\n\t\tthis.boundary = 4;\n\t\tthis.itemSize = 1;\n\n\t}\n\n}\n\n/**\n * Represents a Vector2 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector2Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Vector2} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector2() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector2Uniform = true;\n\n\t\tthis.boundary = 8;\n\t\tthis.itemSize = 2;\n\n\t}\n\n}\n\n/**\n * Represents a Vector3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector3Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Vector3} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector3() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector3Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\n/**\n * Represents a Vector4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector4Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Vector4} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector4() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector4Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\n/**\n * Represents a Color uniform.\n *\n * @private\n * @augments Uniform\n */\nclass ColorUniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Color} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Color() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isColorUniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\n/**\n * Represents a Matrix3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix3Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Matrix3} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix3() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix3Uniform = true;\n\n\t\tthis.boundary = 48;\n\t\tthis.itemSize = 12;\n\n\t}\n\n}\n\n/**\n * Represents a Matrix4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix4Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {String} name - The uniform's name.\n\t * @param {Matrix4} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix4() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix4Uniform = true;\n\n\t\tthis.boundary = 64;\n\t\tthis.itemSize = 16;\n\n\t}\n\n}\n\n/**\n * A special form of Number uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments NumberUniform\n */\nclass NumberNodeUniform extends NumberUniform {\n\n\t/**\n\t * Constructs a new node-based Number uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Number} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector2 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector2Uniform\n */\nclass Vector2NodeUniform extends Vector2Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector2 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector2} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector3Uniform\n */\nclass Vector3NodeUniform extends Vector3Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector3 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector3} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector4Uniform\n */\nclass Vector4NodeUniform extends Vector4Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector4 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector4} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Color uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments ColorUniform\n */\nclass ColorNodeUniform extends ColorUniform {\n\n\t/**\n\t * Constructs a new node-based Color uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Color} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Matrix3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix3Uniform\n */\nclass Matrix3NodeUniform extends Matrix3Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix3 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix3} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Matrix4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix4Uniform\n */\nclass Matrix4NodeUniform extends Matrix4Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix4 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix4} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {String} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 )\n];\n\n//\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();\nconst outputDirection = vec3( direction.x, direction.y, direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\tget _hasInitialized() {\n\n\t\treturn this._renderer.hasInitialized();\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {Number} [sigma=0] - The blur radius in radians.\n\t * @param {Number} [near=0.1] - The near plane distance.\n\t * @param {Number} [far=100] - The far plane distance.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tthis._setSize( 256 );\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this.fromScene( scene, sigma, near, far, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( equirectangular );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\tasync fromEquirectangularAsync( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {RenderTarget?} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( cubemap );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n\t\t\tthis.fromCubemapAsync( cubemap, renderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\tasync fromCubemapAsync( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) await this._renderer.init();\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tasync compileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tawait this._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tasync compileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tawait this._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSizeFromTexture( texture ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t}\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tthis._setSizeFromTexture( texture );\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t//depthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\tasync _compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tawait this._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ 1, 1, 1, 1, - 1, 1 ];\n\t\tconst forwardSign = [ 1, - 1, 1, - 1, 1, - 1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.autoClear = false;\n\n\t\tlet backgroundBox = this._backgroundBox;\n\n\t\tif ( backgroundBox === null ) {\n\n\t\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\t\tname: 'PMREM.Background',\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tdepthTest: false\n\t\t\t} );\n\n\t\t\tbackgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\t}\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundBox.material.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundBox.material.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\tconst n = this._lodPlanes.length;\n\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t *\n\t * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.\n\t * @param {Number} lodIn - The input level-of-detail.\n\t * @param {Number} lodOut - The output level-of-detail.\n\t * @param {Number} sigma - The blur radius in radians.\n\t * @param {Vector3} [poleAxis] - The pole axis.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas, lodMeshes };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getMaterial( type ) {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\tmaterial.name = `PMREM_${ type }`;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture( null );\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'blur' );\n\tmaterial.uniforms = materialUniforms; // TODO: Move to outside of the material\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'cubemap' );\n\tmaterial.fragmentNode = cubeTexture( envTexture, outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'equirect' );\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nconst rendererCache = new WeakMap();\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tif ( /e/g.test( value ) ) {\n\n\t\treturn String( value ).replace( /\\+/g, '' );\n\n\t} else {\n\n\t\tvalue = Number( value );\n\n\t\treturn value + ( value % 1 ? '' : '.0' );\n\n\t}\n\n};\n\n/**\n * Base class for builders which generate a shader program based\n * on a 3D object and its node material definition.\n */\nclass NodeBuilder {\n\n\t/**\n\t * Constructs a new node builder.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The current renderer.\n\t * @param {NodeParser} parser - A reference to a node parser.\n\t */\n\tconstructor( object, renderer, parser ) {\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The material of the 3D object.\n\t\t *\n\t\t * @type {Material?}\n\t\t */\n\t\tthis.material = ( object && object.material ) || null;\n\n\t\t/**\n\t\t * The geometry of the 3D object.\n\t\t *\n\t\t * @type {BufferGeometry?}\n\t\t */\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\n\t\t/**\n\t\t * The current renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A reference to a node parser.\n\t\t *\n\t\t * @type {NodeParser}\n\t\t */\n\t\tthis.parser = parser;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {Scene?}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t\t/**\n\t\t * The camera the 3D object is rendered with.\n\t\t *\n\t\t * @type {Camera?}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A list of all nodes the builder is processing\n\t\t * for this 3D object.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * A list of all sequential nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.sequentialNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#update} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateBefore} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateAfter} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = [];\n\n\t\t/**\n\t\t * A dictionary that assigns each node to a unique hash.\n\t\t *\n\t\t * @type {Object<Number,Node>}\n\t\t */\n\t\tthis.hashNodes = {};\n\n\t\t/**\n\t\t * A reference to a node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver?}\n\t\t * @default null\n\t\t */\n\t\tthis.monitor = null;\n\n\t\t/**\n\t\t * A reference to the current lights node.\n\t\t *\n\t\t * @type {LightsNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * A reference to the current environment node.\n\t\t *\n\t\t * @type {Node?}\n\t\t * @default null\n\t\t */\n\t\tthis.environmentNode = null;\n\n\t\t/**\n\t\t * A reference to the current fog node.\n\t\t *\n\t\t * @type {FogNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.fogNode = null;\n\n\t\t/**\n\t\t * The current clipping context.\n\t\t *\n\t\t * @type {ClippingContext?}\n\t\t */\n\t\tthis.clippingContext = null;\n\n\t\t/**\n\t\t * The generated vertex shader.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.vertexShader = null;\n\n\t\t/**\n\t\t * The generated fragment shader.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.fragmentShader = null;\n\n\t\t/**\n\t\t * The generated compute shader.\n\t\t *\n\t\t * @type {String?}\n\t\t */\n\t\tthis.computeShader = null;\n\n\t\t/**\n\t\t * Nodes used in the primary flow of code generation.\n\t\t *\n\t\t * @type {Object<String,Array<Node>>}\n\t\t */\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\n\t\t/**\n\t\t * Nodes code from `.flowNodes`.\n\t\t *\n\t\t * @type {Object<String,String>}\n\t\t */\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\n\t\t/**\n\t\t * This dictionary holds the node uniforms of the builder.\n\t\t * The uniforms are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the output structs of the builder.\n\t\t * The structs are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the bindings for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindings = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t/**\n\t\t * This dictionary maintains the binding indices per bind group.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindingsIndexes = {};\n\n\t\t/**\n\t\t * Reference to the array of bind groups.\n\t\t *\n\t\t * @type {Array<BindGroup>?}\n\t\t */\n\t\tthis.bindGroups = null;\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link AttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.attributes = [];\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link BufferAttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.bufferAttributes = [];\n\n\t\t/**\n\t\t * This array holds the node varyings of this builder.\n\t\t *\n\t\t * @type {Array<NodeVarying>}\n\t\t */\n\t\tthis.varyings = [];\n\n\t\t/**\n\t\t * This dictionary holds the (native) node codes of this builder.\n\t\t * The codes are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object<String,Array<NodeCode>>}\n\t\t */\n\t\tthis.codes = {};\n\n\t\t/**\n\t\t * This dictionary holds the node variables of this builder.\n\t\t * The variables are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object<String,Array<NodeVar>>}\n\t\t */\n\t\tthis.vars = {};\n\n\t\t/**\n\t\t * Current code flow.\n\t\t * All code generated in this stack will be stored in `.flow`.\n\t\t *\n\t\t * @type {{code: String}}\n\t\t */\n\t\tthis.flow = { code: '' };\n\n\t\t/**\n\t\t * A chain of nodes.\n\t\t * Used to check recursive calls in node-graph.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.chaining = [];\n\n\t\t/**\n\t\t * The current stack.\n\t\t * This reflects the current process in the code block hierarchy,\n\t\t * it is useful to know if the current process is inside a conditional for example.\n\t\t *\n\t\t * @type {StackNode}\n\t\t */\n\t\tthis.stack = stack();\n\n\t\t/**\n\t\t * List of stack nodes.\n\t\t * The current stack hierarchy is stored in an array.\n\t\t *\n\t\t * @type {Array<StackNode>}\n\t\t */\n\t\tthis.stacks = [];\n\n\t\t/**\n\t\t * A tab value. Used for shader string generation.\n\t\t *\n\t\t * @type {String}\n\t\t * @default '\\t'\n\t\t */\n\t\tthis.tab = '\\t';\n\n\t\t/**\n\t\t * Reference to the current function node.\n\t\t *\n\t\t * @type {FunctionNode?}\n\t\t * @default null\n\t\t */\n\t\tthis.currentFunctionNode = null;\n\n\t\t/**\n\t\t * The builder's context.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.context = {\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\t/**\n\t\t * The builder's cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t */\n\t\tthis.cache = new NodeCache();\n\n\t\t/**\n\t\t * Since the {@link NodeBuilder#cache} might be temporarily\n\t\t * overwritten by other caches, this member retains the reference\n\t\t * to the builder's own cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t * @default this.cache\n\t\t */\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\t/**\n\t\t * The current shader stage.\n\t\t *\n\t\t * @type {('vertex'|'fragment'|'compute'|'any')?}\n\t\t */\n\t\tthis.shaderStage = null;\n\n\t\t/**\n\t\t * The current build stage.\n\t\t *\n\t\t * @type {('setup'|'analyze'|'generate')?}\n\t\t */\n\t\tthis.buildStage = null;\n\n\t\t/**\n\t\t * Whether comparison in shader code are generated with methods or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useComparisonMethod = false;\n\n\t}\n\n\t/**\n\t * Returns the bind groups of the current renderer.\n\t *\n\t * @return {ChainMap} The cache.\n\t */\n\tgetBindGroupsCache() {\n\n\t\tlet bindGroupsCache = rendererCache.get( this.renderer );\n\n\t\tif ( bindGroupsCache === undefined ) {\n\n\t\t\tbindGroupsCache = new ChainMap();\n\n\t\t\trendererCache.set( this.renderer, bindGroupsCache );\n\n\t\t}\n\n\t\treturn bindGroupsCache;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link RenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {Number} width - The width of the render target.\n\t * @param {Number} height - The height of the render target.\n\t * @param {Object} options - The options of the render target.\n\t * @return {RenderTarget} The render target.\n\t */\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link CubeRenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {Number} size - The size of the cube render target.\n\t * @param {Object} options - The options of the cube render target.\n\t * @return {CubeRenderTarget} The cube render target.\n\t */\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link PMREMGenerator}.\n\t *\n\t * @return {PMREMGenerator} The PMREM generator.\n\t */\n\tcreatePMREMGenerator() {\n\n\t\t// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support\n\n\t\treturn new PMREMGenerator( this.renderer );\n\n\t}\n\n\t/**\n\t * Whether the given node is included in the internal array of nodes or not.\n\t *\n\t * @param {Node} node - The node to test.\n\t * @return {Boolean} Whether the given node is included in the internal array of nodes or not.\n\t */\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t/**\n\t * Returns a bind group for the given group name and binding.\n\t *\n\t * @private\n\t * @param {String} groupName - The group name.\n\t * @param {Array<NodeUniformsGroup>} bindings - List of bindings.\n\t * @return {BindGroup} The bind group\n\t */\n\t_getBindGroup( groupName, bindings ) {\n\n\t\tconst bindGroupsCache = this.getBindGroupsCache();\n\n\t\t//\n\n\t\tconst bindingsArray = [];\n\n\t\tlet sharedGroup = true;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tbindingsArray.push( binding );\n\n\t\t\tsharedGroup = sharedGroup && binding.groupNode.shared !== true;\n\n\t\t}\n\n\t\t//\n\n\t\tlet bindGroup;\n\n\t\tif ( sharedGroup ) {\n\n\t\t\tbindGroup = bindGroupsCache.get( bindingsArray );\n\n\t\t\tif ( bindGroup === undefined ) {\n\n\t\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t\t\tbindGroupsCache.set( bindingsArray, bindGroup );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns an array of node uniform groups for the given group name and shader stage.\n\t *\n\t * @param {String} groupName - The group name.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Array<NodeUniformsGroup>} The array of node uniform groups.\n\t */\n\tgetBindGroupArray( groupName, shaderStage ) {\n\n\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\tlet bindGroup = bindings[ groupName ];\n\n\t\tif ( bindGroup === undefined ) {\n\n\t\t\tif ( this.bindingsIndexes[ groupName ] === undefined ) {\n\n\t\t\t\tthis.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };\n\n\t\t\t}\n\n\t\t\tbindings[ groupName ] = bindGroup = [];\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns a list bindings of all shader stages separated by groups.\n\t *\n\t * @return {Array<BindGroup>} The list of bindings.\n\t */\n\tgetBindings() {\n\n\t\tlet bindingsGroups = this.bindGroups;\n\n\t\tif ( bindingsGroups === null ) {\n\n\t\t\tconst groups = {};\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tfor ( const groupName in bindings[ shaderStage ] ) {\n\n\t\t\t\t\tconst uniforms = bindings[ shaderStage ][ groupName ];\n\n\t\t\t\t\tconst groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );\n\t\t\t\t\tgroupUniforms.push( ...uniforms );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingsGroups = [];\n\n\t\t\tfor ( const groupName in groups ) {\n\n\t\t\t\tconst group = groups[ groupName ];\n\n\t\t\t\tconst bindingsGroup = this._getBindGroup( groupName, group );\n\n\t\t\t\tbindingsGroups.push( bindingsGroup );\n\n\t\t\t}\n\n\t\t\tthis.bindGroups = bindingsGroups;\n\n\t\t}\n\n\t\treturn bindingsGroups;\n\n\t}\n\n\t/**\n\t * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.\n\t */\n\tsortBindingGroups() {\n\n\t\tconst bindingsGroups = this.getBindings();\n\n\t\tbindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );\n\n\t\tfor ( let i = 0; i < bindingsGroups.length; i ++ ) {\n\n\t\t\tconst bindingGroup = bindingsGroups[ i ];\n\t\t\tthis.bindingsIndexes[ bindingGroup.name ].group = i;\n\n\t\t\tbindingGroup.index = i;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The builder maintains each node in a hash-based dictionary.\n\t * This method sets the given node (value) with the given hash (key) into this dictionary.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {Number} hash - The hash of the node.\n\t */\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\t/**\n\t * Adds a node to this builder.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * It is used to add Nodes that will be used as FRAME and RENDER events,\n\t * and need to follow a certain sequence in the calls to work correctly.\n\t * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddSequentialNode( node ) {\n\n\t\tif ( this.sequentialNodes.includes( node ) === false ) {\n\n\t\t\tthis.sequentialNodes.push( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks the update types of nodes\n\t */\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const node of this.sequentialNodes ) {\n\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\t\t\tconst updateAfterType = node.getUpdateAfterType();\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateAfterType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateAfterNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * A reference the current node which is the\n\t * last node in the chain of nodes.\n\t *\n\t * @type {Node}\n\t */\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\t/**\n\t * Whether the given texture is filtered or not.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {Boolean} Whether the given texture is filtered or not.\n\t */\n\tisFilteredTexture( texture ) {\n\n\t\treturn ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );\n\n\t}\n\n\t/**\n\t * Adds the given node to the internal node chain.\n\t * This is used to check recursive calls in node-graph.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\t/**\n\t * Removes the given node from the internal node chain.\n\t *\n\t * @param {Node} node - The node to remove.\n\t */\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name. E.g.\n\t * the method name `textureDimensions` matches the WGSL name but must be\n\t * resolved to `textureSize` in GLSL.\n\t *\n\t * @abstract\n\t * @param {String} method - The method name to resolve.\n\t * @return {String} The resolved method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\t/**\n\t * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.\n\t *\n\t * @param {Number} hash - The hash of the node.\n\t * @return {Node} The found node.\n\t */\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\t/**\n\t * Adds the Node to a target flow so that it can generate code in the 'generate' process.\n\t *\n\t * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to add.\n\t * @return {Node} The node.\n\t */\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Sets builder's context.\n\t *\n\t * @param {Object} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\t/**\n\t * Returns the builder's current context.\n\t *\n\t * @return {Object} The builder's current context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Gets a context used in shader construction that can be shared across different materials.\n\t * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.\n\t *\n\t * @return {Object} The builder's current context without material.\n\t */\n\tgetSharedContext() {\n\n\t\t({ ...this.context });\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Sets builder's cache.\n\t *\n\t * @param {NodeCache} cache - The cache to set.\n\t */\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\t/**\n\t * Returns the builder's current cache.\n\t *\n\t * @return {NodeCache} The builder's current cache.\n\t */\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\t/**\n\t * Returns a cache for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t * @return {NodeCache} The cache.\n\t */\n\tgetCacheFromNode( node, parent = true ) {\n\n\t\tconst data = this.getDataFromNode( node );\n\t\tif ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );\n\n\t\treturn data.cache;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @abstract\n\t * @param {String} name - The requested feature.\n\t * @return {Boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the vertexIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The instanceIndex shader string.\n\t */\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the instanceIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The instanceIndex shader string.\n\t */\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the drawIndex input variable as a native shader string.\n\t * Only relevant for WebGL and its `WEBGL_multi_draw` extension.\n\t *\n\t * @abstract\n\t * @return {String} The drawIndex shader string.\n\t */\n\tgetDrawIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the frontFacing input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The frontFacing shader string.\n\t */\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the fragCoord input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {String} The fragCoord shader string.\n\t */\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not. WebGL needs\n\t * this method evaluate to `true`, WebGPU to `false`.\n\t *\n\t * @abstract\n\t * @return {Boolean} Whether to flip texture data along its vertical axis or not.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Calling this method increases the usage count for the given node by one.\n\t *\n\t * @param {Node} node - The node to increase the usage count for.\n\t * @return {Number} The updated usage count.\n\t */\n\tincreaseUsage( node ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tnodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n\n\t\treturn nodeData.usageCount;\n\n\t}\n\n\t/**\n\t * Generates a texture sample shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The texture property name.\n\t * @param {String} uvSnippet - Snippet defining the texture coordinates.\n\t * @return {String} The generated shader string.\n\t */\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates a texture LOD shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {String} textureProperty - The texture property name.\n\t * @param {String} uvSnippet - Snippet defining the texture coordinates.\n\t * @param {String} levelSnippet - Snippet defining the mip level.\n\t * @return {String} The generated shader string.\n\t */\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates the shader string for the given type and value.\n\t *\n\t * @param {String} type - The type.\n\t * @param {Any?} [value=null] - The value.\n\t * @return {String} The generated value as a shader string.\n\t */\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\t/**\n\t * It might be necessary to convert certain data types to different ones\n\t * so this method can be used to hide the conversion.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The updated type.\n\t */\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Whether the given attribute name is defined in the geometry or not.\n\t *\n\t * @param {String} name - The attribute name.\n\t * @return {Boolean} Whether the given attribute name is defined in the geometry.\n\t */\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\t/**\n\t * Returns a node attribute for the given name and type.\n\t *\n\t * @param {String} name - The attribute's name.\n\t * @param {String} type - The attribute's type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Returns for the given node and shader stage the property name for the shader.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The property name.\n\t */\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\t/**\n\t * Whether the given type is a vector type or not.\n\t *\n\t * @param {String} type - The type to check.\n\t * @return {Boolean} Whether the given type is a vector type or not.\n\t */\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a matrix type or not.\n\t *\n\t * @param {String} type - The type to check.\n\t * @return {Boolean} Whether the given type is a matrix type or not.\n\t */\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a reference type or not.\n\t *\n\t * @param {String} type - The type to check.\n\t * @return {Boolean} Whether the given type is a reference type or not.\n\t */\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n\n\t}\n\n\t/**\n\t * Whether the given texture needs a conversion to working color space.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to check.\n\t * @return {Boolean} Whether a color space conversion is required or not.\n\t */\n\tneedsToWorkingColorSpace( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the component type of a given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {String} The component type.\n\t */\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the element type for a given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The element type.\n\t */\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\t/**\n\t * Returns the component type for a given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The component type.\n\t */\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The vector type.\n\t */\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Returns the data type for the given the length and component type.\n\t *\n\t * @param {Number} length - The length.\n\t * @param {String} [componentType='float'] - The component type.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = getTypeFromLength( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\t/**\n\t * Returns the type for a given typed array.\n\t *\n\t * @param {TypedArray} array - The typed array.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {String} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\t/**\n\t * Returns the length for the given data type.\n\t *\n\t * @param {String} type - The data type.\n\t * @return {Number} The length.\n\t */\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given matrix type.\n\t *\n\t * @param {String} type - The matrix type.\n\t * @return {String} The vector type.\n\t */\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\t/**\n\t * For a given type this method changes the component type to the\n\t * given value. E.g. `vec4` should be changed to the new component type\n\t * `uint` which results in `uvec4`.\n\t *\n\t * @param {String} type - The type.\n\t * @param {String} newComponentType - The new component type.\n\t * @return {String} The new type.\n\t */\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\t/**\n\t * Returns the integer type pendant for the given type.\n\t *\n\t * @param {String} type - The type.\n\t * @return {String} The integer type.\n\t */\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\t/**\n\t * Adds a stack node to the internal stack.\n\t *\n\t * @return {StackNode} The added stack node.\n\t */\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tthis.stacks.push( getCurrentStack() || this.stack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\t/**\n\t * Removes the last stack node from the internal stack.\n\t *\n\t * @return {StackNode} The removed stack node.\n\t */\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\t/**\n\t * The builder maintains (cached) data for each node during the building process. This method\n\t * can be used to get these data for a specific shader stage and cache.\n\t *\n\t * @param {Node} node - The node to get the data for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {NodeCache?} cache - An optional cache.\n\t * @return {Object} The node data.\n\t */\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\t/**\n\t * Returns the properties for the given node and shader stage.\n\t *\n\t * @param {Node} node - The node to get the properties for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.\n\t * @return {Object} The node properties.\n\t */\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.\n\t *\n\t * @param {BufferAttributeNode} node - The buffer attribute node.\n\t * @param {String} type - The node type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructTypeNode} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<String>} types - The output struct types.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {StructTypeNode} The struct type attribute.\n\t */\n\tgetStructTypeFromNode( node, types, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet structType = nodeData.structType;\n\n\t\tif ( structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tstructType = new StructTypeNode( 'StructType' + index, types );\n\n\t\t\tthis.structs[ shaderStage ].push( structType );\n\n\t\t\tnodeData.structType = structType;\n\n\t\t}\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeUniform} for the given uniform node.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {String} type - The uniform type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {String?} name - The name of the uniform.\n\t * @return {NodeUniform} The node uniform.\n\t */\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVar} for the given variable node.\n\t *\n\t * @param {VarNode} node - The variable node.\n\t * @param {String?} name - The variable's name.\n\t * @param {String} [type=node.getNodeType( this )] - The variable's type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {NodeVar} The node variable.\n\t */\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\n\t\t\tif ( name === null ) name = 'nodeVar' + vars.length;\n\n\t\t\tnodeVar = new NodeVar( name, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVarying} for the given varying node.\n\t *\n\t * @param {(VaryingNode|PropertyNode)} node - The varying node.\n\t * @param {String?} name - The varying's name.\n\t * @param {String} [type=node.getNodeType( this )] - The varying's type.\n\t * @return {NodeVar} The node varying.\n\t */\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\tnodeVarying = new NodeVarying( name, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeCode} for the given code node.\n\t *\n\t * @param {CodeNode} node - The code node.\n\t * @param {String} type - The node type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {NodeCode} The node code.\n\t */\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\t/**\n\t * Adds a code flow based on the code-block hierarchy.\n\n\t * This is used so that code-blocks like If,Else create their variables locally if the Node\n\t * is only used inside one of these conditionals in the current shader stage.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.\n\t */\n\taddFlowCodeHierarchy( node, nodeBlock ) {\n\n\t\tconst { flowCodes, flowCodeBlock } = this.getDataFromNode( node );\n\n\t\tlet needsFlowCode = true;\n\t\tlet nodeBlockHierarchy = nodeBlock;\n\n\t\twhile ( nodeBlockHierarchy ) {\n\n\t\t\tif ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {\n\n\t\t\t\tneedsFlowCode = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;\n\n\t\t}\n\n\t\tif ( needsFlowCode ) {\n\n\t\t\tfor ( const flowCode of flowCodes ) {\n\n\t\t\t\tthis.addLineFlowCode( flowCode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow code-block.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {String} code - The code to add.\n\t * @param {Node} nodeBlock - Current ConditionalNode\n\t */\n\taddLineFlowCodeBlock( node, code, nodeBlock ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tconst flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );\n\t\tconst codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );\n\n\t\tflowCodes.push( code );\n\t\tcodeBlock.set( nodeBlock, true );\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow.\n\t *\n\t * @param {String} code - The code to add.\n\t * @param {Node?} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddLineFlowCode( code, node = null ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tif ( node !== null && this.context.nodeBlock ) {\n\n\t\t\tthis.addLineFlowCodeBlock( node, code, this.context.nodeBlock );\n\n\t\t}\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a code to the current code flow.\n\t *\n\t * @param {String} code - Shader code.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Add tab in the code that will be generated so that other snippets respect the current tabulation.\n\t * Typically used in codes with If,Else.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a tab.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current flow data based on a Node.\n\t *\n\t * @param {Node} node - Node that the flow was started.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Object} The flow data.\n\t */\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\t/**\n\t * Executes the node flow based on a root node to generate the final shader code.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @return {Object} The code flow.\n\t */\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.\n\t * @return {FunctionNode} The build function node.\n\t */\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a TSL function: Fn().\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.\n\t * @return {Object}\n\t */\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tconst inputs = {\n\t\t\t[ Symbol.iterator ]() {\n\n\t\t\t\tlet index = 0;\n\t\t\t\tconst values = Object.values( this );\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => ( {\n\t\t\t\t\t\tvalue: values[ index ],\n\t\t\t\t\t\tdone: index ++ >= values.length\n\t\t\t\t\t} )\n\t\t\t\t};\n\n\t\t\t}\n\t\t};\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {String?} output - Expected output type. For example 'vec3'.\n\t * @return {Object}\n\t */\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @abstract\n\t * @param {String} op - The operator name to resolve.\n\t * @return {String} The resolved operator name.\n\t */\n\tgetFunctionOperator( /* op */ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a child Node.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {String?} output - Expected output type. For example 'vec3'.\n\t * @return {Object} The code flow.\n\t */\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Executes a flow of code in a different stage.\n\t *\n\t * Some nodes like `varying()` have the ability to compute code in vertex-stage and\n\t * return the value in fragment-stage even if it is being executed in an input fragment.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to execute.\n\t * @param {String?} output - Expected output type. For example 'vec3'.\n\t * @param {String?} propertyName - The property name to assign the result.\n\t * @return {Object}\n\t */\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Returns an array holding all node attributes of this node builder.\n\t *\n\t * @return {Array<NodeAttribute>} The node attributes of this builder.\n\t */\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\t/**\n\t * Returns the attribute definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The attribute code section.\n\t */\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the varying definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The varying code section.\n\t */\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns a single variable definition as a shader string for the given variable type and name.\n\t *\n\t * @param {String} type - The variable's type.\n\t * @param {String} name - The variable's name.\n\t * @return {String} The shader string.\n\t */\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\t/**\n\t * Returns the variable definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The variable code section.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the uniform definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The uniform code section.\n\t */\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the native code definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {String} The native code section.\n\t */\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the hash of this node builder.\n\t *\n\t * @return {String} The hash.\n\t */\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\t/**\n\t * Sets the current shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')?} shaderStage - The shader stage to set.\n\t */\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\t/**\n\t * Returns the current shader stage.\n\t *\n\t * @return {('vertex'|'fragment'|'compute'|'any')?} The current shader stage.\n\t */\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\t/**\n\t * Sets the current build stage.\n\t *\n\t * @param {('setup'|'analyze'|'generate')?} buildStage - The build stage to set.\n\t */\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\t/**\n\t * Returns the current build stage.\n\t *\n\t * @return {('setup'|'analyze'|'generate')?} The current build stage.\n\t */\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t *\n\t * @abstract\n\t */\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Central build method which controls the build for the given object.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tbuild() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tlet nodeMaterial = renderer.library.fromMaterial( material );\n\n\t\t\tif ( nodeMaterial === null ) {\n\n\t\t\t\tconsole.error( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t\t\tnodeMaterial = new NodeMaterial();\n\n\t\t\t}\n\n\t\t\tnodeMaterial.build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a uniform representation which is later used for UBO generation and rendering.\n\t *\n\t * @param {NodeUniform} uniformNode - The uniform node.\n\t * @param {String} type - The requested type.\n\t * @return {Uniform} The uniform.\n\t */\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\t/**\n\t * Formats the given shader snippet from a given type into another one. E.g.\n\t * this method might be used to convert a simple float string `\"1.0\"` into a\n\t * `vec3` representation: `\"vec3<f32>( 1.0 )\"`.\n\t *\n\t * @param {String} snippet - The shader snippet.\n\t * @param {String} fromType - The source type.\n\t * @param {String} toType - The target type.\n\t * @return {String} The updated shader string.\n\t */\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 16 && toTypeLength === 9 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 9 && toTypeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;\n\n\t\t}\n\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\t/**\n\t * Returns a signature with the engine's current revision.\n\t *\n\t * @return {String} The signature.\n\t */\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - Node System\\n`;\n\n\t}\n\n\t// deprecated\n\n\tcreateNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168\n\n\t\tthrow new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );\n\n\t}\n\n}\n\n/**\n * Management class for updating nodes. The module tracks metrics like\n * the elapsed time, delta time, the render and frame ID to correctly\n * call the node update methods {@link Node#updateBefore}, {@link Node#update}\n * and {@link Node#updateAfter} depending on the node's configuration.\n */\nclass NodeFrame {\n\n\t/**\n\t * Constructs a new node fame.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The elapsed time in seconds.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.time = 0;\n\n\t\t/**\n\t\t * The delta time in seconds.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.deltaTime = 0;\n\n\t\t/**\n\t\t * The frame ID.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.frameId = 0;\n\n\t\t/**\n\t\t * The render ID.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t\t/**\n\t\t * Used to control the {@link Node#update} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateBefore} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateBeforeMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateAfter} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateAfterMap = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the current renderer.\n\t\t *\n\t\t * @type {Renderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the current material.\n\t\t *\n\t\t * @type {Material?}\n\t\t * @default null\n\t\t */\n\t\tthis.material = null;\n\n\t\t/**\n\t\t * A reference to the current camera.\n\t\t *\n\t\t * @type {Camera?}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A reference to the current 3D object.\n\t\t *\n\t\t * @type {Object3D?}\n\t\t * @default null\n\t\t */\n\t\tthis.object = null;\n\n\t\t/**\n\t\t * A reference to the current scene.\n\t\t *\n\t\t * @type {Scene?}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t}\n\n\t/**\n\t * Returns a dictionary for a given node and update map which\n\t * is used to correctly call node update methods per frame or render.\n\t *\n\t * @private\n\t * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.\n\t * @param {Node} nodeRef - The reference to the current node.\n\t * @return {Object<String,WeakMap>} The dictionary.\n\t */\n\t_getMaps( referenceMap, nodeRef ) {\n\n\t\tlet maps = referenceMap.get( nodeRef );\n\n\t\tif ( maps === undefined ) {\n\n\t\t\tmaps = {\n\t\t\t\trenderMap: new WeakMap(),\n\t\t\t\tframeMap: new WeakMap()\n\t\t\t};\n\n\t\t\treferenceMap.set( nodeRef, maps );\n\n\t\t}\n\n\t\treturn maps;\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateBefore} for the given node.\n\t * It makes sure {@link Node#updateBeforeType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateBeforeNode( node ) {\n\n\t\tconst updateType = node.getUpdateBeforeType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateBefore( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateAfter} for the given node.\n\t * It makes sure {@link Node#updateAfterType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateAfterNode( node ) {\n\n\t\tconst updateType = node.getUpdateAfterType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateAfter( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#update} for the given node.\n\t * It makes sure {@link Node#updateType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateNode( node ) {\n\n\t\tconst updateType = node.getUpdateType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst { frameMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( frameMap.get( reference ) !== this.frameId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tframeMap.set( reference, this.frameId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst { renderMap } = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( renderMap.get( reference ) !== this.renderId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\trenderMap.set( reference, this.renderId );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the internal state of the node frame. This method is\n\t * called by the renderer in its internal animation loop.\n\t */\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\n/**\n * Describes the input of a {@link NodeFunction}.\n */\nclass NodeFunctionInput {\n\n\t/**\n\t * Constructs a new node function input.\n\t *\n\t * @param {String} type - The input type.\n\t * @param {String} name - The input name.\n\t * @param {Number?} [count=null] - If the input is an Array, count will be the length.\n\t * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).\n\t * @param {Boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).\n\t */\n\tconstructor( type, name, count = null, qualifier = '', isConst = false ) {\n\n\t\t/**\n\t\t *  The input type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The input name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * If the input is an Array, count will be the length.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t *The parameter qualifier (only relevant for GLSL).\n\t\t *\n\t\t * @type {('in'|'out'|'inout')}\n\t\t * @default ''\n\t\t */\n\t\tthis.qualifier = qualifier;\n\n\t\t/**\n\t\t * Whether the input uses a const qualifier or not (only relevant for GLSL).\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isConst = isConst;\n\n\t}\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\n/**\n * Module for representing directional lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass DirectionalLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'DirectionalLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new directional light node.\n\t *\n\t * @param {DirectionalLight?} [light=null] - The directional light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightColor = this.colorNode;\n\t\tconst lightDirection = lightTargetDirection( this.light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\nconst _matrix41 = /*@__PURE__*/ new Matrix4();\nconst _matrix42 = /*@__PURE__*/ new Matrix4();\n\nlet _ltcLib = null;\n\n/**\n * Module for representing rect area lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass RectAreaLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'RectAreaLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new rect area light node.\n\t *\n\t * @param {RectAreaLight?} [light=null] - The rect area light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the half height of the are light.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the half width of the are light.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * The `updateType` is set to `NodeUpdateType.RENDER` since the light\n\t\t * relies on `viewMatrix` which might vary per render call.\n\t\t *\n\t\t * @type {String}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Overwritten to updated rect area light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tconst viewMatrix = frame.camera.matrixWorldInverse;\n\n\t\t_matrix42.identity();\n\t\t_matrix41.copy( light.matrixWorld );\n\t\t_matrix41.premultiply( viewMatrix );\n\t\t_matrix42.extractRotation( _matrix41 );\n\n\t\tthis.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );\n\t\tthis.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\tthis.halfWidth.value.applyMatrix4( _matrix42 );\n\t\tthis.halfHeight.value.applyMatrix4( _matrix42 );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tlet ltc_1, ltc_2;\n\n\t\tif ( builder.isAvailable( 'float32Filterable' ) ) {\n\n\t\t\tltc_1 = texture( _ltcLib.LTC_FLOAT_1 );\n\t\t\tltc_2 = texture( _ltcLib.LTC_FLOAT_2 );\n\n\t\t} else {\n\n\t\t\tltc_1 = texture( _ltcLib.LTC_HALF_1 );\n\t\t\tltc_2 = texture( _ltcLib.LTC_HALF_2 );\n\n\t\t}\n\n\t\tconst { colorNode, light } = this;\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst lightPosition = lightViewPosition( light );\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.directRectArea( {\n\t\t\tlightColor: colorNode,\n\t\t\tlightPosition,\n\t\t\thalfWidth: this.halfWidth,\n\t\t\thalfHeight: this.halfHeight,\n\t\t\treflectedLight,\n\t\t\tltc_1,\n\t\t\tltc_2\n\t\t}, builder.stack, builder );\n\n\t}\n\n\t/**\n\t * Used to configure the internal BRDF approximation texture data.\n\t *\n\t * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.\n\t */\n\tstatic setLTC( ltc ) {\n\n\t\t_ltcLib = ltc;\n\n\t}\n\n}\n\n/**\n * Module for representing spot lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass SpotLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'SpotLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new spot light node.\n\t *\n\t * @param {SpotLight?} [light=null] - The spot light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the cone cosine.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.coneCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the penumbra cosine.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the cutoff distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the decay exponent.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated spot light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tthis.coneCosNode.value = Math.cos( light.angle );\n\t\tthis.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\t/**\n\t * Computes the spot attenuation for the given angle.\n\t *\n\t * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst { coneCosNode, penumbraCosNode } = this;\n\n\t\treturn smoothstep( coneCosNode, penumbraCosNode, angleCosine );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst lightingModel = builder.context.lightingModel;\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode\n\n\t\tconst lightDirection = lVector.normalize();\n\t\tconst angleCos = lightDirection.dot( lightTargetDirection( light ) );\n\t\tconst spotAttenuation = this.getSpotAttenuation( angleCos );\n\n\t\tconst lightDistance = lVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tlet lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );\n\n\t\tif ( light.map ) {\n\n\t\t\tconst spotLightCoord = lightProjectionUV( light );\n\t\t\tconst projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );\n\n\t\t\tconst inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();\n\n\t\t\tlightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );\n\n\t\t}\n\n\t\tconst reflectedLight = builder.context.reflectedLight;\n\n\t\tlightingModel.direct( {\n\t\t\tlightDirection,\n\t\t\tlightColor,\n\t\t\treflectedLight\n\t\t}, builder.stack, builder );\n\n\t}\n\n}\n\n/**\n * An IES version of the default spot light node.\n *\n * @augments SpotLightNode\n */\nclass IESSpotLightNode extends SpotLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'IESSpotLightNode';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to compute an IES conform spot attenuation.\n\t *\n\t * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( angleCosine ) {\n\n\t\tconst iesMap = this.light.iesMap;\n\n\t\tlet spotAttenuation = null;\n\n\t\tif ( iesMap && iesMap.isTexture === true ) {\n\n\t\t\tconst angle = angleCosine.acos().mul( 1.0 / Math.PI );\n\n\t\t\tspotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;\n\n\t\t} else {\n\n\t\t\tspotAttenuation = super.getSpotAttenuation( angleCosine );\n\n\t\t}\n\n\t\treturn spotAttenuation;\n\n\t}\n\n}\n\n/**\n * Module for representing ambient lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass AmbientLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'AmbientLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new ambient light node.\n\t *\n\t * @param {AmbientLight?} [light=null] - The ambient light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tcontext.irradiance.addAssign( this.colorNode );\n\n\t}\n\n}\n\n/**\n * Module for representing hemisphere lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass HemisphereLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'HemisphereLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new hemisphere light node.\n\t *\n\t * @param {HemisphereLight?} [light=null] - The hemisphere light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the light's position.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.lightPositionNode = lightPosition( light );\n\n\t\t/**\n\t\t * A node representing the light's direction.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.lightDirectionNode = this.lightPositionNode.normalize();\n\n\t\t/**\n\t\t * Uniform node representing the light's ground color.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.groundColorNode = uniform( new Color() ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated hemisphere light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.lightPositionNode.object3d = light;\n\n\t\tthis.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode, groundColorNode, lightDirectionNode } = this;\n\n\t\tconst dotNL = normalView.dot( lightDirectionNode );\n\t\tconst hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );\n\n\t\tconst irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\n/**\n * Module for representing light probes as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass LightProbeNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightProbeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new light probe node.\n\t *\n\t * @param {LightProbe?} [light=null] - The light probe.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tconst array = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );\n\n\t\t/**\n\t\t * Light probe represented as a uniform of spherical harmonics.\n\t\t *\n\t\t * @type {UniformArrayNode}\n\t\t */\n\t\tthis.lightProbe = uniformArray( array );\n\n\t}\n\n\t/**\n\t * Overwritten to updated light probe specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst irradiance = getShIrradianceAt( normalWorld, this.lightProbe );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\n/**\n * Base class for node parsers. A derived parser must be implemented\n * for each supported native shader language.\n */\nclass NodeParser {\n\n\t/**\n\t * The method parses the given native code an returns a node function.\n\t *\n\t * @abstract\n\t * @param {String} source - The native shader code.\n\t * @return {NodeFunction} A node function.\n\t */\n\tparseFunction( /*source*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\n/**\n * Base class for node functions. A derived module must be implemented\n * for each supported native shader language. Similar to other `Node*` modules,\n * this class is only relevant during the building process and not used\n * in user-level code.\n */\nclass NodeFunction {\n\n\t/**\n\t * Constructs a new node function.\n\t *\n\t * @param {String} type - The node type. This type is the return type of the node function.\n\t * @param {Array<NodeFunctionInput>} inputs - The function's inputs.\n\t * @param {String} [name=''] - The function's name.\n\t * @param {String} [precision=''] - The precision qualifier.\n\t */\n\tconstructor( type, inputs, name = '', precision = '' ) {\n\n\t\t/**\n\t\t * The node type. This type is the return type of the node function.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The function's inputs.\n\t\t *\n\t\t * @type {Array<NodeFunctionInput>}\n\t\t */\n\t\tthis.inputs = inputs;\n\n\t\t/**\n\t\t * The name of the uniform.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The precision qualifier.\n\t\t *\n\t\t * @type {String}\n\t\t * @default ''\n\t\t */\n\t\tthis.precision = precision;\n\n\t}\n\n\t/**\n\t * This method returns the native code of the node function.\n\t *\n\t * @abstract\n\t * @param {String} name - The function's name.\n\t * @return {String} A shader code.\n\t */\n\tgetCode( /*name = this.name*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n}\n\nNodeFunction.isNodeFunction = true;\n\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse$1 = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp$1 );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tprecision,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a GLSL node function.\n *\n * @augments NodeFunction\n */\nclass GLSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new GLSL node function.\n\t *\n\t * @param {String} source - The GLSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );\n\n\t\tsuper( type, inputs, name, precision );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\t/**\n\t * This method returns the GLSL code of the node function.\n\t *\n\t * @param {String} [name=this.name] - The function's name.\n\t * @return {String} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, precision } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( precision !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ precision } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\n/**\n * A GLSL node parser.\n *\n * @augments NodeParser\n */\nclass GLSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given GLSL code an returns a node function.\n\t *\n\t * @param {String} source - The GLSL code.\n\t * @return {GLSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new GLSLNodeFunction( source );\n\n\t}\n\n}\n\nconst _outputNodeMap = new WeakMap();\n\n/**\n * This renderer module manages node-related objects and is the\n * primary interface between the renderer and the node system.\n *\n * @private\n * @augments DataMap\n */\nclass Nodes extends DataMap {\n\n\t/**\n\t * Constructs a new nodes management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( renderer, backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The node frame.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.nodeFrame = new NodeFrame();\n\n\t\t/**\n\t\t * A cache for managing node builder states.\n\t\t *\n\t\t * @type {Map<Number,NodeBuilderState>}\n\t\t */\n\t\tthis.nodeBuilderCache = new Map();\n\n\t\t/**\n\t\t * A cache for managing data cache key data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.callHashCache = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node uniforms group data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.groupsData = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node objects of\n\t\t * scene properties like fog or environments.\n\t\t *\n\t\t * @type {Object<String,WeakMap>}\n\t\t */\n\t\tthis.cacheLib = {};\n\n\t}\n\n\t/**\n\t * Returns `true` if the given node uniforms group must be updated or not.\n\t *\n\t * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.\n\t * @return {Boolean} Whether the node uniforms group requires an update or not.\n\t */\n\tupdateGroup( nodeUniformsGroup ) {\n\n\t\tconst groupNode = nodeUniformsGroup.groupNode;\n\t\tconst name = groupNode.name;\n\n\t\t// objectGroup is always updated\n\n\t\tif ( name === objectGroup.name ) return true;\n\n\t\t// renderGroup is updated once per render/compute call\n\n\t\tif ( name === renderGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst renderId = this.nodeFrame.renderId;\n\n\t\t\tif ( uniformsGroupData.renderId !== renderId ) {\n\n\t\t\t\tuniformsGroupData.renderId = renderId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// frameGroup is updated once per frame\n\n\t\tif ( name === frameGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst frameId = this.nodeFrame.frameId;\n\n\t\t\tif ( uniformsGroupData.frameId !== frameId ) {\n\n\t\t\t\tuniformsGroupData.frameId = frameId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// other groups are updated just when groupNode.needsUpdate is true\n\n\t\tconst groupChain = [ groupNode, nodeUniformsGroup ];\n\n\t\tlet groupData = this.groupsData.get( groupChain );\n\t\tif ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );\n\n\t\tif ( groupData.version !== groupNode.version ) {\n\n\t\t\tgroupData.version = groupNode.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the cache key for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Number} The cache key.\n\t */\n\tgetForRenderCacheKey( renderObject ) {\n\n\t\treturn renderObject.initialCacheKey;\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet nodeBuilderState = renderObjectData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst { nodeBuilderCache } = this;\n\n\t\t\tconst cacheKey = this.getForRenderCacheKey( renderObject );\n\n\t\t\tnodeBuilderState = nodeBuilderCache.get( cacheKey );\n\n\t\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );\n\t\t\t\tnodeBuilder.scene = renderObject.scene;\n\t\t\t\tnodeBuilder.material = renderObject.material;\n\t\t\t\tnodeBuilder.camera = renderObject.camera;\n\t\t\t\tnodeBuilder.context.material = renderObject.material;\n\t\t\t\tnodeBuilder.lightsNode = renderObject.lightsNode;\n\t\t\t\tnodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );\n\t\t\t\tnodeBuilder.fogNode = this.getFogNode( renderObject.scene );\n\t\t\t\tnodeBuilder.clippingContext = renderObject.clippingContext;\n\t\t\t\tnodeBuilder.build();\n\n\t\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\t\tnodeBuilderCache.set( cacheKey, nodeBuilderState );\n\n\t\t\t}\n\n\t\t\tnodeBuilderState.usedTimes ++;\n\n\t\t\trenderObjectData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Deletes the given object from the internal data map\n\t *\n\t * @param {Any} object - The object to delete.\n\t * @return {Object?} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tif ( object.isRenderObject ) {\n\n\t\t\tconst nodeBuilderState = this.get( object ).nodeBuilderState;\n\t\t\tnodeBuilderState.usedTimes --;\n\n\t\t\tif ( nodeBuilderState.usedTimes === 0 ) {\n\n\t\t\t\tthis.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst computeData = this.get( computeNode );\n\n\t\tlet nodeBuilderState = computeData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );\n\t\t\tnodeBuilder.build();\n\n\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\tcomputeData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Creates a node builder state for the given node builder.\n\t *\n\t * @private\n\t * @param {NodeBuilder} nodeBuilder - The node builder.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\t_createNodeBuilderState( nodeBuilder ) {\n\n\t\treturn new NodeBuilderState(\n\t\t\tnodeBuilder.vertexShader,\n\t\t\tnodeBuilder.fragmentShader,\n\t\t\tnodeBuilder.computeShader,\n\t\t\tnodeBuilder.getAttributesArray(),\n\t\t\tnodeBuilder.getBindings(),\n\t\t\tnodeBuilder.updateNodes,\n\t\t\tnodeBuilder.updateBeforeNodes,\n\t\t\tnodeBuilder.updateAfterNodes,\n\t\t\tnodeBuilder.monitor,\n\t\t\tnodeBuilder.transforms\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns an environment node for the current configured\n\t * scene environment.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene environment.\n\t */\n\tgetEnvironmentNode( scene ) {\n\n\t\tthis.updateEnvironment( scene );\n\n\t\tlet environmentNode = null;\n\n\t\tif ( scene.environmentNode && scene.environmentNode.isNode ) {\n\n\t\t\tenvironmentNode = scene.environmentNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.environmentNode ) {\n\n\t\t\t\tenvironmentNode = sceneData.environmentNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn environmentNode;\n\n\t}\n\n\t/**\n\t * Returns a background node for the current configured\n\t * scene background.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene background.\n\t */\n\tgetBackgroundNode( scene ) {\n\n\t\tthis.updateBackground( scene );\n\n\t\tlet backgroundNode = null;\n\n\t\tif ( scene.backgroundNode && scene.backgroundNode.isNode ) {\n\n\t\t\tbackgroundNode = scene.backgroundNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.backgroundNode ) {\n\n\t\t\t\tbackgroundNode = sceneData.backgroundNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn backgroundNode;\n\n\t}\n\n\t/**\n\t * Returns a fog node for the current configured scene fog.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene fog.\n\t */\n\tgetFogNode( scene ) {\n\n\t\tthis.updateFog( scene );\n\n\t\treturn scene.fogNode || this.get( scene ).fogNode || null;\n\n\t}\n\n\t/**\n\t * Returns a cache key for the given scene and lights node.\n\t * This key is used by `RenderObject` as a part of the dynamic\n\t * cache key (a key that must be checked every time the render\n\t * objects is drawn).\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @return {Number} The cache key.\n\t */\n\tgetCacheKey( scene, lightsNode ) {\n\n\t\tconst chain = [ scene, lightsNode ];\n\t\tconst callId = this.renderer.info.calls;\n\n\t\tlet cacheKeyData = this.callHashCache.get( chain );\n\n\t\tif ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {\n\n\t\t\tconst environmentNode = this.getEnvironmentNode( scene );\n\t\t\tconst fogNode = this.getFogNode( scene );\n\n\t\t\tconst values = [];\n\n\t\t\tif ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );\n\t\t\tif ( environmentNode ) values.push( environmentNode.getCacheKey() );\n\t\t\tif ( fogNode ) values.push( fogNode.getCacheKey() );\n\n\t\t\tvalues.push( this.renderer.shadowMap.enabled ? 1 : 0 );\n\n\t\t\tcacheKeyData = {\n\t\t\t\tcallId,\n\t\t\t\tcacheKey: hashArray( values )\n\t\t\t};\n\n\t\t\tthis.callHashCache.set( chain, cacheKeyData );\n\n\t\t}\n\n\t\treturn cacheKeyData.cacheKey;\n\n\t}\n\n\t/**\n\t * A boolean that indicates whether tone mapping should be enabled\n\t * or not.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isToneMappingState() {\n\n\t\treturn this.renderer.getRenderTarget() ? false : true;\n\n\t}\n\n\t/**\n\t * If a scene background is configured, this method makes sure to\n\t * represent the background with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateBackground( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tconst forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );\n\n\t\t\tif ( sceneData.background !== background || forceUpdate ) {\n\n\t\t\t\tconst backgroundNode = this.getCacheNode( 'background', background, () => {\n\n\t\t\t\t\tif ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\t\t\t\tif ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {\n\n\t\t\t\t\t\t\treturn pmremTexture( background );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet envMap;\n\n\t\t\t\t\t\t\tif ( background.isCubeTexture === true ) {\n\n\t\t\t\t\t\t\t\tenvMap = cubeTexture( background );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tenvMap = texture( background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn cubeMapNode( envMap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( background.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( background, screenUV.flipY() ).setUpdateMatrix( true );\n\n\t\t\t\t\t} else if ( background.isColor !== true ) {\n\n\t\t\t\t\t\tconsole.error( 'WebGPUNodes: Unsupported background configuration.', background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, forceUpdate );\n\n\t\t\t\tsceneData.backgroundNode = backgroundNode;\n\t\t\t\tsceneData.background = background;\n\t\t\t\tsceneData.backgroundBlurriness = scene.backgroundBlurriness;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.backgroundNode ) {\n\n\t\t\tdelete sceneData.backgroundNode;\n\t\t\tdelete sceneData.background;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is part of the caching of nodes which are used to represents the\n\t * scene's background, fog or environment.\n\t *\n\t * @param {String} type - The type of object to cache.\n\t * @param {Object} object - The object.\n\t * @param {Function} callback - A callback that produces a node representation for the given object.\n\t * @param {Boolean} [forceUpdate=false] - Whether an update should be enforced or not.\n\t * @return {Node} The node representation.\n\t */\n\tgetCacheNode( type, object, callback, forceUpdate = false ) {\n\n\t\tconst nodeCache = this.cacheLib[ type ] || ( this.cacheLib[ type ] = new WeakMap() );\n\n\t\tlet node = nodeCache.get( object );\n\n\t\tif ( node === undefined || forceUpdate ) {\n\n\t\t\tnode = callback();\n\t\t\tnodeCache.set( object, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * If a scene fog is configured, this method makes sure to\n\t * represent the fog with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateFog( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst sceneFog = scene.fog;\n\n\t\tif ( sceneFog ) {\n\n\t\t\tif ( sceneData.fog !== sceneFog ) {\n\n\t\t\t\tconst fogNode = this.getCacheNode( 'fog', sceneFog, () => {\n\n\t\t\t\t\tif ( sceneFog.isFogExp2 ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst density = reference( 'density', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, densityFogFactor( density ) );\n\n\t\t\t\t\t} else if ( sceneFog.isFog ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst near = reference( 'near', 'float', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst far = reference( 'far', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, rangeFogFactor( near, far ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.Renderer: Unsupported fog configuration.', sceneFog );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.fogNode = fogNode;\n\t\t\t\tsceneData.fog = sceneFog;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdelete sceneData.fogNode;\n\t\t\tdelete sceneData.fog;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * If a scene environment is configured, this method makes sure to\n\t * represent the environment with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateEnvironment( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst environment = scene.environment;\n\n\t\tif ( environment ) {\n\n\t\t\tif ( sceneData.environment !== environment ) {\n\n\t\t\t\tconst environmentNode = this.getCacheNode( 'environment', environment, () => {\n\n\t\t\t\t\tif ( environment.isCubeTexture === true ) {\n\n\t\t\t\t\t\treturn cubeTexture( environment );\n\n\t\t\t\t\t} else if ( environment.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( environment );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'Nodes: Unsupported environment configuration.', environment );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.environmentNode = environmentNode;\n\t\t\t\tsceneData.environment = environment;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.environmentNode ) {\n\n\t\t\tdelete sceneData.environmentNode;\n\t\t\tdelete sceneData.environment;\n\n\t\t}\n\n\t}\n\n\tgetNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {\n\n\t\tconst nodeFrame = this.nodeFrame;\n\t\tnodeFrame.renderer = renderer;\n\t\tnodeFrame.scene = scene;\n\t\tnodeFrame.object = object;\n\t\tnodeFrame.camera = camera;\n\t\tnodeFrame.material = material;\n\n\t\treturn nodeFrame;\n\n\t}\n\n\tgetNodeFrameForRender( renderObject ) {\n\n\t\treturn this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );\n\n\t}\n\n\t/**\n\t * Returns the current output cache key.\n\t *\n\t * @return {String} The output cache key.\n\t */\n\tgetOutputCacheKey() {\n\n\t\tconst renderer = this.renderer;\n\n\t\treturn renderer.toneMapping + ',' + renderer.currentColorSpace;\n\n\t}\n\n\t/**\n\t * Checks if the output configuration (tone mapping and color space) for\n\t * the given target has changed.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {Boolean} Whether the output configuration has changed or not.\n\t */\n\thasOutputChange( outputTarget ) {\n\n\t\tconst cacheKey = _outputNodeMap.get( outputTarget );\n\n\t\treturn cacheKey !== this.getOutputCacheKey();\n\n\t}\n\n\t/**\n\t * Returns a node that represents the output configuration (tone mapping and\n\t * color space) for the current target.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {Node} The output node.\n\t */\n\tgetOutputNode( outputTarget ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst cacheKey = this.getOutputCacheKey();\n\n\t\tconst output = texture( outputTarget, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );\n\n\t\t_outputNodeMap.set( outputTarget, cacheKey );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateBefore()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateBefore( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateBeforeNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateBeforeNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateAfter()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAfter( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateAfterNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateAfterNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tconst nodeFrame = this.getNodeFrame();\n\t\tconst nodeBuilder = this.getForCompute( computeNode );\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst monitor = renderObject.getMonitor();\n\n\t\treturn monitor.needsRefresh( renderObject, nodeFrame );\n\n\t}\n\n\t/**\n\t * Frees the intenral resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\t\tthis.cacheLib = {};\n\n\t}\n\n}\n\nconst _plane = /*@__PURE__*/ new Plane();\n\n/**\n * Represents the state that is used to perform clipping via clipping planes.\n * There is a default clipping context for each render context. When the\n * scene holds instances of `ClippingGroup`, there will be a context for each\n * group.\n *\n * @private\n */\nclass ClippingContext {\n\n\t/**\n\t * Constructs a new clipping context.\n\t *\n\t * @param {ClippingContext?} [parentContext=null] - A reference to the parent clipping context.\n\t */\n\tconstructor( parentContext = null ) {\n\n\t\t/**\n\t\t * The clipping context's version.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n\t\t *\n\t\t * @type {Boolean?}\n\t\t * @default null\n\t\t */\n\t\tthis.clipIntersection = null;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.cacheKey = '';\n\n\t\t/**\n\t\t * Whether the shadow pass is active or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shadowPass = false;\n\n\t\t/**\n\t\t * The view normal matrix.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.viewNormalMatrix = new Matrix3();\n\n\t\t/**\n\t\t * Internal cache for maintaining clipping contexts.\n\t\t *\n\t\t * @type {WeakMap<ClippingGroup,ClippingContext>}\n\t\t */\n\t\tthis.clippingGroupContexts = new WeakMap();\n\n\t\t/**\n\t\t * The intersection planes.\n\t\t *\n\t\t * @type {Array<Vector4>}\n\t\t */\n\t\tthis.intersectionPlanes = [];\n\n\t\t/**\n\t\t * The intersection planes.\n\t\t *\n\t\t * @type {Array<Vector4>}\n\t\t */\n\t\tthis.unionPlanes = [];\n\n\t\t/**\n\t\t * The version of the clipping context's parent context.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @readonly\n\t\t */\n\t\tthis.parentVersion = null;\n\n\t\tif ( parentContext !== null ) {\n\n\t\t\tthis.viewNormalMatrix = parentContext.viewNormalMatrix;\n\t\t\tthis.clippingGroupContexts = parentContext.clippingGroupContexts;\n\n\t\t\tthis.shadowPass = parentContext.shadowPass;\n\t\t\tthis.viewMatrix = parentContext.viewMatrix;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Projects the given source clipping planes and writes the result into the\n\t * destination array.\n\t *\n\t * @param {Array<Plane>} source - The source clipping planes.\n\t * @param {Array<Vector4>} destination - The destination.\n\t * @param {Number} offset - The offset.\n\t */\n\tprojectPlanes( source, destination, offset ) {\n\n\t\tconst l = source.length;\n\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );\n\n\t\t\tconst v = destination[ offset + i ];\n\t\t\tconst normal = _plane.normal;\n\n\t\t\tv.x = - normal.x;\n\t\t\tv.y = - normal.y;\n\t\t\tv.z = - normal.z;\n\t\t\tv.w = _plane.constant;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the root clipping context of a scene.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t */\n\tupdateGlobal( scene, camera ) {\n\n\t\tthis.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial );\n\t\tthis.viewMatrix = camera.matrixWorldInverse;\n\n\t\tthis.viewNormalMatrix.getNormalMatrix( this.viewMatrix );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} parentContext - The parent context.\n\t * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.\n\t */\n\tupdate( parentContext, clippingGroup ) {\n\n\t\tlet update = false;\n\n\t\tif ( parentContext.version !== this.parentVersion ) {\n\n\t\t\tthis.intersectionPlanes = Array.from( parentContext.intersectionPlanes );\n\t\t\tthis.unionPlanes = Array.from( parentContext.unionPlanes );\n\t\t\tthis.parentVersion = parentContext.version;\n\n\t\t}\n\n\t\tif ( this.clipIntersection !== clippingGroup.clipIntersection ) {\n\n\t\t\tthis.clipIntersection = clippingGroup.clipIntersection;\n\n\t\t\tif ( this.clipIntersection ) {\n\n\t\t\t\tthis.unionPlanes.length = parentContext.unionPlanes.length;\n\n\t\t\t} else {\n\n\t\t\t\tthis.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst srcClippingPlanes = clippingGroup.clippingPlanes;\n\t\tconst l = srcClippingPlanes.length;\n\n\t\tlet dstClippingPlanes;\n\t\tlet offset;\n\n\t\tif ( this.clipIntersection ) {\n\n\t\t\tdstClippingPlanes = this.intersectionPlanes;\n\t\t\toffset = parentContext.intersectionPlanes.length;\n\n\t\t} else {\n\n\t\t\tdstClippingPlanes = this.unionPlanes;\n\t\t\toffset = parentContext.unionPlanes.length;\n\n\t\t}\n\n\t\tif ( dstClippingPlanes.length !== offset + l ) {\n\n\t\t\tdstClippingPlanes.length = offset + l;\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tdstClippingPlanes[ offset + i ] = new Vector4();\n\n\t\t\t}\n\n\t\t\tupdate = true;\n\n\t\t}\n\n\t\tthis.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );\n\n\t\tif ( update ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a clipping context for the given clipping group.\n\t *\n\t * @param {ClippingGroup} clippingGroup - The clipping group.\n\t * @return {ClippingContext} The clipping context.\n\t */\n\tgetGroupContext( clippingGroup ) {\n\n\t\tif ( this.shadowPass && ! clippingGroup.clipShadows ) return this;\n\n\t\tlet context = this.clippingGroupContexts.get( clippingGroup );\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ClippingContext( this );\n\t\t\tthis.clippingGroupContexts.set( clippingGroup, context );\n\n\t\t}\n\n\t\tcontext.update( this, clippingGroup );\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * The count of union clipping planes.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget unionClippingCount() {\n\n\t\treturn this.unionPlanes.length;\n\n\t}\n\n}\n\n/**\n * This module is used to represent render bundles inside the renderer\n * for further processing.\n *\n * @private\n */\nclass RenderBundle {\n\n\t/**\n\t * Constructs a new bundle group.\n\t *\n\t * @param {BundleGroup} bundleGroup - The bundle group.\n\t * @param {Camera} camera - The camera the bundle group is rendered with.\n\t */\n\tconstructor( bundleGroup, camera ) {\n\n\t\tthis.bundleGroup = bundleGroup;\n\t\tthis.camera = camera;\n\n\t}\n\n}\n\n/**\n * This renderer module manages render bundles.\n *\n * @private\n */\nclass RenderBundles {\n\n\t/**\n\t * Constructs a new render bundle management component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A chain map for maintaining the render bundles.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.bundles = new ChainMap();\n\n\t}\n\n\t/**\n\t * Returns a render bundle for the given bundle group and camera.\n\t *\n\t * @param {BundleGroup} bundleGroup - The bundle group.\n\t * @param {Camera} camera - The camera the bundle group is rendered with.\n\t * @return {RenderBundle} The render bundle.\n\t */\n\tget( bundleGroup, camera ) {\n\n\t\tconst bundles = this.bundles;\n\t\tconst keys = [ bundleGroup, camera ];\n\n\t\tlet bundle = bundles.get( keys );\n\n\t\tif ( bundle === undefined ) {\n\n\t\t\tbundle = new RenderBundle( bundleGroup, camera );\n\t\t\tbundles.set( keys, bundle );\n\n\t\t}\n\n\t\treturn bundle;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.bundles = new ChainMap();\n\n\t}\n\n}\n\n/**\n * The purpose of a node library is to assign node implementations\n * to existing library features. In `WebGPURenderer` lights, materials\n * which are not based on `NodeMaterial` as well as tone mapping techniques\n * are implemented with node-based modules.\n *\n * @private\n */\nclass NodeLibrary {\n\n\t/**\n\t * Constructs a new node library.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A weak map that maps lights to light nodes.\n\t\t *\n\t\t * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}\n\t\t */\n\t\tthis.lightNodes = new WeakMap();\n\n\t\t/**\n\t\t * A map that maps materials to node materials.\n\t\t *\n\t\t * @type {WeakMap<String,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.materialNodes = new Map();\n\n\t\t/**\n\t\t * A map that maps tone mapping techniques (constants)\n\t\t * to tone mapping node functions.\n\t\t *\n\t\t * @type {WeakMap<Number,Function>}\n\t\t */\n\t\tthis.toneMappingNodes = new Map();\n\n\t}\n\n\t/**\n\t * Returns a matching node material instance for the given material object.\n\t *\n\t * This method also assigns/copies the properties of the given material object\n\t * to the node material. This is done to make sure the current material\n\t * configuration carries over to the node version.\n\t *\n\t * @param {Material} material - A material.\n\t * @return {NodeMaterial} The corresponding node material.\n\t */\n\tfromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial ) return material;\n\n\t\tlet nodeMaterial = null;\n\n\t\tconst nodeMaterialClass = this.getMaterialNodeClass( material.type );\n\n\t\tif ( nodeMaterialClass !== null ) {\n\n\t\t\tnodeMaterial = new nodeMaterialClass();\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n\t/**\n\t * Adds a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {Function} toneMappingNode - The tone mapping node function.\n\t * @param {Number} toneMapping - The tone mapping.\n\t */\n\taddToneMapping( toneMappingNode, toneMapping ) {\n\n\t\tthis.addType( toneMappingNode, toneMapping, this.toneMappingNodes );\n\n\t}\n\n\t/**\n\t * Returns a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {Number} toneMapping - The tone mapping.\n\t * @return {Function?} The tone mapping node function. Returns `null` if no node function is found.\n\t */\n\tgetToneMappingFunction( toneMapping ) {\n\n\t\treturn this.toneMappingNodes.get( toneMapping ) || null;\n\n\t}\n\n\t/**\n\t * Returns a node material class definition for a material type.\n\t *\n\t * @param {Sring} materialType - The material type.\n\t * @return {NodeMaterial.constructor?} The node material class definition. Returns `null` if no node material is found.\n\t */\n\tgetMaterialNodeClass( materialType ) {\n\n\t\treturn this.materialNodes.get( materialType ) || null;\n\n\t}\n\n\t/**\n\t * Adds a node material class definition for a given material type.\n\t *\n\t * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.\n\t * @param {Sring} materialClassType - The material type.\n\t */\n\taddMaterial( materialNodeClass, materialClassType ) {\n\n\t\tthis.addType( materialNodeClass, materialClassType, this.materialNodes );\n\n\t}\n\n\t/**\n\t * Returns a light node class definition for a light class definition.\n\t *\n\t * @param {Light.constructor} light - The light class definition.\n\t * @return {AnalyticLightNode.constructor?} The light node class definition. Returns `null` if no light node is found.\n\t */\n\tgetLightNodeClass( light ) {\n\n\t\treturn this.lightNodes.get( light ) || null;\n\n\t}\n\n\t/**\n\t * Adds a light node class definition for a given light class definition.\n\t *\n\t * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.\n\t * @param {Light.constructor} lightClass - The light class definition.\n\t */\n\taddLight( lightNodeClass, lightClass ) {\n\n\t\tthis.addClass( lightNodeClass, lightClass, this.lightNodes );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given type to the provided type library.\n\t *\n\t * @param {Any} nodeClass - The node class definition.\n\t * @param {String} type - The object type.\n\t * @param {Map} library - The type library.\n\t */\n\taddType( nodeClass, type, library ) {\n\n\t\tif ( library.has( type ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ type }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );\n\n\t\tlibrary.set( type, nodeClass );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given class definition to the provided type library.\n\t *\n\t * @param {Any} nodeClass - The node class definition.\n\t * @param {Any} baseClass - The class definition.\n\t * @param {WeakMap} library - The type library.\n\t */\n\taddClass( nodeClass, baseClass, library ) {\n\n\t\tif ( library.has( baseClass ) ) {\n\n\t\t\tconsole.warn( `Redefinition of node ${ baseClass.name }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );\n\n\t\tlibrary.set( baseClass, nodeClass );\n\n\t}\n\n}\n\nconst _defaultLights = /*@__PURE__*/ new LightsNode();\n\n/**\n * This renderer module manages the lights nodes which are unique\n * per scene and camera combination.\n *\n * The lights node itself is later configured in the render list\n * with the actual lights from the scene.\n *\n * @private\n * @augments ChainMap\n */\nclass Lighting extends ChainMap {\n\n\t/**\n\t * Constructs a lighting management component.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\t/**\n\t * Creates a new lights node for the given array of lights.\n\t *\n\t * @param {Array<Light>} lights - The render object.\n\t * @return {Boolean} Whether if the given render object has an initialized geometry or not.\n\t */\n\tcreateNode( lights = [] ) {\n\n\t\treturn new LightsNode().setLights( lights );\n\n\t}\n\n\t/**\n\t * Returns a lights node for the given scene and camera.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera.\n\t * @return {LightsNode} The lights node.\n\t */\n\tgetNode( scene, camera ) {\n\n\t\t// ignore post-processing\n\n\t\tif ( scene.isQuadMesh ) return _defaultLights;\n\n\t\t// tiled lighting\n\n\t\tconst keys = [ scene, camera ];\n\n\t\tlet node = this.get( keys );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = this.createNode();\n\t\t\tthis.set( keys, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\n/** @module Renderer **/\n\nconst _scene = /*@__PURE__*/ new Scene();\nconst _drawingBufferSize = /*@__PURE__*/ new Vector2();\nconst _screen = /*@__PURE__*/ new Vector4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _vector4 = /*@__PURE__*/ new Vector4();\n\n/**\n * Base class for renderers.\n */\nclass Renderer {\n\n\t/**\n\t * Constructs a new renderer.\n\t *\n\t * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0\n\t * to overwrite the default.\n\t * @param {Function?} [parameters.getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t */\n\tconstructor( backend, parameters = {} ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderer = true;\n\n\t\t//\n\n\t\tconst {\n\t\t\tlogarithmicDepthBuffer = false,\n\t\t\talpha = true,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\tantialias = false,\n\t\t\tsamples = 0,\n\t\t\tgetFallback = null\n\t\t} = parameters;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t * This value of this property will automatically be created by\n\t\t * the renderer.\n\t\t *\n\t\t * @type {HTMLCanvasElement|OffscreenCanvas}\n\t\t */\n\t\tthis.domElement = backend.getDomElement();\n\n\t\t/**\n\t\t * A reference to the current backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The number of MSAA samples.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis.samples = samples || ( antialias === true ) ? 4 : 0;\n\n\t\t/**\n\t\t * Whether the renderer should automatically clear the current rendering target\n\t\t * before execute a `render()` call. The target can be the canvas (default framebuffer)\n\t\t * or the current bound render target (custom framebuffer).\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClear = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the color buffer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearColor = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the depth buffer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearDepth = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the stencil buffer.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearStencil = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should be transparent or opaque.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.alpha = alpha;\n\n\t\t/**\n\t\t * Whether logarithmic depth buffer is enabled or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n\t\t/**\n\t\t * Defines the output color space of the renderer.\n\t\t *\n\t\t * @type {String}\n\t\t * @default SRGBColorSpace\n\t\t */\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\t/**\n\t\t * Defines the tone mapping of the renderer.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default NoToneMapping\n\t\t */\n\t\tthis.toneMapping = NoToneMapping;\n\n\t\t/**\n\t\t * Defines the tone mapping exposure.\n\t\t *\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t/**\n\t\t * Whether the renderer should sort its render lists or not.\n\t\t *\n\t\t * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.\n\t\t * By definition, sorting objects may not work in all cases. Depending on the needs of application,\n\t\t * it may be necessary to turn off sorting and use other methods to deal with transparency rendering\n\t\t * e.g. manually determining each object's rendering order.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sortObjects = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a depth buffer or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a stencil buffer or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = stencil;\n\n\t\t/**\n\t\t * Holds a series of statistical information about the GPU memory\n\t\t * and the rendering process. Useful for debugging and monitoring.\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.info = new Info();\n\n\t\tthis.nodes = {\n\t\t\tmodelViewMatrix: null,\n\t\t\tmodelNormalViewMatrix: null\n\t\t};\n\n\t\t/**\n\t\t * The node library defines how certain library objects like materials, lights\n\t\t * or tone mapping functions are mapped to node types. This is required since\n\t\t * although instances of classes like `MeshBasicMaterial` or `PointLight` can\n\t\t * be part of the scene graph, they are internally represented as nodes for\n\t\t * further processing.\n\t\t *\n\t\t * @type {NodeLibrary}\n\t\t */\n\t\tthis.library = new NodeLibrary();\n\n\t\t/**\n\t\t * A map-like data structure for managing lights.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = new Lighting();\n\n\t\t// internals\n\n\t\t/**\n\t\t * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._getFallback = getFallback;\n\n\t\t/**\n\t\t * The renderer's pixel ration.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The width of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._width = this.domElement.width;\n\n\t\t/**\n\t\t * The height of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._height = this.domElement.height;\n\n\t\t/**\n\t\t * The viewport of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * The scissor rectangle of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * Whether the scissor test should be enabled or not.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._scissorTest = false;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Attributes?}\n\t\t * @default null\n\t\t */\n\t\tthis._attributes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing geometries.\n\t\t *\n\t\t * @private\n\t\t * @type {Geometries?}\n\t\t * @default null\n\t\t */\n\t\tthis._geometries = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing node related logic.\n\t\t *\n\t\t * @private\n\t\t * @type {Nodes?}\n\t\t * @default null\n\t\t */\n\t\tthis._nodes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing the internal animation loop.\n\t\t *\n\t\t * @private\n\t\t * @type {Animation?}\n\t\t * @default null\n\t\t */\n\t\tthis._animation = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader program bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {Bindings?}\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render objects.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderObjects?}\n\t\t * @default null\n\t\t */\n\t\tthis._objects = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render and cmopute pipelines.\n\t\t *\n\t\t * @private\n\t\t * @type {Pipelines?}\n\t\t * @default null\n\t\t */\n\t\tthis._pipelines = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render bundles.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderBundles?}\n\t\t * @default null\n\t\t */\n\t\tthis._bundles = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render lists.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderLists?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderLists = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render contexts.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContexts?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderContexts = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing textures.\n\t\t *\n\t\t * @private\n\t\t * @type {Textures?}\n\t\t * @default null\n\t\t */\n\t\tthis._textures = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for backgrounds.\n\t\t *\n\t\t * @private\n\t\t * @type {Background?}\n\t\t * @default null\n\t\t */\n\t\tthis._background = null;\n\n\t\t/**\n\t\t * This fullscreen quad is used for internal render passes\n\t\t * like the tone mapping and color space output pass.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quad = new QuadMesh( new NodeMaterial() );\n\t\tthis._quad.material.name = 'Renderer_output';\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContext?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderContext = null;\n\n\t\t/**\n\t\t * A custom sort function for the opaque render list.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._opaqueSort = null;\n\n\t\t/**\n\t\t * A custom sort function for the transparent render list.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._transparentSort = null;\n\n\t\t/**\n\t\t * The framebuffer target.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis._frameBufferTarget = null;\n\n\t\tconst alphaClear = this.alpha === true ? 0 : 1;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @private\n\t\t * @type {Color4}\n\t\t */\n\t\tthis._clearColor = new Color4( 0, 0, 0, alphaClear );\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 1\n\t\t */\n\t\tthis._clearDepth = 1;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._clearStencil = 0;\n\n\t\t/**\n\t\t * The current render target.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderTarget = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeCubeFace = 0;\n\n\t\t/**\n\t\t * The active mipmap level.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeMipmapLevel = 0;\n\n\t\t/**\n\t\t * The MRT setting.\n\t\t *\n\t\t * @private\n\t\t * @type {MRTNode?}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * This function defines how a render object is going\n\t\t * to be rendered.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._renderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render object function.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render bundle.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderBundle?}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderBundle = null;\n\n\t\t/**\n\t\t * Next to `_renderObjectFunction()`, this function provides another hook\n\t\t * for influening the render process of a render object. It is meant for internal\n\t\t * use and only relevant for `compileAsync()` right now. Instead of using\n\t\t * the default logic of `_renderObjectDirect()` which actually draws the render object,\n\t\t * a different function might be used which performs no draw but just the node\n\t\t * and pipeline updates.\n\t\t *\n\t\t * @private\n\t\t * @type {Function?}\n\t\t * @default null\n\t\t */\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t/**\n\t\t * Indicates whether the device has been lost or not. In WebGL terms, the device\n\t\t * lost is considered as a context lost. When this is set to `true`, rendering\n\t\t * isn't possible anymore.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._isDeviceLost = false;\n\n\t\t/**\n\t\t * A callback function that defines what should happen when a device/context lost occurs.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.onDeviceLost = this._onDeviceLost;\n\n\t\t/**\n\t\t * Whether the renderer has been initialized or not.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * A reference to the promise which initializes the renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {Promise?}\n\t\t * @default null\n\t\t */\n\t\tthis._initPromise = null;\n\n\t\t/**\n\t\t * An array of compilation promises which are used in `compileAsync()`.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Promise>?}\n\t\t * @default null\n\t\t */\n\t\tthis._compilationPromises = null;\n\n\t\t/**\n\t\t * Whether the renderer should render transparent render objects or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\t/**\n\t\t * Whether the renderer should render opaque render objects or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.opaque = true;\n\n\t\t/**\n\t\t * Shadow map configuration\n\t\t * @typedef {Object} ShadowMapConfig\n\t\t * @property {Boolean} enabled - Whether to globally enable shadows or not.\n\t\t * @property {Number} type - The shadow map type.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's shadow configuration.\n\t\t *\n\t\t * @type {module:Renderer~ShadowMapConfig}\n\t\t */\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: PCFShadowMap\n\t\t};\n\n\t\t/**\n\t\t * XR configuration.\n\t\t * @typedef {Object} XRConfig\n\t\t * @property {Boolean} enabled - Whether to globally enable XR or not.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's XR configuration.\n\t\t *\n\t\t * @type {module:Renderer~XRConfig}\n\t\t */\n\t\tthis.xr = {\n\t\t\tenabled: false\n\t\t};\n\n\t\t/**\n\t\t * Debug configuration.\n\t\t * @typedef {Object} DebugConfig\n\t\t * @property {Boolean} checkShaderErrors - Whether shader errors should be checked or not.\n\t\t * @property {Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.\n\t\t * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camerea and 3D object.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's debug configuration.\n\t\t *\n\t\t * @type {module:Renderer~DebugConfig}\n\t\t */\n\t\tthis.debug = {\n\t\t\tcheckShaderErrors: true,\n\t\t\tonShaderError: null,\n\t\t\tgetShaderAsync: async ( scene, camera, object ) => {\n\n\t\t\t\tawait this.compileAsync( scene, camera );\n\n\t\t\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\t\t\tconst renderContext = this._renderContexts.get( scene, camera, this._renderTarget );\n\n\t\t\t\tconst material = scene.overrideMaterial || object.material;\n\n\t\t\t\tconst renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );\n\n\t\t\t\tconst { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();\n\n\t\t\t\treturn { fragmentShader, vertexShader };\n\n\t\t\t}\n\t\t};\n\n\t}\n\n\t/**\n\t * Initializes the renderer so it is ready for usage.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the renderer has been initialized.\n\t */\n\tasync init() {\n\n\t\tif ( this._initialized ) {\n\n\t\t\tthrow new Error( 'Renderer: Backend has already been initialized.' );\n\n\t\t}\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tlet backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( this._getFallback !== null ) {\n\n\t\t\t\t\t// try the fallback\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tthis.backend = backend = this._getFallback( error );\n\t\t\t\t\t\tawait backend.init( this );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\treject( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._animation = new Animation( this._nodes, this.info );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( this, backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists( this.lighting );\n\t\t\tthis._bundles = new RenderBundles();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.start();\n\t\t\tthis._initialized = true;\n\n\t\t\tresolve();\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\t/**\n\t * The coordinate system of the renderer. The value of this property\n\t * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or\n\t * `THREE.WebGPUCoordinateSystem`.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\t/**\n\t * Compiles all materials in the given scene. This can be useful to avoid a\n\t * phenomenon which is called \"shader compilation stutter\", which occurs when\n\t * rendering an object with a new shader for the first time.\n\t *\n\t * If you want to add a 3D object to an existing scene, use the third optional\n\t * parameter for applying the target scene. Note that the (target) scene's lighting\n\t * and environment must be configured before calling this method.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {Promise} A Promise that resolves when the compile has been finished.\n\t */\n\tasync compileAsync( scene, camera, targetScene = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\t\tconst previousCompilationPromises = this._compilationPromises;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( targetScene, camera, renderTarget );\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tconst compilationPromises = [];\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this.renderObject;\n\n\t\tthis._handleObjectFunction = this._createObjectPipeline;\n\n\t\tthis._compilationPromises = compilationPromises;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tnodeFrame.update();\n\n\t\t//\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\t// include lights from target scene\n\t\tif ( targetScene !== scene ) {\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderList.pushLight( object );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\trenderList.finish();\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\n\t\t}\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst transparentDoublePassObjects = renderList.transparentDoublePass;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\t\tthis._compilationPromises = previousCompilationPromises;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n\t\tawait Promise.all( compilationPromises );\n\n\t}\n\n\t/**\n\t * Renders the scene in an async fashion.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( scene, camera ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tconst renderContext = this._renderScene( scene, camera );\n\n\t\tawait this.backend.resolveTimestampAsync( renderContext, 'render' );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.backend.waitForGPU();\n\n\t}\n\n\t/**\n\t * Sets the given MRT configuration.\n\t *\n\t * @param {MRTNode} mrt - The MRT node to set.\n\t * @return {Renderer} A reference to this renderer.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the MRT configuration.\n\t *\n\t * @return {MRTNode} The MRT configuration.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * Default implementation of the device lost callback.\n\t *\n\t * @private\n\t * @param {Object} info - Information about the context lost.\n\t */\n\t_onDeviceLost( info ) {\n\n\t\tlet errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n\n\t\tif ( info.reason ) {\n\n\t\t\terrorMessage += `\\nReason: ${info.reason}`;\n\n\t\t}\n\n\t\tconsole.error( errorMessage );\n\n\t\tthis._isDeviceLost = true;\n\n\t}\n\n\t/**\n\t * Renders the given render bundle.\n\t *\n\t * @private\n\t * @param {Object} bundle - Render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundle belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderBundle( bundle, sceneRef, lightsNode ) {\n\n\t\tconst { bundleGroup, camera, renderList } = bundle;\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst renderBundle = this._bundles.get( bundleGroup, camera );\n\t\tconst renderBundleData = this.backend.get( renderBundle );\n\n\t\tif ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();\n\n\t\t//\n\n\t\tconst needsUpdate = bundleGroup.version !== renderBundleData.version;\n\t\tconst renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;\n\n\t\trenderBundleData.renderContexts.add( renderContext );\n\n\t\tif ( renderBundleNeedsUpdate ) {\n\n\t\t\tthis.backend.beginBundle( renderContext );\n\n\t\t\tif ( renderBundleData.renderObjects === undefined || needsUpdate ) {\n\n\t\t\t\trenderBundleData.renderObjects = [];\n\n\t\t\t}\n\n\t\t\tthis._currentRenderBundle = renderBundle;\n\n\t\t\tconst opaqueObjects = renderList.opaque;\n\n\t\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\n\t\t\tthis._currentRenderBundle = null;\n\n\t\t\t//\n\n\t\t\tthis.backend.finishBundle( renderContext, renderBundle );\n\n\t\t\trenderBundleData.version = bundleGroup.version;\n\n\t\t} else {\n\n\t\t\tconst { renderObjects } = renderBundleData;\n\n\t\t\tfor ( let i = 0, l = renderObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderObject = renderObjects[ i ];\n\n\t\t\t\tif ( this._nodes.needsRefresh( renderObject ) ) {\n\n\t\t\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t\t\t\tthis._nodes.updateAfter( renderObject );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.backend.addBundle( renderContext, renderBundle );\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * The target of the method is the default framebuffer (meaning the canvas)\n\t * or alternatively a render target when specified via `setRenderTarget()`.\n\t *\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @return {Promise?} A Promise that resolve when the scene has been rendered.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\trender( scene, camera ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );\n\n\t\t\treturn this.renderAsync( scene, camera );\n\n\t\t}\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t/**\n\t * Returns an internal render target which is used when computing the output tone mapping\n\t * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render\n\t * pass and not inline to achieve more correct results.\n\t *\n\t * @private\n\t * @return {RenderTarget?} The render target. The method returns `null` if no output conversion should be applied.\n\t */\n\t_getFrameBufferTarget() {\n\n\t\tconst { currentToneMapping, currentColorSpace } = this;\n\n\t\tconst useToneMapping = currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = currentColorSpace !== LinearSRGBColorSpace;\n\n\t\tif ( useToneMapping === false && useColorSpace === false ) return null;\n\n\t\tconst { width, height } = this.getDrawingBufferSize( _drawingBufferSize );\n\t\tconst { depth, stencil } = this;\n\n\t\tlet frameBufferTarget = this._frameBufferTarget;\n\n\t\tif ( frameBufferTarget === null ) {\n\n\t\t\tframeBufferTarget = new RenderTarget( width, height, {\n\t\t\t\tdepthBuffer: depth,\n\t\t\t\tstencilBuffer: stencil,\n\t\t\t\ttype: HalfFloatType, // FloatType\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tsamples: this.samples\n\t\t\t} );\n\n\t\t\tframeBufferTarget.isPostProcessingRenderTarget = true;\n\n\t\t\tthis._frameBufferTarget = frameBufferTarget;\n\n\t\t}\n\n\t\tframeBufferTarget.depthBuffer = depth;\n\t\tframeBufferTarget.stencilBuffer = stencil;\n\t\tframeBufferTarget.setSize( width, height );\n\t\tframeBufferTarget.viewport.copy( this._viewport );\n\t\tframeBufferTarget.scissor.copy( this._scissor );\n\t\tframeBufferTarget.viewport.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissor.multiplyScalar( this._pixelRatio );\n\t\tframeBufferTarget.scissorTest = this._scissorTest;\n\n\t\treturn frameBufferTarget;\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera.\n\t *\n\t * @private\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @param {Boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.\n\t * @return {RenderContext} The current render context.\n\t */\n\t_renderScene( scene, camera, useFrameBufferTarget = true ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tconst frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst outputRenderTarget = this._renderTarget;\n\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\t//\n\n\t\tlet renderTarget;\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\trenderTarget = frameBufferTarget;\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t} else {\n\n\t\t\trenderTarget = outputRenderTarget;\n\n\t\t}\n\n\t\t//\n\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.render.calls ++;\n\t\tthis.info.render.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t//\n\n\t\tlet viewport = this._viewport;\n\t\tlet scissor = this._scissor;\n\t\tlet pixelRatio = this._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = this.domElement.width;\n\t\t\trenderContext.height = this.domElement.height;\n\t\t\trenderContext.depth = this.depth;\n\t\t\trenderContext.stencil = this.stencil;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst {\n\t\t\tbundles,\n\t\t\tlightsNode,\n\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\ttransparent: transparentObjects,\n\t\t\topaque: opaqueObjects\n\t\t} = renderList;\n\n\t\tif ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\n\t\t//\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\tthis.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\treturn renderContext;\n\n\t}\n\n\t/**\n\t * Returns the maximum available anisotropy for texture filtering.\n\t *\n\t * @return {Number} The maximum available anisotropy.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.backend.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Returns the active cube face.\n\t *\n\t * @return {Number} The active cube face.\n\t */\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\t/**\n\t * Returns the active mipmap level.\n\t *\n\t * @return {Number} The active mipmap level.\n\t */\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Applications are advised to always define the animation loop\n\t * with this method and not manually with `requestAnimationFrame()`\n\t * for best compatibility.\n\t *\n\t * @async\n\t * @param {Function} callback - The application's animation loop.\n\t * @return {Promise} A Promise that resolves when the set has been exeucted.\n\t */\n\tasync setAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._animation.setAnimationLoop( callback );\n\n\t}\n\n\t/**\n\t * Can be used to transfer buffer data from a storage buffer attribute\n\t * from the GPU to the CPU in context of compute shaders.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the rendering context.\n\t *\n\t * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.backend.getContext();\n\n\t}\n\n\t/**\n\t * Returns the pixel ratio.\n\t *\n\t * @return {Number} The pixel ratio.\n\t */\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\t/**\n\t * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\t/**\n\t * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Sets the given pixel ration and resizes the canvas if necessary.\n\t *\n\t * @param {Number} [value=1] - The pixel ratio.\n\t */\n\tsetPixelRatio( value = 1 ) {\n\n\t\tif ( this._pixelRatio === value ) return;\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\t/**\n\t * This method allows to define the drawing buffer size by specifying\n\t * width, height and pixel ratio all at once. The size of the drawing\n\t * buffer is computed with this formula:\n\t * ````\n\t * size.x = width * pixelRatio;\n\t * size.y = height * pixelRatio;\n\t *```\n\t *\n\t * @param {Number} width - The width in logical pixels.\n\t * @param {Number} height - The height in logical pixels.\n\t * @param {Number} pixelRatio - The pixel ratio.\n\t */\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Sets the size of the renderer.\n\t *\n\t * @param {Number} width - The width in logical pixels.\n\t * @param {Number} height - The height in logical pixels.\n\t * @param {Boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n\t */\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the opaque render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the transparent render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\t/**\n\t * Returns the scissor rectangle.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The scissor rectangle.\n\t */\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Defines the scissor rectangle.\n\t *\n\t * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {Number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {Number} width - The width of the scissor box in logical pixel unit.\n\t * @param {Number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the scissor test value.\n\t *\n\t * @return {Boolean} Whether the scissor test should be enabled or not.\n\t */\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t\tthis.backend.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Returns the viewport definition.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The viewport definition.\n\t */\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\t/**\n\t * Defines the viewport.\n\t *\n\t * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {Number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {Number} width - The width of the viewport in logical pixel unit.\n\t * @param {Number} height - The height of the viewport in logical pixel unit.\n\t * @param {Number} minDepth - The minimum depth value of the viewport. WebGPU only.\n\t * @param {Number} maxDepth - The maximum depth value of the viewport. WebGPU only.\n\t */\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\t/**\n\t * Returns the clear color.\n\t *\n\t * @param {Color} target - The method writes the result in this target object.\n\t * @return {Color} The clear color.\n\t */\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\t/**\n\t * Defines the clear color and optionally the clear alpha.\n\t *\n\t * @param {Color} color - The clear color.\n\t * @param {Number} [alpha=1] - The clear alpha.\n\t */\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear alpha.\n\t *\n\t * @return {Number} The clear alpha.\n\t */\n\tgetClearAlpha() {\n\n\t\treturn this._clearColor.a;\n\n\t}\n\n\t/**\n\t * Defines the clear alpha.\n\t *\n\t * @param {Number} alpha - The clear alpha.\n\t */\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear depth.\n\t *\n\t * @return {Number} The clear depth.\n\t */\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\t/**\n\t * Defines the clear depth.\n\t *\n\t * @param {Number} depth - The clear depth.\n\t */\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\t/**\n\t * Returns the clear stencil.\n\t *\n\t * @return {Number} The clear stencil.\n\t */\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\t/**\n\t * Defines the clear stencil.\n\t *\n\t * @param {Number} stencil - The clear stencil.\n\t */\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\t/**\n\t * This method performs an occlusion query for the given 3D object.\n\t * It returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation. This method ignores `autoClear` properties.\n\t *\n\t * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );\n\n\t\t\treturn this.clearAsync( color, depth, stencil );\n\n\t\t}\n\n\t\tconst renderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\tlet renderContext = null;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext = this._renderContexts.get( null, null, renderTarget );\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t}\n\n\t\tthis.backend.clear( color, depth, stencil, renderContext );\n\n\t\tif ( renderTarget !== null && this._renderTarget === null ) {\n\n\t\t\t// If a color space transform or tone mapping is required,\n\t\t\t// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.\n\n\t\t\tconst quad = this._quad;\n\n\t\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\t\tquad.material.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearColor() {\n\n\t\treturn this.clear( true, false, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearDepth() {\n\n\t\treturn this.clear( false, true, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.\n\t *\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t * Only returned when the renderer has not been initialized.\n\t */\n\tclearStencil() {\n\n\t\treturn this.clear( false, false, true );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clear}.\n\t *\n\t * @async\n\t * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearAsync( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.clear( color, depth, stencil );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clearColor}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearColorAsync() {\n\n\t\tthis.clearAsync( true, false, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clearDepth}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearDepthAsync() {\n\n\t\tthis.clearAsync( false, true, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link module:Renderer~Renderer#clearStencil}.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearStencilAsync() {\n\n\t\tthis.clearAsync( false, false, true );\n\n\t}\n\n\t/**\n\t * The current output tone mapping of the renderer. When a render target is set,\n\t * the output tone mapping is always `NoToneMapping`.\n\t *\n\t * @type {Number}\n\t */\n\tget currentToneMapping() {\n\n\t\treturn this._renderTarget !== null ? NoToneMapping : this.toneMapping;\n\n\t}\n\n\t/**\n\t * The current output color space of the renderer. When a render target is set,\n\t * the output color space is always `LinearSRGBColorSpace`.\n\t *\n\t * @type {String}\n\t */\n\tget currentColorSpace() {\n\n\t\treturn this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;\n\n\t}\n\n\t/**\n\t * Frees all internal resources of the renderer. Call this method if the renderer\n\t * is no longer in use by your app.\n\t */\n\tdispose() {\n\n\t\tthis.info.dispose();\n\t\tthis.backend.dispose();\n\n\t\tthis._animation.dispose();\n\t\tthis._objects.dispose();\n\t\tthis._pipelines.dispose();\n\t\tthis._nodes.dispose();\n\t\tthis._bindings.dispose();\n\t\tthis._renderLists.dispose();\n\t\tthis._renderContexts.dispose();\n\t\tthis._textures.dispose();\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\t/**\n\t * Sets the given render target. Calling this method means the renderer does not\n\t * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {RenderTarget?} renderTarget - The render target to set.\n\t * @param {Number} [activeCubeFace=0] - The active cube face.\n\t * @param {Number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Returns the current render target.\n\t *\n\t * @return {RenderTarget?} The render target. Returns `null` if no render target is set.\n\t */\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\t/**\n\t * Callback for {@link module:Renderer~Renderer#setRenderObjectFunction}.\n\t *\n\t * @callback renderObjectFunction\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\n\t/**\n\t * Sets the given render object function. Calling this method overwrites the default implementation\n\t * which is {@link module:Renderer~Renderer#renderObject}. Defining a custom function can be useful\n\t * if you want to modify the way objects are rendered. For example you can define things like \"every\n\t * object that has material of a certain type should perform a pre-pass with a special overwrite material\".\n\t * The custom function must always call `renderObject()` in its implementation.\n\t *\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {module:Renderer~renderObjectFunction?} renderObjectFunction - The render object function.\n\t */\n\tsetRenderObjectFunction( renderObjectFunction ) {\n\n\t\tthis._renderObjectFunction = renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Returns the current render object function.\n\t *\n\t * @return {Function?} The current render object function. Returns `null` if no function is set.\n\t */\n\tgetRenderObjectFunction() {\n\n\t\treturn this._renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @return {Promise?} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.\n\t */\n\tcompute( computeNodes ) {\n\n\t\tif ( this.isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );\n\n\t\t\treturn this.computeAsync( computeNodes );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.compute.calls ++;\n\t\tthis.info.compute.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tif ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {\n\n\t\t\tthrow new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );\n\n\t\t}\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.delete( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tconst onInitFn = computeNode.onInitFunction;\n\n\t\t\t\tif ( onInitFn !== null ) {\n\n\t\t\t\t\tonInitFn.call( computeNode, { renderer: this } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t\t//\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes.\n\t *\n\t * @async\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @return {Promise?} A Promise that resolve when the compute has finished.\n\t */\n\tasync computeAsync( computeNodes ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.compute( computeNodes );\n\n\t\tawait this.backend.resolveTimestampAsync( computeNodes, 'compute' );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend.\n\t *\n\t * @async\n\t * @param {String} name - The feature's name.\n\t * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( name ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend. If the\n\t * renderer has not been initialized, this method always returns `false`.\n\t *\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\t/**\n\t * Returns `true` when the renderer has been initialized.\n\t *\n\t * @return {Boolean} Whether the renderer has been initialized or not.\n\t */\n\thasInitialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\t/**\n\t * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture.\n\t * @return {Promise} A Promise that resolves when the texture has been initialized.\n\t */\n\tasync initTextureAsync( texture ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * This method can only be used if the renderer has been initialized.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tinitTexture( texture ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tconsole.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );\n\n\t\t}\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer into the given texture.\n\t *\n\t * @param {FramebufferTexture} framebufferTexture - The texture.\n\t * @param {Vector2|Vector4} rectangle - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.\n\t */\n\tcopyFramebufferToTexture( framebufferTexture, rectangle = null ) {\n\n\t\tif ( rectangle !== null ) {\n\n\t\t\tif ( rectangle.isVector2 ) {\n\n\t\t\t\trectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();\n\n\t\t\t} else if ( rectangle.isVector4 ) {\n\n\t\t\t\trectangle = _vector4.copy( rectangle ).floor();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );\n\n\t\t}\n\n\t\t//\n\n\t\tlet renderContext = this._currentRenderContext;\n\t\tlet renderTarget;\n\n\t\tif ( renderContext !== null ) {\n\n\t\t\trenderTarget = renderContext.renderTarget;\n\n\t\t} else {\n\n\t\t\trenderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\t\trenderContext = this._textures.get( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._textures.updateTexture( framebufferTexture, { renderTarget } );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Copies data of source texture into a destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.\n\t * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.\n\t * @param {Number} level - The mipmap level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tthis._textures.updateTexture( srcTexture );\n\t\tthis._textures.updateTexture( dstTexture );\n\n\t\tthis.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\t/**\n\t * Reads pixel data from the given render target.\n\t *\n\t * @async\n\t * @param {RenderTarget} renderTarget - The render target to read from.\n\t * @param {Number} x - The `x` coordinate of the copy region's origin.\n\t * @param {Number} y - The `y` coordinate of the copy region's origin.\n\t * @param {Number} width - The width of the copy region.\n\t * @param {Number} height - The height of the copy region.\n\t * @param {Number} [textureIndex=0] - The texture index of a MRT render target.\n\t * @param {Number} [faceIndex=0] - The active cube face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.\n\t */\n\tasync readRenderTargetPixelsAsync( renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0 ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.textures[ textureIndex ], x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Analyzes the given 3D object's hierarchy and builds render lists from the\n\t * processed hierarchy.\n\t *\n\t * @param {Object3D} object - The 3D object to process (usually a scene).\n\t * @param {Camera} camera - The camera the object is rendered with.\n\t * @param {Number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\t_projectObject( object, camera, groupOrder, renderList, clippingContext ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\tif ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\tconsole.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {\n\n\t\t\tconst baseRenderList = renderList;\n\n\t\t\t// replace render list\n\t\t\trenderList = this._renderLists.get( object, camera );\n\n\t\t\trenderList.begin();\n\n\t\t\tbaseRenderList.pushBundle( {\n\t\t\t\tbundleGroup: object,\n\t\t\t\tcamera,\n\t\t\t\trenderList,\n\t\t\t} );\n\n\t\t\trenderList.finish();\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the given render bundles.\n\t *\n\t * @private\n\t * @param {Array<Object>} bundles - Array with render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundles belong to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderBundles( bundles, sceneRef, lightsNode ) {\n\n\t\tfor ( const bundle of bundles ) {\n\n\t\t\tthis._renderBundle( bundle, sceneRef, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the transparent objects from the given render lists.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The transparent render list.\n\t * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {\n\n\t\tif ( doublePassList.length > 0 ) {\n\n\t\t\t// render back side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );\n\n\t\t\t// render front side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = FrontSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t\t// restore\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the objects from the given render list.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The render list.\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {\n\n\t\t// process renderable objects\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t// @TODO: Add support for multiple materials per object. This will require to extract\n\t\t\t// the material from the renderItem object and pass it with its group data to renderObject().\n\n\t\t\tconst { object, geometry, material, group, clippingContext } = renderItem;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tconst vp = camera2.viewport;\n\t\t\t\t\t\tconst minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;\n\t\t\t\t\t\tconst maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;\n\n\t\t\t\t\t\tconst viewportValue = this._currentRenderContext.viewportValue;\n\t\t\t\t\t\tviewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();\n\t\t\t\t\t\tviewportValue.minDepth = minDepth;\n\t\t\t\t\t\tviewportValue.maxDepth = maxDepth;\n\n\t\t\t\t\t\tthis.backend.updateViewport( this._currentRenderContext );\n\n\t\t\t\t\t\tthis._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method represents the default render object function that manages the render lifecycle\n\t * of the object.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\trenderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {\n\n\t\tlet overridePositionNode;\n\t\tlet overrideColorNode;\n\t\tlet overrideDepthNode;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial !== null ) {\n\n\t\t\tconst overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\toverridePositionNode = overrideMaterial.positionNode;\n\t\t\t\toverrideMaterial.positionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\toverrideMaterial.alphaTest = material.alphaTest;\n\t\t\toverrideMaterial.alphaMap = material.alphaMap;\n\t\t\toverrideMaterial.transparent = material.transparent || material.transmission > 0;\n\n\t\t\tif ( overrideMaterial.isShadowNodeMaterial ) {\n\n\t\t\t\toverrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n\n\t\t\t\tif ( material.depthNode && material.depthNode.isNode ) {\n\n\t\t\t\t\toverrideDepthNode = overrideMaterial.depthNode;\n\t\t\t\t\toverrideMaterial.depthNode = material.depthNode;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.castShadowNode && material.castShadowNode.isNode ) {\n\n\t\t\t\t\toverrideColorNode = overrideMaterial.colorNode;\n\t\t\t\t\toverrideMaterial.colorNode = material.castShadowNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial = overrideMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( overridePositionNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.positionNode = overridePositionNode;\n\n\t\t}\n\n\t\tif ( overrideDepthNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.depthNode = overrideDepthNode;\n\n\t\t}\n\n\t\tif ( overrideColorNode !== undefined ) {\n\n\t\t\tscene.overrideMaterial.colorNode = overrideColorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t/**\n\t * This method represents the default `_handleObjectFunction` implementation which creates\n\t * a render object from the given data and performs the draw command with the selected backend.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tconst needsRefresh = this._nodes.needsRefresh( renderObject );\n\n\t\tif ( needsRefresh ) {\n\n\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\tthis._geometries.updateForRender( renderObject );\n\n\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t}\n\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tif ( this._currentRenderBundle !== null ) {\n\n\t\t\tconst renderBundleData = this.backend.get( this._currentRenderBundle );\n\n\t\t\trenderBundleData.renderObjects.push( renderObject );\n\n\t\t\trenderObject.bundle = this._currentRenderBundle.bundleGroup;\n\n\t\t}\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t\tif ( needsRefresh ) this._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.\n\t * Used in `compileAsync()`.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {String?} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_createObjectPipeline( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\tthis._geometries.updateForRender( renderObject );\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\n\t\tthis._pipelines.getForRender( renderObject, this._compilationPromises );\n\n\t\tthis._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * Alias for `compileAsync()`.\n\t *\n\t * @method\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {Promise} A Promise that resolves when the compile has been finished.\n\t */\n\tget compile() {\n\n\t\treturn this.compileAsync;\n\n\t}\n\n}\n\n/**\n * A binding represents the connection between a resource (like a texture, sampler\n * or uniform buffer) and the resource definition in a shader stage.\n *\n * This module is an abstract base class for all concrete bindings types.\n *\n * @abstract\n * @private\n */\nclass Binding {\n\n\t/**\n\t * Constructs a new binding.\n\t *\n\t * @param {String} [name=''] - The binding's name.\n\t */\n\tconstructor( name = '' ) {\n\n\t\t/**\n\t\t * The binding's name.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * A bitmask that defines in what shader stages the\n\t\t * binding's resource is accessible.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.visibility = 0;\n\n\t}\n\n\t/**\n\t * Makes sure binding's resource is visible for the given shader stage.\n\t *\n\t * @param {Number} visibility - The shader stage.\n\t */\n\tsetVisibility( visibility ) {\n\n\t\tthis.visibility |= visibility;\n\n\t}\n\n\t/**\n\t * Clones the binding.\n\t *\n\t * @return {Binding} The cloned binding.\n\t */\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\n/** @module BufferUtils **/\n\n/**\n * This function is usually called with the length in bytes of an array buffer.\n * It returns an padded value whic ensure chunk size alignment according to STD140 layout.\n *\n * @function\n * @param {Number} floatLength - The buffer length.\n * @return {Number} The padded length.\n */\nfunction getFloatLength( floatLength ) {\n\n\t// ensure chunk size alignment (STD140 layout)\n\n\treturn floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );\n\n}\n\n/**\n * Represents a buffer binding type.\n *\n * @private\n * @abstract\n * @augments Binding\n */\nclass Buffer extends Binding {\n\n\t/**\n\t * Constructs a new buffer.\n\t *\n\t * @param {String} name - The buffer's name.\n\t * @param {TypedArray} [buffer=null] - The buffer.\n\t */\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuffer = true;\n\n\t\t/**\n\t\t * The bytes per element.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n\n\t\t/**\n\t\t * A reference to the internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis._buffer = buffer;\n\n\t}\n\n\t/**\n\t * The buffer's byte length.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget byteLength() {\n\n\t\treturn getFloatLength( this._buffer.byteLength );\n\n\t}\n\n\t/**\n\t * A reference to the internal buffer.\n\t *\n\t * @type {Float32Array}\n\t * @readonly\n\t */\n\tget buffer() {\n\n\t\treturn this._buffer;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {Boolean} Whether the buffer has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\treturn true;\n\n\t}\n\n}\n\n/**\n * Represents a uniform buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass UniformBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {String} name - The buffer's name.\n\t * @param {TypedArray} [buffer=null] - The buffer.\n\t */\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name, buffer );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformBuffer = true;\n\n\t}\n\n}\n\nlet _id$4 = 0;\n\n/**\n * A special form of uniform buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments UniformBuffer\n */\nclass NodeUniformBuffer extends UniformBuffer {\n\n\t/**\n\t * Constructs a new node-based uniform buffer.\n\t *\n\t * @param {BufferNode} nodeUniform - The uniform buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The uniform buffer node.\n\t\t *\n\t\t * @type {BufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The uniform buffer.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\n/**\n * This class represents a uniform buffer binding but with\n * an API that allows to maintain individual uniform objects.\n *\n * @private\n * @augments UniformBuffer\n */\nclass UniformsGroup extends UniformBuffer {\n\n\t/**\n\t * Constructs a new uniforms group.\n\t *\n\t * @param {String} name - The group's name.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformsGroup = true;\n\n\t\t/**\n\t\t * An array with the raw uniform values.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Number>?}\n\t\t * @default null\n\t\t */\n\t\tthis._values = null;\n\n\t\t/**\n\t\t * An array of uniform objects.\n\t\t *\n\t\t * The order of uniforms in this array must match the order of uniforms in the shader.\n\t\t *\n\t\t * @type {Array<Uniform>}\n\t\t */\n\t\tthis.uniforms = [];\n\n\t}\n\n\t/**\n\t * Adds a uniform to this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to add.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a uniform from this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to remove.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * An array with the raw uniform values.\n\t *\n\t * @type {Array<Number>}\n\t */\n\tget values() {\n\n\t\tif ( this._values === null ) {\n\n\t\t\tthis._values = Array.from( this.buffer );\n\n\t\t}\n\n\t\treturn this._values;\n\n\t}\n\n\t/**\n\t * A Float32 array buffer with the uniform values.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\t/**\n\t * The byte length of the buffer with correct buffer alignment.\n\t *\n\t * @type {Number}\n\t */\n\tget byteLength() {\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\tconst { boundary, itemSize } = uniform;\n\n\t\t\t// offset within a single chunk in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES;\n\t\t\tconst remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;\n\n\t\t\t// conformance tests\n\n\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkOffset );\n\n\t\t\t} else if ( chunkOffset % boundary !== 0 ) {\n\n\t\t\t\t// check for correct alignment\n\n\t\t\t\toffset += ( chunkOffset % boundary );\n\n\t\t\t}\n\n\t\t\tuniform.offset = ( offset / this.bytesPerElement );\n\n\t\t\toffset += ( itemSize * this.bytesPerElement );\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\t/**\n\t * Updates this group by updating each uniform object of\n\t * the internal uniform list. The uniform objects check if their\n\t * values has actually changed so this method only returns\n\t * `true` if there is a real value change.\n\t *\n\t * @return {Boolean} Whether the uniforms have been updated and\n\t * must be uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given uniform by calling an update method matching\n\t * the uniforms type.\n\t *\n\t * @param {Uniform} uniform - The uniform to update.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isNumberUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\tconsole.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\t/**\n\t * Updates a given Number uniform.\n\t *\n\t * @param {NumberUniform} uniform - The Number uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset ] = a[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector2 uniform.\n\t *\n\t * @param {Vector2Uniform} uniform - The Vector2 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector3 uniform.\n\t *\n\t * @param {Vector3Uniform} uniform - The Vector3 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector4 uniform.\n\t *\n\t * @param {Vector4Uniform} uniform - The Vector4 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\t\t\tb[ offset + 3 ] = a[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Color uniform.\n\t *\n\t * @param {ColorUniform} uniform - The Color uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = c.r;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = c.g;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix3 uniform.\n\t *\n\t * @param {Matrix3Uniform} uniform - The Matrix3 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];\n\t\t\tb[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];\n\t\t\tb[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];\n\t\t\tb[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];\n\t\t\tb[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];\n\t\t\tb[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];\n\t\t\tb[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix4 uniform.\n\t *\n\t * @param {Matrix4Uniform} uniform - The Matrix4 uniform.\n\t * @return {Boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\tconst b = this.buffer;\n\t\t\tb.set( e, offset );\n\t\t\tsetArray( a, e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Returns a typed array that matches the given data type.\n\t *\n\t * @param {String} type - The data type.\n\t * @return {TypedArray} The typed array.\n\t */\n\t_getBufferForType( type ) {\n\n\t\tif ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );\n\t\tif ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );\n\t\treturn this.buffer;\n\n\t}\n\n}\n\n/**\n * Sets the values of the second array to the first array.\n *\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {Number} offset - An index offset for the first array.\n */\nfunction setArray( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ offset + i ] = b[ i ];\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given arrays are equal.\n *\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {Number} offset - An index offset for the first array.\n * @return {Boolean} Whether the given arrays are equal or not.\n */\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nlet _id$3 = 0;\n\n/**\n * A special form of uniforms group that represents\n * the individual uniforms as node-based uniforms.\n *\n * @private\n * @augments UniformsGroup\n */\nclass NodeUniformsGroup extends UniformsGroup {\n\n\t/**\n\t * Constructs a new node-based uniforms group.\n\t *\n\t * @param {String} name - The group's name.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, groupNode ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The group's ID.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$3 ++;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeUniformsGroup = true;\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\n/**\n * Represents a sampled texture binding type.\n *\n * @private\n * @augments Binding\n */\nclass SampledTexture extends Binding {\n\n\t/**\n\t * Constructs a new sampled texture.\n\t *\n\t * @param {String} name - The sampled texture's name.\n\t * @param {Texture?} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This identifier.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = _id$2 ++;\n\n\t\t/**\n\t\t * The texture this binding is referring to.\n\t\t *\n\t\t * @type {Texture?}\n\t\t */\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The binding's version.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\t/**\n\t\t * Whether the texture is a storage texture or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.store = false;\n\n\t\t/**\n\t\t * The binding's generation which is an additional version\n\t\t * qualifier.\n\t\t *\n\t\t * @type {Number?}\n\t\t * @default null\n\t\t */\n\t\tthis.generation = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledTexture = true;\n\n\t}\n\n\t/**\n\t * Returns `true` whether this binding requires an update for the\n\t * given generation.\n\t *\n\t * @param {Number} generation - The generation.\n\t * @return {Boolean} Whether an update is required or not.\n\t */\n\tneedsBindingsUpdate( generation ) {\n\n\t\tconst { texture } = this;\n\n\t\tif ( generation !== this.generation ) {\n\n\t\t\tthis.generation = generation;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn texture.isVideoTexture;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @param {Number} generation - The generation.\n\t * @return {Boolean} Whether the texture has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tconst { texture, version } = this;\n\n\t\tif ( version !== texture.version ) {\n\n\t\t\tthis.version = texture.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n\n/**\n * A special form of sampled texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments SampledTexture\n */\nclass NodeSampledTexture extends SampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled texture.\n\t *\n\t * @param {String} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {String?} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {String?}\n\t\t * @default null\n\t\t */\n\t\tthis.access = access;\n\n\t}\n\n\t/**\n\t * Overwrites the default to additionally check if the node value has changed.\n\t *\n\t * @param {Number} generation - The generation.\n\t * @return {Boolean} Whether an update is required or not.\n\t */\n\tneedsBindingsUpdate( generation ) {\n\n\t\treturn this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @param {Number} generation - The generation.\n\t * @return {Boolean} Whether the texture has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tconst { textureNode } = this;\n\n\t\tif ( this.texture !== textureNode.value ) {\n\n\t\t\tthis.texture = textureNode.value;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn super.update();\n\n\t}\n\n}\n\n/**\n * A special form of sampled cube texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled cube texture.\n\t *\n\t * @param {String} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {String?} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledCubeTexture = true;\n\n\t}\n\n}\n\n/**\n * A special form of sampled 3D texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledTexture3D extends NodeSampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled 3D texture.\n\t *\n\t * @param {String} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {String?} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledTexture3D = true;\n\n\t}\n\n}\n\nconst glslMethods = {\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports$1 = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n`;\n\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\tthis.uniformGroups = {};\n\t\tthis.transforms = [];\n\t\tthis.extensions = {};\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t\tthis.useComparisonMethod = true;\n\n\t}\n\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\n\t\t}\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {\n\n\t\tif ( depthSnippet ) {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t} else {\n\n\t\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true ) {\n\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.compareFunction ) {\n\n\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'texture3D' ) {\n\n\t\t\t\tsnippet = `sampler3D ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `layout( location = ${i} ) out ${ member} m${i};` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length === 0 ) {\n\n\t\t\treturn 'layout( location = 0 ) out vec4 fragColor;\\n';\n\n\t\t}\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\n\t\t\tlet snippet = '\\n';\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n';\n\n\t\t\tsnippets.push( snippet );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\tsnippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\\n`;\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\tsnippet += `${flat}in ${type} ${varying.name};\\n`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\tlet result = supports$1[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports$1[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tsnippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions \n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\n${shaderData.structs}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nlet _vector2 = null;\nlet _color4 = null;\n\n/**\n * Most of the rendering related logic is implemented in the\n * {@link module:Renderer} module and related management components.\n * Sometimes it is required though to execute commands which are\n * specific to the current 3D backend (which is WebGPU or WebGL 2).\n * This abstract base class defines an interface that encapsulates\n * all backend-related logic. Derived classes for each backend must\n * implement the interface.\n *\n * @abstract\n * @private\n */\nclass Backend {\n\n\t/**\n\t * Constructs a new backend.\n\t *\n\t * @param {Object} parameters - An object holding parameters for the backend.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\t/**\n\t\t * The parameters of the backend.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = Object.assign( {}, parameters );\n\n\t\t/**\n\t\t * This weak map holds backend-specific data of objects\n\t\t * like textures, attributes or render targets.\n\t\t *\n\t\t * @type {WeakMap}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {Renderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t *\n\t\t * @type {(HTMLCanvasElement|OffscreenCanvas)?}\n\t\t * @default null\n\t\t */\n\t\tthis.domElement = null;\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage. Concrete backends\n\t * are supposed to implement their rendering context creation and related\n\t * operations in this method.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @abstract\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {}\n\n\t// render context\n\n\t/**\n\t * This method is executed at the beginning of a render call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * draw calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a render call and\n\t * can be used by the backend to finalize work after draw\n\t * calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * compute tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( /*computeGroup*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * can be used by the backend to finalize work after compute\n\t * tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( /*computeGroup*/ ) {}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( /*renderObject, info*/ ) { }\n\n\t// compute node\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t */\n\tcompute( /*computeGroup, computeNode, computeBindings, computePipeline*/ ) { }\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( /*program*/ ) { }\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( /*program*/ ) { }\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tupdateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t * @abstract\n\t * @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( /*binding*/ ) { }\n\n\t// pipeline\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( /*renderObject, promises*/ ) { }\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @abstract\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( /*computePipeline, bindings*/ ) { }\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) { }\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {String} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) { }\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {NodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( /*renderObject, renderer*/ ) { }\n\n\t// textures\n\n\t/**\n\t * Creates a sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( /*texture*/ ) {}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( /*texture*/ ) { }\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( /*texture, options={}*/ ) { }\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( /*texture, options = {}*/ ) { }\n\n\t/**\n\t * Generates mipmaps for the given texture\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( /*texture*/ ) { }\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {TypedArray} The texture data as a typed array.\n\t */\n\tcopyTextureToBuffer( /*texture, x, y, width, height, faceIndex*/ ) {}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @abstract\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( /*srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0*/ ) {}\n\n\t/**\n\t* Copies the current bound framebuffer to the given texture.\n\t*\n\t* @abstract\n\t* @param {Texture} texture - The destination texture.\n\t* @param {RenderContext} renderContext - The render context.\n\t* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t*/\n\tcopyFramebufferToTexture( /*texture, renderContext, rectangle*/ ) {}\n\n\t// attributes\n\n\t/**\n\t * Creates the buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the buffer of an indexed shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the buffer of a storage attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Updates the buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Destroys the buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( /*attribute*/ ) { }\n\n\t// canvas\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @abstract\n\t * @return {Object} The rendering context.\n\t */\n\tgetContext() { }\n\n\t/**\n\t * Backends can use this method if they have to run\n\t * logic when the renderer gets resized.\n\t *\n\t * @abstract\n\t */\n\tupdateSize() { }\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( /*renderContext*/ ) {}\n\n\t// utils\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene. Backends must implement this method by using\n\t * a Occlusion Query API.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( /*renderContext, object*/ ) {}\n\n\t/**\n\t * Resolves the time stamp for the given render context and type.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {String} type - The render context.\n\t * @return {Promise} A Promise that resolves when the time stamp has been computed.\n\t */\n\tasync resolveTimestampAsync( /*renderContext, type*/ ) { }\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @abstract\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {}\n\n\t/**\n\t * Checks if the given feature is supported by the backend.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {String} name - The feature's name.\n\t * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( /*name*/ ) { }\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @abstract\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( /*name*/ ) {}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @abstract\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {}\n\n\t/**\n\t * Returns the drawing buffer size.\n\t *\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize() {\n\n\t\t_vector2 = _vector2 || new Vector2();\n\n\t\treturn this.renderer.getDrawingBufferSize( _vector2 );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @abstract\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( /*boolean*/ ) { }\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst renderer = this.renderer;\n\n\t\t_color4 = _color4 || new Color4();\n\n\t\trenderer.getClearColor( _color4 );\n\n\t\t_color4.getRGB( _color4, this.renderer.currentColorSpace );\n\n\t\treturn _color4;\n\n\t}\n\n\t/**\n\t * Returns the DOM element. If no DOM element exists, the backend\n\t * creates a new one.\n\t *\n\t * @return {HTMLCanvasElement} The DOM element.\n\t */\n\tgetDomElement() {\n\n\t\tlet domElement = this.domElement;\n\n\t\tif ( domElement === null ) {\n\n\t\t\tdomElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );\n\n\t\t\tthis.domElement = domElement;\n\n\t\t}\n\n\t\treturn domElement;\n\n\t}\n\n\t/**\n\t * Sets a dictionary for the given object into the\n\t * internal data structure.\n\t *\n\t * @param {Object} object - The object.\n\t * @param {Object} value - The dictionary to set.\n\t */\n\tset( object, value ) {\n\n\t\tthis.data.set( object, value );\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The object's dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Checks if the given object has a dictionary\n\t * with data defined.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Boolean} Whether a dictionary for the given object as been defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Deletes an object from the internal data structure.\n\t *\n\t * @param {Object} object - The object to delete.\n\t */\n\tdelete( object ) {\n\n\t\tthis.data.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t *\n\t * @abstract\n\t */\n\tdispose() { }\n\n}\n\nlet _id$1 = 0;\n\nclass DualAttributeData {\n\n\tconstructor( attributeData, dualBuffer ) {\n\n\t\tthis.buffers = [ attributeData.bufferGPU, dualBuffer ];\n\t\tthis.type = attributeData.type;\n\t\tthis.bufferType = attributeData.bufferType;\n\t\tthis.pbo = attributeData.pbo;\n\t\tthis.byteLength = attributeData.byteLength;\n\t\tthis.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n\t\tthis.version = attributeData.version;\n\t\tthis.isInteger = attributeData.isInteger;\n\t\tthis.activeBufferIndex = 0;\n\t\tthis.baseId = attributeData.id;\n\n\t}\n\n\n\tget id() {\n\n\t\treturn `${ this.baseId }|${ this.activeBufferIndex }`;\n\n\t}\n\n\tget bufferGPU() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ];\n\n\t}\n\n\tget transformBuffer() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ^ 1 ];\n\n\t}\n\n\tswitchBuffers() {\n\n\t\tthis.activeBufferIndex ^= 1;\n\n\t}\n\n}\n\nclass WebGLAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, bufferType ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage || gl.STATIC_DRAW;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet bufferGPU = bufferData.bufferGPU;\n\n\t\tif ( bufferGPU === undefined ) {\n\n\t\t\tbufferGPU = this._createBuffer( gl, bufferType, array, usage );\n\n\t\t\tbufferData.bufferGPU = bufferGPU;\n\t\t\tbufferData.bufferType = bufferType;\n\t\t\tbufferData.version = bufferAttribute.version;\n\n\t\t}\n\n\t\t//attribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\tlet attributeData = {\n\t\t\tbufferGPU,\n\t\t\tbufferType,\n\t\t\ttype,\n\t\t\tbyteLength: array.byteLength,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tpbo: attribute.pbo,\n\t\t\tisInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n\t\t\tid: _id$1 ++\n\t\t};\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t// create buffer for transform feedback use\n\t\t\tconst bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );\n\t\t\tattributeData = new DualAttributeData( attributeData, bufferGPUDual );\n\n\t\t}\n\n\t\tbackend.set( attribute, attributeData );\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst bufferType = bufferData.bufferType;\n\t\tconst updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, bufferData.bufferGPU );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\tbufferData.version = bufferAttribute.version;\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tbackend.delete( attribute.data );\n\n\t\t}\n\n\t\tconst attributeData = backend.get( attribute );\n\n\t\tgl.deleteBuffer( attributeData.bufferGPU );\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst { bufferGPU } = backend.get( bufferAttribute );\n\n\t\tconst array = attribute.array;\n\t\tconst byteLength = array.byteLength;\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );\n\n\t\tconst writeBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\t\tgl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );\n\n\t\tgl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new attribute.array.constructor( array.length );\n\n\t\t// Ensure the buffer is bound before reading\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\n\t\tgl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );\n\n\t\tgl.deleteBuffer( writeBuffer );\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, null );\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, null );\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t_createBuffer( gl, bufferType, array, usage ) {\n\n\t\tconst bufferGPU = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, bufferGPU );\n\t\tgl.bufferData( bufferType, array, usage );\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\treturn bufferGPU;\n\n\t}\n\n}\n\nlet initialized$1 = false, equationToGL, factorToGL;\n\nclass WebGLState {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\n\t\tthis.enabled = {};\n\t\tthis.currentFlipSided = null;\n\t\tthis.currentCullFace = null;\n\t\tthis.currentProgram = null;\n\t\tthis.currentBlendingEnabled = false;\n\t\tthis.currentBlending = null;\n\t\tthis.currentBlendSrc = null;\n\t\tthis.currentBlendDst = null;\n\t\tthis.currentBlendSrcAlpha = null;\n\t\tthis.currentBlendDstAlpha = null;\n\t\tthis.currentPremultipledAlpha = null;\n\t\tthis.currentPolygonOffsetFactor = null;\n\t\tthis.currentPolygonOffsetUnits = null;\n\t\tthis.currentColorMask = null;\n\t\tthis.currentDepthFunc = null;\n\t\tthis.currentDepthMask = null;\n\t\tthis.currentStencilFunc = null;\n\t\tthis.currentStencilRef = null;\n\t\tthis.currentStencilFuncMask = null;\n\t\tthis.currentStencilFail = null;\n\t\tthis.currentStencilZFail = null;\n\t\tthis.currentStencilZPass = null;\n\t\tthis.currentStencilMask = null;\n\t\tthis.currentLineWidth = null;\n\t\tthis.currentClippingPlanes = 0;\n\n\t\tthis.currentBoundFramebuffers = {};\n\t\tthis.currentDrawbuffers = new WeakMap();\n\n\t\tthis.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.currentTextureSlot = null;\n\t\tthis.currentBoundTextures = {};\n\t\tthis.currentBoundBufferBases = {};\n\n\t\tif ( initialized$1 === false ) {\n\n\t\t\tthis._init( this.gl );\n\n\t\t\tinitialized$1 = true;\n\n\t\t}\n\n\t}\n\n\t_init( gl ) {\n\n\t\t// Store only WebGL constants here.\n\n\t\tequationToGL = {\n\t\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tfactorToGL = {\n\t\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t\t[ OneFactor ]: gl.ONE,\n\t\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t}\n\n\tenable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== true ) {\n\n\t\t\tthis.gl.enable( id );\n\t\t\tenabled[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tdisable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== false ) {\n\n\t\t\tthis.gl.disable( id );\n\t\t\tenabled[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tsetFlipSided( flipSided ) {\n\n\t\tif ( this.currentFlipSided !== flipSided ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tthis.currentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tsetCullFace( cullFace ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== this.currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tthis.currentCullFace = cullFace;\n\n\t}\n\n\tsetLineWidth( width ) {\n\n\t\tconst { currentLineWidth, gl } = this;\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tthis.currentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\n\tsetBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( this.currentBlendingEnabled === true ) {\n\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tthis.currentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.currentBlendingEnabled === false ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.currentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {\n\n\t\t\t\tif ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tthis.currentBlendEquation = AddEquation;\n\t\t\t\t\tthis.currentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.currentBlendSrc = null;\n\t\t\t\tthis.currentBlendDst = null;\n\t\t\t\tthis.currentBlendSrcAlpha = null;\n\t\t\t\tthis.currentBlendDstAlpha = null;\n\n\t\t\t\tthis.currentBlending = blending;\n\t\t\t\tthis.currentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tthis.currentBlendEquation = blendEquation;\n\t\t\tthis.currentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tthis.currentBlendSrc = blendSrc;\n\t\t\tthis.currentBlendDst = blendDst;\n\t\t\tthis.currentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.currentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tthis.currentBlending = blending;\n\t\tthis.currentPremultipledAlpha = false;\n\n\t}\n\n\tsetColorMask( colorMask ) {\n\n\t\tif ( this.currentColorMask !== colorMask ) {\n\n\t\t\tthis.gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tthis.currentColorMask = colorMask;\n\n\t\t}\n\n\t}\n\n\tsetDepthTest( depthTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( depthTest ) {\n\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t}\n\n\tsetDepthMask( depthMask ) {\n\n\t\tif ( this.currentDepthMask !== depthMask ) {\n\n\t\t\tthis.gl.depthMask( depthMask );\n\t\t\tthis.currentDepthMask = depthMask;\n\n\t\t}\n\n\t}\n\n\tsetDepthFunc( depthFunc ) {\n\n\t\tif ( this.currentDepthFunc !== depthFunc ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tthis.currentDepthFunc = depthFunc;\n\n\t\t}\n\n\t}\n\n\tsetStencilTest( stencilTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( stencilTest ) {\n\n\t\t\tthis.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t}\n\n\tsetStencilMask( stencilMask ) {\n\n\t\tif ( this.currentStencilMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilMask( stencilMask );\n\t\t\tthis.currentStencilMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\tsetStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( this.currentStencilFunc !== stencilFunc ||\n\t\t\t this.currentStencilRef !== stencilRef ||\n\t\t\t this.currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\tthis.currentStencilFunc = stencilFunc;\n\t\t\tthis.currentStencilRef = stencilRef;\n\t\t\tthis.currentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\tsetStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( this.currentStencilFail !== stencilFail ||\n\t\t\t this.currentStencilZFail !== stencilZFail ||\n\t\t\t this.currentStencilZPass !== stencilZPass ) {\n\n\t\t\tthis.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\tthis.currentStencilFail = stencilFail;\n\t\t\tthis.currentStencilZFail = stencilZFail;\n\t\t\tthis.currentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t}\n\n\tsetMaterial( material, frontFaceCW, hardwareClippingPlanes ) {\n\n\t\tconst { gl } = this;\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? this.disable( gl.CULL_FACE )\n\t\t\t: this.enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tthis.setFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? this.setBlending( NoBlending )\n\t\t\t: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tthis.setDepthFunc( material.depthFunc );\n\t\tthis.setDepthTest( material.depthTest );\n\t\tthis.setDepthMask( material.depthWrite );\n\t\tthis.setColorMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tthis.setStencilTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tthis.setStencilMask( material.stencilWriteMask );\n\t\t\tthis.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tthis.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tthis.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true && this.backend.renderer.samples > 1\n\t\t\t? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tif ( hardwareClippingPlanes > 0 ) {\n\n\t\t\tif ( this.currentClippingPlanes !== hardwareClippingPlanes ) {\n\n\t\t\t\tconst CLIP_DISTANCE0_WEBGL = 0x3000;\n\n\t\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\t\tif ( i < hardwareClippingPlanes ) {\n\n\t\t\t\t\t\tthis.enable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tthis.currentPolygonOffsetFactor = factor;\n\t\t\t\tthis.currentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tuseProgram( program ) {\n\n\t\tif ( this.currentProgram !== program ) {\n\n\t\t\tthis.gl.useProgram( program );\n\n\t\t\tthis.currentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// framebuffer\n\n\n\tbindFramebuffer( target, framebuffer ) {\n\n\t\tconst { gl, currentBoundFramebuffers } = this;\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tdrawBuffers( renderContext, framebuffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet drawBuffers = [];\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tdrawBuffers = this.currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tthis.currentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\n\t// texture\n\n\tactiveTexture( webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tbindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tbindBufferBase( target, index, buffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst key = `${target}-${index}`;\n\n\t\tif ( this.currentBoundBufferBases[ key ] !== buffer ) {\n\n\t\t\tgl.bindBufferBase( target, index, buffer );\n\t\t\tthis.currentBoundBufferBases[ key ] = buffer;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\tunbindTexture() {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures } = this;\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n}\n\nclass WebGLUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\t\tthis.extensions = backend.extensions;\n\n\t}\n\n\tconvert( p, colorSpace = NoColorSpace ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\treturn gl.HALF_FLOAT;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( colorSpace === SRGBColorSpace ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\treturn gl.UNSIGNED_INT_24_8;\n\n\t\t}\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\t_clientWaitAsync() {\n\n\t\tconst { gl } = this;\n\n\t\tconst sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\tgl.flush();\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tfunction test() {\n\n\t\t\t\tconst res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );\n\n\t\t\t\tif ( res === gl.WAIT_FAILED ) {\n\n\t\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\t\treject();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( res === gl.TIMEOUT_EXPIRED ) {\n\n\t\t\t\t\trequestAnimationFrame( test );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t\ttest();\n\n\t\t} );\n\n\t}\n\n}\n\nlet initialized = false, wrappingToGL, filterToGL, compareToGL;\n\nclass WebGLTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.defaultTextures = {};\n\n\t\tif ( initialized === false ) {\n\n\t\t\tthis._init( this.gl );\n\n\t\t\tinitialized = true;\n\n\t\t}\n\n\t}\n\n\t_init( gl ) {\n\n\t\t// Store only WebGL constants here.\n\n\t\twrappingToGL = {\n\t\t\t[ RepeatWrapping ]: gl.REPEAT,\n\t\t\t[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,\n\t\t\t[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT\n\t\t};\n\n\t\tfilterToGL = {\n\t\t\t[ NearestFilter ]: gl.NEAREST,\n\t\t\t[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t\t[ LinearFilter ]: gl.LINEAR,\n\t\t\t[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tcompareToGL = {\n\t\t\t[ NeverCompare ]: gl.NEVER,\n\t\t\t[ AlwaysCompare ]: gl.ALWAYS,\n\t\t\t[ LessCompare ]: gl.LESS,\n\t\t\t[ LessEqualCompare ]: gl.LEQUAL,\n\t\t\t[ EqualCompare ]: gl.EQUAL,\n\t\t\t[ GreaterEqualCompare ]: gl.GEQUAL,\n\t\t\t[ GreaterCompare ]: gl.GREATER,\n\t\t\t[ NotEqualCompare ]: gl.NOTEQUAL\n\t\t};\n\n\t}\n\n\tfilterFallback( f ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\n\n\t\t\treturn gl.NEAREST;\n\n\t\t}\n\n\t\treturn gl.LINEAR;\n\n\t}\n\n\tgetGLTextureType( texture ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet glTextureType;\n\n\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_CUBE_MAP;\n\n\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_2D_ARRAY;\n\n\t\t} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642\n\n\t\t\tglTextureType = gl.TEXTURE_3D;\n\n\t\t} else {\n\n\t\t\tglTextureType = gl.TEXTURE_2D;\n\n\n\t\t}\n\n\t\treturn glTextureType;\n\n\t}\n\n\tgetInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === gl.RED ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.R32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RG32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;\n\t\t\tif ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_COMPONENT ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_STENCIL ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;\n\n\t\t}\n\n\t\tif ( internalFormat === gl.R16F || internalFormat === gl.R32F ||\n\t\t\tinternalFormat === gl.RG16F || internalFormat === gl.RG32F ||\n\t\t\tinternalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tsetTextureParameters( textureType, texture ) {\n\n\t\tconst { gl, extensions, backend } = this;\n\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t}\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\n\n\t\tconst hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n\t\t// follow WebGPU backend mapping for texture filtering\n\t\tconst minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\tif ( texture.anisotropy > 1 ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\tgl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tconst { gl, backend, defaultTextures } = this;\n\n\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tlet textureGPU = defaultTextures[ glTextureType ];\n\n\t\tif ( textureGPU === undefined ) {\n\n\t\t\ttextureGPU = gl.createTexture();\n\n\t\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\t// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\tdefaultTextures[ glTextureType ] = textureGPU;\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tisDefault: true\n\t\t} );\n\n\t}\n\n\tcreateTexture( texture, options ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { levels, width, height, depth } = options;\n\n\t\tconst glFormat = backend.utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = backend.utils.convert( texture.type );\n\t\tconst glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\tconst textureGPU = gl.createTexture();\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( ! texture.isVideoTexture ) {\n\n\t\t\tgl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tglFormat,\n\t\t\tglType,\n\t\t\tglInternalFormat\n\t\t} );\n\n\t}\n\n\tcopyBufferToTexture( buffer, texture ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\tconst { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );\n\n\t\tconst { width, height } = texture.source.data;\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\n\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );\n\n\t\tbackend.state.unbindTexture();\n\t\t// debug\n\t\t// const framebuffer = gl.createFramebuffer();\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n\t\t// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n\t\t// const readout = new Float32Array( width * height * 4 );\n\n\t\t// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n\t\t// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n\t\t// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\t// console.log( readout );\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst { gl } = this;\n\t\tconst { width, height } = options;\n\t\tconst { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );\n\n\t\tif ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\tconst getImage = ( source ) => {\n\n\t\t\tif ( source.isDataTexture ) {\n\n\t\t\t\treturn source.image.data;\n\n\t\t\t} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||\n\t\t\t\tsource instanceof OffscreenCanvas ) {\n\n\t\t\t\treturn source;\n\n\t\t\t}\n\n\t\t\treturn source.data;\n\n\t\t};\n\n\t\tthis.backend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tconst mipmaps = texture.mipmaps;\n\t\t\tconst image = options.image;\n\n\t\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\n\t\t\t\t\tif ( texture.format !== gl.RGBA ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tgl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'Unsupported compressed texture format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tconst images = options.images;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst image = getImage( images[ i ] );\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\ttexture.update();\n\n\t\t\tgl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );\n\n\n\t\t} else {\n\n\t\t\tconst image = getImage( options.image );\n\n\t\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t}\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, glTextureType } = backend.get( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\tgl.generateMipmap( glTextureType );\n\n\t}\n\n\tdeallocateRenderBuffers( renderTarget ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\t// remove framebuffer reference\n\t\tif ( renderTarget ) {\n\n\t\t\tconst renderContextData = backend.get( renderTarget );\n\n\t\t\trenderContextData.renderBufferStorageSetup = undefined;\n\n\t\t\tif ( renderContextData.framebuffers ) {\n\n\t\t\t\tfor ( const cacheKey in renderContextData.framebuffers ) {\n\n\t\t\t\t\tgl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.framebuffers;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.depthRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.depthRenderbuffer );\n\t\t\t\tdelete renderContextData.depthRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.stencilRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );\n\t\t\t\tdelete renderContextData.stencilRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaFrameBuffer ) {\n\n\t\t\t\tgl.deleteFramebuffer( renderContextData.msaaFrameBuffer );\n\t\t\t\tdelete renderContextData.msaaFrameBuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaRenderbuffers ) {\n\n\t\t\t\tfor ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {\n\n\t\t\t\t\tgl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.msaaRenderbuffers;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, renderTarget } = backend.get( texture );\n\n\t\tthis.deallocateRenderBuffers( renderTarget );\n\t\tgl.deleteTexture( textureGPU );\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );\n\n\t\tlet width, height, minX, minY;\n\t\tlet dstX, dstY;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\tminX = srcRegion.min.x;\n\t\t\tminY = srcRegion.min.y;\n\n\t\t} else {\n\n\t\t\twidth = srcTexture.image.width;\n\t\t\theight = srcTexture.image.height;\n\t\t\tminX = 0;\n\t\t\tminY = 0;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\n\t\t} else {\n\n\t\t\tdstX = 0;\n\t\t\tdstY = 0;\n\n\t\t}\n\n\t\tstate.bindTexture( glTextureType, dstTextureGPU );\n\n\t\t// As another texture upload may have changed pixelStorei\n\t\t// parameters, make sure they are correct for the dstTexture\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\tconst currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );\n\t\tconst currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );\n\t\tconst currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );\n\t\tconst currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );\n\t\tconst currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );\n\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );\n\n\t\tif ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {\n\n\t\t\tconst srcTextureData = backend.get( srcTexture );\n\t\t\tconst dstTextureData = backend.get( dstTexture );\n\n\t\t\tconst srcRenderContextData = backend.get( srcTextureData.renderTarget );\n\t\t\tconst dstRenderContextData = backend.get( dstTextureData.renderTarget );\n\n\t\t\tconst srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];\n\t\t\tconst dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );\n\n\t\t\tlet mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\tif ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;\n\n\t\t\tgl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\n\t\t} else {\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );\n\n\t\tstate.unbindTexture();\n\n\t}\n\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst { gl } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU } = this.backend.get( texture );\n\n\t\tconst { x, y, z: width, w: height } = rectangle;\n\n\t\tconst requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );\n\n\t\tconst srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;\n\n\t\tif ( requireDrawFrameBuffer ) {\n\n\t\t\tconst partial = ( x !== 0 || y !== 0 );\n\t\t\tlet mask;\n\t\t\tlet attachment;\n\n\t\t\tif ( texture.isDepthTexture === true ) {\n\n\t\t\t\tmask = gl.DEPTH_BUFFER_BIT;\n\t\t\t\tattachment = gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tmask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmask = gl.COLOR_BUFFER_BIT;\n\t\t\t\tattachment = gl.COLOR_ATTACHMENT0;\n\n\t\t\t}\n\n\t\t\tif ( partial ) {\n\n\t\t\t\tconst renderTargetContextData = this.backend.get( renderContext.renderTarget );\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\n\t\t\t\tconst flippedY = srcHeight - y - height;\n\n\t\t\t\tgl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\n\t\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );\n\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t} else {\n\n\t\t\t\tconst fb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );\n\t\t\t\tgl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );\n\n\t\t\t\tgl.deleteFramebuffer( fb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps ) this.generateMipmaps( texture );\n\n\t\tthis.backend._setFramebuffer( renderContext );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tsetupRenderBufferStorage( renderbuffer, renderContext ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tconst { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;\n\n\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( depthBuffer && ! stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = gl.DEPTH_COMPONENT24;\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === gl.FLOAT ) {\n\n\t\t\t\t\t\tglInternalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );\n\n\t\t\t}\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( depthBuffer && stencilBuffer ) {\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );\n\n\t\t\t}\n\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t}\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst { backend, gl } = this;\n\n\t\tconst { textureGPU, glFormat, glType } = this.backend.get( texture );\n\n\t\tconst fb = gl.createFramebuffer();\n\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\tconst target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n\n\t\tgl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );\n\n\t\tconst typedArrayType = this._getTypedArrayType( glType );\n\t\tconst bytesPerTexel = this._getBytesPerTexel( glType, glFormat );\n\n\t\tconst elementCount = width * height;\n\t\tconst byteLength = elementCount * bytesPerTexel;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );\n\t\tgl.readPixels( x, y, width, height, glFormat, glType, 0 );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tgl.deleteFramebuffer( fb );\n\n\t\treturn dstBuffer;\n\n\t}\n\n\t_getTypedArrayType( glType ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_INT ) return Uint32Array;\n\n\t\tif ( glType === gl.HALF_FLOAT ) return Uint16Array;\n\t\tif ( glType === gl.FLOAT ) return Float32Array;\n\n\t\tthrow new Error( `Unsupported WebGL type: ${glType}` );\n\n\t}\n\n\t_getBytesPerTexel( glType, glFormat ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet bytesPerComponent = 0;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_5_5_1 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_6_5 ||\n\t\t\tglType === gl.UNSIGNED_SHORT ||\n\t\t\tglType === gl.HALF_FLOAT ) bytesPerComponent = 2;\n\n\t\tif ( glType === gl.UNSIGNED_INT ||\n\t\t\tglType === gl.FLOAT ) bytesPerComponent = 4;\n\n\t\tif ( glFormat === gl.RGBA ) return bytesPerComponent * 4;\n\t\tif ( glFormat === gl.RGB ) return bytesPerComponent * 3;\n\t\tif ( glFormat === gl.ALPHA ) return bytesPerComponent;\n\n\t}\n\n}\n\nclass WebGLExtensions {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.gl = this.backend.gl;\n\t\tthis.availableExtensions = this.gl.getSupportedExtensions();\n\n\t\tthis.extensions = {};\n\n\t}\n\n\tget( name ) {\n\n\t\tlet extension = this.extensions[ name ];\n\n\t\tif ( extension === undefined ) {\n\n\t\t\textension = this.gl.getExtension( name );\n\n\t\t\tthis.extensions[ name ] = extension;\n\n\t\t}\n\n\t\treturn extension;\n\n\t}\n\n\thas( name ) {\n\n\t\treturn this.availableExtensions.includes( name );\n\n\t}\n\n}\n\nclass WebGLCapabilities {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis.maxAnisotropy = null;\n\n\t}\n\n\tgetMaxAnisotropy() {\n\n\t\tif ( this.maxAnisotropy !== null ) return this.maxAnisotropy;\n\n\t\tconst gl = this.backend.gl;\n\t\tconst extensions = this.backend.extensions;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tthis.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tthis.maxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn this.maxAnisotropy;\n\n\t}\n\n}\n\nconst GLFeatureName = {\n\n\t'WEBGL_multi_draw': 'WEBGL_multi_draw',\n\t'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n\t'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n\t'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n\t'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',\n\t'EXT_texture_compression_bptc': 'texture-compression-bptc',\n\t'EXT_disjoint_timer_query_webgl2': 'timestamp-query',\n\n};\n\nclass WebGLBufferRenderer {\n\n\tconstructor( backend ) {\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.info = backend.renderer.info;\n\t\tthis.mode = null;\n\t\tthis.index = 0;\n\t\tthis.type = null;\n\t\tthis.object = null;\n\n\t}\n\n\trender( start, count ) {\n\n\t\tconst { gl, mode, object, type, info, index } = this;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElements( mode, count, type, start );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, 1 );\n\n\t}\n\n\trenderInstances( start, count, primcount ) {\n\n\t\tconst { gl, mode, type, index, object, info } = this;\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElementsInstanced( mode, count, type, start, primcount );\n\n\t\t} else {\n\n\t\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\t}\n\n\t\tinfo.update( object, count, mode, primcount );\n\n\t}\n\n\trenderMultiDraw( starts, counts, drawCount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\trenderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, mode, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n}\n\n/**\n * A backend implementation targeting WebGL 2.\n *\n * @private\n * @augments Backend\n */\nclass WebGLBackend extends Backend {\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @param {WebGL2RenderingContext} [parameters.context=undefined] - A WebGL 2 rendering context.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGLBackend = true;\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLAttributeUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis.attributeUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLExtensions?}\n\t\t * @default null\n\t\t */\n\t\tthis.extensions = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding capability-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLCapabilities?}\n\t\t * @default null\n\t\t */\n\t\tthis.capabilities = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLTextureUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding renderer-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLBufferRenderer?}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferRenderer = null;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext?}\n\t\t * @default null\n\t\t */\n\t\tthis.gl = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding state-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLState?}\n\t\t * @default null\n\t\t */\n\t\tthis.state = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLUtils?}\n\t\t * @default null\n\t\t */\n\t\tthis.utils = null;\n\n\t\t/**\n\t\t * Dictionary for caching VAOs.\n\t\t *\n\t\t * @type {Object<String,WebGLVertexArrayObject>}\n\t\t */\n\t\tthis.vaoCache = {};\n\n\t\t/**\n\t\t * Dictionary for caching transform feedback objects.\n\t\t *\n\t\t * @type {Object<String,WebGLTransformFeedback>}\n\t\t */\n\t\tthis.transformFeedbackCache = {};\n\n\t\t/**\n\t\t * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.\n\t\t * Only relevant when using compute shaders.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.discard = false;\n\n\t\t/**\n\t\t * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the\n\t\t * device does not support the extension.\n\t\t *\n\t\t * @type {EXTDisjointTimerQueryWebGL2?}\n\t\t * @default null\n\t\t */\n\t\tthis.disjoint = null;\n\n\t\t/**\n\t\t* A reference to the `KHR_parallel_shader_compile` extension. `null` if the\n\t\t* device does not support the extension.\n\t\t*\n\t\t* @type {KHRParallelShaderCompile?}\n\t\t* @default null\n\t\t*/\n\t\tthis.parallel = null;\n\n\t\t/**\n\t\t * Whether to track timestamps with a Timestamp Query API or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContext}\n\t\t * @default null\n\t\t */\n\t\tthis._currentContext = null;\n\n\t\t/**\n\t\t * A unique collection of bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakSet}\n\t\t */\n\t\tthis._knownBindings = new WeakSet();\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tinit( renderer ) {\n\n\t\tsuper.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );\n\n\t \tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst contextLossInfo = {\n\t\t\t\tapi: 'WebGL',\n\t\t\t\tmessage: event.statusMessage || 'Unknown reason',\n\t\t\t\treason: null,\n\t\t\t\toriginalEvent: event\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( contextLossInfo );\n\n\t\t}\n\n\t\tthis._onContextLost = onContextLost;\n\n\t\trenderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\tthis.gl = glContext;\n\n\t\tthis.extensions = new WebGLExtensions( this );\n\t\tthis.capabilities = new WebGLCapabilities( this );\n\t\tthis.attributeUtils = new WebGLAttributeUtils( this );\n\t\tthis.textureUtils = new WebGLTextureUtils( this );\n\t\tthis.bufferRenderer = new WebGLBufferRenderer( this );\n\n\t\tthis.state = new WebGLState( this );\n\t\tthis.utils = new WebGLUtils( this );\n\n\t\tthis.extensions.get( 'EXT_color_buffer_float' );\n\t\tthis.extensions.get( 'WEBGL_clip_cull_distance' );\n\t\tthis.extensions.get( 'OES_texture_float_linear' );\n\t\tthis.extensions.get( 'EXT_color_buffer_half_float' );\n\t\tthis.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\tthis.extensions.get( 'WEBGL_render_shared_exponent' );\n\t\tthis.extensions.get( 'WEBGL_multi_draw' );\n\n\t\tthis.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );\n\t\tthis.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\t/**\n\t * Transfers buffer data from a storage buffer attribute\n\t * from the GPU to the CPU in context of compute shaders.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.utils._clientWaitAsync();\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tinitTimestampQuery( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( this.queryRunning ) {\n\n\t\t  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];\n\t\t  renderContextData.queryQueue.push( renderContext );\n\t\t  return;\n\n\t\t}\n\n\t\tif ( renderContextData.activeQuery ) {\n\n\t\t  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );\n\t\t  renderContextData.activeQuery = null;\n\n\t\t}\n\n\t\trenderContextData.activeQuery = this.gl.createQuery();\n\n\t\tif ( renderContextData.activeQuery !== null ) {\n\n\t\t  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );\n\t\t  this.queryRunning = true;\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\t/**\n\t * Prepares the timestamp buffer.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tprepareTimestampBuffer( renderContext ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( renderContextData.activeQuery ) {\n\n\t\t  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );\n\n\t\t  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];\n\t\t  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );\n\t\t  renderContextData.activeQuery = null;\n\t\t  this.queryRunning = false;\n\n\t\t  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {\n\n\t\t\t\tconst nextRenderContext = renderContextData.queryQueue.shift();\n\t\t\t\tthis.initTimestampQuery( nextRenderContext );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resolves the time stamp for the given render context and type.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {String} type - The render context.\n\t * @return {Promise} A Promise that resolves when the time stamp has been computed.\n\t */\n\tasync resolveTimestampAsync( renderContext, type = 'render' ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];\n\n\t\tfor ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {\n\n\t\t  const queryInfo = renderContextData.gpuQueries[ i ];\n\t\t  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );\n\t\t  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );\n\n\t\t  if ( available && ! disjoint ) {\n\n\t\t\t\tconst elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );\n\t\t\t\tconst duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds\n\t\t\t\tthis.gl.deleteQuery( queryInfo.query );\n\t\t\t\trenderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query\n\t\t\t\ti --;\n\t\t\t\tthis.renderer.info.updateTimestamp( type, duration );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.gl;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGL state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\t//\n\n\t\tthis.initTimestampQuery( renderContext );\n\n\t\trenderContextData.previousContext = this._currentContext;\n\t\tthis._currentContext = renderContext;\n\n\t\tthis._setFramebuffer( renderContext );\n\n\t\tthis.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );\n\n\t\t//\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t} else {\n\n\t\t\tgl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tgl.scissor( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the async reading of all previous queries complete\n\t\t\trenderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\t\t\trenderContextData.occlusionQueries = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst previousContext = renderContextData.previousContext;\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t}\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tconst textures = renderContext.textures;\n\n\t\tif ( textures !== null ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps ) {\n\n\t\t\t\t\tthis.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._currentContext = previousContext;\n\n\t\tif ( renderContext.textures !== null && renderContext.renderTarget ) {\n\n\t\t\tconst renderTargetContextData = this.get( renderContext.renderTarget );\n\n\t\t\tconst { samples } = renderContext.renderTarget;\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\n\t\t\t\tconst mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tconst textures = renderContext.textures;\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t// TODO Add support for MRT\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\t\t\tconst viewY = renderContext.height - height - y;\n\n\t\t\t\t\t\tgl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );\n\t\t\t\t\t\tgl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( previousContext !== null ) {\n\n\t\t\tthis._setFramebuffer( previousContext );\n\n\t\t\tif ( previousContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( previousContext );\n\n\t\t\t} else {\n\n\t\t\t\tgl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tresolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueries && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\t\t\tconst { gl } = this;\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueries = null;\n\n\t\t\tconst check = () => {\n\n\t\t\t\tlet completed = 0;\n\n\t\t\t\t// check all queries and requeue as appropriate\n\t\t\t\tfor ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {\n\n\t\t\t\t\tconst query = currentOcclusionQueries[ i ];\n\n\t\t\t\t\tif ( query === null ) continue;\n\n\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {\n\n\t\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t\t\tcurrentOcclusionQueries[ i ] = null;\n\t\t\t\t\t\tgl.deleteQuery( query );\n\n\t\t\t\t\t\tcompleted ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( completed < currentOcclusionQueries.length ) {\n\n\t\t\t\t\trequestAnimationFrame( check );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderContextData.occluded = occluded;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheck();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { x, y, width, height } = renderContext.viewportValue;\n\n\t\tgl.viewport( x, renderContext.height - height - y, width, height );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {Boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( boolean ) {\n\n\t\t\tgl.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tgl.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {Boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {Object?} [descriptor=null] - The render context of the current set render target.\n\t * @param {Boolean} [setFrameBuffer=true] - TODO.\n\t */\n\tclear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\t// premultiply alpha\n\n\t\t\tclearColor.r *= clearColor.a;\n\t\t\tclearColor.g *= clearColor.a;\n\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\tdescriptor = {\n\t\t\t\ttextures: null,\n\t\t\t\tclearColorValue: clearColor\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tlet clear = 0;\n\n\t\tif ( color ) clear |= gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) clear |= gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;\n\n\t\tif ( clear !== 0 ) {\n\n\t\t\tlet clearColor;\n\n\t\t\tif ( descriptor.clearColorValue ) {\n\n\t\t\t\tclearColor = descriptor.clearColorValue;\n\n\t\t\t} else {\n\n\t\t\t\tclearColor = this.getClearColor();\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tclearColor.r *= clearColor.a;\n\t\t\t\tclearColor.g *= clearColor.a;\n\t\t\t\tclearColor.b *= clearColor.a;\n\n\t\t\t}\n\n\t\t\tif ( depth ) this.state.setDepthMask( true );\n\n\t\t\tif ( descriptor.textures === null ) {\n\n\t\t\t\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );\n\t\t\t\tgl.clear( clear );\n\n\t\t\t} else {\n\n\t\t\t\tif ( setFrameBuffer ) this._setFramebuffer( descriptor );\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tfor ( let i = 0; i < descriptor.textures.length; i ++ ) {\n\n\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( depth && stencil ) {\n\n\t\t\t\t\tgl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );\n\n\t\t\t\t} else if ( depth ) {\n\n\t\t\t\t\tgl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );\n\n\t\t\t\t} else if ( stencil ) {\n\n\t\t\t\t\tgl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tthis.initTimestampQuery( computeGroup );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tif ( this.discard === false ) {\n\n\t\t\t// required here to handle async behaviour of render.compute()\n\t\t\tgl.enable( gl.RASTERIZER_DISCARD );\n\t\t\tthis.discard = true;\n\n\t\t}\n\n\t\tconst { programGPU, transformBuffers, attributes } = this.get( pipeline );\n\n\t\tconst vaoKey = this._getVaoKey( null, attributes );\n\n\t\tconst vaoGPU = this.vaoCache[ vaoKey ];\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tthis._createVao( null, attributes );\n\n\t\t} else {\n\n\t\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\tthis._bindUniforms( bindings );\n\n\t\tconst transformFeedbackGPU = this._getTransformFeedback( transformBuffers );\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\t\tgl.beginTransformFeedback( gl.POINTS );\n\n\t\tif ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {\n\n\t\t\tgl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( gl.POINTS, 0, computeNode.count );\n\n\t\t}\n\n\t\tgl.endTransformFeedback();\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\t// switch active buffers\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst dualAttributeData = transformBuffers[ i ];\n\n\t\t\tif ( dualAttributeData.pbo ) {\n\n\t\t\t\tthis.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );\n\n\t\t\t}\n\n\t\t\tdualAttributeData.switchBuffers();\n\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.discard = false;\n\n\t\tgl.disable( gl.RASTERIZER_DISCARD );\n\n\t\tthis.prepareTimestampBuffer( computeGroup );\n\n\t\tif ( this._currentContext ) {\n\n\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject/*, info*/ ) {\n\n\t\tconst { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;\n\t\tconst { programGPU } = this.get( pipeline );\n\n\t\tconst { gl, state } = this;\n\n\t\tconst contextData = this.get( context );\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t//\n\n\t\tthis._bindUniforms( renderObject.getBindings() );\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW, hardwareClippingPlanes );\n\n\t\tstate.useProgram( programGPU );\n\n\t\t//\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet vaoGPU = renderObjectData.staticVao;\n\n\t\tif ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {\n\n\t\t\tconst vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );\n\n\t\t\tvaoGPU = this.vaoCache[ vaoKey ];\n\n\t\t\tif ( vaoGPU === undefined ) {\n\n\t\t\t\tlet staticVao;\n\n\t\t\t\t( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );\n\n\t\t\t\tif ( staticVao ) {\n\n\t\t\t\t\trenderObjectData.staticVao = vaoGPU;\n\t\t\t\t\trenderObjectData.geometryId = renderObject.geometry.id;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\t//\n\n\t\tconst index = renderObject.getIndex();\n\n\t\t//\n\n\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\tif ( lastObject !== object && lastObject !== undefined ) {\n\n\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t}\n\n\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\tconst query = gl.createQuery();\n\n\t\t\t\tgl.beginQuery( gl.ANY_SAMPLES_PASSED, query );\n\n\t\t\t\tcontextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;\n\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t}\n\n\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t}\n\n\t\t//\n\t\tconst renderer = this.bufferRenderer;\n\n\t\tif ( object.isPoints ) renderer.mode = gl.POINTS;\n\t\telse if ( object.isLineSegments ) renderer.mode = gl.LINES;\n\t\telse if ( object.isLine ) renderer.mode = gl.LINE_STRIP;\n\t\telse if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;\n\t\telse {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );\n\t\t\t\trenderer.mode = gl.LINES;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.mode = gl.TRIANGLES;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { vertexCount, instanceCount } = drawParams;\n\t\tlet { firstVertex } = drawParams;\n\n\t\trenderer.object = object;\n\n\t\tif ( index !== null ) {\n\n\t\t\tfirstVertex *= index.array.BYTES_PER_ELEMENT;\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\trenderer.index = index.count;\n\t\t\trenderer.type = indexData.type;\n\n\t\t} else {\n\n\t\t\trenderer.index = 0;\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\twarnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t}\n\n\t\t} else if ( instanceCount > 1 ) {\n\n\t\t\trenderer.renderInstances( firstVertex, vertexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\trenderer.render( firstVertex, vertexCount );\n\n\t\t}\n\t\t//\n\n\t\tgl.bindVertexArray( null );\n\n\t}\n\n\t/**\n\t * Explain why always null is returned.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Explain why no cache key is computed.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {String} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {TypedArray} The texture data as a typed array.\n\t */\n\tcopyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( /*texture*/ ) {\n\n\t\t//console.warn( 'Abstract class.' );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( /*texture*/ ) {}\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {GLSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new GLSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { stage, code } = program;\n\n\t\tconst shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );\n\n\t\tgl.shaderSource( shader, code );\n\t\tgl.compileShader( shader );\n\n\t\tthis.set( program, {\n\t\t\tshaderGPU: shader\n\t\t} );\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst gl = this.gl;\n\t\tconst pipeline = renderObject.pipeline;\n\n\t\t// Program\n\n\t\tconst { fragmentProgram, vertexProgram } = pipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( vertexProgram ).shaderGPU;\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\t\tgl.linkProgram( programGPU );\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU,\n\t\t\tfragmentShader,\n\t\t\tvertexShader\n\t\t} );\n\n\t\tif ( promises !== null && this.parallel ) {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tconst parallel = this.parallel;\n\t\t\t\tconst checkStatus = () => {\n\n\t\t\t\t\tif ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {\n\n\t\t\t\t\t\tthis._completeCompile( renderObject, pipeline );\n\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trequestAnimationFrame( checkStatus );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcheckStatus();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._completeCompile( renderObject, pipeline );\n\n\t}\n\n\t/**\n\t * Formats the source code of error messages.\n\t *\n\t * @private\n\t * @param {String} string - The code.\n\t * @param {Number} errorLine - The error line.\n\t * @return {String} The formatted code.\n\t */\n\t_handleSource( string, errorLine ) {\n\n\t\tconst lines = string.split( '\\n' );\n\t\tconst lines2 = [];\n\n\t\tconst from = Math.max( errorLine - 6, 0 );\n\t\tconst to = Math.min( errorLine + 6, lines.length );\n\n\t\tfor ( let i = from; i < to; i ++ ) {\n\n\t\t\tconst line = i + 1;\n\t\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t\t}\n\n\t\treturn lines2.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Gets the shader compilation errors from the info log.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {WebGLShader} shader - The WebGL shader object.\n\t * @param {String} type - The shader type.\n\t * @return {String} The shader errors.\n\t */\n\t_getShaderErrors( gl, shader, type ) {\n\n\t\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\t\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\t\tif ( status && errors === '' ) return '';\n\n\t\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\t\tif ( errorMatches ) {\n\n\t\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t\t} else {\n\n\t\t\treturn errors;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Logs shader compilation errors.\n\t *\n\t * @private\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.\n\t * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.\n\t */\n\t_logProgramError( programGPU, glFragmentShader, glVertexShader ) {\n\n\t\tif ( this.renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst gl = this.gl;\n\n\t\t\tconst programLog = gl.getProgramInfoLog( programGPU ).trim();\n\n\t\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\n\t\t\t\tif ( typeof this.renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\tthis.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Completes the shader program setup for the given render object.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {RenderPipeline} pipeline - The render pipeline.\n\t */\n\t_completeCompile( renderObject, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst { programGPU, fragmentShader, vertexShader } = pipelineData;\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\t//\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t// Program\n\n\t\tconst fragmentProgram = {\n\t\t\tstage: 'fragment',\n\t\t\tcode: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n\t\t};\n\n\t\tthis.createProgram( fragmentProgram );\n\n\t\tconst { computeProgram } = computePipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( computeProgram ).shaderGPU;\n\n\t\tconst transforms = computeProgram.transforms;\n\n\t\tconst transformVaryingNames = [];\n\t\tconst transformAttributeNodes = [];\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\ttransformVaryingNames.push( transform.varyingName );\n\t\t\ttransformAttributeNodes.push( transform.attributeNode );\n\n\t\t}\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\n\t\tgl.transformFeedbackVaryings(\n\t\t\tprogramGPU,\n\t\t\ttransformVaryingNames,\n\t\t\tgl.SEPARATE_ATTRIBS\n\t\t);\n\n\t\tgl.linkProgram( programGPU );\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\tconst attributeNodes = computeProgram.attributes;\n\t\tconst attributes = [];\n\t\tconst transformBuffers = [];\n\n\t\tfor ( let i = 0; i < attributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = attributeNodes[ i ].node.attribute;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < transformAttributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = transformAttributeNodes[ i ].attribute;\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\ttransformBuffers.push( attributeData );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.set( computePipeline, {\n\t\t\tprogramGPU,\n\t\t\ttransformBuffers,\n\t\t\tattributes\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings /*, cacheIndex, version*/ ) {\n\n\t\tif ( this._knownBindings.has( bindings ) === false ) {\n\n\t\t\tthis._knownBindings.add( bindings );\n\n\t\t\tlet uniformBuffers = 0;\n\t\t\tlet textures = 0;\n\n\t\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\t\tthis.set( bindGroup, {\n\t\t\t\t\ttextures: textures,\n\t\t\t\t\tuniformBuffers: uniformBuffers\n\t\t\t\t} );\n\n\t\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\t\tif ( binding.isUniformBuffer ) uniformBuffers ++;\n\t\t\t\t\tif ( binding.isSampledTexture ) textures ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updateBindings( bindGroup, bindings );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tupdateBindings( bindGroup /*, bindings, cacheIndex, version*/ ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst bindGroupData = this.get( bindGroup );\n\n\t\tlet i = bindGroupData.uniformBuffers;\n\t\tlet t = bindGroupData.textures;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\tconst data = binding.buffer;\n\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: i ++,\n\t\t\t\t\tbufferGPU\n\t\t\t\t} );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst { textureGPU, glTextureType } = this.get( binding.texture );\n\n\t\t\t\tthis.set( binding, {\n\t\t\t\t\tindex: t ++,\n\t\t\t\t\ttextureGPU,\n\t\t\t\t\tglTextureType\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\tconst bindingData = this.get( binding );\n\t\t\tconst bufferGPU = bindingData.bufferGPU;\n\t\t\tconst data = binding.buffer;\n\n\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t}\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Updates the buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tconst keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );\n\n\t\tconst extensions = this.extensions;\n\n\t\tfor ( let i = 0; i < keysMatching.length; i ++ ) {\n\n\t\t\tif ( extensions.has( keysMatching[ i ] ) ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tthis.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tthis.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Configures the active framebuffer from the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} descriptor - The render context.\n\t */\n\t_setFramebuffer( descriptor ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tlet currentFrameBuffer = null;\n\n\t\tif ( descriptor.textures !== null ) {\n\n\t\t\tconst renderTarget = descriptor.renderTarget;\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\t\t\tconst { samples, depthBuffer, stencilBuffer } = renderTarget;\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isRenderTarget3D = renderTarget.isRenderTarget3D === true;\n\t\t\tconst isRenderTargetArray = renderTarget.isRenderTargetArray === true;\n\n\t\t\tlet msaaFb = renderTargetContextData.msaaFrameBuffer;\n\t\t\tlet depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n\n\t\t\tconst cacheKey = getCacheKey( descriptor );\n\n\t\t\tlet fb;\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.cubeFramebuffers[ cacheKey ];\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.framebuffers[ cacheKey ];\n\n\t\t\t}\n\n\t\t\tif ( fb === undefined ) {\n\n\t\t\t\tfb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tconst { textureGPU } = this.get( textures[ 0 ] );\n\n\t\t\t\t\tconst cubeFace = this.renderer._activeCubeFace;\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetContextData.framebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tconst attachment = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t\tif ( isRenderTarget3D || isRenderTargetArray ) {\n\n\t\t\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\t\t\tgl.framebufferTextureLayer( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.drawBuffers( descriptor, fb );\n\n\t\t\t\t}\n\n\t\t\t\tif ( descriptor.depthTexture !== null ) {\n\n\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tif ( msaaFb === undefined ) {\n\n\t\t\t\t\tconst invalidationArray = [];\n\n\t\t\t\t\tmsaaFb = gl.createFramebuffer();\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );\n\n\t\t\t\t\tconst msaaRenderbuffers = [];\n\n\t\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tmsaaRenderbuffers[ i ] = gl.createRenderbuffer();\n\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\t\t\t\t\t\tinvalidationArray.push( gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tif ( depthBuffer ) {\n\n\t\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst texture = descriptor.textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.msaaFrameBuffer = msaaFb;\n\t\t\t\t\trenderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n\n\t\t\t\t\tif ( depthRenderbuffer === undefined ) {\n\n\t\t\t\t\t\tdepthRenderbuffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );\n\n\t\t\t\t\t\trenderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.invalidationArray = invalidationArray;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t} else {\n\n\t\t\t\tcurrentFrameBuffer = fb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );\n\n\t}\n\n\t/**\n\t * Computes the VAO key for the given index and attributes.\n\t *\n\t * @private\n\t * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {String} The VAO key.\n\t */\n\t_getVaoKey( index, attributes ) {\n\n\t\tlet key = '';\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attributeData = this.get( attributes[ i ] );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t}\n\n\t\treturn key;\n\n\t}\n\n\t/**\n\t * Creates a VAO from the index and attributes.\n\t *\n\t * @private\n\t * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {Object} The VAO data.\n\t */\n\t_createVao( index, attributes ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst vaoGPU = gl.createVertexArray();\n\t\tlet key = '';\n\n\t\tlet staticVao = true;\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );\n\n\t\t\tkey += ':' + indexData.id;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );\n\t\t\tgl.enableVertexAttribArray( i );\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;\n\n\t\t\tlet stride, offset;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\tstride = attribute.data.stride * attributeData.bytesPerElement;\n\t\t\t\toffset = attribute.offset * attributeData.bytesPerElement;\n\n\t\t\t} else {\n\n\t\t\t\tstride = 0;\n\t\t\t\toffset = 0;\n\n\t\t\t}\n\n\t\t\tif ( attributeData.isInteger ) {\n\n\t\t\t\tgl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );\n\n\t\t\t} else {\n\n\t\t\t\tgl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );\n\n\t\t\t}\n\n\t\t\tif ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.meshPerAttribute );\n\n\t\t\t} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n\t\tthis.vaoCache[ key ] = vaoGPU;\n\n\t\treturn { vaoGPU, staticVao };\n\n\t}\n\n\t/**\n\t * Creates a tranform feedback from the given transform buffers.\n\t *\n\t * @private\n\t * @param {Array<DualAttributeData>} transformBuffers - The tranform buffers.\n\t * @return {WebGLTransformFeedback} The tranform feedback.\n\t */\n\t_getTransformFeedback( transformBuffers ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tkey += ':' + transformBuffers[ i ].id;\n\n\t\t}\n\n\t\tlet transformFeedbackGPU = this.transformFeedbackCache[ key ];\n\n\t\tif ( transformFeedbackGPU !== undefined ) {\n\n\t\t\treturn transformFeedbackGPU;\n\n\t\t}\n\n\t\tconst { gl } = this;\n\n\t\ttransformFeedbackGPU = gl.createTransformFeedback();\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst attributeData = transformBuffers[ i ];\n\n\t\t\tgl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );\n\n\t\t}\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\tthis.transformFeedbackCache[ key ] = transformFeedbackGPU;\n\n\t\treturn transformFeedbackGPU;\n\n\t}\n\n\t/**\n\t * Setups the given bindings.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t */\n\t_setupBindings( bindings, programGPU ) {\n\n\t\tconst gl = this.gl;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\tconst location = gl.getUniformBlockIndex( programGPU, binding.name );\n\t\t\t\t\tgl.uniformBlockBinding( programGPU, location, index );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tconst location = gl.getUniformLocation( programGPU, binding.name );\n\t\t\t\t\tgl.uniform1i( location, index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds the given uniforms.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\t_bindUniforms( bindings ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\t// TODO USE bindBufferRange to group multiple uniform buffers\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tstate.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );\n\n\t}\n\n}\n\nconst GPUPrimitiveTopology = {\n\tPointList: 'point-list',\n\tLineList: 'line-list',\n\tLineStrip: 'line-strip',\n\tTriangleList: 'triangle-list',\n\tTriangleStrip: 'triangle-strip',\n};\n\nconst GPUCompareFunction = {\n\tNever: 'never',\n\tLess: 'less',\n\tEqual: 'equal',\n\tLessEqual: 'less-equal',\n\tGreater: 'greater',\n\tNotEqual: 'not-equal',\n\tGreaterEqual: 'greater-equal',\n\tAlways: 'always'\n};\n\nconst GPUStoreOp = {\n\tStore: 'store',\n\tDiscard: 'discard'\n};\n\nconst GPULoadOp = {\n\tLoad: 'load',\n\tClear: 'clear'\n};\n\nconst GPUFrontFace = {\n\tCCW: 'ccw',\n\tCW: 'cw'\n};\n\nconst GPUCullMode = {\n\tNone: 'none',\n\tFront: 'front',\n\tBack: 'back'\n};\n\nconst GPUIndexFormat = {\n\tUint16: 'uint16',\n\tUint32: 'uint32'\n};\n\nconst GPUTextureFormat = {\n\n\t// 8-bit formats\n\n\tR8Unorm: 'r8unorm',\n\tR8Snorm: 'r8snorm',\n\tR8Uint: 'r8uint',\n\tR8Sint: 'r8sint',\n\n\t// 16-bit formats\n\n\tR16Uint: 'r16uint',\n\tR16Sint: 'r16sint',\n\tR16Float: 'r16float',\n\tRG8Unorm: 'rg8unorm',\n\tRG8Snorm: 'rg8snorm',\n\tRG8Uint: 'rg8uint',\n\tRG8Sint: 'rg8sint',\n\n\t// 32-bit formats\n\n\tR32Uint: 'r32uint',\n\tR32Sint: 'r32sint',\n\tR32Float: 'r32float',\n\tRG16Uint: 'rg16uint',\n\tRG16Sint: 'rg16sint',\n\tRG16Float: 'rg16float',\n\tRGBA8Unorm: 'rgba8unorm',\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb',\n\tRGBA8Snorm: 'rgba8snorm',\n\tRGBA8Uint: 'rgba8uint',\n\tRGBA8Sint: 'rgba8sint',\n\tBGRA8Unorm: 'bgra8unorm',\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb',\n\t// Packed 32-bit formats\n\tRGB9E5UFloat: 'rgb9e5ufloat',\n\tRGB10A2Unorm: 'rgb10a2unorm',\n\tRG11B10uFloat: 'rgb10a2unorm',\n\n\t// 64-bit formats\n\n\tRG32Uint: 'rg32uint',\n\tRG32Sint: 'rg32sint',\n\tRG32Float: 'rg32float',\n\tRGBA16Uint: 'rgba16uint',\n\tRGBA16Sint: 'rgba16sint',\n\tRGBA16Float: 'rgba16float',\n\n\t// 128-bit formats\n\n\tRGBA32Uint: 'rgba32uint',\n\tRGBA32Sint: 'rgba32sint',\n\tRGBA32Float: 'rgba32float',\n\n\t// Depth and stencil formats\n\n\tStencil8: 'stencil8',\n\tDepth16Unorm: 'depth16unorm',\n\tDepth24Plus: 'depth24plus',\n\tDepth24PlusStencil8: 'depth24plus-stencil8',\n\tDepth32Float: 'depth32float',\n\n\t// 'depth32float-stencil8' extension\n\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\n\t// BC compressed formats usable if 'texture-compression-bc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tBC1RGBAUnorm: 'bc1-rgba-unorm',\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n\tBC2RGBAUnorm: 'bc2-rgba-unorm',\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n\tBC3RGBAUnorm: 'bc3-rgba-unorm',\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n\tBC4RUnorm: 'bc4-r-unorm',\n\tBC4RSnorm: 'bc4-r-snorm',\n\tBC5RGUnorm: 'bc5-rg-unorm',\n\tBC5RGSnorm: 'bc5-rg-snorm',\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat',\n\tBC6HRGBFloat: 'bc6h-rgb-float',\n\tBC7RGBAUnorm: 'bc7-rgba-unorm',\n\tBC7RGBAUnormSRGB: 'bc7-rgba-srgb',\n\n\t// ETC2 compressed formats usable if 'texture-compression-etc2' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tETC2RGB8Unorm: 'etc2-rgb8unorm',\n\tETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n\tETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n\tETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n\tETC2RGBA8Unorm: 'etc2-rgba8unorm',\n\tETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n\tEACR11Unorm: 'eac-r11unorm',\n\tEACR11Snorm: 'eac-r11snorm',\n\tEACRG11Unorm: 'eac-rg11unorm',\n\tEACRG11Snorm: 'eac-rg11snorm',\n\n\t// ASTC compressed formats usable if 'texture-compression-astc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tASTC4x4Unorm: 'astc-4x4-unorm',\n\tASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n\tASTC5x4Unorm: 'astc-5x4-unorm',\n\tASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n\tASTC5x5Unorm: 'astc-5x5-unorm',\n\tASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n\tASTC6x5Unorm: 'astc-6x5-unorm',\n\tASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n\tASTC6x6Unorm: 'astc-6x6-unorm',\n\tASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n\tASTC8x5Unorm: 'astc-8x5-unorm',\n\tASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n\tASTC8x6Unorm: 'astc-8x6-unorm',\n\tASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n\tASTC8x8Unorm: 'astc-8x8-unorm',\n\tASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n\tASTC10x5Unorm: 'astc-10x5-unorm',\n\tASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n\tASTC10x6Unorm: 'astc-10x6-unorm',\n\tASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n\tASTC10x8Unorm: 'astc-10x8-unorm',\n\tASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n\tASTC10x10Unorm: 'astc-10x10-unorm',\n\tASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n\tASTC12x10Unorm: 'astc-12x10-unorm',\n\tASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n\tASTC12x12Unorm: 'astc-12x12-unorm',\n\tASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',\n\n};\n\nconst GPUAddressMode = {\n\tClampToEdge: 'clamp-to-edge',\n\tRepeat: 'repeat',\n\tMirrorRepeat: 'mirror-repeat'\n};\n\nconst GPUFilterMode = {\n\tLinear: 'linear',\n\tNearest: 'nearest'\n};\n\nconst GPUBlendFactor = {\n\tZero: 'zero',\n\tOne: 'one',\n\tSrc: 'src',\n\tOneMinusSrc: 'one-minus-src',\n\tSrcAlpha: 'src-alpha',\n\tOneMinusSrcAlpha: 'one-minus-src-alpha',\n\tDst: 'dst',\n\tOneMinusDstColor: 'one-minus-dst',\n\tDstAlpha: 'dst-alpha',\n\tOneMinusDstAlpha: 'one-minus-dst-alpha',\n\tSrcAlphaSaturated: 'src-alpha-saturated',\n\tConstant: 'constant',\n\tOneMinusConstant: 'one-minus-constant'\n};\n\nconst GPUBlendOperation = {\n\tAdd: 'add',\n\tSubtract: 'subtract',\n\tReverseSubtract: 'reverse-subtract',\n\tMin: 'min',\n\tMax: 'max'\n};\n\nconst GPUColorWriteFlags = {\n\tNone: 0,\n\tRed: 0x1,\n\tGreen: 0x2,\n\tBlue: 0x4,\n\tAlpha: 0x8,\n\tAll: 0xF\n};\n\nconst GPUStencilOperation = {\n\tKeep: 'keep',\n\tZero: 'zero',\n\tReplace: 'replace',\n\tInvert: 'invert',\n\tIncrementClamp: 'increment-clamp',\n\tDecrementClamp: 'decrement-clamp',\n\tIncrementWrap: 'increment-wrap',\n\tDecrementWrap: 'decrement-wrap'\n};\n\nconst GPUBufferBindingType = {\n\tUniform: 'uniform',\n\tStorage: 'storage',\n\tReadOnlyStorage: 'read-only-storage'\n};\n\nconst GPUStorageTextureAccess = {\n\tWriteOnly: 'write-only',\n\tReadOnly: 'read-only',\n\tReadWrite: 'read-write',\n};\n\nconst GPUTextureSampleType = {\n\tFloat: 'float',\n\tUnfilterableFloat: 'unfilterable-float',\n\tDepth: 'depth',\n\tSInt: 'sint',\n\tUInt: 'uint'\n};\n\nconst GPUTextureDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tThreeD: '3d'\n};\n\nconst GPUTextureViewDimension = {\n\tOneD: '1d',\n\tTwoD: '2d',\n\tTwoDArray: '2d-array',\n\tCube: 'cube',\n\tCubeArray: 'cube-array',\n\tThreeD: '3d'\n};\n\nconst GPUTextureAspect = {\n\tAll: 'all',\n\tStencilOnly: 'stencil-only',\n\tDepthOnly: 'depth-only'\n};\n\nconst GPUInputStepMode = {\n\tVertex: 'vertex',\n\tInstance: 'instance'\n};\n\nconst GPUFeatureName = {\n\tDepthClipControl: 'depth-clip-control',\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\tTextureCompressionBC: 'texture-compression-bc',\n\tTextureCompressionETC2: 'texture-compression-etc2',\n\tTextureCompressionASTC: 'texture-compression-astc',\n\tTimestampQuery: 'timestamp-query',\n\tIndirectFirstInstance: 'indirect-first-instance',\n\tShaderF16: 'shader-f16',\n\tRG11B10UFloat: 'rg11b10ufloat-renderable',\n\tBGRA8UNormStorage: 'bgra8unorm-storage',\n\tFloat32Filterable: 'float32-filterable',\n\tClipDistances: 'clip-distances',\n\tDualSourceBlending: 'dual-source-blending',\n\tSubgroups: 'subgroups'\n};\n\n/**\n * Represents a sampler binding type.\n *\n * @private\n * @augments Binding\n */\nclass Sampler extends Binding {\n\n\t/**\n\t * Constructs a new sampler.\n\t *\n\t * @param {String} name - The samplers's name.\n\t * @param {Texture?} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The texture the sampler is referring to.\n\t\t *\n\t\t * @type {Texture?}\n\t\t */\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The binding's version.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampler = true;\n\n\t}\n\n}\n\n/**\n * A special form of sampler binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments Sampler\n */\nclass NodeSampler extends Sampler {\n\n\t/**\n\t * Constructs a new node-based sampler.\n\t *\n\t * @param {String} name - The samplers's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, textureNode, groupNode ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * Updates the texture value of this sampler.\n\t */\n\tupdate() {\n\n\t\tthis.texture = this.textureNode.value;\n\n\t}\n\n}\n\n/**\n * Represents a storage buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass StorageBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {String} name - The buffer's name.\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tconstructor( name, attribute ) {\n\n\t\tsuper( name, attribute ? attribute.array : null );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {BufferAttribute}\n\t\t */\n\t\tthis.attribute = attribute;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBuffer = true;\n\n\t}\n\n}\n\nlet _id = 0;\n\n/**\n * A special form of storage buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments StorageBuffer\n */\nclass NodeStorageBuffer extends StorageBuffer {\n\n\t/**\n\t * Constructs a new node-based storage buffer.\n\t *\n\t * @param {StorageBufferNode} nodeUniform - The storage buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {StorageBufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The storage buffer.\n\t *\n\t * @type {BufferAttribute}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\nclass WebGPUTexturePassUtils extends DataMap {\n\n\tconstructor( device ) {\n\n\t\tsuper();\n\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t// We'll need a new pipeline for every texture format used.\n\t\tthis.transferPipelines = {};\n\t\tthis.flipYPipelines = {};\n\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `mipmap-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `flipY-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst textureData = this.get( textureGPU );\n\n\t\tif ( textureData.useCount === undefined ) {\n\n\t\t\ttextureData.useCount = 0;\n\t\t\ttextureData.layers = [];\n\n\t\t}\n\n\t\tconst passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tthis._mipmapRunBundles( commandEncoder, passes );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\tif ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;\n\n\t\ttextureData.useCount ++;\n\n\t}\n\n\t_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst passes = [];\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passDescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tconst passEncoder = this.device.createRenderBundleEncoder( {\n\t\t\t\tcolorFormats: [ textureGPUDescriptor.format ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\n\t\t\tpasses.push( {\n\t\t\t\trenderBundles: [ passEncoder.finish() ],\n\t\t\t\tpassDescriptor\n\t\t\t} );\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\treturn passes;\n\n\t}\n\n\t_mipmapRunBundles( commandEncoder, passes ) {\n\n\t\tconst levels = passes.length;\n\n\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\tconst pass = passes[ i ];\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );\n\n\t\t\tpassEncoder.executeBundles( pass.renderBundles );\n\n\t\t\tpassEncoder.end();\n\n\t\t}\n\n\t}\n\n}\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\nclass WebGPUTextureUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t\tthis._passUtils = null;\n\n\t\tthis.defaultTexture = {};\n\t\tthis.defaultCubeTexture = {};\n\t\tthis.defaultVideoFrame = null;\n\n\t\tthis.colorBuffer = null;\n\n\t\tthis.depthTexture = new DepthTexture();\n\t\tthis.depthTexture.name = 'depthBuffer';\n\n\t}\n\n\tcreateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst textureGPU = backend.get( texture );\n\n\t\tconst samplerDescriptorGPU = {\n\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\tmaxAnisotropy: 1\n\t\t};\n\n\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t}\n\n\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t}\n\n\t\ttextureGPU.sampler = device.createSampler( samplerDescriptorGPU );\n\n\t}\n\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tthis.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tconst { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySamples,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\t\t\tconst videoFrame = new VideoFrame( video );\n\n\t\t\ttextureDescriptorGPU.size.width = videoFrame.displayWidth;\n\t\t\ttextureDescriptorGPU.size.height = videoFrame.displayHeight;\n\n\t\t\tvideoFrame.close();\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tif ( format === undefined ) {\n\n\t\t\t\tconsole.warn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\t\treturn this.createDefaultTexture( texture );\n\n\t\t\t}\n\n\t\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\t}\n\n\t\tif ( isMSAA ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = samples;\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\tdestroyTexture( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\tdestroySampler( texture ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tdelete textureData.sampler;\n\n\t}\n\n\tgenerateMipmaps( texture ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetColorBuffer() {\n\n\t\tif ( this.colorBuffer ) this.colorBuffer.destroy();\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tthis.colorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.samples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\treturn this.colorBuffer;\n\n\t}\n\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\n\t\tconst depthTexture = this.depthTexture;\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\n\t\tthis.createTexture( depthTexture, { width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\tconst video = texture.source.data;\n\n\t\t\ttextureData.externalTexture = video;\n\n\t\t} else {\n\n\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: width * height * bytesPerTexel,\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t_isEnvironmentTexture( texture ) {\n\n\t\tconst mapping = texture.mapping;\n\n\t\treturn ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t}\n\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t_getDefaultVideoFrame() {\n\n\t\tlet defaultVideoFrame = this.defaultVideoFrame;\n\n\t\tif ( defaultVideoFrame === null ) {\n\n\t\t\tconst init = {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tcodedWidth: 1,\n\t\t\t\tcodedHeight: 1,\n\t\t\t\tformat: 'RGBA',\n\t\t\t};\n\n\t\t\tthis.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );\n\n\t\t}\n\n\t\treturn defaultVideoFrame;\n\n\t}\n\n\t_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t}, {\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );\n\n\t}\n\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: 0,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_getBlockData( format ) {\n\n\t\t// this method is only relevant for compressed texture formats\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\nfunction getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib$1 = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\t'texture_depth_multisampled_2d': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib$1[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib$1[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a WSL node function.\n *\n * @augments NodeFunction\n */\nclass WGSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new WGSL node function.\n\t *\n\t * @param {String} source - The WGSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\t/**\n\t * This method returns the WGSL code of the node function.\n\t *\n\t * @param {String} [name=this.name] - The function's name.\n\t * @return {String} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\n/**\n * A WGSL node parser.\n *\n * @augments NodeParser\n */\nclass WGSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given WGSL code an returns a node function.\n\t *\n\t * @param {String} source - The WGSL code.\n\t * @return {WGSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n// WebGPU issue: does not support pow() with negative base on Windows\n\nif ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {\n\n\twgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );\n\twgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );\n\twgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );\n\n\twgslMethods.pow_float = 'tsl_pow_float';\n\twgslMethods.pow_vec2 = 'tsl_pow_vec2';\n\twgslMethods.pow_vec3 = 'tsl_pow_vec3';\n\twgslMethods.pow_vec4 = 'tsl_pow_vec4';\n\n}\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n//\n\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\tthis.uniformGroups = {};\n\n\t\tthis.builtins = {};\n\n\t\tthis.directives = {};\n\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );\n\n\t\t}\n\n\t}\n\n\t_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false ) {\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }_${texture.isData3DTexture ? '3d' : '2d'}T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\t// For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate\n\t\t\tconst coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';\n\t\t\tlet code = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\\n\\n\\treturn ${coordType}(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\tconsole.warn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tcode += ',\\n';\n\t\t\t\taddWrapSnippet( texture.wrapR, 'z' );\n\n\t\t\t}\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\t\t\tlet dimensionType;\n\n\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\t\t\tconst isMultisampled = primarySamples > 1;\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tdimensionType = 'vec3<u32>';\n\n\t\t\t} else {\n\n\t\t\t\t// Regular 2D textures, depth textures, etc.\n\t\t\t\tdimensionType = 'vec2<u32>';\n\n\t\t\t}\n\n\t\t\t// Build parameters string based on texture type and multisampling\n\t\t\tif ( isMultisampled || texture.isVideoTexture || texture.isStorageTexture ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${ levelSnippet } )` : ''}`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, dimensionType ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t\tif ( texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\t\ttextureData.arrayLayerCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode(\n\t\t\t\t\t\t`textureNumLayers(${textureProperty})`,\n\t\t\t\t\t\t'u32'\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// For cube textures, we know it's always 6 faces\n\t\t\tif ( texture.isTextureCube ) {\n\n\t\t\t\ttextureData.cubeFaceCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode( '6u', 'u32' )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst vecType = texture.isData3DTexture ? 'vec3' : 'vec2';\n\t\tconst coordSnippet = `${vecType}<u32>(${wrapFunction}(${uvSnippet}) * ${vecType}<f32>(${textureDimension}))`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );\n\n\t}\n\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {\n\n\t\tif ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;\n\n\t\t} else if ( depthSnippet ) {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\treturn `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t}\n\n\t}\n\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {\n\n\t\treturn `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t}\n\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\tthis.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;\n\n\t}\n\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else if ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( texture.isVideoTexture === true ) {\n\n\t\t\tsnippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\tconsole.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\treturn `NodeBuffer_${ node.id }.${name}`;\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t_getUniformGroupCount( shaderStage ) {\n\n\t\treturn Object.keys( this.uniforms[ shaderStage ] ).length;\n\n\t}\n\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' )\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\treturn node.access;\n\n\t}\n\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\t\tconst members = struct.getMemberTypes();\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst member = members[ i ];\n\t\t\tsnippets.push( `\\t@location( ${i} ) m${i} : ${ member }<f32>` );\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\tif ( builtins ) snippets.push( '\\t' + builtins );\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tfor ( let index = 0, length = structs.length; index < length; index ++ ) {\n\n\t\t\tconst struct = structs[ index ];\n\t\t\tconst name = struct.name;\n\n\t\t\tlet snippet = `\\struct ${ name } {\\n`;\n\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\tsnippet += '\\n}';\n\n\n\t\t\tsnippets.push( snippet );\n\n\t\t\tsnippets.push( `\\nvar<private> output : ${ name };\\n\\n` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\n' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `var ${ name } : ${ this.getType( type ) }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ' @interpolate( flat )';\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\ttextureType = `texture_depth${multisampled}_2d`;\n\n\t\t\t\t} else if ( texture.isVideoTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_external';\n\n\t\t\t\t} else if ( texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\ttextureType = `texture_storage_2d<${ format }, ${ access }>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${multisampled}_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;\n\t\t\t\tconst bufferSnippet = `\\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\\n`;\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.nodeType;\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;\\n\\n';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( codeNode );\n\n\t\t}\n\n\t\treturn codeNode;\n\n\t}\n\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// uniforms\n${shaderData.uniforms}\n\n// structs\n${shaderData.structs}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSize} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`;\n\n\t}\n\n}\n\nclass WebGPUUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tgetCurrentDepthStencilFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.depthTexture !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.depthTexture );\n\n\t\t} else if ( renderContext.depth && renderContext.stencil ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24PlusStencil8;\n\n\t\t} else if ( renderContext.depth ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24Plus;\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\tgetTextureFormatGPU( texture ) {\n\n\t\treturn this.backend.get( texture ).format;\n\n\t}\n\n\tgetTextureSampleData( texture ) {\n\n\t\tlet samples;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tsamples = 1;\n\n\t\t} else if ( texture.isDepthTexture && ! texture.renderTarget ) {\n\n\t\t\tconst renderer = this.backend.renderer;\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t\tsamples = renderTarget ? renderTarget.samples : renderer.samples;\n\n\t\t} else if ( texture.renderTarget ) {\n\n\t\t\tsamples = texture.renderTarget.samples;\n\n\t\t}\n\n\t\tsamples = samples || 1;\n\n\t\tconst isMSAA = samples > 1 && texture.renderTarget !== null && ( texture.isDepthTexture !== true && texture.isFramebufferTexture !== true );\n\t\tconst primarySamples = isMSAA ? 1 : samples;\n\n\t\treturn { samples, primarySamples, isMSAA };\n\n\t}\n\n\tgetCurrentColorFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.textures[ 0 ] );\n\n\t\t} else {\n\n\t\t\tformat = this.getPreferredCanvasFormat(); // default context format\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\tgetCurrentColorSpace( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn renderContext.textures[ 0 ].colorSpace;\n\n\t\t}\n\n\t\treturn this.backend.renderer.outputColorSpace;\n\n\t}\n\n\tgetPrimitiveTopology( object, material ) {\n\n\t\tif ( object.isPoints ) return GPUPrimitiveTopology.PointList;\n\t\telse if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;\n\t\telse if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;\n\t\telse if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;\n\n\t}\n\n\tgetSampleCount( sampleCount ) {\n\n\t\tlet count = 1;\n\n\t\tif ( sampleCount > 1 ) {\n\n\t\t\t// WebGPU only supports power-of-two sample counts and 2 is not a valid value\n\t\t\tcount = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );\n\n\t\t\tif ( count === 2 ) {\n\n\t\t\t\tcount = 4;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tgetSampleCountRenderContext( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn this.getSampleCount( renderContext.sampleCount );\n\n\t\t}\n\n\t\treturn this.getSampleCount( this.backend.renderer.samples );\n\n\t}\n\n\tgetPreferredCanvasFormat() {\n\n\t\t// TODO: Remove this check when Quest 34.5 is out\n\t\t// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949\n\n\t\tif ( navigator.userAgent.includes( 'Quest' ) ) {\n\n\t\t\treturn GPUTextureFormat.BGRA8Unorm;\n\n\t\t} else {\n\n\t\t\treturn navigator.gpu.getPreferredCanvasFormat();\n\n\t\t}\n\n\t}\n\n}\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Int16Array, 'sint32' ], // patch for INT16\n\t[ Uint32Array, 'uint32' ],\n\t[ Uint16Array, 'uint32' ], // patch for UINT16\n\t[ Float32Array, 'float32' ]\n] );\n\nclass WebGPUAttributeUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tlet array = bufferAttribute.array;\n\n\t\t\t// patch for INT16 and UINT16\n\t\t\tif ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {\n\n\t\t\t\tconst tempArray = new Uint32Array( array.length );\n\t\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\ttempArray[ i ] = array[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tarray = tempArray;\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t\tif ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {\n\n\t\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t\t}\n\n\t\t\t\t// Update BufferAttribute\n\t\t\t\tbufferAttribute.itemSize = 4;\n\t\t\t\tbufferAttribute.array = array;\n\n\t\t\t}\n\n\t\t\tconst size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tconst array = bufferAttribute.array;\n\t\tconst isTypedArray = this._isTypedArray( array );\n\t\tconst updateRanges = bufferAttribute.updateRanges;\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tconst byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\n\t\t\t\tconst dataOffset = range.start * byteOffsetFactor;\n\t\t\t\tconst size = range.count * byteOffsetFactor;\n\n\t\t\t\tdevice.queue.writeBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\t0,\n\t\t\t\t\tarray,\n\t\t\t\t\tdataOffset,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t}\n\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\t// patch for INT16 and UINT16\n\t\t\t\tif ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {\n\n\t\t\t\t\tarrayStride = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tconst readBufferGPU = device.createBuffer( {\n\t\t\tlabel: `${ attribute.name }_readback`,\n\t\t\tsize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {\n\t\t\tlabel: `readback_encoder_${ attribute.name }`\n\t\t} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\tconst dstBuffer = new attribute.array.constructor( arrayBuffer.slice( 0 ) );\n\n\t\treadBufferGPU.unmap();\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize === 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\tconsole.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t_isTypedArray( array ) {\n\n\t\treturn ArrayBuffer.isView( array ) && ! ( array instanceof DataView );\n\n\t}\n\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\nclass WebGPUBindingUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\t\tthis.bindGroupLayoutCache = new WeakMap();\n\n\t}\n\n\tcreateBindingsLayout( bindGroup ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tif ( binding.visibility & 4 ) {\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\tif ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = 'comparison';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {\n\n\t\t\t\tbindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst storageTexture = {}; // GPUStorageTextureBindingLayout\n\t\t\t\tstorageTexture.format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tconst access = binding.access;\n\n\t\t\t\tif ( access === NodeAccess.READ_WRITE ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadWrite;\n\n\t\t\t\t} else if ( access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.WriteOnly;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadOnly;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.storageTexture = storageTexture;\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tconst { primarySamples } = backend.utils.getTextureSampleData( binding.texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\ttexture.multisampled = true;\n\n\t\t\t\t\tif ( ! binding.texture.isDepthTexture ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {\n\n\t\t\t\t\tconst type = binding.texture.type;\n\n\t\t\t\t\tif ( type === IntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.SInt;\n\n\t\t\t\t\t} else if ( type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UInt;\n\n\t\t\t\t\t} else if ( type === FloatType ) {\n\n\t\t\t\t\t\tif ( this.backend.hasFeature( 'float32-filterable' ) ) {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Float;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( `WebGPUBindingUtils: Unsupported binding \"${ binding }\".` );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\tcreateBindings( bindGroup, bindings, cacheIndex, version = 0 ) {\n\n\t\tconst { backend, bindGroupLayoutCache } = this;\n\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tlet bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );\n\n\t\tif ( bindLayoutGPU === undefined ) {\n\n\t\t\tbindLayoutGPU = this.createBindingsLayout( bindGroup );\n\t\t\tbindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );\n\n\t\t}\n\n\t\tlet bindGroupGPU;\n\n\t\tif ( cacheIndex > 0 ) {\n\n\t\t\tif ( bindingsData.groups === undefined ) {\n\n\t\t\t\tbindingsData.groups = [];\n\t\t\t\tbindingsData.versions = [];\n\n\t\t\t}\n\n\t\t\tif ( bindingsData.versions[ cacheIndex ] === version ) {\n\n\t\t\t\tbindGroupGPU = bindingsData.groups[ cacheIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bindGroupGPU === undefined ) {\n\n\t\t\tbindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );\n\n\t\t\tif ( cacheIndex > 0 ) {\n\n\t\t\t\tbindingsData.groups[ cacheIndex ] = bindGroupGPU;\n\t\t\t\tbindingsData.versions[ cacheIndex ] = version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.layout = bindLayoutGPU;\n\n\t}\n\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\tcreateBindGroup( bindGroup, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer_' + binding.name,\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n\t\t\t\t\tconst propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;\n\n\t\t\t\t\tresourceGPU = textureData[ propertyName ];\n\n\t\t\t\t\tif ( resourceGPU === undefined ) {\n\n\t\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t\t\t} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroup_' + bindGroup.name,\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\nclass WebGPUPipelineUtils {\n\n\tconstructor( backend ) {\n\n\t\tthis.backend = backend;\n\n\t}\n\n\t_getSampleCount( renderObjectContext ) {\n\n\t\treturn this.backend.utils.getSampleCountRenderContext( renderObjectContext );\n\n\t}\n\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst { object, material, geometry, pipeline } = renderObject;\n\t\tconst { vertexProgram, fragmentProgram } = pipeline;\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\t\tconst utils = backend.utils;\n\n\t\tconst pipelineData = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindGroup of renderObject.getBindings() ) {\n\n\t\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );\n\n\t\t// blending\n\n\t\tlet blending;\n\n\t\tif ( material.transparent === true && material.blending !== NoBlending ) {\n\n\t\t\tblending = this._getBlending( material );\n\n\t\t}\n\n\t\t// stencil\n\n\t\tlet stencilFront = {};\n\n\t\tif ( material.stencilWrite === true ) {\n\n\t\t\tstencilFront = {\n\t\t\t\tcompare: this._getStencilCompare( material ),\n\t\t\t\tfailOp: this._getStencilOperation( material.stencilFail ),\n\t\t\t\tdepthFailOp: this._getStencilOperation( material.stencilZFail ),\n\t\t\t\tpassOp: this._getStencilOperation( material.stencilZPass )\n\t\t\t};\n\n\t\t}\n\n\t\tconst colorWriteMask = this._getColorWriteMask( material );\n\n\t\tconst targets = [];\n\n\t\tif ( renderObject.context.textures !== null ) {\n\n\t\t\tconst textures = renderObject.context.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst colorFormat = utils.getTextureFormatGPU( textures[ i ] );\n\n\t\t\t\ttargets.push( {\n\t\t\t\t\tformat: colorFormat,\n\t\t\t\t\tblend: blending,\n\t\t\t\t\twriteMask: colorWriteMask\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\n\t\t\ttargets.push( {\n\t\t\t\tformat: colorFormat,\n\t\t\t\tblend: blending,\n\t\t\t\twriteMask: colorWriteMask\n\t\t\t} );\n\n\t\t}\n\n\t\tconst vertexModule = backend.get( vertexProgram ).module;\n\t\tconst fragmentModule = backend.get( fragmentProgram ).module;\n\n\t\tconst primitiveState = this._getPrimitiveState( object, geometry, material );\n\t\tconst depthCompare = this._getDepthCompare( material );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\n\t\tconst sampleCount = this._getSampleCount( renderObject.context );\n\n\t\tconst pipelineDescriptor = {\n\t\t\tlabel: `renderPipeline_${ material.name || material.type }_${ material.id }`,\n\t\t\tvertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),\n\t\t\tfragment: Object.assign( {}, fragmentModule, { targets } ),\n\t\t\tprimitive: primitiveState,\n\t\t\tmultisample: {\n\t\t\t\tcount: sampleCount,\n\t\t\t\talphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n\t\t\t},\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t};\n\n\n\t\tconst depthStencil = {};\n\t\tconst renderDepth = renderObject.context.depth;\n\t\tconst renderStencil = renderObject.context.stencil;\n\n\t\tif ( renderDepth === true || renderStencil === true ) {\n\n\t\t\tif ( renderDepth === true ) {\n\n\t\t\t\tdepthStencil.format = depthStencilFormat;\n\t\t\t\tdepthStencil.depthWriteEnabled = material.depthWrite;\n\t\t\t\tdepthStencil.depthCompare = depthCompare;\n\n\t\t\t}\n\n\t\t\tif ( renderStencil === true ) {\n\n\t\t\t\tdepthStencil.stencilFront = stencilFront;\n\t\t\t\tdepthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n\t\t\t\tdepthStencil.stencilReadMask = material.stencilFuncMask;\n\t\t\t\tdepthStencil.stencilWriteMask = material.stencilWriteMask;\n\n\t\t\t}\n\n\t\t\tpipelineDescriptor.depthStencil = depthStencil;\n\n\t\t}\n\n\n\t\tif ( promises === null ) {\n\n\t\t\tpipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );\n\n\t\t} else {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tdevice.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {\n\n\t\t\t\t\tpipelineData.pipeline = pipeline;\n\t\t\t\t\tresolve();\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t}\n\n\t}\n\n\tcreateBundleEncoder( renderContext ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { utils, device } = backend;\n\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderContext );\n\t\tconst sampleCount = this._getSampleCount( renderContext );\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'renderBundleEncoder',\n\t\t\tcolorFormats: [ colorFormat ],\n\t\t\tdepthStencilFormat,\n\t\t\tsampleCount\n\t\t};\n\n\t\treturn device.createRenderBundleEncoder( descriptor );\n\n\t}\n\n\tcreateComputePipeline( pipeline, bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst computeProgram = backend.get( pipeline.computeProgram ).module;\n\n\t\tconst pipelineGPU = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindingsGroup of bindings ) {\n\n\t\t\tconst bindingsData = backend.get( bindingsGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\tpipelineGPU.pipeline = device.createComputePipeline( {\n\t\t\tcompute: computeProgram,\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t} );\n\n\t}\n\n\t_getBlending( material ) {\n\n\t\tlet color, alpha;\n\n\t\tconst blending = material.blending;\n\t\tconst blendSrc = material.blendSrc;\n\t\tconst blendDst = material.blendDst;\n\t\tconst blendEquation = material.blendEquation;\n\n\n\t\tif ( blending === CustomBlending ) {\n\n\t\t\tconst blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n\t\t\tconst blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n\t\t\tconst blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n\n\t\t\tcolor = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrc ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDst ),\n\t\t\t\toperation: this._getBlendOperation( blendEquation )\n\t\t\t};\n\n\t\t\talpha = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrcAlpha ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDstAlpha ),\n\t\t\t\toperation: this._getBlendOperation( blendEquationAlpha )\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst premultipliedAlpha = material.premultipliedAlpha;\n\n\t\t\tconst setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {\n\n\t\t\t\tcolor = {\n\t\t\t\t\tsrcFactor: srcRGB,\n\t\t\t\t\tdstFactor: dstRGB,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t\talpha = {\n\t\t\t\t\tsrcFactor: srcAlpha,\n\t\t\t\t\tdstFactor: dstAlpha,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( color !== undefined && alpha !== undefined ) {\n\n\t\t\treturn { color, alpha };\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );\n\n\t\t}\n\n\t}\n\n\t_getBlendFactor( blend ) {\n\n\t\tlet blendFactor;\n\n\t\tswitch ( blend ) {\n\n\t\t\tcase ZeroFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase OneFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.One;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Src;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrc;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase DstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Dst;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstColor;\n\t\t\t\tbreak;\n\n\t\t\tcase DstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.DstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaSaturateFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlphaSaturated;\n\t\t\t\tbreak;\n\n\t\t\tcase BlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Constant;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusBlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusConstant;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );\n\n\t\t}\n\n\t\treturn blendFactor;\n\n\t}\n\n\t_getStencilCompare( material ) {\n\n\t\tlet stencilCompare;\n\n\t\tconst stencilFunc = material.stencilFunc;\n\n\t\tswitch ( stencilFunc ) {\n\n\t\t\tcase NeverStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Never;\n\t\t\t\tbreak;\n\n\t\t\tcase AlwaysStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Always;\n\t\t\t\tbreak;\n\n\t\t\tcase LessStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Less;\n\t\t\t\tbreak;\n\n\t\t\tcase LessEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.LessEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase EqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Equal;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Greater;\n\t\t\t\tbreak;\n\n\t\t\tcase NotEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.NotEqual;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );\n\n\t\t}\n\n\t\treturn stencilCompare;\n\n\t}\n\n\t_getStencilOperation( op ) {\n\n\t\tlet stencilOperation;\n\n\t\tswitch ( op ) {\n\n\t\t\tcase KeepStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Keep;\n\t\t\t\tbreak;\n\n\t\t\tcase ZeroStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase ReplaceStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Replace;\n\t\t\t\tbreak;\n\n\t\t\tcase InvertStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Invert;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );\n\n\t\t}\n\n\t\treturn stencilOperation;\n\n\t}\n\n\t_getBlendOperation( blendEquation ) {\n\n\t\tlet blendOperation;\n\n\t\tswitch ( blendEquation ) {\n\n\t\t\tcase AddEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Add;\n\t\t\t\tbreak;\n\n\t\t\tcase SubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Subtract;\n\t\t\t\tbreak;\n\n\t\t\tcase ReverseSubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.ReverseSubtract;\n\t\t\t\tbreak;\n\n\t\t\tcase MinEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Min;\n\t\t\t\tbreak;\n\n\t\t\tcase MaxEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Max;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );\n\n\t\t}\n\n\t\treturn blendOperation;\n\n\t}\n\n\t_getPrimitiveState( object, geometry, material ) {\n\n\t\tconst descriptor = {};\n\t\tconst utils = this.backend.utils;\n\n\t\tdescriptor.topology = utils.getPrimitiveTopology( object, material );\n\n\t\tif ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {\n\n\t\t\tdescriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t}\n\n\t\tswitch ( material.side ) {\n\n\t\t\tcase FrontSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Back;\n\t\t\t\tbreak;\n\n\t\t\tcase BackSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.Front;\n\t\t\t\tbreak;\n\n\t\t\tcase DoubleSide:\n\t\t\t\tdescriptor.frontFace = GPUFrontFace.CCW;\n\t\t\t\tdescriptor.cullMode = GPUCullMode.None;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t_getColorWriteMask( material ) {\n\n\t\treturn ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n\n\t}\n\n\t_getDepthCompare( material ) {\n\n\t\tlet depthCompare;\n\n\t\tif ( material.depthTest === false ) {\n\n\t\t\tdepthCompare = GPUCompareFunction.Always;\n\n\t\t} else {\n\n\t\t\tconst depthFunc = material.depthFunc;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Never;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Always;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Less;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.LessEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Equal;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Greater;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.NotEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn depthCompare;\n\n\t}\n\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n\n\n/**\n * A backend implementation targeting WebGPU.\n *\n * @private\n * @augments Backend\n */\nclass WebGPUBackend extends Backend {\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @param {Boolean} [parameters.trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.\n\t * @param {String?} [parameters.powerPreference=null] - The power preference.\n\t * @param {String?} [parameters.requiredLimits={}] - Specifies the limits that are required by the device request.\n\t * The request will fail if the adapter cannot provide these limits.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPUBackend = true;\n\n\t\t// some parameters require default values other than \"undefined\"\n\t\tthis.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\t/**\n\t\t * Whether to track timestamps with a Timestamp Query API or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t\t/**\n\t\t * A reference to the device.\n\t\t *\n\t\t * @type {GPUDevice?}\n\t\t * @default null\n\t\t */\n\t\tthis.device = null;\n\n\t\t/**\n\t\t * A reference to the context.\n\t\t *\n\t\t * @type {GPUCanvasContext?}\n\t\t * @default null\n\t\t */\n\t\tthis.context = null;\n\n\t\t/**\n\t\t * A reference to the color attachment of the default framebuffer.\n\t\t *\n\t\t * @type {GPUTexture?}\n\t\t * @default null\n\t\t */\n\t\tthis.colorBuffer = null;\n\n\t\t/**\n\t\t * A reference to the default render pass descriptor.\n\t\t *\n\t\t * @type {Object?}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common utility functions.\n\t\t *\n\t\t * @type {WebGPUUtils}\n\t\t */\n\t\tthis.utils = new WebGPUUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUAttributeUtils}\n\t\t */\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader binding-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUBindingUtils}\n\t\t */\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader pipeline-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUPipelineUtils}\n\t\t */\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUTextureUtils}\n\t\t */\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\n\t\t/**\n\t\t * A map that manages the resolve buffers for occlusion queries.\n\t\t *\n\t\t * @type {Map<Number,GPUBuffer>}\n\t\t */\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\t// create the device if it is not passed with parameters\n\n\t\tlet device;\n\n\t\tif ( parameters.device === undefined ) {\n\n\t\t\tconst adapterOptions = {\n\t\t\t\tpowerPreference: parameters.powerPreference\n\t\t\t};\n\n\t\t\tconst adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;\n\n\t\t\tif ( adapter === null ) {\n\n\t\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t\t}\n\n\t\t\t// feature support\n\n\t\t\tconst features = Object.values( GPUFeatureName );\n\n\t\t\tconst supportedFeatures = [];\n\n\t\t\tfor ( const name of features ) {\n\n\t\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deviceDescriptor = {\n\t\t\t\trequiredFeatures: supportedFeatures,\n\t\t\t\trequiredLimits: parameters.requiredLimits\n\t\t\t};\n\n\t\t\tdevice = await adapter.requestDevice( deviceDescriptor );\n\n\t\t} else {\n\n\t\t\tdevice = parameters.device;\n\n\t\t}\n\n\t\tdevice.lost.then( ( info ) => {\n\n\t\t\tconst deviceLossInfo = {\n\t\t\t\tapi: 'WebGPU',\n\t\t\t\tmessage: info.message || 'Unknown reason',\n\t\t\t\treason: info.reason || null,\n\t\t\t\toriginalEvent: info\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( deviceLossInfo );\n\n\t\t} );\n\n\t\tconst context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );\n\n\t\tthis.device = device;\n\t\tthis.context = context;\n\n\t\tconst alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n\n\t\tthis.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );\n\n\t\tthis.context.configure( {\n\t\t\tdevice: this.device,\n\t\t\tformat: this.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\talphaMode: alphaMode\n\t\t} );\n\n\t\tthis.updateSize();\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {Number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\t/**\n\t * Transfers buffer data from a storage buffer attribute\n\t * from the GPU to the CPU in context of compute shaders.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {GPUCanvasContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Returns the default render pass descriptor.\n\t *\n\t * In WebGPU, the default framebuffer must be configured\n\t * like custom fraemebuffers so the backend needs a render\n\t * pass descriptor even when rendering directly to screen.\n\t *\n\t * @private\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getDefaultRenderPassDescriptor() {\n\n\t\tlet descriptor = this.defaultRenderPassdescriptor;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: null\n\t\t\t\t} ],\n\t\t\t};\n\n\t\t\tif ( this.renderer.depth === true || this.renderer.stencil === true ) {\n\n\t\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\t\tcolorAttachment.view = this.colorBuffer.createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tthis.defaultRenderPassdescriptor = descriptor;\n\n\t\t}\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\tif ( this.renderer.samples > 0 ) {\n\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * Returns the render pass descriptor for the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getRenderPassDescriptor( renderContext, colorAttachmentsConfig = {} ) {\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tlet descriptors = renderTargetData.descriptors;\n\n\t\tif ( descriptors === undefined ||\n\t\t\trenderTargetData.width !== renderTarget.width ||\n\t\t\trenderTargetData.height !== renderTarget.height ||\n\t\t\trenderTargetData.dimensions !== renderTarget.dimensions ||\n\t\t\trenderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||\n\t\t\trenderTargetData.activeCubeFace !== renderContext.activeCubeFace ||\n\t\t\trenderTargetData.samples !== renderTarget.samples ||\n\t\t\trenderTargetData.loadOp !== colorAttachmentsConfig.loadOp\n\t\t) {\n\n\t\t\tdescriptors = {};\n\n\t\t\trenderTargetData.descriptors = descriptors;\n\n\t\t\t// dispose\n\n\t\t\tconst onDispose = () => {\n\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onDispose );\n\n\t\t\t\tthis.delete( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\tconst cacheKey = renderContext.getCacheKey();\n\n\t\tlet descriptor = descriptors[ cacheKey ];\n\n\t\tif ( descriptor === undefined ) {\n\n\t\t\tconst textures = renderContext.textures;\n\t\t\tconst colorAttachments = [];\n\n\t\t\tlet sliceIndex;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst viewDescriptor = {\n\t\t\t\t\tlabel: `colorAttachment_${ i }`,\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tarrayLayerCount: 1,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t};\n\n\t\t\t\tif ( renderTarget.isRenderTarget3D ) {\n\n\t\t\t\t\tsliceIndex = renderContext.activeCubeFace;\n\n\t\t\t\t\tviewDescriptor.baseArrayLayer = 0;\n\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.ThreeD;\n\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t} else if ( renderTarget.isRenderTargetArray ) {\n\n\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;\n\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t}\n\n\t\t\t\tconst textureView = textureData.texture.createView( viewDescriptor );\n\n\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tview = textureView;\n\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachments.push( {\n\t\t\t\t\tview,\n\t\t\t\t\tdepthSlice: sliceIndex,\n\t\t\t\t\tresolveTarget,\n\t\t\t\t\tloadOp: GPULoadOp.Load,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\t...colorAttachmentsConfig\n\t\t\t\t} );\n\n\t\t\t}\n\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments,\n\t\t\t};\n\n\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\n\t\t\t\tconst depthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\t\t\t\tdescriptor.depthStencilAttachment = depthStencilAttachment;\n\n\t\t\t}\n\n\t\t\tdescriptors[ cacheKey ] = descriptor;\n\n\t\t\trenderTargetData.width = renderTarget.width;\n\t\t\trenderTargetData.height = renderTarget.height;\n\t\t\trenderTargetData.samples = renderTarget.samples;\n\t\t\trenderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;\n\t\t\trenderTargetData.activeCubeFace = renderContext.activeCubeFace;\n\t\t\trenderTargetData.dimensions = renderTarget.dimensions;\n\t\t\trenderTargetData.depthSlice = sliceIndex;\n\t\t\trenderTargetData.loadOp = colorAttachments[ 0 ].loadOp;\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGPU state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tlet descriptor;\n\n\t\tif ( renderContext.textures === null ) {\n\n\t\t\tdescriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t} else {\n\n\t\t\tdescriptor = this._getRenderPassDescriptor( renderContext, { loadOp: GPULoadOp.Load } );\n\n\t\t}\n\n\t\tthis.initTimestampQuery( renderContext, descriptor );\n\n\t\tdescriptor.occlusionQuerySet = occlusionQuerySet;\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentPass = currentPass;\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.renderBundles = [];\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tcurrentPass.setScissorRect( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( renderContextData.renderBundles.length > 0 ) {\n\n\t\t\trenderContextData.currentPass.executeBundles( renderContextData.renderBundles );\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\trenderContextData.currentPass.end();\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( renderContext, renderContextData.encoder );\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {Boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {\n\n\t\t\t\tif ( results[ i ] !== BigInt( 0 ) ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {Boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {Boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {RenderContext?} [renderTargetContext=null] - The render context of the current set render target.\n\t */\n\tclear( color, depth, stencil, renderTargetContext = null ) {\n\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\n\t\tlet colorAttachments = [];\n\n\t\tlet depthStencilAttachment;\n\t\tlet clearValue;\n\n\t\tlet supportsDepth;\n\t\tlet supportsStencil;\n\n\t\tif ( color ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\tif ( this.renderer.alpha === true ) {\n\n\t\t\t\t// premultiply alpha\n\n\t\t\t\tconst a = clearColor.a;\n\n\t\t\t\tclearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };\n\n\t\t\t} else {\n\n\t\t\t\tclearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( renderTargetContext === null ) {\n\n\t\t\tsupportsDepth = renderer.depth;\n\t\t\tsupportsStencil = renderer.stencil;\n\n\t\t\tconst descriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t\tif ( color ) {\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t\tconst colorAttachment = colorAttachments[ 0 ];\n\n\t\t\t\tcolorAttachment.clearValue = clearValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsupportsDepth = renderTargetContext.depth;\n\t\t\tsupportsStencil = renderTargetContext.stencil;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tconst descriptor = this._getRenderPassDescriptor( renderTargetContext, { loadOp: GPULoadOp.Clear } );\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderTargetContext.depthTexture );\n\n\t\t\t\tdepthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.texture.createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsDepth ) {\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderer.getClearDepth();\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsStencil ) {\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( {} );\n\t\tconst currentPass = encoder.beginRenderPass( {\n\t\t\tcolorAttachments,\n\t\t\tdepthStencilAttachment\n\t\t} );\n\n\t\tcurrentPass.end();\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\n\t\tconst descriptor = {};\n\n\t\tthis.initTimestampQuery( computeGroup, descriptor );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder();\n\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline ) {\n\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t// bind groups\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tpassEncoderGPU.setBindGroup( i, bindingsData.group );\n\n\t\t}\n\n\t\tconst maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n\n\t\tconst computeNodeData = this.get( computeNode );\n\n\t\tif ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };\n\n\t\tconst { dispatchSize } = computeNodeData;\n\n\t\tif ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {\n\n\t\t\tdispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );\n\t\t\tdispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );\n\n\t\t} else {\n\n\t\t\tdispatchSize.x = computeNode.dispatchCount;\n\n\t\t}\n\n\t\tpassEncoderGPU.dispatchWorkgroups(\n\t\t\tdispatchSize.x,\n\t\t\tdispatchSize.y,\n\t\t\tdispatchSize.z\n\t\t);\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\n\t\tthis.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );\n\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\tawait this.device.queue.onSubmittedWorkDone();\n\n\t}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, context, pipeline } = renderObject;\n\t\tconst bindings = renderObject.getBindings();\n\t\tconst renderContextData = this.get( context );\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\t\tconst currentSets = renderContextData.currentSets;\n\t\tconst passEncoderGPU = renderContextData.currentPass;\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t// pipeline\n\n\t\tif ( currentSets.pipeline !== pipelineGPU ) {\n\n\t\t\tpassEncoderGPU.setPipeline( pipelineGPU );\n\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t}\n\n\t\t// bind groups\n\n\t\tconst currentBindingGroups = currentSets.bindingGroups;\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tif ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {\n\n\t\t\t\tpassEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );\n\t\t\t\tcurrentBindingGroups[ bindGroup.index ] = bindGroup.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst index = renderObject.getIndex();\n\n\t\tconst hasIndex = ( index !== null );\n\n\t\t// index\n\n\t\tif ( hasIndex === true ) {\n\n\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\tcurrentSets.index = index;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// occlusion queries - handle multiple consecutive draw calls for an object\n\n\t\tif ( renderContextData.occlusionQuerySet !== undefined ) {\n\n\t\t\tconst lastObject = renderContextData.lastOcclusionObject;\n\n\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.endOcclusionQuery();\n\t\t\t\t\trenderContextData.occlusionQueryIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\tpassEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );\n\t\t\t\t\trenderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t}\n\n\t\t\t\trenderContextData.lastOcclusionObject = object;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// draw\n\n\t\tif ( object.isBatchedMesh === true ) {\n\n\t\t\tconst starts = object._multiDrawStarts;\n\t\t\tconst counts = object._multiDrawCounts;\n\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\tconst drawInstances = object._multiDrawInstances;\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tconst count = drawInstances ? drawInstances[ i ] : 1;\n\t\t\t\tconst firstInstance = count > 1 ? 0 : i;\n\n\t\t\t\tif ( hasIndex === true ) {\n\n\t\t\t\t\tpassEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / index.array.BYTES_PER_ELEMENT, 0, firstInstance );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.draw( counts[ i ], count, starts[ i ], firstInstance );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( hasIndex === true ) {\n\n\t\t\tconst { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;\n\n\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\tif ( indirect !== null ) {\n\n\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\tpassEncoderGPU.drawIndexedIndirect( buffer, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );\n\n\t\t\t}\n\n\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t} else {\n\n\t\t\tconst { vertexCount, instanceCount, firstVertex } = drawParams;\n\n\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\tif ( indirect !== null ) {\n\n\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\tpassEncoderGPU.drawIndirect( buffer, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\t}\n\n\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCountRenderContext( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||\n\t\t\tdata.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||\n\t\t\tdata.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||\n\t\t\tdata.primitiveTopology !== primitiveTopology ||\n\t\t\tdata.clippingContextCacheKey !== renderObject.clippingContextCacheKey\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\t\t\tdata.sampleCount = sampleCount;\n\t\t\tdata.colorSpace = colorSpace;\n\t\t\tdata.colorFormat = colorFormat;\n\t\t\tdata.depthStencilFormat = depthStencilFormat;\n\t\t\tdata.primitiveTopology = primitiveTopology;\n\t\t\tdata.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {String} The cache key.\n\t */\n\tgetRenderCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\treturn [\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tutils.getSampleCountRenderContext( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material ),\n\t\t\trenderObject.getGeometryCacheKey(),\n\t\t\trenderObject.clippingContextCacheKey\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t */\n\tcreateSampler( texture ) {\n\n\t\tthis.textureUtils.createSampler( texture );\n\n\t}\n\n\t/**\n\t * Destroys the sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to destroy the sampler for.\n\t */\n\tdestroySampler( texture ) {\n\n\t\tthis.textureUtils.destroySampler( texture );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tdestroyTexture( texture ) {\n\n\t\tthis.textureUtils.destroyTexture( texture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {Number} x - The x coordinate of the copy origin.\n\t * @param {Number} y - The y coordinate of the copy origin.\n\t * @param {Number} width - The width of the copy.\n\t * @param {Number} height - The height of the copy.\n\t * @param {Number} faceIndex - The face index.\n\t * @return {TypedArray} The texture data as a typed array.\n\t */\n\tcopyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} descriptor - The query descriptor.\n\t */\n\tinitTimestampQuery( renderContext, descriptor ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( ! renderContextData.timeStampQuerySet ) {\n\n\n\t\t\tconst type = renderContext.isComputeNode ? 'compute' : 'render';\n\t\t\tconst timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2, label: `timestamp_${type}_${renderContext.id}` } );\n\n\t\t\tconst timestampWrites = {\n\t\t\t\tquerySet: timeStampQuerySet,\n\t\t\t\tbeginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.\n\t\t\t\tendOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.\n\t\t\t};\n\n\t\t\tObject.assign( descriptor, { timestampWrites } );\n\n\t\t\trenderContextData.timeStampQuerySet = timeStampQuerySet;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Prepares the timestamp buffer.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {GPUCommandEncoder} encoder - The command encoder.\n\t */\n\tprepareTimestampBuffer( renderContext, encoder ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\n\t\tconst size = 2 * BigInt64Array.BYTES_PER_ELEMENT;\n\n\t\tif ( renderContextData.currentTimestampQueryBuffers === undefined ) {\n\n\t\t\trenderContextData.currentTimestampQueryBuffers = {\n\t\t\t\tresolveBuffer: this.device.createBuffer( {\n\t\t\t\t\tlabel: 'timestamp resolve buffer',\n\t\t\t\t\tsize: size,\n\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n\t\t\t\t} ),\n\t\t\t\tresultBuffer: this.device.createBuffer( {\n\t\t\t\t\tlabel: 'timestamp result buffer',\n\t\t\t\t\tsize: size,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n\t\t\t\t} )\n\t\t\t};\n\n\t\t}\n\n\t\tconst { resolveBuffer, resultBuffer } = renderContextData.currentTimestampQueryBuffers;\n\n\n\t\tencoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );\n\n\t\tif ( resultBuffer.mapState === 'unmapped' ) {\n\n\t\t\tencoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resolves the time stamp for the given render context and type.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {String} type - The render context.\n\t * @return {Promise} A Promise that resolves when the time stamp has been computed.\n\t */\n\tasync resolveTimestampAsync( renderContext, type = 'render' ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tif ( renderContextData.currentTimestampQueryBuffers === undefined ) return;\n\n\t\tconst { resultBuffer } = renderContextData.currentTimestampQueryBuffers;\n\n\t\tif ( resultBuffer.mapState === 'unmapped' ) {\n\n\t\t\tresultBuffer.mapAsync( GPUMapMode.READ ).then( () => {\n\n\t\t\t\tconst times = new BigUint64Array( resultBuffer.getMappedRange() );\n\t\t\t\tconst duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;\n\n\n\t\t\t\tthis.renderer.info.updateTimestamp( type, duration );\n\n\t\t\t\tresultBuffer.unmap();\n\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {WGSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage + ( program.name !== '' ? `_${ program.name }` : '' ) } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject, promises );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\t/**\n\t * Prepares the state for encoding render bundles.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginBundle( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData._currentPass = renderContextData.currentPass;\n\t\trenderContextData._currentSets = renderContextData.currentSets;\n\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );\n\n\t}\n\n\t/**\n\t * After processing render bundles this method finalizes related work.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle.\n\t */\n\tfinishBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst bundleEncoder = renderContextData.currentPass;\n\t\tconst bundleGPU = bundleEncoder.finish();\n\n\t\tthis.get( bundle ).bundleGPU = bundleGPU;\n\n\t\t// restore render pass state\n\n\t\trenderContextData.currentSets = renderContextData._currentSets;\n\t\trenderContextData.currentPass = renderContextData._currentPass;\n\n\t}\n\n\t/**\n\t * Adds a render bundle to the render context data.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle to add.\n\t */\n\taddBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData.renderBundles.push( this.get( bundle ).bundleGPU );\n\n\t}\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {Number} cacheIndex - The cache index.\n\t * @param {Number} version - The version.\n\t */\n\tupdateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the buffer of an indirect storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateIndirectStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Updates the buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\t/**\n\t * Triggers an update of the default render pass descriptor.\n\t */\n\tupdateSize() {\n\n\t\tthis.colorBuffer = this.textureUtils.getColorBuffer();\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t}\n\n\t// utils public\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {Number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn 16;\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {String} name - The feature's name.\n\t * @return {Boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\treturn this.device.features.has( name );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.\n\t * @param {Number} [level=0] - The mip level to copy.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {\n\n\t\tlet dstX = 0;\n\t\tlet dstY = 0;\n\t\tlet dstLayer = 0;\n\n\t\tlet srcX = 0;\n\t\tlet srcY = 0;\n\t\tlet srcLayer = 0;\n\n\t\tlet srcWidth = srcTexture.image.width;\n\t\tlet srcHeight = srcTexture.image.height;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\tsrcX = srcRegion.x;\n\t\t\tsrcY = srcRegion.y;\n\t\t\tsrcLayer = srcRegion.z || 0;\n\t\t\tsrcWidth = srcRegion.width;\n\t\t\tsrcHeight = srcRegion.height;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstLayer = dstPosition.z || 0;\n\n\t\t}\n\n\t\tconst encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );\n\n\t\tconst sourceGPU = this.get( srcTexture ).texture;\n\t\tconst destinationGPU = this.get( dstTexture ).texture;\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: srcX, y: srcY, z: srcLayer }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU,\n\t\t\t\tmipLevel: level,\n\t\t\t\torigin: { x: dstX, y: dstY, z: dstLayer }\n\t\t\t},\n\t\t\t[\n\t\t\t\tsrcWidth,\n\t\t\t\tsrcHeight,\n\t\t\t\t1\n\t\t\t]\n\t\t);\n\n\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( renderContext.renderTarget ) {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.get( renderContext.depthTexture ).texture;\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.get( renderContext.textures[ 0 ] ).texture;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\tif ( sourceGPU.format !== destinationGPU.format ) {\n\n\t\t\tconsole.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet encoder;\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\trenderContextData.currentPass.end();\n\n\t\t\tencoder = renderContextData.encoder;\n\n\t\t} else {\n\n\t\t\tencoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );\n\n\t\t}\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: [ rectangle.x, rectangle.y, 0 ],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\trectangle.z,\n\t\t\t\trectangle.w\n\t\t\t]\n\t\t);\n\n\t\tif ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\tconst { descriptor } = renderContextData;\n\n\t\t\tfor ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {\n\n\t\t\t\tdescriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\trenderContextData.currentPass.setScissorRect( x, y, width, height );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\t}\n\n\t}\n\n}\n\nclass IESSpotLight extends SpotLight {\n\n\tconstructor( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tsuper( color, intensity, distance, angle, penumbra, decay );\n\n\t\tthis.iesMap = null;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesMap = source.iesMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * This version of a node library represents the standard version\n * used in {@link WebGPURenderer}. It maps lights, tone mapping\n * techniques and materials to node-based implementations.\n *\n * @private\n * @augments NodeLibrary\n */\nclass StandardNodeLibrary extends NodeLibrary {\n\n\t/**\n\t * Constructs a new standard node library.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );\n\t\tthis.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );\n\t\tthis.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );\n\t\tthis.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );\n\t\tthis.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );\n\t\tthis.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );\n\t\tthis.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );\n\t\tthis.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );\n\t\tthis.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );\n\t\tthis.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );\n\t\tthis.addMaterial( PointsNodeMaterial, 'PointsMaterial' );\n\t\tthis.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );\n\t\tthis.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );\n\n\t\tthis.addLight( PointLightNode, PointLight );\n\t\tthis.addLight( DirectionalLightNode, DirectionalLight );\n\t\tthis.addLight( RectAreaLightNode, RectAreaLight );\n\t\tthis.addLight( SpotLightNode, SpotLight );\n\t\tthis.addLight( AmbientLightNode, AmbientLight );\n\t\tthis.addLight( HemisphereLightNode, HemisphereLight );\n\t\tthis.addLight( LightProbeNode, LightProbe );\n\t\tthis.addLight( IESSpotLightNode, IESSpotLight );\n\n\t\tthis.addToneMapping( linearToneMapping, LinearToneMapping );\n\t\tthis.addToneMapping( reinhardToneMapping, ReinhardToneMapping );\n\t\tthis.addToneMapping( cineonToneMapping, CineonToneMapping );\n\t\tthis.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );\n\t\tthis.addToneMapping( agxToneMapping, AgXToneMapping );\n\t\tthis.addToneMapping( neutralToneMapping, NeutralToneMapping );\n\n\t}\n\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\n\n/**\n * This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability\n * to target different backends. By default, the renderer tries to use a WebGPU backend if the\n * browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.\n *\n * @augments module:Renderer~Renderer\n */\nclass WebGPURenderer extends Renderer {\n\n\t/**\n\t * Constructs a new WebGPU renderer.\n\t *\n\t * @param {Object} parameters - The configuration parameter.\n\t * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0\n\t * to overwrite the default.\n\t * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it\n\t * WebGL 2 backend no matter if WebGPU is supported or not.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tlet BackendClass;\n\n\t\tif ( parameters.forceWebGL ) {\n\n\t\t\tBackendClass = WebGLBackend;\n\n\t\t} else {\n\n\t\t\tBackendClass = WebGPUBackend;\n\n\t\t\tparameters.getFallback = () => {\n\n\t\t\t\tconsole.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );\n\n\t\t\t\treturn new WebGLBackend( parameters );\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst backend = new BackendClass( parameters );\n\n\t\t//super( new Proxy( backend, debugHandler ) );\n\t\tsuper( backend, parameters );\n\n\t\t/**\n\t\t * The generic default value is overwritten with the\n\t\t * standard node library for type mapping.\n\t\t *\n\t\t * @type {StandardNodeLibrary}\n\t\t */\n\t\tthis.library = new StandardNodeLibrary();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPURenderer = true;\n\n\t}\n\n}\n\n/**\n * A specialized group which eanbles applications access to the\n * Render Bundle API of WebGPU. The group with all its descendant nodes\n * are considered as one render bundle and processed as such by\n * the renderer.\n *\n * This module is only fully supported by `WebGPURenderer` with a WebGPU backend.\n * With a WebGL backend, the group can technically be rendered but without\n * any performance improvements.\n *\n * @augments Group\n */\nclass BundleGroup extends Group {\n\n\t/**\n\t * Constructs a new bundle group.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBundleGroup = true;\n\n\t\t/**\n\t\t * This property is only relevant for detecting types\n\t\t * during serialization/deserialization. It should always\n\t\t * match the class name.\n\t\t *\n\t\t * @type {String}\n\t\t * @readonly\n\t\t * @default 'BundleGroup'\n\t\t */\n\t\tthis.type = 'BundleGroup';\n\n\t\t/**\n\t\t * Whether the bundle is static or not. When set to `true`, the structure\n\t\t * is assumed to be static and does not change. E.g. no new objects are\n\t\t * added to the group\n\t\t *\n\t\t * If a change is required, an update can still be forced by setting the\n\t\t * `needsUpdate` flag to `true`.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.static = true;\n\n\t\t/**\n\t\t * The bundle group's version.\n\t\t *\n\t\t * @type {Number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the bundle group has changed.\n\t *\n\t * @type {Boolean}\n\t * @default false\n\t * @param {Boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nconst _material = /*@__PURE__*/ new NodeMaterial();\nconst _quadMesh = /*@__PURE__*/ new QuadMesh( _material );\n\n/**\n * This module is responsible to manage the post processing setups in apps.\n * You usually create a single instance of this class and use it to define\n * the output of your post processing effect chain.\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n */\nclass PostProcessing {\n\n\t/**\n\t * Constructs a new post processing management module.\n\t *\n\t * @param {Renderer} renderer - A reference to the renderer.\n\t * @param {Node<vec4>} outputNode - An optional output node.\n\t */\n\tconstructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A node which defines the final output of the post\n\t\t * processing. This is usually the last node in a chain\n\t\t * of effect nodes.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * Whether the default output tone mapping and color\n\t\t * space transformation should be enabled or not.\n\t\t *\n\t\t * It is enabled by default by it must be disabled when\n\t\t * effects must be executed after tone mapping and color\n\t\t * space conversion. A typical example is FXAA which\n\t\t * requires sRGB input.\n\t\t *\n\t\t * When set to `false`, the app must control the output\n\t\t * transformation with `RenderOutputNode`.\n\t\t *\n\t\t * ```js\n\t\t * const outputPass = renderOutput( scenePass );\n\t\t * ```\n\t\t *\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.outputColorTransform = true;\n\n\t\t/**\n\t\t * Must be set to `true` when the output node changes.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.needsUpdate = true;\n\n\t\t_material.name = 'PostProcessing';\n\n\t}\n\n\t/**\n\t * When `PostProcessing` is used to apply post processing effects,\n\t * the application must use this version of `render()` inside\n\t * its animation loop (not the one from the renderer).\n\t */\n\trender() {\n\n\t\tthis._update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\t_quadMesh.render( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n\t/**\n\t * Updates the state of the module.\n\t *\n\t * @private\n\t */\n\t_update() {\n\n\t\tif ( this.needsUpdate === true ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\t\t_quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput( this.outputNode, toneMapping, outputColorSpace ) : this.outputNode.context( { toneMapping, outputColorSpace } );\n\t\t\t_quadMesh.material.needsUpdate = true;\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * When `PostProcessing` is used to apply post processing effects,\n\t * the application must use this version of `renderAsync()` inside\n\t * its animation loop (not the one from the renderer).\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync() {\n\n\t\tthis._update();\n\n\t\tconst renderer = this.renderer;\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = LinearSRGBColorSpace;\n\n\t\t//\n\n\t\tawait _quadMesh.renderAsync( renderer );\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t}\n\n}\n\n/**\n * This special type of texture is intended for compute shaders.\n * It can be used to compute the data of a texture with a compute shader.\n *\n * Note: This type of texture can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments Texture\n */\nclass StorageTexture extends Texture {\n\n\t/**\n\t * Constructs a new storage texture.\n\t *\n\t * @param {Number} [width=1] - The storage texture's width.\n\t * @param {Number} [height=1] - The storage texture's height.\n\t */\n\tconstructor( width = 1, height = 1 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The image object which just represents the texture's dimension.\n\t\t *\n\t\t * @type {{width: Number, height:Number}}\n\t\t */\n\t\tthis.image = { width, height };\n\n\t\t/**\n\t\t * The default `magFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.magFilter = LinearFilter;\n\n\t\t/**\n\t\t * The default `minFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.minFilter = LinearFilter;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTexture = true;\n\n\t}\n\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * It can be used to encode draw parameters for indirect draw calls.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments StorageBufferAttribute\n */\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n\n\t/**\n\t * Constructs a new storage buffer attribute.\n\t *\n\t * @param {Number|Uint32Array} count - The item count. It is also valid to pass a `Uint32Array` as an argument.\n\t * The subsequent parameter is then obsolete.\n\t * @param {Number} itemSize - The item size.\n\t */\n\tconstructor( count, itemSize ) {\n\n\t\tsuper( count, itemSize, Uint32Array );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndirectStorageBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * A loader for loading node objects in the three.js JSON Object/Scene format.\n *\n * @augments Loader\n */\nclass NodeLoader extends Loader {\n\n\t/**\n\t * Constructs a new node loader.\n\t *\n\t * @param {LoadingManager?} manager - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of textures.\n\t\t *\n\t\t * @type {Object<String,Texture>}\n\t\t */\n\t\tthis.textures = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<String,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t}\n\n\t/**\n\t * Loads the node definitions from the given URL.\n\t *\n\t * @param {String} url - The path/URL of the file to be loaded.\n\t * @param {Function} onLoad - Will be called when load completes.\n\t * @param {Function} onProgress - Will be called while load progresses.\n\t * @param {Function} onError - Will be called when errors are thrown during the loading process.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( text ) => {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( this.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parse the node dependencies for the loaded node.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {Object<String,Node>} A dictionary with node dependencies.\n\t */\n\tparseNodes( json ) {\n\n\t\tconst nodes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tconst { uuid, type } = nodeJSON;\n\n\t\t\t\tnodes[ uuid ] = this.createNodeFromType( type );\n\t\t\t\tnodes[ uuid ].uuid = uuid;\n\n\t\t\t}\n\n\t\t\tconst meta = { nodes, textures: this.textures };\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tnodeJSON.meta = meta;\n\n\t\t\t\tconst node = nodes[ nodeJSON.uuid ];\n\t\t\t\tnode.deserialize( nodeJSON );\n\n\t\t\t\tdelete nodeJSON.meta;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n\t/**\n\t * Parses the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {Node} The parsed node.\n\t */\n\tparse( json ) {\n\n\t\tconst node = this.createNodeFromType( json.type );\n\t\tnode.uuid = json.uuid;\n\n\t\tconst nodes = this.parseNodes( json.nodes );\n\t\tconst meta = { nodes, textures: this.textures };\n\n\t\tjson.meta = meta;\n\n\t\tnode.deserialize( json );\n\n\t\tdelete json.meta;\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of textures.\n\t *\n\t * @param {Object<String,Texture>} value - The texture library defines as `<uuid,texture>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a node object from the given type.\n\t *\n\t * @param {String} type - The node type.\n\t * @return {Node} The created node instance.\n\t */\n\tcreateNodeFromType( type ) {\n\n\t\tif ( this.nodes[ type ] === undefined ) {\n\n\t\t\tconsole.error( 'THREE.NodeLoader: Node type not found:', type );\n\t\t\treturn float();\n\n\t\t}\n\n\t\treturn nodeObject( new this.nodes[ type ]() );\n\n\t}\n\n}\n\n/**\n * A special type of material loader for loading node materials.\n *\n * @augments MaterialLoader\n */\nclass NodeMaterialLoader extends MaterialLoader {\n\n\t/**\n\t * Constructs a new node material loader.\n\t *\n\t * @param {LoadingManager?} manager - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<String,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node material types.\n\t\t *\n\t\t * @type {Object<String,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.nodeMaterials = {};\n\n\t}\n\n\t/**\n\t * Parses the node material from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {NodeMaterial}. The parsed material.\n\t */\n\tparse( json ) {\n\n\t\tconst material = super.parse( json );\n\n\t\tconst nodes = this.nodes;\n\t\tconst inputNodes = json.inputNodes;\n\n\t\tfor ( const property in inputNodes ) {\n\n\t\t\tconst uuid = inputNodes[ property ];\n\n\t\t\tmaterial[ property ] = nodes[ uuid ];\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node material types.\n\t *\n\t * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a node material from the given type.\n\t *\n\t * @param {String} type - The node material type.\n\t * @return {Node} The created node material instance.\n\t */\n\tcreateMaterialFromType( type ) {\n\n\t\tconst materialClass = this.nodeMaterials[ type ];\n\n\t\tif ( materialClass !== undefined ) {\n\n\t\t\treturn new materialClass();\n\n\t\t}\n\n\t\treturn super.createMaterialFromType( type );\n\n\t}\n\n}\n\n/**\n * A special type of object loader for loading 3D objects using\n * node materials.\n *\n * @augments ObjectLoader\n */\nclass NodeObjectLoader extends ObjectLoader {\n\n\t/**\n\t * Constructs a new node object loader.\n\t *\n\t * @param {LoadingManager?} manager - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<String,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node material types.\n\t\t *\n\t\t * @type {Object<String,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.nodeMaterials = {};\n\n\t\t/**\n\t\t * A reference for holdng the `nodes` JSON property.\n\t\t *\n\t\t * @private\n\t\t * @type {Object?}\n\t\t */\n\t\tthis._nodesJSON = null;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node material types.\n\t *\n\t * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Function} onLoad - The onLoad callback function.\n\t * @return {Object3D}. The parsed 3D object.\n\t */\n\tparse( json, onLoad ) {\n\n\t\tthis._nodesJSON = json.nodes;\n\n\t\tconst data = super.parse( json, onLoad );\n\n\t\tthis._nodesJSON = null; // dispose\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON and textures.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Object<String,Texture>} textures - The texture library.\n\t * @return {Object<String,Node>}. The parsed nodes.\n\t */\n\tparseNodes( json, textures ) {\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new NodeLoader();\n\t\t\tloader.setNodes( this.nodes );\n\t\t\tloader.setTextures( textures );\n\n\t\t\treturn loader.parseNodes( json );\n\n\t\t}\n\n\t\treturn {};\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON and textures.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Object<String,Texture>} textures - The texture library.\n\t * @return {Object<String,NodeMaterial>}. The parsed materials.\n\t */\n\tparseMaterials( json, textures ) {\n\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst nodes = this.parseNodes( this._nodesJSON, textures );\n\n\t\t\tconst loader = new NodeMaterialLoader();\n\t\t\tloader.setTextures( textures );\n\t\t\tloader.setNodes( nodes );\n\t\t\tloader.setNodeMaterials( this.nodeMaterials );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n}\n\n/**\n * In earlier three.js versions, clipping was defined globally\n * on the renderer or on material level. This special version of\n * `THREE.Group` allows to encode the clipping state into the scene\n * graph. Meaning if you create an instance of this group, all\n * descendant 3D objects will be affected by the respective clipping\n * planes.\n *\n * Note: `ClippingGroup` can only be used with `WebGPURenderer`.\n *\n * @augments Group\n */\nclass ClippingGroup extends Group {\n\n\t/**\n\t * Constructs a new clipping group.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isClippingGroup = true;\n\n\t\t/**\n\t\t * An array with clipping planes.\n\t\t *\n\t\t * @type {Array<Plane>}\n\t\t */\n\t\tthis.clippingPlanes = [];\n\n\t\t/**\n\t\t * Whether clipping should be enabled or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipIntersection = false;\n\n\t\t/**\n\t\t * Whether shadows should be clipped or not.\n\t\t *\n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipShadows = false;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RendererUtils, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowBaseNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };\n"],"names":["refreshUniforms","NodeMaterialObserver","constructor","builder","this","renderObjects","WeakMap","hasNode","containsNode","hasAnimation","object","isSkinnedMesh","renderId","firstInitialization","renderObject","has","getRenderObjectData","data","get","undefined","geometry","material","getMaterialData","attributes","getAttributesData","indexVersion","index","version","drawRange","start","count","worldMatrix","matrixWorld","clone","center","morphTargetInfluences","slice","bundle","transmission","width","height","context","bufferWidth","bufferHeight","set","attributesData","name","attribute","property","isNode","renderer","nodes","modelViewMatrix","modelNormalViewMatrix","value","isTexture","id","equals","renderObjectData","copy","materialData","mtlValue","storedGeometryData","storedAttributes","storedAttributeNames","Object","keys","currentAttributeNames","length","storedAttributeData","storedIndexVersion","currentIndexVersion","morphChanged","i","needsRefresh","nodeFrame","isStatic","static","isBundle","cyrb53","seed","h1","h2","Array","val","Math","imul","ch","charCodeAt","hashString","str","hashArray","array","hash$1","params","getCacheKey$1","force","values","push","getSelf","childNode","getNodeChildren","getCacheKey","node","toJSON","startsWith","isArray","child","subProperty","typeFromLength","Map","dataFromObject","getTypeFromLength","getValueType","typeOf","isVector2","isVector3","isVector4","isMatrix3","isMatrix4","isColor","ArrayBuffer","getValueFromType","type","last4","base64ToArrayBuffer","getDataFromObject","arrayBufferToBase64","arrayBuffer","chars","Uint8Array","String","fromCharCode","btoa","base64","from","atob","c","buffer","NodeShaderStage","VERTEX","FRAGMENT","NodeUpdateType","NONE","FRAME","RENDER","OBJECT","NodeAccess","READ_ONLY","WRITE_ONLY","READ_WRITE","defaultShaderStages","defaultBuildStages","shaderStages","vectorComponents","_nodeId","Node","nodeType","super","updateType","updateBeforeType","updateAfterType","uuid","generateUUID","global","_cacheKey","_cacheKeyVersion","defineProperty","needsUpdate","onUpdate","callback","update","bind","onFrameUpdate","onRenderUpdate","onObjectUpdate","onReference","updateReference","self","isGlobal","getChildren","dispose","dispatchEvent","traverse","customCacheKey","getScope","getHash","getUpdateType","getUpdateBeforeType","getUpdateAfterType","getElementType","getNodeType","nodeProperties","getNodeProperties","outputNode","getShared","hash","getNodeFromHash","setup","analyze","increaseUsage","build","generate","output","updateBefore","console","warn","updateAfter","refNode","addNode","addChain","result","buildStage","getBuildStage","properties","initialized","isNodeOutput","nodeData","getDataFromNode","snippet","flowCodes","nodeBlock","addFlowCodeHierarchy","format","removeChain","addSequentialNode","getSerializeChildren","serialize","json","nodeChildren","inputNodes","Number","isInteger","meta","deserialize","inputArray","inputObject","isRoot","textures","images","extractFromCache","cache","key","metadata","generator","ArrayElementNode","indexNode","isArrayElementNode","ConvertNode","convertTo","requestType","overloadingType","split","getTypeLength","TempNode","isTempNode","hasDependencies","usageCount","getVectorType","propertyName","nodeVar","getVarFromNode","getPropertyName","addLineFlowCode","JoinNode","reduce","cur","primitiveType","getComponentType","snippetValues","input","inputSnippet","inputPrimitiveType","getType","join","_stringVectorComponents","SplitNode","components","isSplitNode","getVectorLength","vectorLength","max","indexOf","nodeTypeLength","nodeSnippet","SetNode","sourceNode","targetNode","sourceType","componentType","targetType","targetSnippet","sourceSnippet","component","FlipNode","sourceCache","sourceProperty","componentIndex","InputNode","isInputNode","precision","getInputType","setPrecision","toArray","valueType","fromArray","ConstNode","isConstNode","generateConst","currentStack","NodeElements","addMethodChaining","nodeElement","Error","parseSwizzle","props","replace","parseSwizzleAndSort","sort","shaderNodeHandler","NodeClosure","inputs","shift","nodeObjects","prop","nodeObj","isStackNode","assign","add","endsWith","test","nodeObject","toLowerCase","Reflect","nodeObjectsCacheMap","nodeBuilderFunctionsCacheMap","ShaderNodeObjects","objects","altType","ShaderNodeArray","len","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","nodeArray","ShaderNodeImmutable","ShaderCallNodeInternal","shaderNode","getOutputNode","call","onceOutput","layout","functionNodesCacheMap","functionNode","buildFunctionNode","currentFunctionNode","includes","jsFunc","once","setupOutput","addStack","stack","removeStack","ShaderNodeInternal","setLayout","bools","uints","ints","floats","PI","boolsCacheMap","bool","uintsCacheMap","uint","intsCacheMap","map","el","int","floatsCacheMap","float","cacheMaps","constNodesCacheMap","getConstNode","ConvertType","cacheMap","every","param","_","safeGetNodeType","defined","v","getConstNodeType","ShaderNode","Proxy","obj","Fn","ShaderNodeObject","nodeProxy","nodeImmutable","fn","setCurrentStack","getCurrentStack","If","append","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat2","mat3","mat4","element","convert","types","UniformGroupNode","shared","order","isUniformGroup","uniformGroup","sharedUniformGroup","frameGroup","renderGroup","objectGroup","UniformNode","isUniformNode","groupNode","label","setGroup","group","getGroup","getUniformHash","frame","sharedNode","setHashNode","sharedNodeType","nodeUniform","getUniformFromNode","shaderStage","uniform","arg1","arg2","PropertyNode","varying","isPropertyNode","getVaryingFromNode","needsInterpolation","varyingProperty","diffuseColor","emissive","roughness","metalness","clearcoat","clearcoatRoughness","sheen","sheenRoughness","iridescence","iridescenceIOR","iridescenceThickness","alphaT","anisotropy","anisotropyT","anisotropyB","specularColor","specularF90","shininess","dashSize","gapSize","ior","thickness","attenuationDistance","attenuationColor","dispersion","AssignNode","needsSplitAssign","isAvailable","targetLength","target","source","sourceVar","targetRoot","FunctionCallNode","parameters","setParameters","getParameters","getInputs","generateInput","inputNode","func","OperatorNode","op","aNode","bNode","finalOp","typeA","typeB","getIntegerType","typeLength","isMatrix","isVector","getVectorFromMatrix","changeComponentType","a","b","outputLength","fnOpSnippet","getFunctionOperator","useComparisonMethod","getMethod","sub","mul","div","modInt","equal","notEqual","lessThan","greaterThan","lessThanEqual","greaterThanEqual","and","or","not","xor","bitAnd","bitNot","bitOr","bitXor","shiftLeft","shiftRight","remainder","MathNode","method","cNode","aType","bType","cType","aLen","bLen","cLen","LENGTH","DISTANCE","DOT","CROSS","ALL","EQUALS","MOD","inputType","coordinateSystem","TRANSFORM_DIRECTION","tA","tB","mulNode","xyz","normalize","NEGATE","ONE_MINUS","RECIPROCAL","DIFFERENCE","abs","STEP","MIN","MAX","REFRACT","MIX","ATAN","ANY","RADIANS","DEGREES","EXP","EXP2","LOG","LOG2","SQRT","INVERSE_SQRT","FLOOR","CEIL","NORMALIZE","FRACT","SIN","COS","TAN","ASIN","ACOS","ABS","SIGN","DFDX","DFDY","ROUND","TRUNC","FWIDTH","TRANSPOSE","BITCAST","REFLECT","POW","CLAMP","SMOOTHSTEP","FACEFORWARD","EPSILON","all","any","radians","degrees","exp","exp2","log","log2","sqrt","inverseSqrt","floor","ceil","fract","sin","cos","tan","asin","acos","atan","sign","negate","oneMinus","dFdx","dFdy","round","reciprocal","trunc","fwidth","transpose","min$1","max$1","mod","step","reflect","distance","difference","dot","cross","pow","pow2","pow3","pow4","transformDirection","cbrt","lengthSq","mix","clamp","low","high","saturate","refract","smoothstep","faceForward","rand","uv","dt","xy","sn","mixElement","t","e1","e2","smoothstepElement","x","atan2","y","ConditionalNode","condNode","ifNode","elseNode","ifType","elseType","currentNodeBlock","parentNodeBlock","nodeProperty","needsOutput","addFlowCode","tab","addFlowTab","ifSnippet","removeFlowTab","elseSnippet","select","cond","ContextNode","isContextNode","previousContext","getContext","setContext","VarNode","isVarNode","createVar","temp","VaryingNode","isVaryingNode","setupVarying","needsReassign","reassignPosition","needsPositionReassign","flowNodeFromShaderStage","isPositionNodeInput","vertexStage","sRGBTransferEOTF","sRGBTransferOETF","WORKING_COLOR_SPACE","OUTPUT_COLOR_SPACE","ColorSpaceNode","colorNode","resolveColorSpace","colorSpace","workingColorSpace","outputColorSpace","enabled","getTransfer","rgb","getPrimaries","_getMatrix","toOutputColorSpace","toWorkingColorSpace","workingToColorSpace","colorSpaceToWorking","ReferenceElementNode$1","referenceNode","isReferenceElementNode","uniformType","arrayType","elementType","ReferenceBaseNode","reference","setNodeType","updateValue","getValueFromReference","state","RendererReferenceNode","rendererReference","ToneMappingNode","toneMapping","exposureNode","toneMappingExposure","toneMappingFn","library","getToneMappingFunction","error","mapping","exposure","BufferAttributeNode","bufferType","bufferStride","bufferOffset","isBufferNode","usage","instanced","isBufferAttribute","isInstancedBufferAttribute","bufferData","globalCache","getData","setData","getTypeFromAttribute","itemSize","stride","offset","isInterleavedBuffer","bufferAttribute","setUsage","nodeAttribute","getBufferAttributeFromNode","setInstanced","dynamicBufferAttribute","instancedBufferAttribute","instancedDynamicBufferAttribute","bufferNode","ComputeNode","computeNode","workgroupSize","isComputeNode","dispatchCount","onInitFunction","updateDispatchCount","size","onInit","compute","CacheNode","parent","isCacheNode","previousCache","getCache","getCacheFromNode","setCache","BypassNode","callNode","isBypassNode","bypass","RemapNode","inLowNode","inHighNode","outLowNode","outHighNode","doClamp","remap","remapClamp","ExpressionNode","expression","Discard","conditional","RenderOutputNode","isRenderOutputNode","renderOutput","AttributeNode","attributeName","_attributeName","getAttributeName","hasGeometryAttribute","getAttribute","setAttributeName","attributeType","TextureSizeNode","textureNode","levelNode","isTextureSizeNode","textureProperty","level","textureSize","MaxMipLevelNode","_textureNode","texture","image","maxMipLevel","TextureNode","uvNode","biasNode","isTextureNode","compareNode","depthNode","gradNode","sampler","updateMatrix","_value","_matrixUniform","setUpdateMatrix","isDepthTexture","getDefaultUV","channel","getTransformedUV","matrix","setupUV","isFlipY","ImageBitmap","flipY","isRenderTargetTexture","isFramebufferTexture","setY","forceUVContext","getUV","getTextureLevel","generateUV","generateSnippet","uvSnippet","levelSnippet","biasSnippet","depthSnippet","compareSnippet","gradSnippet","generateTextureLevel","generateTextureBias","generateTextureGrad","generateTextureCompare","generateTextureLoad","generateTexture","isReference","needsToWorkingColorSpace","setSampler","getSampler","sample","blur","amountNode","bias","compare","grad","gradNodeX","gradNodeY","depth","matrixUniform","matrixAutoUpdate","newNode","textureLoad","cameraNear","camera","near","cameraFar","far","cameraProjectionMatrix","projectionMatrix","cameraViewMatrix","matrixWorldInverse","cameraPosition","setFromMatrixPosition","Object3DNode","object3d","_uniformNode","WORLD_MATRIX","POSITION","VIEW_POSITION","DIRECTION","SCALE","uniformNode","setFromMatrixScale","getWorldDirection","applyMatrix4","objectPosition","ModelNode","modelWorldMatrix","modelNormalMatrix","getNormalMatrix","mediumpModelViewMatrix","toVar","positionGeometry","positionLocal","positionPrevious","positionWorld","positionWorldDirection","positionView","setupPositionView","positionViewDirection","FrontFacingNode","isFrontFacingNode","side","getFrontFacing","frontFacing","faceDirection","normalGeometry","normalLocal","hasAttribute","normalFlat","normalView","flatShading","transformNormalToView","normalWorld","transformedNormalView","setupNormal","transformedNormalWorld","transformedClearcoatNormalView","setupClearcoatNormal","transformNormal","normal","m","transformedNormal","materialRefractionRatio","refractionRatio","reflectView","refractView","reflectVector","refractVector","CubeTextureNode","isCubeTextureNode","yz","cubeUV","cubeTexture","BufferNode","bufferCount","UniformArrayElementNode","uniformArrayNode","isArrayBufferElementNode","paddedType","getPaddedType","UniformArrayNode","isArrayBufferNode","charAt","vector","r","g","elements","z","w","Float32Array","paddedElementLength","Int32Array","Uint32Array","uniformArray","ReferenceElementNode","ReferenceNode","referenceBuffer","MaterialReferenceNode","isMaterialReferenceNode","materialReference","tangentGeometry","computeTangents","tangentLocal","tangentView","getBitangent","crossNormalTangent","bitangentView","TBNViewMatrix","transformedBentNormalView","bentNormal","perturbNormal2Arb","eye_pos","surf_norm","mapN","q0","q1","st0","st1","N","q1perp","q0perp","T","B","det","scale","NormalMapNode","scaleNode","normalMapType","normalMap","dHdxy_fwd","bumpScale","sampleTexture","texNode","Hll","perturbNormalArb","surf_pos","dHdxy","vSigmaX","vN","R1","R2","fDet","vGrad","BumpMapNode","bumpMap","_propertyCache","MaterialNode","getFloat","getColor","getTexture","COLOR","OPACITY","opacityNode","alphaMap","SPECULAR_STRENGTH","specularMap","SPECULAR_INTENSITY","specularIntensityNode","specularIntensityMap","SPECULAR_COLOR","specularColorNode","specularColorMap","ROUGHNESS","roughnessNode","roughnessMap","METALNESS","metalnessNode","metalnessMap","EMISSIVE","emissiveIntensityNode","emissiveNode","emissiveMap","NORMAL","CLEARCOAT","clearcoatNode","clearcoatMap","CLEARCOAT_ROUGHNESS","clearcoatRoughnessNode","clearcoatRoughnessMap","CLEARCOAT_NORMAL","clearcoatNormalMap","SHEEN","sheenNode","sheenColorMap","SHEEN_ROUGHNESS","sheenRoughnessNode","sheenRoughnessMap","ANISOTROPY","anisotropyMap","anisotropyPolar","materialAnisotropyVector","rg","IRIDESCENCE_THICKNESS","iridescenceThicknessMaximum","iridescenceThicknessRange","iridescenceThicknessMap","iridescenceThicknessMinimum","TRANSMISSION","transmissionNode","transmissionMap","THICKNESS","thicknessNode","thicknessMap","IOR","LIGHT_MAP","AO","outputType","ALPHA_TEST","SHININESS","SPECULAR","REFLECTIVITY","ROTATION","IRIDESCENCE","IRIDESCENCE_IOR","ATTENUATION_DISTANCE","ATTENUATION_COLOR","LINE_SCALE","LINE_DASH_SIZE","LINE_GAP_SIZE","LINE_WIDTH","LINE_DASH_OFFSET","POINT_WIDTH","DISPERSION","materialAlphaTest","materialColor","materialShininess","materialEmissive","materialOpacity","materialSpecular","materialSpecularIntensity","materialSpecularColor","materialSpecularStrength","materialReflectivity","materialRoughness","materialMetalness","materialNormal","materialClearcoat","materialClearcoatRoughness","materialClearcoatNormal","materialRotation","materialSheen","materialSheenRoughness","materialAnisotropy","materialIridescence","materialIridescenceIOR","materialIridescenceThickness","materialTransmission","materialThickness","materialIOR","materialAttenuationDistance","materialAttenuationColor","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineDashOffset","materialDispersion","materialLightMap","materialAO","anisotropyRotation","modelViewProjection","setupModelViewProjection","IndexNode","isIndexNode","getVertexIndex","INSTANCE","getInstanceIndex","DRAW","getDrawIndex","INVOCATION_LOCAL","getInvocationLocalIndex","INVOCATION_SUBGROUP","getInvocationSubgroupIndex","SUBGROUP","getSubgroupIndex","vertexIndex","instanceIndex","drawIndex","InstanceNode","instanceMatrix","instanceColor","instanceMatrixNode","instanceColorNode","bufferColor","bufferFn","instanceBuffers","instancePosition","instanceNormal","InstancedMeshNode","instancedMesh","BatchNode","batchMesh","batchingIdNode","getIndirectIndex","_indirectTexture","indirectId","matricesTexture","_matricesTexture","j","toInt","batchingMatrix","colorsTexture","_colorsTexture","getBatchingColor","bm","batchingNormal","mulAssign","batch","_frameId","SkinningNode","skinnedMesh","useReference","bindMatrixNode","bindMatrixInverseNode","boneMatricesNode","skinIndexNode","skinWeightNode","skeleton","bones","bindMatrix","bindMatrixInverse","boneMatrices","previousBoneMatricesNode","getSkinnedPosition","position","boneMatX","boneMatY","boneMatZ","boneMatW","skinVertex","skinned","getSkinnedNormal","skinMatrix","getPreviousSkinnedPosition","previousBoneMatrices","needsPreviousBoneMatrices","mrt","getMRT","useVelocity","skinPosition","skinNormal","frameId","skinningReference","LoopNode","getVarName","getProperties","stackNode","l","returnsNode","end","condition","internalParam","startSnippet","endSnippet","declarationSnippet","conditionalSnippet","updateSnippet","getVar","forSnippet","stackSnippet","returnsSnippet","Loop","Break","_morphTextures","_morphVec4","getMorph","bufferMap","influence","texelIndex","MorphNode","mesh","morphBaseInfluence","hasMorphPosition","morphAttributes","hasMorphNormals","morphAttribute","morphTargetsCount","hasMorphColors","entry","morphTargets","morphNormals","morphColors","vertexDataCount","maxTextureSize","bufferTexture","vertexDataStride","morphTarget","morphNormal","morphColor","fromBufferAttribute","disposeTexture","delete","removeEventListener","addEventListener","getEntry","morphTexture","addAssign","morphTargetsRelative","morphReference","LightingNode","isLightingNode","AONode","aoNode","ambientOcclusion","LightingContextNode","lightingModel","backdropNode","backdropAlphaNode","reflectedLight","directDiffuse","directSpecular","indirectDiffuse","indirectSpecular","radiance","irradiance","iblIrradiance","backdrop","backdropAlpha","lightingContext","IrradianceNode","screenSizeVec","viewportVec","ScreenNode","isViewportNode","VIEWPORT","SIZE","renderTarget","getRenderTarget","viewport","getViewport","multiplyScalar","getPixelRatio","getDrawingBufferSize","screenCoordinate","screenSize","COORDINATE","coord","getFragCoord","UV","screenUV","_size$4","zw","ViewportTextureNode","framebufferTexture","minFilter","generateMipmaps","isOutputTextureNode","currentGenerateMipmaps","copyFramebufferToTexture","viewportTextureNode","viewportMipTexture","sharedDepthbuffer","ViewportDepthTextureNode","viewportDepthTexture","ViewportDepthNode","valueNode","isViewportDepthNode","DEPTH_BASE","getFragDepth","depthBase","DEPTH","isPerspectiveCamera","viewZToPerspectiveDepth","viewZToOrthographicDepth","LINEAR_DEPTH","viewZ","perspectiveDepthToViewZ","viewZToLogarithmicDepth","numerator","denominator","linearDepth","builtin","isBuiltinNode","ClippingNode","DEFAULT","clippingContext","intersectionPlanes","unionPlanes","hardwareClipping","ALPHA_TO_COVERAGE","setupAlphaToCoverage","HARDWARE","setupHardwareClipping","setupDefault","distanceToPlane","distanceGradient","clipOpacity","numUnionPlanes","clippingPlanes","plane","numIntersectionPlanes","intersectionClipOpacity","discard","clipped","enableHardwareClipping","hw_clip_distances","getClipDistance","hash2D","hash3D","getAlphaHashThreshold","maxDeriv","pixScale","pixScales","alpha","lerpFactor","cases","threshold","NodeMaterial","isNodeMaterial","fog","lights","lightsNode","envNode","normalNode","alphaTestNode","positionNode","geometryNode","shadowPositionNode","receivedShadowNode","castShadowNode","mrtNode","fragmentNode","vertexNode","customProgramCacheKey","setupObserver","setupVertex","resultNode","addFlow","clippingNode","setupClipping","depthWrite","depthTest","depthBuffer","setupDepth","setupDiffuseColor","setupVariants","outgoingLightNode","setupLighting","basicOutput","materialMRT","merge","isOutputStructNode","monitor","samples","alphaToCoverage","candidateCount","logarithmicDepthBuffer","setupPosition","vertex","displacementMap","displacementScale","displacementBias","isBatchedMesh","isInstancedMesh","vertexColors","alphaTest","alphaHash","transparent","blending","setupOutgoingLight","setupEnvironment","envMap","isCubeTexture","setupLightMap","lightMap","setupLights","materialLightsNode","lightMapNode","aoMap","lightsN","lighting","createNode","getLights","setupLightingModel","hasLights","fogNode","setDefaultValues","descriptors","getOwnPropertyDescriptors","prototype","getOwnPropertyDescriptor","_defaultValues$d","LineBasicNodeMaterial","isLineBasicNodeMaterial","setValues","_defaultValues$c","LineDashedNodeMaterial","isLineDashedNodeMaterial","dashOffset","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","vLineDistance","directionToColor","_defaultValues$a","MeshNormalNodeMaterial","isMeshNormalNodeMaterial","EquirectUVNode","dirNode","dir","u","equirectUV","CubeRenderTarget","options","isCubeRenderTarget","fromEquirectangularTexture","texture$1","currentMinFilter","magFilter","scene","currentMRT","setMRT","_cache$1","CubeMapNode","_cubeTexture","_cubeTextureNode","defaultTexture","_defaultTexture","cubeMap","mapTextureMapping","isEquirectangularMapReady$1","onTextureDispose","event","cubeMapNode","BasicEnvironmentNode","environment","BasicLightMapNode","RECIPROCAL_PI","irradianceLightMap","LightingModel","finish","direct","directRectArea","indirect","BasicLightingModel","outgoingLight","combine","_defaultValues$9","MeshBasicNodeMaterial","isMeshBasicNodeMaterial","F_Schlick","f0","f90","dotVH","fresnel","BRDF_Lambert","D_BlinnPhong","dotNH","BRDF_BlinnPhong","lightDirection","halfDir","F","G","D","PhongLightingModel","specular","lightColor","_defaultValues$8","MeshLambertNodeMaterial","isMeshLambertNodeMaterial","_defaultValues$7","MeshPhongNodeMaterial","isMeshPhongNodeMaterial","shininessNode","specularNode","getGeometryRoughness","dxy","getRoughness","geometryRoughness","roughnessFactor","min","V_GGX_SmithCorrelated","dotNL","dotNV","a2","gv","gl","V_GGX_SmithCorrelated_Anisotropic","alphaB","dotTV","dotBV","dotTL","dotBL","qualifier","D_GGX","denom","D_GGX_Anisotropic","dotTH","dotBH","v2","w2","BRDF_GGX","f","USE_IRIDESCENCE","USE_ANISOTROPY","V","DFGApprox","c0","c1","a004","EnvironmentBRDF","fab","Schlick_to_F0","x2","x5","D_Charlie","invAlpha","sin2h","V_Neubelt","BRDF_Sheen","LTC_Uv","LTC_ClippedSphereFormFactor","LTC_EdgeVectorFormFactor","v1","theta_sintheta","LTC_Evaluate","P","mInv","p0","p1","p2","p3","lightNormal","T1","T2","mat","coords0","coords1","coords2","coords3","vectorFormFactor","bC","w0","w1","w3","g0","g1","h0","bicubic","texelSize","lod","uvScaled","iuv","fuv","g0x","g1x","h0x","h1x","h0y","h1y","textureBicubic","lodNode","fLodSize","cLodSize","fLodSizeInv","cLodSizeInv","fSample","cSample","getVolumeTransmissionRay","n","modelMatrix","refractionVector","modelScale","applyIorToRoughness","viewportBackSideTexture","viewportFrontSideTexture","getTransmissionSample","fragCoord","transmissionSample","volumeAttenuation","transmissionDistance","attenuationCoefficient","getIBLVolumeRefraction","viewMatrix","projMatrix","transmittedLight","transmittance","halfSpread","iors","transmissionRay","refractedRayExit","ndcPos","refractionCoords","divAssign","attenuatedColor","transmittanceFactor","XYZ_TO_REC709","IorToFresnel0","transmittedIor","incidentIor","evalIridescence","outsideIOR","eta2","cosTheta1","thinFilmThickness","baseF0","cosTheta2Sq","cosTheta2","R0","R12","T121","phi12","phi21","baseIOR","fresnel0","sqrtF0","Fresnel0ToIor","toVec3","R23","phi23","OPD","phi","R123","r123","Rs","I","Cm","Sm","phase","pos","VAR","evalSensitivity","IBLSheenBRDF","viewDir","r2","clearcoatF0","clearcoatF90","PhysicalLightingModel","clearcoatRadiance","clearcoatSpecularDirect","clearcoatSpecularIndirect","sheenSpecularDirect","sheenSpecularIndirect","iridescenceFresnel","iridescenceF0","dotNVi","computeMultiscattering","singleScatter","multiScatter","FssEss","Ems","Favg","Fms","ccIrradiance","lightPosition","halfWidth","halfHeight","ltc_1","ltc_2","t1","t2","dotNVcc","clearcoatEnv","singleScattering","multiScattering","cosineWeightedIrradiance","totalScattering","diffuse","aoNV","aoExp","Fcc","clearcoatLight","sheenEnergyComp","sheenLight","cubeUV_r0","cubeUV_m0","cubeUV_r1","cubeUV_m1","cubeUV_r4","cubeUV_m4","cubeUV_r5","cubeUV_m5","cubeUV_r6","cubeUV_m6","cubeUV_minMipLevel","cubeUV_minTileSize","getFace","direction","absDirection","face","Else","ElseIf","roughnessToMip","mip","getDirection","uv_immutable","zyx","xzy","xz","textureCubeUV","sampleDir_immutable","roughness_immutable","CUBEUV_TEXEL_WIDTH","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","sampleDir","mipF","mipInt","color0","bilinearCubeUV","color1","direction_immutable","mipInt_immutable","filterInt","faceSize","subAssign","getSample","outputDirection","theta","axis","cosTheta","sampleDirection","latitudinal","poleAxis","weights","dTheta","gl_FragColor","_generator","_cache","_getPMREMFromTexture","cacheTexture","pmremVersion","isCubeMapReady","fromCubemap","isEquirectangularMapReady","fromEquirectangular","PMREMNode","_pmrem","_texture","_width","_height","_maxMip","updateFromTexture","cubeUVSize","imageHeight","maxMip","texelHeight","texelWidth","_generateCubeUVSize","pmrem","isPMREMTexture","createPMREMGenerator","pmremTexture","_envNodeCache","EnvironmentNode","cacheEnvNode","intensity","radianceNormalView","useAnisotropy","createRadianceContext","createIrradianceContext","isolateRadiance","isolateIrradiance","clearcoatRadianceContext","isolateClearcoatRadiance","normalViewNode","reflectVec","normalWorldNode","_defaultValues$6","MeshStandardNodeMaterial","isMeshStandardNodeMaterial","environmentNode","setupSpecular","_defaultValues$5","MeshPhysicalNodeMaterial","isMeshPhysicalNodeMaterial","clearcoatNormalNode","iridescenceNode","iridescenceIORNode","iridescenceThicknessNode","iorNode","attenuationDistanceNode","attenuationColorNode","dispersionNode","anisotropyNode","useClearcoat","useIridescence","useSheen","useTransmission","useDispersion","anisotropyV","getGradientIrradiance","gradientMap","fw","ToonLightingModel","_defaultValues$4","MeshToonNodeMaterial","isMeshToonNodeMaterial","MatcapUVNode","matcapUV","_defaultValues$3","MeshMatcapNodeMaterial","isMeshMatcapNodeMaterial","matcapColor","matcap","_defaultValues$2","PointsNodeMaterial","isPointsNodeMaterial","RotateNode","rotationNode","cosAngle","sinAngle","rotation","rotationXMatrix","rotationYMatrix","rotationZMatrix","rotate","_defaultValues$1","SpriteNodeMaterial","isSpriteNodeMaterial","_useSizeAttenuation","sizeAttenuation","mvPosition","orthoScale","alignedPosition","reference$1","rotatedPosition","ShadowMaskModel","shadowNode","shadowMask","_defaultValues","ShadowNodeMaterial","isShadowNodeMaterial","epsilon","ret","Animation","info","_context","_animationLoop","_requestId","time","requestAnimationFrame","autoReset","reset","stop","cancelAnimationFrame","setAnimationLoop","ChainMap","weakMap","_id$9","RenderObject","geometries","renderContext","_nodes","_geometries","pipeline","vertexBuffers","drawParams","clippingContextCacheKey","cacheKey","initialNodesCacheKey","getDynamicCacheKey","initialCacheKey","_nodeBuilderState","_bindings","_monitor","onDispose","isRenderObject","onMaterialDispose","updateClipping","clippingNeedsUpdate","hardwareClippingPlanes","unionClippingCount","getNodeBuilderState","getForRender","getMonitor","getBindings","createBindings","getIndex","getIndirect","getChainArray","setGeometry","getAttributes","nodeAttributes","Set","isInterleavedBufferAttribute","getVertexBuffers","getDrawParameters","vertexCount","firstVertex","instanceCount","firstInstance","hasIndex","isInstancedBufferGeometry","rangeFactor","wireframe","isPoints","isLineSegments","isLine","isLineLoop","lastVertex","itemCount","Infinity","getGeometryCacheKey","normalized","getMaterialCacheKey","proto","getPrototypeOf","descriptor","getKeys","valueKey","receiveShadow","needsGeometryUpdate","_chainArray","RenderObjects","pipelines","bindings","chainMaps","passId","chainMap","getChainMap","createRenderObject","DataMap","AttributeType","GPU_CHUNK_BYTES","Attributes","backend","attributeData","destroyAttribute","createAttribute","createIndexAttribute","createStorageAttribute","createIndirectStorageAttribute","_getBufferAttribute","updateAttribute","getWireframeVersion","getWireframeIndex","indices","geometryIndex","geometryPosition","arrayNeedsUint32","Geometries","wireframes","attributeCall","updateForRender","initGeometry","updateAttributes","memory","geometryAttributes","geometryAttribute","wireframeAttribute","isStorageBufferAttribute","isStorageInstancedBufferAttribute","callId","render","calls","Info","frameCalls","drawCalls","triangles","points","lines","timestamp","previousFrameCalls","timestampCalls","isMesh","isSprite","updateTimestamp","previousRenderFrameCalls","previousComputeFrameCalls","Pipeline","usedTimes","RenderPipeline","vertexProgram","fragmentProgram","ComputePipeline","computeProgram","isComputePipeline","_id$8","ProgrammableStage","code","stage","transforms","Pipelines","caches","programs","fragment","getForCompute","_needsComputeUpdate","previousPipeline","nodeBuilderState","stageCompute","computeShader","_releaseProgram","createProgram","_getComputeCacheKey","_releasePipeline","_getComputePipeline","promises","_needsRenderUpdate","stageVertex","vertexShader","stageFragment","fragmentShader","_getRenderCacheKey","_getRenderPipeline","createComputePipeline","createRenderPipeline","getRenderCacheKey","program","needsRenderUpdate","Bindings","bindGroup","groupData","_init","updateForCompute","_updateBindings","_update","binding","isSampledTexture","updateTexture","isStorageBuffer","isIndirectStorageBufferAttribute","needsBindingsUpdate","cacheBindings","cacheIndex","isNodeUniformsGroup","updateGroup","isUniformBuffer","updateBinding","isSampler","texturesTextureData","generation","updated","textureData","externalTexture","isDefaultTexture","isWebGPUBackend","isStorageTexture","store","needsMipmap","needsMipmaps","updateBindings","painterSortStable","groupOrder","renderOrder","reversePainterSortStable","needsDoublePass","forceSinglePass","RenderList","renderItems","renderItemsIndex","opaque","transparentDoublePass","bundles","getNode","lightsArray","occlusionQueryCount","begin","getNextRenderItem","renderItem","occlusionTest","unshift","pushBundle","pushLight","light","customOpaqueSort","customTransparentSort","setLights","il","RenderLists","lists","list","_id$7","RenderContext","clearColor","clearColorValue","clearDepth","clearDepthValue","stencil","clearStencil","clearStencilValue","viewportValue","scissor","scissorValue","depthTexture","activeCubeFace","sampleCount","isRenderContext","RenderContexts","chainKey","attachmentState","stencilBuffer","renderState","_size$3","Textures","updateRenderTarget","activeMipmapLevel","renderTargetData","depthTextureMips","getSize","mipWidth","mipHeight","useDepthTexture","textureNeedsUpdate","_destroyTexture","isRenderTarget","destroySampler","destroyTexture","levels","getMipLevels","createSampler","createTexture","complete","dataReady","mipmaps","createDefaultTexture","mipLevelCount","isCompressedTexture","isEnvironmentTexture","Color4","ParameterNode","isParameterNode","StackNode","_currentCond","boolNode","methodNode","previousStack","elseif","_defaultRT","flipX","_camera","QuadGeometry","setAttribute","_geometry","QuadMesh","isQuadMesh","renderAsync","_e1","_m1","SceneNode","BACKGROUND_BLURRINESS","BACKGROUND_INTENSITY","BACKGROUND_ROTATION","background","backgroundRotation","makeRotationFromEuler","identity","backgroundBlurriness","backgroundIntensity","_size","PassTextureNode","passNode","PassMultipleTextureNode","textureName","previousTexture","getPreviousTexture","PassNode","_pixelRatio","_textures","_textureNodes","_linearDepthNodes","_viewZNodes","_previousTextures","_previousTextureNodes","_cameraNear","_cameraFar","_mrt","isPassNode","toggleTexture","prevTexture","getTextureNode","getPreviousTextureNode","getViewZNode","viewZNode","getLinearDepthNode","linearDepthNode","isWebGLBackend","setSize","currentRenderTarget","setRenderTarget","effectiveWidth","effectiveHeight","setPixelRatio","pixelRatio","linearToneMapping","reinhardToneMapping","cineonToneMapping","RRTAndODTFit","acesFilmicToneMapping","ACESInputMat","ACESOutputMat","LINEAR_REC2020_TO_LINEAR_SRGB","LINEAR_SRGB_TO_LINEAR_REC2020","agxDefaultContrastApprox","x_immutable","x4","agxToneMapping","colortone","AgXInsetMatrix","AgXOutsetMatrix","AgxMinEv","AgxMaxEv","neutralToneMapping","StartCompression","Desaturation","peak","d","newPeak","CodeNode","language","isCodeNode","setIncludes","getIncludes","include","nodeCode","getCodeFromNode","FunctionNode","getNodeFunction","nodeFunction","parser","parseFunction","getCode","Resources","getViewZ","rangeFogFactor","densityFogFactor","density","toFloat","AtomicFunctionNode","pointerNode","storeNode","methodSnippet","varSnippet","ATOMIC_LOAD","ATOMIC_STORE","ATOMIC_ADD","ATOMIC_SUB","ATOMIC_MAX","ATOMIC_MIN","ATOMIC_AND","ATOMIC_OR","ATOMIC_XOR","uniformsLib","getLightData","uniforms","lightShadowMatrix","shadowMatrix","castShadow","shadow","updateMatrices","lightProjectionUV","projectionUV","spotLightCoord","lightTargetPosition","targetPosition","lightViewPosition","viewPosition","lightTargetDirection","getLightNodeById","lightNodes","lightNode","isAnalyticLightNode","_lightsNodeRef","LightsNode","totalDiffuseNode","totalSpecularNode","_lights","_lightNodes","_lightNodesHash","lightIDs","setupLightsNode","previousLightNodes","sortLights","nodeLibrary","lightNodeClass","getLightNodeClass","totalDiffuse","ShadowBaseNode","isShadowBaseNode","setupShadowPosition","shadowPositionWorld","saveRendererState","getActiveCubeFace","getActiveMipmapLevel","renderObjectFunction","getRenderObjectFunction","getClearColor","clearAlpha","getClearAlpha","autoClear","scissorTest","getScissorTest","resetRendererState","setRenderObjectFunction","setClearColor","restoreRendererState","setScissorTest","saveSceneState","backgroundNode","overrideMaterial","resetSceneState","restoreSceneState","resetRendererAndSceneState","restoreRendererAndSceneState","shadowMaterialLib","linearDistance","dist","getShadowMaterial","isPointLight","nearDistance","farDistance","referencePosition","linearShadowDistance","BasicShadowFilter","shadowCoord","PCFShadowFilter","depthCompare","mapSize","radius","dx0","dy0","dx1","dy1","dx2","dy2","dx3","dy3","PCFSoftShadowFilter","dx","dy","VSMShadowFilter","occlusion","distribution","hardShadow","variance","softnessProbability","VSMPassVertical","shadowPass","mean","squaredMean","uvStride","uvStart","uvOffset","std_dev","VSMPassHorizontal","_shadowFilterLib","_rendererState","_quadMesh$1","ShadowNode","shadowMap","vsmShadowMapVertical","vsmShadowMapHorizontal","vsmMaterialVertical","vsmMaterialHorizontal","_node","isShadowNode","setupShadowFilter","filterFn","frustumTest","setupShadowCoord","shadowPosition","coordZ","isOrthographicCamera","cameraNearLocal","cameraFarLocal","getShadowFilterFn","setupShadow","shadowMapType","compareFunction","createRenderTarget","updateProjectionMatrix","shadowPassVertical","shadowPassHorizontal","getSharedContext","shadowIntensity","normalBias","filterNode","shadowDepthTexture","shadowTexture","shadowColor","shadowOutput","renderShadow","updateShadow","shadowType","depthVersion","_depthVersionCached","layers","mask","currentRenderObjectFunction","onBeforeShadow","onAfterShadow","vsmPass","autoUpdate","AnalyticLightNode","baseColorNode","shadowColorNode","setupShadowNode","customShadowNode","getDistanceAttenuation","lightDistance","cutoffDistance","decayExponent","distanceFalloff","_clearColor$2","cubeToUV","texelSizeY","absV","scaleToCube","planar","almostOne","signX","signY","BasicPointShadowFilter","bd3D","dp","PointShadowFilter","xyy","yyy","xyx","yyx","xxy","yxy","xxx","yxx","pointShadowFilter","lightToPosition","lightToPositionLength","_viewport","_viewportSize","_shadowMapSize","PointShadowNode","shadowFrameExtents","getFrameExtents","multiply","previousAutoClear","previousClearColor","previousClearAlpha","clear","viewportCount","getViewportCount","vp","directPointLight","lVector","lightAttenuation","PointLightNode","cutoffDistanceNode","decayExponentNode","decay","pointShadow","getShIrradianceAt","shCoefficients","_clearColor$1","Background","renderList","getBackgroundNode","forceClear","_clearColor","getRGB","sceneData","backgroundMesh","backgroundMeshNode","viewProj","setZ","nodeMaterial","frustumCulled","onBeforeRender","copyPosition","backgroundCacheKey","depthClearValue","_clearDepth","stencilClearValue","_clearStencil","autoClearColor","autoClearDepth","autoClearStencil","_id$6","BindGroup","bindingsReference","NodeBuilderState","updateNodes","updateBeforeNodes","updateAfterNodes","instanceGroup","bindingsGroup","instanceBinding","NodeAttribute","isNodeAttribute","NodeUniform","isNodeUniform","NodeVar","isNodeVar","NodeVarying","isNodeVarying","NodeCode","_id$5","NodeCache","nodesData","StructTypeNode","isStructTypeNode","getMemberTypes","Uniform","boundary","setValue","getValue","NumberUniform","isNumberUniform","Vector2Uniform","isVector2Uniform","Vector3Uniform","isVector3Uniform","Vector4Uniform","isVector4Uniform","ColorUniform","isColorUniform","Matrix3Uniform","isMatrix3Uniform","Matrix4Uniform","isMatrix4Uniform","NumberNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_cubeCamera","_oldTarget","_oldActiveCubeFace","_oldActiveMipmapLevel","PHI","INV_PHI","_axisDirections","_faceLib","PMREMGenerator","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_lodMeshes","_blurMaterial","_cubemapMaterial","_equirectMaterial","_backgroundBox","_hasInitialized","hasInitialized","fromScene","sigma","_setSize","cubeUVRenderTarget","_allocateTargets","fromSceneAsync","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","init","equirectangular","_setSizeFromTexture","fromEquirectangularAsync","_fromTexture","cubemap","fromCubemapAsync","compileCubemapShader","_getCubemapMaterial","_compileMaterial","compileEquirectangularShader","_getEquirectMaterial","_dispose","cubeSize","outputTarget","_setViewport","_textureToCubeUV","_createRenderTarget","sizeLods","lodPlanes","sigmas","lodMeshes","lodMax","totalLods","sizeLod","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","faceIndex","coordinates","faceIdx","fill","planes","_createPlanes","materialUniforms","_getMaterial","_getBlurShader","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","backgroundBox","backgroundMaterial","useSolidColor","col","up","lookAt","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","sigmaPixels","sum","weight","outputSize","envTexture","rendererCache","typeFromArray","Int8Array","Int16Array","Uint16Array","NodeBuilder","sequentialNodes","hashNodes","flowNodes","flowCode","structs","bindingsIndexes","bindGroups","bufferAttributes","varyings","codes","vars","flow","chaining","stacks","flowsData","getBindGroupsCache","bindGroupsCache","createCubeRenderTarget","_getBindGroup","groupName","bindingsArray","sharedGroup","getBindGroupArray","bindingsGroups","groups","sortBindingGroups","bindingGroup","buildUpdateNodes","currentNode","isFilteredTexture","pop","generateTextureLod","getComponentTypeFromTexture","isDataTexture","exec","baseType","getTypeFromArray","dataAttribute","vecType","vecNum","newComponentType","lastStack","getStructTypeFromNode","structType","variable","nodeVarying","flowCodeBlock","needsFlowCode","nodeBlockHierarchy","addLineFlowCodeBlock","codeBlock","getFlowData","flowNode","flowData","flowChildNode","previous","buildFunctionCode","flowShaderNode","Symbol","iterator","next","done","flowStagesNode","previousFlow","previousVars","previousBuildStage","setBuildStage","getVars","previousShaderStage","setShaderStage","getAttributesArray","concat","getVaryings","getUniforms","getCodes","getShaderStage","buildCode","fromMaterial","getNodeUniform","fromType","toType","fromTypeLength","toTypeLength","getSignature","createNodeMaterial","NodeFrame","deltaTime","updateMap","updateBeforeMap","updateAfterMap","_getMaps","referenceMap","nodeRef","maps","renderMap","frameMap","updateBeforeNode","updateAfterNode","updateNode","lastTime","performance","now","NodeFunctionInput","isConst","isNodeFunctionInput","DirectionalLightNode","_matrix41","_matrix42","_ltcLib","RectAreaLightNode","premultiply","extractRotation","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setLTC","ltc","SpotLightNode","coneCosNode","penumbraCosNode","angle","penumbra","getSpotAttenuation","angleCosine","angleCos","spotAttenuation","projectedTexture","IESSpotLightNode","iesMap","AmbientLightNode","HemisphereLightNode","lightPositionNode","lightDirectionNode","groundColorNode","groundColor","hemiDiffuseWeight","LightProbeNode","lightProbe","sh","coefficients","NodeParser","NodeFunction","isNodeFunction","declarationRegexp$1","propertiesRegexp$1","pragmaMain","GLSLNodeFunction","inputsCode","blockCode","headerCode","pragmaMainIndex","trim","mainCode","declaration","match","propsMatches","nameMatch","parseInt","isNaN","substring","parse$1","declarationCode","GLSLNodeParser","_outputNodeMap","Nodes","nodeBuilderCache","callHashCache","groupsData","cacheLib","nodeUniformsGroup","uniformsGroupData","groupChain","getForRenderCacheKey","nodeBuilder","createNodeBuilder","getEnvironmentNode","getFogNode","_createNodeBuilderState","computeData","updateEnvironment","updateBackground","updateFog","chain","cacheKeyData","isToneMappingState","forceUpdate","getCacheNode","nodeCache","sceneFog","isFogExp2","isFog","getNodeFrame","getNodeFrameForRender","getOutputCacheKey","currentColorSpace","hasOutputChange","_plane","ClippingContext","parentContext","clipIntersection","viewNormalMatrix","clippingGroupContexts","parentVersion","projectPlanes","destination","constant","updateGlobal","clippingGroup","srcClippingPlanes","dstClippingPlanes","getGroupContext","clipShadows","RenderBundle","bundleGroup","RenderBundles","NodeLibrary","materialNodes","toneMappingNodes","nodeMaterialClass","getMaterialNodeClass","addToneMapping","toneMappingNode","addType","materialType","addMaterial","materialNodeClass","materialClassType","addLight","lightClass","addClass","nodeClass","baseClass","_defaultLights","Lighting","_scene","_drawingBufferSize","_screen","_frustum","_projScreenMatrix","_vector4","Renderer","isRenderer","antialias","getFallback","domElement","getDomElement","sortObjects","_getFallback","_scissor","_scissorTest","_attributes","_animation","_objects","_pipelines","_bundles","_renderLists","_renderContexts","_background","_quad","_currentRenderContext","_opaqueSort","_transparentSort","_frameBufferTarget","alphaClear","_renderTarget","_activeCubeFace","_activeMipmapLevel","_renderObjectFunction","_currentRenderObjectFunction","_currentRenderBundle","_handleObjectFunction","_renderObjectDirect","_isDeviceLost","onDeviceLost","_onDeviceLost","_initialized","_initPromise","_compilationPromises","xr","debug","checkShaderErrors","onShaderError","getShaderAsync","async","compileAsync","Promise","resolve","reject","targetScene","previousRenderId","previousRenderContext","previousRenderObjectFunction","previousCompilationPromises","sceneRef","isScene","compilationPromises","_createObjectPipeline","_projectObject","traverseVisible","isLight","opaqueObjects","transparentObjects","transparentDoublePassObjects","_renderObjects","_renderTransparents","_renderScene","resolveTimestampAsync","waitForGPU","errorMessage","api","message","reason","_renderBundle","renderBundle","renderBundleData","renderContexts","renderBundleNeedsUpdate","beginBundle","finishBundle","addBundle","_getFrameBufferTarget","currentToneMapping","useToneMapping","useColorSpace","frameBufferTarget","isPostProcessingRenderTarget","useFrameBufferTarget","outputRenderTarget","matrixWorldAutoUpdate","updateMatrixWorld","minDepth","maxDepth","multiplyMatrices","setFromProjectionMatrix","beginRender","_renderBundles","finishRender","quad","onAfterRender","getMaxAnisotropy","getArrayBufferAsync","setDrawingBufferSize","setViewport","updateSize","updateStyle","style","setOpaqueSort","setTransparentSort","getScissor","setScissor","boolean","setClearAlpha","getClearDepth","setClearDepth","getClearStencil","setClearStencil","isOccluded","clearAsync","clearColorAsync","clearDepthAsync","clearStencilAsync","computeNodes","isDeviceLost","computeAsync","computeList","beginCompute","onInitFn","computeBindings","computePipeline","finishCompute","hasFeatureAsync","hasFeature","initTextureAsync","initTexture","rectangle","copyTextureToTexture","srcTexture","dstTexture","srcRegion","dstPosition","readRenderTargetPixelsAsync","textureIndex","copyTextureToBuffer","visible","isGroup","isClippingGroup","isLOD","intersectsSprite","intersectsObject","boundingSphere","computeBoundingSphere","groupMaterial","materialIndex","isBundleGroup","baseRenderList","children","doublePassList","isArrayCamera","cameras","jl","camera2","updateViewport","overridePositionNode","overrideColorNode","overrideDepthNode","shadowSide","draw","Binding","visibility","setVisibility","Buffer","isBuffer","bytesPerElement","BYTES_PER_ELEMENT","_buffer","byteLength","floatLength","UniformBuffer","_id$4","NodeUniformBuffer","UniformsGroup","isUniformsGroup","_values","addUniform","removeUniform","splice","chunkOffset","updateByType","updateNumber","updateVector2","updateVector3","updateVector4","updateColor","updateMatrix3","updateMatrix4","_getBufferForType","e","arraysEqual","setArray","_id$3","NodeUniformsGroup","_id$2","SampledTexture","isVideoTexture","NodeSampledTexture","access","NodeSampledCubeTexture","isSampledCubeTexture","NodeSampledTexture3D","isSampledTexture3D","glslMethods","textureDimensions","precisionLib","medium","supports$1","swizzleAssign","storageBuffer","defaultPrecisions","GLSLNodeBuilder","uniformGroups","extensions","builtins","getOutputStructName","setupPBO","storageBufferNode","pbo","originalArray","numElements","typeMap","Uint8ClampedArray","newSize","newArray","pboTexture","isPBOTexture","pboNode","generatePBO","storageArrayElementNode","indexSnippet","elementNodeData","bufferNodeData","propertySizeName","prefix","uvIndexSnippet","snippets","bindingSnippets","typePrefix","isDataArrayTexture","isCompressedArrayTexture","bufferCountSnippet","groupSnippets","_getGLSLUniformStruct","gpuType","location","getStructMembers","struct","members","member","getStructs","acc","curr","enableExtension","behavior","getExtensions","ext","extensionName","planeCount","registerTransform","varyingName","attributeNode","getTransforms","transform","_getGLSLVertexCode","shaderData","_getGLSLFragmentCode","shadersData","mainNode","flowSlotData","slotName","stageData","uniformGPU","uniformsStage","uniformsGroup","_vector2","_color4","Backend","destroyProgram","canvas","_id$1","DualAttributeData","dualBuffer","buffers","bufferGPU","activeBufferIndex","baseId","transformBuffer","switchBuffers","WebGLAttributeUtils","STATIC_DRAW","_createBuffer","FLOAT","isFloat16BufferAttribute","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","bufferGPUDual","updateRanges","bindBuffer","bufferSubData","range","clearUpdateRanges","deleteBuffer","COPY_READ_BUFFER","writeBuffer","createBuffer","COPY_WRITE_BUFFER","STREAM_READ","copyBufferSubData","utils","_clientWaitAsync","dstBuffer","getBufferSubData","equationToGL","factorToGL","initialized$1","WebGLState","currentFlipSided","currentCullFace","currentProgram","currentBlendingEnabled","currentBlending","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentColorMask","currentDepthFunc","currentDepthMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilMask","currentLineWidth","currentClippingPlanes","currentBoundFramebuffers","currentDrawbuffers","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","currentTextureSlot","currentBoundTextures","currentBoundBufferBases","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","enable","disable","setFlipSided","flipSided","frontFace","CW","CCW","setCullFace","cullFace","CULL_FACE","BACK","FRONT","FRONT_AND_BACK","setLineWidth","lineWidth","setBlending","blendEquation","blendSrc","blendDst","blendEquationAlpha","blendSrcAlpha","blendDstAlpha","premultipliedAlpha","BLEND","currentBlendEquation","currentBlendEquationAlpha","blendEquationSeparate","blendFuncSeparate","blendFunc","setColorMask","colorMask","setDepthTest","DEPTH_TEST","setDepthMask","depthMask","setDepthFunc","depthFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","setStencilTest","stencilTest","STENCIL_TEST","setStencilMask","stencilMask","setStencilFunc","stencilFunc","stencilRef","setStencilOp","stencilFail","stencilZFail","stencilZPass","stencilOp","setMaterial","frontFaceCW","colorWrite","stencilWrite","stencilWriteMask","stencilFuncMask","setPolygonOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","SAMPLE_ALPHA_TO_COVERAGE","CLIP_DISTANCE0_WEBGL","units","POLYGON_OFFSET_FILL","useProgram","bindFramebuffer","framebuffer","DRAW_FRAMEBUFFER","FRAMEBUFFER","drawBuffers","COLOR_ATTACHMENT0","activeTexture","webglSlot","TEXTURE0","bindTexture","webglType","webglTexture","boundTexture","bindBufferBase","unbindTexture","WebGLUtils","p","extension","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_INT_5_9_9_9_REV","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","DEPTH_STENCIL","RED","RED_INTEGER","RG","RG_INTEGER","RGBA_INTEGER","COMPRESSED_SRGB_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","COMPRESSED_RGBA8_ETC2_EAC","COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","COMPRESSED_RGBA_ASTC_4x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR","COMPRESSED_RGBA_ASTC_5x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR","COMPRESSED_RGBA_ASTC_5x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR","COMPRESSED_RGBA_ASTC_6x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR","COMPRESSED_RGBA_ASTC_6x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR","COMPRESSED_RGBA_ASTC_8x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR","COMPRESSED_RGBA_ASTC_8x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR","COMPRESSED_RGBA_ASTC_8x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR","COMPRESSED_RGBA_ASTC_10x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR","COMPRESSED_RGBA_ASTC_10x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR","COMPRESSED_RGBA_ASTC_10x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR","COMPRESSED_RGBA_ASTC_10x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR","COMPRESSED_RGBA_ASTC_12x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR","COMPRESSED_RGBA_ASTC_12x12_KHR","COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT","COMPRESSED_RGBA_BPTC_UNORM_EXT","COMPRESSED_RED_RGTC1_EXT","COMPRESSED_SIGNED_RED_RGTC1_EXT","COMPRESSED_RED_GREEN_RGTC2_EXT","COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT","UNSIGNED_INT_24_8","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","res","clientWaitSync","SYNC_FLUSH_COMMANDS_BIT","WAIT_FAILED","deleteSync","TIMEOUT_EXPIRED","wrappingToGL","filterToGL","compareToGL","WebGLTextureUtils","defaultTextures","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","filterFallback","getGLTextureType","glTextureType","TEXTURE_CUBE_MAP","TEXTURE_2D_ARRAY","isData3DTexture","TEXTURE_3D","TEXTURE_2D","getInternalFormat","internalFormatName","glFormat","glType","forceLinearTransfer","internalFormat","R32F","R16F","R8","R16","R32UI","R8I","R16I","R32I","R8UI","R16UI","RG32F","RG16F","RG8","RG16","RG32UI","RG8I","RG16I","RG32I","RG8UI","RG16UI","RGB32F","RGB16F","RGB8","RGB16","RGB32UI","RGB8I","RGB16I","RGB32I","SRGB8","UNSIGNED_SHORT_5_6_5","RGB565","RGB5_A1","RGB4","RGB9_E5","RGB_INTEGER","RGB8UI","RGB16UI","RGBA32F","RGBA16F","RGBA8","RGBA16","RGBA32UI","RGBA8I","RGBA16I","RGBA32I","SRGB8_ALPHA8","RGBA4","RGBA8UI","RGBA16UI","DEPTH24_STENCIL8","DEPTH_COMPONENT32F","setTextureParameters","textureType","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","UNPACK_COLORSPACE_CONVERSION_WEBGL","texParameteri","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_WRAP_R","wrapR","TEXTURE_MAG_FILTER","hasMipmaps","TEXTURE_MIN_FILTER","TEXTURE_COMPARE_MODE","COMPARE_REF_TO_TEXTURE","TEXTURE_COMPARE_FUNC","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","textureGPU","isDefault","glInternalFormat","texStorage3D","texStorage2D","copyBufferToTexture","PIXEL_UNPACK_BUFFER","texSubImage2D","getImage","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","mipmap","compressedTexSubImage3D","texSubImage3D","compressedTexSubImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","deallocateRenderBuffers","renderContextData","renderBufferStorageSetup","framebuffers","deleteFramebuffer","depthRenderbuffer","deleteRenderbuffer","stencilRenderbuffer","msaaFrameBuffer","msaaRenderbuffers","deleteTexture","dstTextureGPU","minX","minY","dstX","dstY","currentUnpackRowLen","UNPACK_ROW_LENGTH","currentUnpackImageHeight","UNPACK_IMAGE_HEIGHT","currentUnpackSkipPixels","UNPACK_SKIP_PIXELS","currentUnpackSkipRows","UNPACK_SKIP_ROWS","currentUnpackSkipImages","UNPACK_SKIP_IMAGES","srcTextureData","dstTextureData","srcRenderContextData","dstRenderContextData","srcFramebuffer","dstFramebuffer","READ_FRAMEBUFFER","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","blitFramebuffer","requireDrawFrameBuffer","srcHeight","partial","attachment","DEPTH_ATTACHMENT","STENCIL_BUFFER_BIT","renderTargetContextData","fb","flippedY","copyTexSubImage2D","createFramebuffer","framebufferTexture2D","_setFramebuffer","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","DEPTH_COMPONENT24","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","typedArrayType","_getTypedArrayType","_getBytesPerTexel","PIXEL_PACK_BUFFER","readPixels","bytesPerComponent","WebGLExtensions","availableExtensions","getSupportedExtensions","getExtension","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","GLFeatureName","WebGLBufferRenderer","mode","drawElements","drawArrays","renderInstances","primcount","drawElementsInstanced","drawArraysInstanced","renderMultiDraw","starts","counts","drawCount","multiDrawElementsWEBGL","multiDrawArraysWEBGL","elementCount","renderMultiDrawInstances","multiDrawElementsInstancedWEBGL","multiDrawArraysInstancedWEBGL","WebGLBackend","attributeUtils","capabilities","textureUtils","bufferRenderer","vaoCache","transformFeedbackCache","disjoint","parallel","trackTimestamp","_currentContext","_knownBindings","WeakSet","glContext","onContextLost","preventDefault","contextLossInfo","statusMessage","originalEvent","_onContextLost","initTimestampQuery","queryRunning","queryQueue","activeQuery","endQuery","TIME_ELAPSED_EXT","createQuery","beginQuery","prepareTimestampBuffer","gpuQueries","query","nextRenderContext","queryInfo","available","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","elapsed","QUERY_RESULT","duration","deleteQuery","drawingBufferWidth","drawingBufferHeight","currentOcclusionQueries","occlusionQueries","currentOcclusionQueryObjects","occlusionQueryObjects","lastOcclusionObject","occlusionQueryIndex","ANY_SAMPLES_PASSED","resolveOccludedAsync","viewY","invalidateSubFramebuffer","invalidationArray","invalidateFramebuffer","occluded","check","completed","SCISSOR_TEST","setFrameBuffer","clearBufferfv","clearBufferfi","clearBufferiv","STENCIL","computeGroup","RASTERIZER_DISCARD","programGPU","transformBuffers","vaoKey","_getVaoKey","vaoGPU","_createVao","bindVertexArray","_bindUniforms","transformFeedbackGPU","_getTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","beginTransformFeedback","POINTS","endTransformFeedback","dualAttributeData","contextData","determinant","staticVao","geometryId","lastObject","LINES","LINE_STRIP","LINE_LOOP","wireframeLinewidth","TRIANGLES","indexData","_multiDrawInstances","_multiDrawStarts","_multiDrawCounts","_multiDrawCount","shader","createShader","FRAGMENT_SHADER","VERTEX_SHADER","shaderSource","compileShader","shaderGPU","attachShader","linkProgram","checkStatus","getProgramParameter","COMPLETION_STATUS_KHR","_completeCompile","_handleSource","string","errorLine","lines2","to","line","_getShaderErrors","status","getShaderParameter","COMPILE_STATUS","errors","getShaderInfoLog","errorMatches","toUpperCase","getShaderSource","_logProgramError","glFragmentShader","glVertexShader","programLog","getProgramInfoLog","LINK_STATUS","vertexErrors","fragmentErrors","getError","VALIDATE_STATUS","pipelineData","_setupBindings","transformVaryingNames","transformAttributeNodes","transformFeedbackVaryings","SEPARATE_ATTRIBS","attributeNodes","ARRAY_BUFFER","uniformBuffers","bindGroupData","UNIFORM_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","keysMatching","filter","currentFrameBuffer","isCube","isWebGLCubeRenderTarget","isRenderTarget3D","isRenderTargetArray","msaaFb","cubeFramebuffers","cubeFace","layer","framebufferTextureLayer","depthStyle","createRenderbuffer","createVertexArray","enableVertexAttribArray","vertexAttribIPointer","vertexAttribPointer","vertexAttribDivisor","meshPerAttribute","isInstancedInterleavedBuffer","createTransformFeedback","TRANSFORM_FEEDBACK_BUFFER","getUniformBlockIndex","uniformBlockBinding","getUniformLocation","uniform1i","bindingData","GPUPrimitiveTopology","GPUCompareFunction","GPUStoreOp","GPULoadOp","GPUFrontFace","GPUCullMode","GPUIndexFormat","GPUTextureFormat","R8Unorm","R8Snorm","R8Uint","R8Sint","R16Uint","R16Sint","R16Float","RG8Unorm","RG8Snorm","RG8Uint","RG8Sint","R32Uint","R32Sint","R32Float","RG16Uint","RG16Sint","RG16Float","RGBA8Unorm","RGBA8UnormSRGB","RGBA8Snorm","RGBA8Uint","RGBA8Sint","BGRA8Unorm","BGRA8UnormSRGB","RGB9E5UFloat","RGB10A2Unorm","RG11B10uFloat","RG32Uint","RG32Sint","RG32Float","RGBA16Uint","RGBA16Sint","RGBA16Float","RGBA32Uint","RGBA32Sint","RGBA32Float","Stencil8","Depth16Unorm","Depth24Plus","Depth24PlusStencil8","Depth32Float","Depth32FloatStencil8","BC1RGBAUnorm","BC1RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC4RUnorm","BC4RSnorm","BC5RGUnorm","BC5RGSnorm","BC6HRGBUFloat","BC6HRGBFloat","BC7RGBAUnorm","BC7RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","GPUAddressMode","GPUFilterMode","GPUBlendFactor","GPUBlendOperation","GPUColorWriteFlags","GPUStencilOperation","GPUBufferBindingType","GPUStorageTextureAccess","GPUTextureSampleType","GPUTextureDimension","GPUTextureViewDimension","GPUTextureAspect","GPUInputStepMode","GPUFeatureName","DepthClipControl","TextureCompressionBC","TextureCompressionETC2","TextureCompressionASTC","TimestampQuery","IndirectFirstInstance","ShaderF16","RG11B10UFloat","BGRA8UNormStorage","Float32Filterable","ClipDistances","DualSourceBlending","Subgroups","Sampler","NodeSampler","StorageBuffer","_id","NodeStorageBuffer","WebGPUTexturePassUtils","device","mipmapSampler","flipYSampler","transferPipelines","flipYPipelines","mipmapVertexShaderModule","createShaderModule","mipmapFragmentShaderModule","flipYFragmentShaderModule","getTransferPipeline","module","entryPoint","targets","primitive","topology","stripIndexFormat","getFlipYPipeline","textureGPUDescriptor","baseArrayLayer","transferPipeline","flipYPipeline","tempTexture","depthOrArrayLayers","GPUTextureUsage","RENDER_ATTACHMENT","TEXTURE_BINDING","srcView","createView","baseMipLevel","dimension","dstView","commandEncoder","createCommandEncoder","pass","sourceView","destinationView","bindGroupLayout","getBindGroupLayout","createBindGroup","entries","resource","passEncoder","beginRenderPass","colorAttachments","view","loadOp","storeOp","clearValue","setPipeline","setBindGroup","queue","submit","destroy","useCount","passes","_mipmapCreateBundles","_mipmapRunBundles","passDescriptor","createRenderBundleEncoder","colorFormats","renderBundles","executeBundles","_compareToWebGPU","_flipMap","WebGPUTextureUtils","_passUtils","defaultCubeTexture","defaultVideoFrame","colorBuffer","samplerDescriptorGPU","addressModeU","_convertAddressMode","addressModeV","addressModeW","_convertFilterMode","mipmapFilter","getFormat","_getDefaultCubeTextureGPU","_getDefaultVideoFrame","_getDefaultTextureGPU","getCurrentColorFormat","getPreferredCanvasFormat","_getDimension","primarySamples","isMSAA","getTextureSampleData","COPY_DST","COPY_SRC","STORAGE_BINDING","textureDescriptorGPU","video","videoFrame","VideoFrame","displayWidth","displayHeight","close","msaaTextureDescriptorGPU","msaaTexture","_generateMipmaps","getColorBuffer","getSampleCount","getDepthBuffer","depthTextureGPU","_copyBufferToTexture","_copyCompressedBufferToTexture","_copyCubeMapToTexture","_copyImageToTexture","bytesPerTexel","bytesPerRow","readBuffer","GPUBufferUsage","MAP_READ","encoder","origin","mapAsync","GPUMapMode","READ","getMappedRange","_isEnvironmentTexture","codedWidth","codedHeight","flipIndex","originDepth","copyExternalImageToTexture","mipLevel","_flipY","_getPassUtils","passUtils","writeTexture","blockData","_getBlockData","isTextureArray","bytesPerImage","rowsPerImage","BC4RSNorm","addressMode","filterMode","formatGPU","features","declarationRegexp","propertiesRegexp","wgslTypeLib$1","WGSLNodeFunction","resolvedType","parse","WGSLNodeParser","GPUShaderStage","COMPUTE","accessNames","wrapNames","gpuShaderStageLib","supports","instance","wgslFnOpLib","wgslTypeLib","wgslCodeCache","wgslPolyfill","tsl_xor","mod_float","mod_vec2","mod_vec3","mod_vec4","equals_bool","equals_bvec2","equals_bvec3","equals_bvec4","repeatWrapping_float","mirrorWrapping_float","clampWrapping_float","biquadraticTexture","wgslMethods","inversesqrt","bitcast","navigator","userAgent","pow_float","pow_vec2","pow_vec3","pow_vec4","diagnostics","WGSLNodeBuilder","directives","scopedArrays","_generateTextureSample","generateFilteredTexture","_generateVideoSample","_generateTextureSampleLevel","isUnfilterable","generateWrapFunction","functionName","coordType","addWrapSnippet","wrap","generateTextureDimension","dimensionsSnippet","textureDimensionNode","textureDimensionsParams","dimensionType","isMultisampled","arrayLayerCount","isTextureCube","cubeFaceCount","_include","wrapFunction","textureDimension","coordSnippet","generateTextureStore","valueSnippet","isSampleCompare","_getUniformGroupCount","fnOp","getNodeAccess","getStorageAccess","isStorageTextureNode","getBuiltin","hasBuiltin","getSubgroupSize","enableSubGroups","enableDirective","getDirectives","directive","enableSubgroupsF16","enableClipDistances","enableShaderF16","enableDualSourceBlending","getBuiltins","getScopedArray","getScopedArrays","attributesSnippet","_getWGSLStruct","bufferSnippets","structSnippets","uniformIndexes","multisampled","bufferTypeSnippet","isAtomic","bufferSnippet","bufferAccessMode","isStorageBufferNode","_getWGSLStructBinding","vectorType","isOutputStruct","returnType","structSnippet","_getWGSLVertexCode","_getWGSLFragmentCode","_getWGSLComputeCode","wgslMethod","_getWGSLMethod","codeNode","structName","WebGPUUtils","getCurrentDepthStencilFormat","getTextureFormatGPU","getCurrentColorSpace","getPrimitiveTopology","getSampleCountRenderContext","gpu","typedArraysToVertexFormatPrefix","typedAttributeToVertexFormatPrefix","typeArraysToVertexFormatPrefixForItemSize1","WebGPUAttributeUtils","tempArray","subarray","mappedAtCreation","unmap","isTypedArray","_isTypedArray","byteOffsetFactor","dataOffset","createShaderVertexBuffers","slot","vertexBufferLayout","arrayStride","stepMode","_getVertexFormat","shaderLocation","readBufferGPU","cmdEncoder","copyBufferToBuffer","gpuCommands","ArrayType","bytesPerUnit","paddedItemSize","isView","DataView","WebGPUBindingUtils","bindGroupLayoutCache","createBindingsLayout","bindingGPU","storageTexture","sampleType","viewDimension","createBindGroupLayout","bindingsData","bindGroupGPU","bindLayoutGPU","versions","layoutGPU","bindingPoint","entriesGPU","UNIFORM","resourceGPU","importExternalTexture","aspectGPU","dimensionViewGPU","aspect","WebGPUPipelineUtils","_getSampleCount","renderObjectContext","bindGroupLayouts","_getBlending","stencilFront","_getStencilCompare","failOp","_getStencilOperation","depthFailOp","passOp","colorWriteMask","_getColorWriteMask","colorFormat","blend","writeMask","vertexModule","fragmentModule","primitiveState","_getPrimitiveState","_getDepthCompare","depthStencilFormat","pipelineDescriptor","multisample","alphaToCoverageEnabled","createPipelineLayout","depthStencil","renderDepth","renderStencil","depthWriteEnabled","stencilBack","stencilReadMask","createRenderPipelineAsync","then","createBundleEncoder","pipelineGPU","srcFactor","_getBlendFactor","dstFactor","operation","_getBlendOperation","setBlend","srcRGB","dstRGB","srcAlpha","dstAlpha","blendFactor","stencilCompare","stencilOperation","blendOperation","cullMode","WebGPUBackend","requiredLimits","defaultRenderPassdescriptor","bindingUtils","pipelineUtils","occludedResolveCache","adapterOptions","powerPreference","adapter","requestAdapter","supportedFeatures","deviceDescriptor","requiredFeatures","requestDevice","lost","deviceLossInfo","alphaMode","configure","_getDefaultRenderPassDescriptor","depthStencilAttachment","colorAttachment","resolveTarget","getCurrentTexture","_getRenderPassDescriptor","colorAttachmentsConfig","dimensions","sliceIndex","viewDescriptor","textureView","depthSlice","occlusionQuerySet","currentOcclusionQuerySet","currentOcclusionQueryBuffer","occlusionQueryBuffer","createQuerySet","depthLoadOp","depthStoreOp","stencilLoadOp","stencilStoreOp","currentPass","currentSets","bindingGroups","setScissorRect","endOcclusionQuery","bufferSize","queryResolveBuffer","QUERY_RESOLVE","resolveQuerySet","results","BigUint64Array","BigInt","renderTargetContext","supportsDepth","supportsStencil","groupGPU","cmdEncoderGPU","passEncoderGPU","beginComputePass","maxComputeWorkgroupsPerDimension","limits","computeNodeData","dispatchSize","dispatchWorkgroups","onSubmittedWorkDone","currentBindingGroups","indexFormat","setIndexBuffer","vertexBuffer","setVertexBuffer","beginOcclusionQuery","drawInstances","drawIndexed","indexCount","firstIndex","drawIndexedIndirect","drawIndirect","primitiveTopology","materialVersion","timeStampQuerySet","timestampWrites","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","BigInt64Array","currentTimestampQueryBuffers","resolveBuffer","resultBuffer","mapState","times","_currentPass","_currentSets","bundleGPU","INDEX","STORAGE","INDIRECT","dstLayer","srcX","srcY","srcLayer","srcWidth","sourceGPU","destinationGPU","IESSpotLight","recursive","StandardNodeLibrary","WebGPURenderer","BackendClass","forceWebGL","isWebGPURenderer"],"sourceRoot":""}