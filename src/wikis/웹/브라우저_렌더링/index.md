---
created: 2023-09-02 13:47:44 +0900
updated: 2023-09-07 01:18:48 +0900
---

# 미리 알아두면 좋은 것들

**CPU**(Central Processing Unit)와 **GPU**(Graphics Processing Unit)에 대해 조금 알아보자. CPU는 컴퓨터의 핵심 부품으로 그 두뇌 역할을 한다. 과거에는 단일 코어로 구성된 CPU가 많았지만 오늘날의 CPU는 대부분 멀티 코어로 구성되어 있다. 이 경우에 하나의 코어는 같은 칩에 있는 다른 CPU라고 할 수 있다. 한편 GPU는 비교적 쉽고 단순한 작업에 특화된 구성이다. 수천개의 코어가 작업을 병렬적으로 빠르게 처리한다. 이름에서도 알 수 있듯이 그래픽 작업을 위해 만들어진 부품이다. 화면에 그래픽을 표시하기 위해서는 대량의 단순 작업을 처리해야 하기 때문이다.

**프로세스**는 프로그램의 실행 단위라고 할 수 있다. 프로세스가 실행되면 결국 연산을 하는데 **스레드**가 주로 그 연산의 주체이다. 프로세스 하나가 존재한다면 스레드는 하나 이상 존재한다. 복수의 스레드를 가지는 프로세스를 멀티 스레드 프로세스라 한다.

애플리케이션을 시작하면 프로세스가 생성된다. 프로세스는 스레드를 통해 연산을 수행하고 운영체제는 프로세스가 동작하는데 필요한 메모리 공간을 제공한다. 프로세스가 종료되면 메모리 공간은 다시 회수된다.

한편 프로세스는 운영체제를 통해 다른 프로세스에서 어떤 작업을 수행하도록 요청할 수 있다. 만약 두 프로세스간 통신이 필요하다면 **IPC**(Inter Process Communication)을 사용한다.

# 브라우저 아키텍처

**브라우저 아키텍처**에는 표준이 없다. 단 하나의 멀티 스레드 프로세스이거나 여러 프로세스로 구성될 수도 있다. 크롬은 멀티 프로세스로 구성된 브라우저다. 그 중 브라우저 프로세스는 다른 프로세스와 협력하는 가장 상위 레벨의 프로세스다. 이 밖에도 렌더러 프로세스, GPU 프로세스, 플러그인 프로세스 등이 있다.

- 브라우저 프로세스: 주소창, 앞/뒤로가기 버튼, 네트워크 요청, 파일 엑세스 등을 제어
- 렌더러 프로세스: 웹사이트가 표시되는 탭 내부의 모든 것들을 제어
- 플러그인 프로세스: 웹사이트의 플러그인을 제어
- GPU 프로세스: 다른 프로세스와 별도로 GPU 작업을 처리

이 밖에도 익스텐션 프로세스, 유틸리티 프로세스 등이 있다. 작업 관리자 메뉴에서 확인할 수 있다.

# 멀티 프로세스 아키텍처의 장점

모든 탭이 단일 렌더러 프로세스에 의해 구동된다면 프로세스에 문제가 발생할 때 모든 탭이 응답하지 않을 수 있다. 서로 독립적인 렌더러 프로세스를 갖는다면 이런 사태를 방지할 수 있다.

다른 장점은 보안에 있다. 브라우저는 운영체제로부터 권한을 위임받아 프로세스의 파일 접근이나 프로세스간의 상호작용을 제어한다. 예를 들어 크롬은 렌더러 프로세스와 같이 사용자 입력을 처리하는 프로세스가 파일에 직접 접근하는 것을 제한할 수 있다. 모든 프로세스는 각자의 메모리 공간을 할당받는다. 프로세스간에 리소스를 자유롭게 공유할 수 없게 하여 특정 프로세스를 통한 보안 공격 혹은 부정적 여파가 미치는 것을 방지할 수 있다. 하지만 각 메모리 공간에 브라우저 엔진, 자바스크립트 엔진과 같은 공통 구성 요소가 포함되어야 하므로 전체 시스템의 메모리 사용량은 증가한다. 크롬에서는 메모리를 절약하기 위해 프로세스 수에 제한을 두고 있다. 이 제한은 디바이스의 성능에 따라 다르며, 리밋에 도달하면 동일한 사이트의 여러 탭을 하나의 프로세스에서 실행하기도 한다.

크롬의 메모리 관리 전략은 디바이스의 성능에 따라 달라진다. 고사양 디바이스에서는 각 서비스를 여러 프로세스로 분할하여 안정성을 높이지만 리소스가 제한된 장치에서는 서비스를 하나의 프로세스로 통합하여 메모리 사용량을 절약한다.

탭마다 각자의 프로세스를 갖더라도 하나의 탭에 여러 사이트가 존재할 수 있다. 대표적인 예시로 iframe이 있다. 이런 경우에 동일 출처가 아닌 사이트가 서로 같은 프로세스를 공유하므로 보안 문제를 초래할 수 있다. 크롬은 이러한 문제를 해결하기 위해 탭이 아닌 사이트마다 렌더러 프로세스를 갖도록 한다. 프로세스 분리는 Site Isolation을 위한 가장 효과적인 방법 중 하나이기 때문이다.

# 주소 표시줄에 URL을 입력하면

사용자가 URL을 입력하면 브라우저는 새로운 페이지를 그려주기 위해 서버에 데이터를 요청한다. **브라우저 프로세스**가 이 역할을 맡는다. 브라우저 프로세스는 버튼이나 주소창의 인풋 영역을 그리기 위한 UI 스레드, 인터넷 통신을 처리하는 네트워크 스레드, 파일 접근을 제어하는 스토리지 스레드 등 여러 스레드를 포함한다.

**UI 스레드**는 사용자가 입력한 값이 검색 키워드인지, URL인지 구분해야 한다. 만약 URL이라면 네비게이션을 시작한다. 엔터 키를 누르면 UI 스레드는 네트워크를 호출한다. 탭에 로딩 스피너를 보여주고 네트워크 스레드를 통해 데이터를 요청한다.

**네트워크 스레드**는 서버로부터 어떤 유형의 데이터가 도착했는지 확인한다. 만약 HTML 파일인 경우 이를 렌더러 프로세스에 전달하지만, zip 파일과 같은 다른 유형의 데이터라면 다운로드 요청으로 간주하고 이를 다운로드 관리자에게 전달한다. 한편으로는 [SafeBrowsing](https://safebrowsing.google.com/) 검사를 수행한다. 이미 등록된 악성 사이트와 일치한다면 네트워크 스레드는 경고 페이지를 표시하도록 요청한다. 또한 크로스 사이트 데이터가 전달되지 않도록 이를 위한 검사도 수행한다. 만약 문제가 없다면 UI 스레드에 데이터가 준비되었음을 알린다.

UI 스레드는 웹 페이지 렌더링을 수행할 렌더러 프로세스를 찾는다. 이 과정은 UI 스레드가 네트워크 스레드에 통신 요청을 보내는 시점에 함께 이루어진다. 모든 과정이 정상적이라면 데이터가 수신되는 시점에 렌더러 프로세스는 이미 대기 중일 것이다.

데이터, 렌더러 프로세스가 모두 준비되었다면 프로세스간 통신이 필요하다. 즉 브라우저 프로세스와 렌더러 프로세스간에 IPC가 발생한다. 렌더러 프로세스로부터 커밋 발생을 확인 받으면 네비게이션은 완료되고 문서 로드 단계가 시작된다. 이 시점에서 주소 표시줄 업데이트, 탭의 세션 기록이 갱신된다.

네비게이션이 커밋되고 나면 렌더러 프로세스는 데이터를 로드하고 페이지를 렌더링한다. 렌더러 프로세스가 렌더링을 모두 완료하면 IPC를 통해 브라우저 프로세스에게 이 사실을 알린다. 이 시점에 UI 스레드는 탭의 로딩 스피너를 중지한다.

이 순간이 사용자의 주소 입력 후 탐색이 완료되는 시점이다. 만약 사용자가 주소창에 다른 URL을 입력하면 어떻게 될까? 아마 동일한 과정을 거치게 되겠지만 그 전에 [beforeunload](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) 이벤트가 등록되어 있는지 확인한다. 탭 내부의 일은 렌더러 프로세스가 처리하기 때문에 브라우저 프로세스는 결국 렌더러 프로세스에게 해당 이벤트의 처리가 필요한지 확인 과정을 거쳐야 한다.

네비게이션이 렌더러 프로세스에 의해 시작된 경우에는 렌더러 프로세스가 beforeunload 핸들러 유무를 확인한다. 그런 다음 브라우저 프로세스에서 시작된 탐색과 동일한 과정을 거친다. 차이점이 있다면 네비게이션이 렌더러 프로세스로부터 시작된다는 점이다. 새로운 네비게이션 과정에는 새로운 렌더러 프로세스가 할당된다.

# Service Worker

**서비스 워커**는 Web API 중 하나로 네트워크 프록시를 구현할 수 있는 수단이다. 개발자는 서비스 워커를 통해 필요에 따라 적절한 캐시 전략을 구사할 수 있다. 여기서 중요한 점은 서비스 워커는 결국 자바스크립트 코드이기 때문에 렌더러 프로세스 관할이라는 점이다. 따라서 브라우저 프로세스는 네비게이션의 목적지가 서비스 워커를 사용하고 있는지 알아야 한다. 네트워크 스레드는 사이트에 서비스 워커가 등록되어 있는지 먼저 확인한다. 존재한다면 UI 스레드는 서비스 워커를 실행하기 위해 렌더러 프로세스를 찾는다. 서비스 워커는 캐시를 사용하여 네트워크 요청을 제거하거나 새로운 데이터를 요청하기도 한다. 

# Navigation Preload

서비스 워커의 부팅 시간 때문에 네트워크 응답이 지연될 수 있다. 부팅 시간이 디바이스마다 다르고 일반적으로 부팅 지연보다는 캐싱의 이점이 더 크다고 볼 수 있지만 네트워크 요청을 해야 하는 경우에는 서비스 워커의 부팅 시간만큼 지연이 발생할 수 밖에 없다. **네비게이션 프리로드**는 이 문제를 해결하기 위한 방법으로 서비스 워커를 부팅하는 동시에 네트워크 요청을 병렬적으로 수행하는 방식이다. 부팅 시간은 여전히 발생하겠지만 네트워크를 지연시키지 않기 때문에 네트워크 요청 지연은 해결된 셈이다.

# 렌더러 프로세스

**렌더러 프로세스**는 탭 내부에서 벌어지는 모든 일을 처리한다. 렌더러 프로세스 역시 여러 스레드를 갖는데 메인 스레드를 포함하여 워커 스레드, 컴포지터 스레드, 래스터 스레드 등이 있다. 렌더러 프로세스의 핵심 역할은 HTML, CSS, Javascript를 통해 웹 페이지를 제작하는 것이다.

## 파싱

네비게이션이 커밋되고 데이터를 받기 시작하면, **메인 스레드**는 HMTL을 해석하여 DOM(Document Object Model)을 생성한다. DOM은 웹 개발자가 자바스크립트를 통해 접근하여 조작할 수 있는 API인 동시에 트리 구조의 데이터다. 한편으로는 웹 페이지의 재현이다. 정적 문서인 HTML을 그것의 표준에 따라 DOM으로 전환한다.

메인 스레드는 동시에 외부 리소스를 더 빠르게 조달하기 위해 `<img>`나 `<link>`와 같은 태그가 있는지 먼저 확인한다. 존재하면 네트워크 스레드에 데이터를 먼저 요청한다.

한편 HTML을 파싱하는 중에 `<script>` 태그를 만나면 구문 해석을 중단한다. 자바스립트에 의해 전체 DOM 구성이 변경될 수도 있기 때문이다. 자바스크립트 코드가 모두 실행되고 나면 구문 해석을 재개한다. 만약 자바스크립트 코드를 비동기적으로 실행하고 싶다면 스크립트 태그에 `async`나 `defer` 속성을 적용할 수 있다.

## 스타일 계산

메인 스레드는 DOM을 생성하고 난 후 CSS 스타일링을 위한 계산에 돌입한다. CSS 파일을 파싱하여 각 DOM 노드에 필요한 스타일을 계산한다. 계산 결과는 개발자 도구 `computed` 섹션에서 확인할 수 있다. 브라우저의 기본 스타일 때문에 만약 CSS가 제공되지 않더라도 각 노드는 computed style을 갖는다.

## 레이아웃

계산이 모두 끝났다면 각 요소를 어떤 위치에 그릴지 정해야 한다. 메인 스레드는 스타일 계산 결과와 DOM을 통해 **레이아웃 트리**를 생성한다. 레이아웃 트리에는 좌표 정보와 요소의 크기 정보가 저장된다. 만약 `display` 속성이 `none`이라면 레이아웃 트리에 포함하지 않는다.

## 페인팅

레이아웃 트리를 완성했다면 이제 각 요소의 위치, 모양, 크기를 모두 알게된 셈이다. 그러나 이 정보만으로는 화면을 그릴 수 없다. 예를 들어, `z-index` 속성이 있다면 더 낮은 [stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)를 갖는 요소보다 전면에 그려야 한다. 하지만 기본적으로 HTML의 마크업 순서대로 요소를 그리기 때문에 추가 작업이 더 필요하다. 메인 스레드는 페인트 단계에서 레이아웃 트리를 살펴보고 **페인트 레코드**를 생성한다. 페인트 레코드에 어떤 요소가 어떤 순서로 어떤 위치에 그려져야 하는지에 대한 정보를 담는다.

한편 메인 스레드는 레이아웃 트리를 참고하여 **레이어 트리**를 생성한다. 레이어는 페인팅할 영역을 나누어 놓은 것을 의미한다. 몇몇 레이어는 그래픽 요소의 특성에 따라 별도의 레이어로 분리하기도 한다. 이 단계에서 각 레이어에 픽셀을 채운다. 이를 **래스터라이징**이라고도 한다.

## 비용

렌더링 주기를 갱신해야 할 때는 비용을 고려해야 한다. 지금까지 살펴본 것처럼 모든 단계는 이전 단계의 결과를 통해 새로운 정보를 만들고 있다. 어떤 변화가 생길 때 메인 스레드는 레이아웃 트리를 다시 만들고 그에 따른 페인팅 레코드도 다시 생성할 것이다. 오늘날 대부분의 디스플레이는 60fps로 화면을 표시한다. 이는 1초에 60번의 화면 갱신이 발생한다는 의미다. 만약 렌더링 과정이 길어져 프레임을 놓치게 되면 사용자는 버벅임을 경험할 수 있다. 부드러운 애니메이션을 위해서는 메인 스레드를 장시간 점유하지 않도록 해야한다. `requestAnimation()`이나 `Web Worker`와 같은 API를 고려하자.

## 컴포지팅

출시 당시, 크롬은 뷰포트 내부 영역에 맞게 래스터라이징하여 화면을 표현했지만 지금은 **컴포지팅**이라는 기법을 사용하고 있다. 기존 방식은 그래픽 요소가 변환되거나 사용자가 페이지를 스크롤할 때마다 래스터 이미지를 새롭게 만들어야 했기 때문에 비효율적인 계산이나 성능 저하를 초래했다. 

컴포지팅은 별도 스레드인 컴포지트 스레드에서 페이지를 구성하는 레이어를 합성한다. 레이어는 페이지 전체 크기만큼 커질 수 있기 때문에 레이어를 타일로 나누고 각 타일을 **래스터 스레드**로 보낸다. 래스터 스레드는 각 타일을 래스터라이징한다. 컴포지트 스레드는 뷰포트 영역을 먼저 작업할 수 있도록 래스터 스레드의 우선순위를 조정할 수 있다. 타일에 픽셀을 모두 채우면 컴포지트 스레드는 각 타일의 위치 정보를 참조하여 **컴포지터 프레임**을 생성한다. 그리고 프레임을 브라우저 프로세스를 통해 GPU에 전송하여 화면에 표시한다.

사용자가 화면을 스크롤하면 이미 픽셀로 채워진 레이어를 합성하여 새로운 프레임을 만들어 보여준다. 컴포지팅의 이점은 메인 스레드가 필요하지 않다는 점이다. 컴포지팅 전용 속성을 사용하면 레이아웃과 페인트 과정을 생략할 수 있기 때문에 애니메이션 성능을 크게 개선시킬 수 있다. 하지만 항상 옳은 것은 아니다. 너무 많은 레이어를 합성하는 것은 디바이스 메모리 성능에 따라 오히려 더 큰 부담을 줄 수 있다. 실제 성능을 측정하고 합성 레이어 수를 관리할 필요가 있다.




# 출처

[Inside look at modern web browser](https://developer.chrome.com/blog/inside-browser-part1)
