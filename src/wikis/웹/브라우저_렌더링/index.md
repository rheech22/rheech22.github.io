---
created: 2023-09-02 13:47:44 +0900
updated: 2023-09-03 03:54:45 +0900
---

# Prerequisite

브라우저를 이해하기 위해서는 CPU(Central Processing Unit)와 GPU(Graphics Processing Unit)가 무엇인지 먼저 알아야 한다. CPU는 컴퓨터의 핵심 부품으로 그 두뇌 역할을 한다. 과거에는 단일 코어로 구성된 CPU가 많았지만 오늘날의 CPU는 대부분 멀티 코어로 구성되어 있다. 이 경우에 하나의 코어는 같은 칩에 있는 다른 CPU라고 할 수 있다. 한편 GPU는 비교적 쉽고 단순한 작업에 특화된 구성이다. 수천개의 코어가 작업을 병렬적으로 빠르게 처리한다. 이름에서도 알 수 있듯이 그래픽 작업을 위해 만들어진 부품이다. 화면에 그래픽을 표시하기 위해서는 대량의 단순 작업을 처리해야 하기 때문이다.

프로세스는 프로그램의 실행 단위라고 할 수 있다. 프로세스가 실행되면 결국 연산을 하게 되는데 주로 스레드가 그 연산의 주체이다. 프로세스 하나가 존재한다면 스레드는 하나 이상 존재한다. 복수의 스레드를 가지는 프로세스를 멀티 스레드 프로세스라 한다.

애플리케이션을 시작하면 프로세스가 생성된다. 프로세스는 스레드를 통해 연산을 수행하고 운영체제는 프로세스가 동작하는데 필요한 메모리 공간을 제공한다. 프로세스가 종료되면 메모리 공간은 다시 회수된다.

한편 프로세스는 운영체제를 통해 다른 프로세스에서 어떤 작업을 수행하도록 요청할 수 있다. 만약 두 프로세스간 통신이 필요하다면 IPC(Inter Process Communication)을 사용한다.

# 브라우저 아키텍처

브라우저 아키텍처에는 표준이 없다. 단 하나의 멀티 스레드 프로세스이거나 여러 프로세스로 구성될 수도 있다. 크롬은 멀티 프로세스로 구성된 브라우저다. 그 중 브라우저 프로세스는 다른 프로세스와 협력하는 가장 상위 레벨의 프로세스다. 이 밖에도 렌더러 프로세스, GPU 프로세스, 플러그인 프로세스 등이 있다.

- 브라우저 프로세스: 주소창, 앞/뒤로가기 버튼, 네트워크 요청, 파일 엑세스 등을 제어
- 렌더러 프로세스: 웹사이트가 표시되는 탭 내부의 모든 것들을 제어
- 플러그인 프로세스: 웹사이트의 플러그인을 제어
- GPU 프로세스: 다른 프로세스와 별도로 GPU 작업을 처리

이 밖에도 익스텐션 프로세스, 유틸리트 프로세스 등이 있다. 작업 관리자 메뉴에서 확인할 수 있다.

# 멀티 프로세스 아키텍처의 장점

모든 탭이 단일 렌더러 프로세스에 의해 구동된다고 가정하자. 여러 탭 중 하나에서 렌더링 문제가 발생한다면 모든 탭이 응답하지 않을 수 있다. (스레드를 분리하면 되는거 아닌가..?) 서로 독립적인 렌더러 프로세스를 갖는다면 이런 문제를 방지할 수 있다.

또 다른 장점 중 하나는 보안이다. 브라우저는 운영체제로부터 권한을 위임받아 프로세스의 파일 접근이나 프로세스간의 상호작용을 제어한다. 예를 들어 크롬은 렌더러 프로세스와 같이 사용자 입력을 처리하는 프로세스에 대해 파일로의 접근을 제한할 수 있다. 각 프로세스는 샌드박싱되어 각자의 메모리 공간을 할당받는다. 이로 인해 프로세스간에 리소스를 자유롭게 공유할 수 없게 되어 특정 프로세스를 통한 보안 공격 혹은 부정적 여파가 미치는 것을 미연에 방지할 수 있다. 하지만 각 메모리 공간에 브라우저 엔진, 자바스크립트 엔진과 같은 공통 구성 요소가 포함되어야 하므로 전체 시스템의 메모리 사용량은 증가한다. 크롬에서는 메모리를 절약하기 위해 프로세스 수에 제한을 두고 있다. 이 제한은 디바이스의 성능에 따라 다르며, 리밋에 도달하면 동일한 사이트의 여러 탭을 하나의 프로세스에서 실행하기도 한다.

크롬의 메모리 관리 전략은 디바이스의 성능에 따라 달라진다. 고사양 디바이스에서는 각 서비스를 여러 프로세스로 분할하여 안정성을 높이지만 리소스가 제한된 장치에서는 서비스를 하나의 프로세스로 통합하여 메모리 사용량을 절약한다.

탭마다 각자의 프로세스를 갖더라도 하나의 탭에 여러 사이트가 존재할 수 있다. 대표적인 예시로 iframe이 있다. 이런 경우에 동일 출처가 아닌 사이트가 서로 같은 프로세스를 공유하므로 보안 문제를 초래할 수 있다. 크롬은 이러한 문제를 해결하기 위해 탭이 아닌 사이트마다 렌더러 프로세스를 갖도록 한다. 프로세스 분리는 Site Isolation을 위한 가장 효과적인 방법 중 하나이다.

# 주소 표시줄에 URL을 입력하면

사용자가 URL을 입력하면 브라우저는 화면에 새로운 페이지를 그려주기 위한 데이터를 서버로부터 받아와야 한다. 브라우저 프로세스가 이 역할을 맡는다. 브라우저 프로세스는 버튼이나 주소창의 인풋 영역을 그리기 위한 UI 스레드, 인터넷 통신을 처리하는 네트워크 스레드, 파일 접근을 제어하는 스토리지 스레드 등 여러 스레드를 포함한다.

UI 스레드는 사용자가 입력한 값이 검색 키워드인지, URL인지 구분해야 한다. 만약 URL이라면 네비게이션이 시작된다. 엔터 키를 누르면 UI 스레드는 네트워크를 호출한다. 텝에 로딩 스피너를 보여주고 네트워크 스레드를 통해 데이터를 요청한다.

네트워크 스레드는 응답이 들어오기 시작하면 응답 본문으로 어떤 유형의 데이터가 도착했는지 확인한다. 만약 HTML 파일인 경우 데이터를 렌더러 프로세스에 전달하지만, zip 파일과 같이 다른 유형의 데이터라면 다운로드 요청으로 간주하고 이를 다운로드 관리자에게 전달한다. 한편으로 SafeBrowsing 검사를 수행하기도 한다. 이미 등록된 악성 사이트와 일치하면 네트워크 스레드는 경고 페이지를 표시하도록 요청한다. 또한 크로스 사이트 데이터가 전달되지 않도록 이를 위한 검사도 수행한다.

네트워크 스레드는 문제가 없다면 UI 스레드에 데이터가 준비되었음을 알린다. UI 스레드는 웹 페이지 렌더링을 수행할 렌더러 프로세스를 찾는다. 이 과정은 UI 스레드가 네트워크 스레드에 통신 요청을 보내는 시점에 이루어진다. 모든 과정이 정상적이라면 데이터가 수신되는 시점에 렌더러 프로세스는 이미 대기 중이다.

데이터, 렌더러 프로세스가 모두 준비되었다면 프로세스간 통신이 필요하다. 즉 브라우저 프로세스에서 렌더러 프로세스로 IPC가 발생한다. 렌더러 프로세스로부터 커밋이 발생했다는 사실을 확인 받으면 네비게이션이 완료되고 문서 로드 단계가 시작된다. 이 시점에서 주소 표시줄 업데이트, 탭의 세션 기록이 갱신된다. 

네비게이션이 커밋되면 렌더러 프로세스는 데이터를 로드하고 페이지를 렌더링한다. 렌더러 프로세스가 렌더링을 모두 완료하면 IPC를 통해 브라우저 프로세스에게 이 사실을 알린다. 이 시점에 UI 스레드는 탭의 로딩 스피너를 중지한다.

이 순간이 사용자의 주소 입력 후 탐색이 완료되는 시점이다. 만약 사용자가 주소창에 다른 URL을 입력하면 어떻게 될까? 아마 동일한 과정을 거치게 되겠지만 그 전에 beforeunload 이벤트가 등록되어 있는지 확인한다. 탭 내부의 일은 렌더러 프로세스가 처리하기 때문에 브라우저 프로세스는 결국 렌더러 프로세스에게 해당 이벤트 처리가 필요한지 확인하는 과정을 거쳐야 한다.

네비게이션이 렌더러 프로세스에 의해 시작된 경우에는 렌더러 프로세스가 beforeunload 핸들러 유무를 확인한다. 그런 다음 브라우저 프로세스에서 시작된 탐색과 동일한 과정을 거친다. 차이점이 있다면 네비게이션 요청이 렌더러 프로세스에서 시작된다는 점이다. 그리고 새로운 네비게이션 과정에는 새로운 렌더러 프로세스가 할당된다.

# Service Worker

서비스 워커는 Web API 중 하나로 네트워크 프록시를 구현할 수 있는 수단이다. 개발자는 서비스 워커를 통해 필요에 따라 적절한 캐시 전략을 구사할 수 있다. 여기서 중요한 점은 서비스 워커는 결국 자바스크립트 코드이기 때문에 렌더러 프로세스의 관할이라는 점이다. 따라서 브라우저 프로세스는 네비게이션의 대상이 되는 사이트가 서비스 워커를 사용하고 있는지  알아야 한다. 네트워크 스레드는 사이트에 서비스 워커가 등록되어 있는지 먼저 확인한다. 등록되어 있다면 UI 스레드는 서비스 워커 코드를 실행하기 위한 렌더러 프로세스를 찾는다. 서비스 워커는 캐시를 사용하여 네트워크 요청을 제거하거나 새로운 데이터를 요청하기도 한다. 

# Navigation Preload

서비스 워커의 부팅 시간 때문에 네트워크 응답이 지연될 수 있다. 부팅 시간이 디바이스마다 다르고 부팅 지연보다는 캐싱의 이점이 더 크다고 볼 수 있지만 네트워크 요청을 해야 하는 경우에는 서비스 워커의 부팅 시간만큼 지연이 발생할 수 밖에 없다. 네비게이션 프리로드는 이 문제를 해결하기 위한 방법으로 서비스 워커를 부팅하는 동시에 네트워크 요청을 병렬적으로 수행하는 방식이다. 부팅 시간은 여전히 발생하겠지만 네트워크를 지연시키지 않기 때문에 네트워크 요청 지연은 해결된 셈이다.

# 출처

[Inside look at modern web browser](https://developer.chrome.com/blog/inside-browser-part1)
