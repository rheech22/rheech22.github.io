---
created: 2023-10-09 16:17:01 +0900
updated: 2023-10-09 17:29:45 +0900
---

# Chapter 1

함수형 프로그래밍의 사전적 정의는 다음과 같다. 1) 수학 함수를 사용하고 부수 효과를 피하는 것이 특징인 프로그래밍 패러다임, 2) 부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일

그러나 위 내용은 실용적인 측면에서 문제가 있다. 실제 세계에서 부수 효과는 소프트웨어를 실행하는 이유가 되기도 때문이다. 실제 함수형 프로그래머는 이러한 사실을 알고 있기 때문에 부수 효과를 잘 다루는 도구를 많이 알고 있다. 마치 순수 함수만 사용하는 것이 함수형 프로그래밍인 것처럼 오해할 수 있지만, 실상은 순수하지 않은 함수를 잘 다룰 줄도 알아야 한다. 사전적 정의는 함수형 프로그래밍을 시작하려는 사람에게 혼란을 줄 수 있기 때문에 이 책에서는 함수형 프로그래밍을 학문적 지식이 아닌 실용적이고 유익한 기술과 개념으로 본다.

부수효과는 함수가 리턴값 이외에 하는 모든 일을 말한다. 이메일 보내기, 파일 읽기 등이 해당될 수 있다.

순수 함수는 인자에만 의존하고 부수 효과가 없는 함수를 말한다.

함수형 프로그래머는 직감적으로 코드를 세 분류로 나눈다.

1. 액션 - eg. sendEmail(), saveUser(), getCurrentTime()
2. 계산 - eg. sum(), string_length()
3. 데이터 - eg. [12, 13, 14, 15]

액션은 호출하는 시점과 횟수에 의존하기 때문에 부를 때 신중해야 한다. 반면 계산이나 데이터는 그렇지 않기 때문에 상대적으로 다루기 쉽고 이해하기 쉽다.

# Chapter 2

함수형 사고에서 가장 먼저 해야 할 것은 액션과 계산, 데이터를 구분하는 것이다. 이를 통해 쉽게 다룰 수 있는 부분과 조심히 다뤄야 할 부분을 명확하게 나눌 수 있기 때문이다.

변경 가능성에 따라 코드를 나눠보자.

- 자주 바뀌는 것 - 비지니스 규칙 - eg. 이번 주 한정 이벤트
- 덜 자주 바뀌는 것 - 도메인 규칙 - eg. 피자 레시피
- 자주 바뀌지 않는 것 - 기술 스택 - eg. 자바스크립트의 객체와 배열

각 계층은 아래에 있는 계층에 기반한다. 이런 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있다. 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있다. 이러한 형태가 일반적인 계층형 설계의 모습이다. 계층형 설계로 만든 코드는 테스트, 재사용, 유지보수가 쉽다.

순차적인 프로그램을 분산 시스템으로 바꾸는 것은 쉽지 않다. 각 시스템의 타임라인이 다르기 때문인데 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법을 **커팅**이라 한다. 커팅은 액션을 올바른 순서로 실행할 수 있도록 보장한다. 

# Chapter 3

모든 개발 과정에서 액션과 계산, 데이터를 구분하는 기술을 적용할 수 있다. 코딩을 시작하기 전 구상 단계에서 요구 사항을 액션과 계산, 데이터로 나눠 생각해 볼 수 있다. 이렇게 하면 구현하기도 전에 특별히 주의해야할 부분을 미리 알 수 있다. 코딩을 하거나 코드를 읽을 때도 이 방법을 적용하면 더 좋은 코드를 만들기 위한 방법을 찾을 수 있다.

액션의 또 다른 이름은 순수하지 않은 함수(impure function), 부수 효과 함수(side-effecting function)다. 액션은 다루기 힘들고 액션의 실행 결과는 코드 전체로 퍼질 수 있기 때문에 주의해서 다루어야 한다. 액션을 부르는 함수가 있다면 그 함수도 액션이 된다. 액션을 전혀 사용하지 않을 수 없기 때문에 액션은 가능한 적게 사용하고 가능한 작게 만드는 것이 좋다. 액션에서 액션과 관련이 없는 코드가 있다면 제거하거나 분리하자.

계산의 또 다른 이름은 순수 함수(pure function)다. 계산은 액션보다 사용하기 쉽고 이해하기에도 쉽다. 액션보다 테스트하기에 좋고 기계적인 분석이 쉽다. 계산은 조합하기도 좋다. 계산을 조합하면 더 큰 계산을 만들 수 있다. 계산을 사용할 때는 실행 시점이나 횟수에 신경쓰지 않아도 되는 장점이 있다. 다만 계산도 액션과 마찬가지로 실행하기 전에는 어떤 일이 발생하지 알 수 없다는 단점이 있기 때문에 이러한 단점이 싫다면 데이터를 사용해야 한다.

데이터는 이벤트에 대한 사실이다. 사실은 변하지 않기 때문에 영구적으로 기록할 수 있다.

# Chapter 4

함수에는 입력과 출력이 있고 입력과 출력은 명시적이거나 암묵적일 수 있다.

아래 함수에서 입력과 출력, 그리고 명시적인 것과 암묵적인 것을 구분하자면,

```js
const add = (amount) => { // amount는 명시적 입력
	console.log(amount); // console은 암묵적 출력
	total += amount; // total를 갱신하는 것도 암묵적 출력
	return total; // 리턴 값은 명시적 출력
}
```

함수에 암묵적 입력과 출력이 있으면 액션이다. 반대로 암묵적인 것 없이 모두 명시적이라면 계산이다. 따라서 `add()`는 액션이다.  함수형 프로그래밍에서 암묵적 입력과 출력을 부수 효과라고 부른다.

`add()`를 계산으로 바꾸자면,

```js
const add = (total, amount) => {
	return total + amount;
}
```

이제 암묵적 입력과 출력 모두 없기 때문에 `add()`는 계산이 되었다. 액션을 계산으로 바꾸거나 액션에서 계산을 빼내는 것은 코드의 재사용성을 높이고 테스트하기 좋은 코드를 만드는 방법이다.

# Chapter 5

일반적으로 암묵적 입력과 추렭은 인자와 리턴값으로 바꿔 제거하는 것이 좋다.

함수를 사용하면 관심사를 자연스럽게 분리할 수 있다.

함수는 작으면 작을수록 재사용하기 쉽다.

작은 함수는 쉽게 이해할 수 있고 유지보수하기 쉽다.

작은 함수는 테스트하기 좋다.

# Chapter 6

카피온라이트는 원본 데이터를 바꾸지 않고 복사본을 변경하는 원칙이다.

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

카피온라이트를 하면 쓰기 함수를 읽기 함수로 바꿀 수 있다. 쓰기는 데이터를 변경하기 때문에 쓰기가 없다면 데이터는 불변형이라고 할 수 있다. 변경 가능한 데이터를 읽는 것은 액션이고 변경 불가능한 데이터를 읽는 것은 계산이다. 바뀔 때마다 복사를 하는 것이 너무 비효율적이라고 말할 수도 있다. 하지만 최적화는 언제든지 가능하기 때문에 필요할 때 하면 된다. 현대 언어의 가비지 콜렉터 성능은 매우 빠른 편이고 대부분의 복사는 얕게 이루어지기 때문에 생각보다 많이 복사되지 않는다. 만약 여러 객체를 원소로 갖는 원본 배열을 복사한 후 원소 하나만을 변경했다면 복사된 배열과 원본 배열은 나머지 원소를 공유하고 있는 셈이다. 이를 구조적 공유라고 한다.



